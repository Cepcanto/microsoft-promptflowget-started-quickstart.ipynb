# Driver to create github workflows
from typing import List, Dict


class Step:
    """
    Base class for each small steps, check out other files for templates.
    """

    name: str

    def __init__(self, name: str) -> None:
        self.name = name

    def get_step(self) -> str:
        # virtual method for overide
        return " " * 6 + f"- name: {self.name}"


class Job:
    """
    Careful: Job and Job indicates no sequential guarantee by default
    """

    name: str
    steps: List[Step]

    def __init__(self, name: str, steps: List[Step]) -> None:
        self.name = name
        self.steps = steps

    def get_job(self) -> str:
        output = " " * 4 + "runs-on: ubuntu-latest\n"
        output += " " * 4 + "steps:\n"
        output += "\n".join([step.get_step() for step in self.steps])
        return output


class Jobs:

    _jobs: Dict[str, Job]

    def add_job(self, job: Job) -> "Jobs":
        self._jobs = {}
        self._jobs[job.name] = job
        return self

    def get_jobs(self) -> str:
        output = "jobs:\n"
        for job in self._jobs.keys():
            output += " " * 2 + f"{job}:\n"
            output += self._jobs[job].get_job()
        return output


class Workflow:
    name: str
    jobs: Jobs
    _template_string: str

    def __init__(self, name: str, jobs: Jobs) -> None:
        self.name = name
        self.jobs = jobs
        self._template_string = f"""# This code is autogenerated.
# Code is generated by running custom script: python3 readme.py
# Any manual changes to this file may cause incorrect behavior.
# Any manual changes will be overwritten if the code is regenerated.

name: {name}
on:
  pull_request:
    branches: [ main,preview/code-first ]
  workflow_dispatch:

"""

    def get_workflow(self):
        output = self._template_string
        output += self.jobs.get_jobs()
        return output
