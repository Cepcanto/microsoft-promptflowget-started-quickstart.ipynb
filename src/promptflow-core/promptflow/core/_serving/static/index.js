var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var require_index_001 = __commonJS({
  "static/index-45e41db4.js"(exports, module) {
    function _mergeNamespaces(n2, m2) {
      for (var i2 = 0; i2 < m2.length; i2++) {
        const e2 = m2[i2];
        if (typeof e2 !== "string" && !Array.isArray(e2)) {
          for (const k2 in e2) {
            if (k2 !== "default" && !(k2 in n2)) {
              const d2 = Object.getOwnPropertyDescriptor(e2, k2);
              if (d2) {
                Object.defineProperty(n2, k2, d2.get ? d2 : {
                  enumerable: true,
                  get: () => e2[k2]
                });
              }
            }
          }
        }
      }
      return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
    }
    (function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link2 of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link2);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node2 of mutation.addedNodes) {
            if (node2.tagName === "LINK" && node2.rel === "modulepreload")
              processPreload(node2);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(link2) {
        const fetchOpts = {};
        if (link2.integrity)
          fetchOpts.integrity = link2.integrity;
        if (link2.referrerPolicy)
          fetchOpts.referrerPolicy = link2.referrerPolicy;
        if (link2.crossOrigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (link2.crossOrigin === "anonymous")
          fetchOpts.credentials = "omit";
        else
          fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link2) {
        if (link2.ep)
          return;
        link2.ep = true;
        const fetchOpts = getFetchOpts(link2);
        fetch(link2.href, fetchOpts);
      }
    })();
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function getDefaultExportFromCjs(x2) {
      return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
    }
    var jsxRuntime$1 = { exports: {} };
    var reactJsxRuntime_production_min = {};
    /*
    object-assign
    (c) Sindre Sorhus
    @license MIT
    */
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject$1(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i2 = 0; i2 < 10; i2++) {
          test2["_" + String.fromCharCode(i2)] = i2;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
          return test2[n2];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    var objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
      var from2;
      var to2 = toObject$1(target);
      var symbols;
      for (var s2 = 1; s2 < arguments.length; s2++) {
        from2 = Object(arguments[s2]);
        for (var key in from2) {
          if (hasOwnProperty$2.call(from2, key)) {
            to2[key] = from2[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from2);
          for (var i2 = 0; i2 < symbols.length; i2++) {
            if (propIsEnumerable.call(from2, symbols[i2])) {
              to2[symbols[i2]] = from2[symbols[i2]];
            }
          }
        }
      }
      return to2;
    };
    var react$1 = { exports: {} };
    var react_production_min = {};
    /** @license React v17.0.2
     * react.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var l$5 = objectAssign, n$5 = 60103, p$5 = 60106;
    react_production_min.Fragment = 60107;
    react_production_min.StrictMode = 60108;
    react_production_min.Profiler = 60114;
    var q$3 = 60109, r$6 = 60110, t$3 = 60112;
    react_production_min.Suspense = 60113;
    var u$4 = 60115, v$2 = 60116;
    if ("function" === typeof Symbol && Symbol.for) {
      var w$2 = Symbol.for;
      n$5 = w$2("react.element");
      p$5 = w$2("react.portal");
      react_production_min.Fragment = w$2("react.fragment");
      react_production_min.StrictMode = w$2("react.strict_mode");
      react_production_min.Profiler = w$2("react.profiler");
      q$3 = w$2("react.provider");
      r$6 = w$2("react.context");
      t$3 = w$2("react.forward_ref");
      react_production_min.Suspense = w$2("react.suspense");
      u$4 = w$2("react.memo");
      v$2 = w$2("react.lazy");
    }
    var x$3 = "function" === typeof Symbol && Symbol.iterator;
    function y$3(a2) {
      if (null === a2 || "object" !== typeof a2)
        return null;
      a2 = x$3 && a2[x$3] || a2["@@iterator"];
      return "function" === typeof a2 ? a2 : null;
    }
    function z$1(a2) {
      for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
        b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
      return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var A$2 = { isMounted: function() {
      return false;
    }, enqueueForceUpdate: function() {
    }, enqueueReplaceState: function() {
    }, enqueueSetState: function() {
    } }, B$2 = {};
    function C$2(a2, b2, c2) {
      this.props = a2;
      this.context = b2;
      this.refs = B$2;
      this.updater = c2 || A$2;
    }
    C$2.prototype.isReactComponent = {};
    C$2.prototype.setState = function(a2, b2) {
      if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2)
        throw Error(z$1(85));
      this.updater.enqueueSetState(this, a2, b2, "setState");
    };
    C$2.prototype.forceUpdate = function(a2) {
      this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
    };
    function D$3() {
    }
    D$3.prototype = C$2.prototype;
    function E$2(a2, b2, c2) {
      this.props = a2;
      this.context = b2;
      this.refs = B$2;
      this.updater = c2 || A$2;
    }
    var F$2 = E$2.prototype = new D$3();
    F$2.constructor = E$2;
    l$5(F$2, C$2.prototype);
    F$2.isPureReactComponent = true;
    var G$1 = { current: null }, H$2 = Object.prototype.hasOwnProperty, I$1 = { key: true, ref: true, __self: true, __source: true };
    function J(a2, b2, c2) {
      var e2, d2 = {}, k2 = null, h2 = null;
      if (null != b2)
        for (e2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
          H$2.call(b2, e2) && !I$1.hasOwnProperty(e2) && (d2[e2] = b2[e2]);
      var g2 = arguments.length - 2;
      if (1 === g2)
        d2.children = c2;
      else if (1 < g2) {
        for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
          f2[m2] = arguments[m2 + 2];
        d2.children = f2;
      }
      if (a2 && a2.defaultProps)
        for (e2 in g2 = a2.defaultProps, g2)
          void 0 === d2[e2] && (d2[e2] = g2[e2]);
      return { $$typeof: n$5, type: a2, key: k2, ref: h2, props: d2, _owner: G$1.current };
    }
    function K(a2, b2) {
      return { $$typeof: n$5, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
    }
    function L$3(a2) {
      return "object" === typeof a2 && null !== a2 && a2.$$typeof === n$5;
    }
    function escape(a2) {
      var b2 = { "=": "=0", ":": "=2" };
      return "$" + a2.replace(/[=:]/g, function(a3) {
        return b2[a3];
      });
    }
    var M$1 = /\/+/g;
    function N$1(a2, b2) {
      return "object" === typeof a2 && null !== a2 && null != a2.key ? escape("" + a2.key) : b2.toString(36);
    }
    function O$3(a2, b2, c2, e2, d2) {
      var k2 = typeof a2;
      if ("undefined" === k2 || "boolean" === k2)
        a2 = null;
      var h2 = false;
      if (null === a2)
        h2 = true;
      else
        switch (k2) {
          case "string":
          case "number":
            h2 = true;
            break;
          case "object":
            switch (a2.$$typeof) {
              case n$5:
              case p$5:
                h2 = true;
            }
        }
      if (h2)
        return h2 = a2, d2 = d2(h2), a2 = "" === e2 ? "." + N$1(h2, 0) : e2, Array.isArray(d2) ? (c2 = "", null != a2 && (c2 = a2.replace(M$1, "$&/") + "/"), O$3(d2, b2, c2, "", function(a3) {
          return a3;
        })) : null != d2 && (L$3(d2) && (d2 = K(d2, c2 + (!d2.key || h2 && h2.key === d2.key ? "" : ("" + d2.key).replace(M$1, "$&/") + "/") + a2)), b2.push(d2)), 1;
      h2 = 0;
      e2 = "" === e2 ? "." : e2 + ":";
      if (Array.isArray(a2))
        for (var g2 = 0; g2 < a2.length; g2++) {
          k2 = a2[g2];
          var f2 = e2 + N$1(k2, g2);
          h2 += O$3(k2, b2, c2, f2, d2);
        }
      else if (f2 = y$3(a2), "function" === typeof f2)
        for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; )
          k2 = k2.value, f2 = e2 + N$1(k2, g2++), h2 += O$3(k2, b2, c2, f2, d2);
      else if ("object" === k2)
        throw b2 = "" + a2, Error(z$1(31, "[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2));
      return h2;
    }
    function P$2(a2, b2, c2) {
      if (null == a2)
        return a2;
      var e2 = [], d2 = 0;
      O$3(a2, e2, "", "", function(a3) {
        return b2.call(c2, a3, d2++);
      });
      return e2;
    }
    function Q(a2) {
      if (-1 === a2._status) {
        var b2 = a2._result;
        b2 = b2();
        a2._status = 0;
        a2._result = b2;
        b2.then(function(b3) {
          0 === a2._status && (b3 = b3.default, a2._status = 1, a2._result = b3);
        }, function(b3) {
          0 === a2._status && (a2._status = 2, a2._result = b3);
        });
      }
      if (1 === a2._status)
        return a2._result;
      throw a2._result;
    }
    var R$4 = { current: null };
    function S$2() {
      var a2 = R$4.current;
      if (null === a2)
        throw Error(z$1(321));
      return a2;
    }
    var T$2 = { ReactCurrentDispatcher: R$4, ReactCurrentBatchConfig: { transition: 0 }, ReactCurrentOwner: G$1, IsSomeRendererActing: { current: false }, assign: l$5 };
    react_production_min.Children = { map: P$2, forEach: function(a2, b2, c2) {
      P$2(a2, function() {
        b2.apply(this, arguments);
      }, c2);
    }, count: function(a2) {
      var b2 = 0;
      P$2(a2, function() {
        b2++;
      });
      return b2;
    }, toArray: function(a2) {
      return P$2(a2, function(a3) {
        return a3;
      }) || [];
    }, only: function(a2) {
      if (!L$3(a2))
        throw Error(z$1(143));
      return a2;
    } };
    react_production_min.Component = C$2;
    react_production_min.PureComponent = E$2;
    react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = T$2;
    react_production_min.cloneElement = function(a2, b2, c2) {
      if (null === a2 || void 0 === a2)
        throw Error(z$1(267, a2));
      var e2 = l$5({}, a2.props), d2 = a2.key, k2 = a2.ref, h2 = a2._owner;
      if (null != b2) {
        void 0 !== b2.ref && (k2 = b2.ref, h2 = G$1.current);
        void 0 !== b2.key && (d2 = "" + b2.key);
        if (a2.type && a2.type.defaultProps)
          var g2 = a2.type.defaultProps;
        for (f2 in b2)
          H$2.call(b2, f2) && !I$1.hasOwnProperty(f2) && (e2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
      }
      var f2 = arguments.length - 2;
      if (1 === f2)
        e2.children = c2;
      else if (1 < f2) {
        g2 = Array(f2);
        for (var m2 = 0; m2 < f2; m2++)
          g2[m2] = arguments[m2 + 2];
        e2.children = g2;
      }
      return {
        $$typeof: n$5,
        type: a2.type,
        key: d2,
        ref: k2,
        props: e2,
        _owner: h2
      };
    };
    react_production_min.createContext = function(a2, b2) {
      void 0 === b2 && (b2 = null);
      a2 = { $$typeof: r$6, _calculateChangedBits: b2, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null };
      a2.Provider = { $$typeof: q$3, _context: a2 };
      return a2.Consumer = a2;
    };
    react_production_min.createElement = J;
    react_production_min.createFactory = function(a2) {
      var b2 = J.bind(null, a2);
      b2.type = a2;
      return b2;
    };
    react_production_min.createRef = function() {
      return { current: null };
    };
    react_production_min.forwardRef = function(a2) {
      return { $$typeof: t$3, render: a2 };
    };
    react_production_min.isValidElement = L$3;
    react_production_min.lazy = function(a2) {
      return { $$typeof: v$2, _payload: { _status: -1, _result: a2 }, _init: Q };
    };
    react_production_min.memo = function(a2, b2) {
      return { $$typeof: u$4, type: a2, compare: void 0 === b2 ? null : b2 };
    };
    react_production_min.useCallback = function(a2, b2) {
      return S$2().useCallback(a2, b2);
    };
    react_production_min.useContext = function(a2, b2) {
      return S$2().useContext(a2, b2);
    };
    react_production_min.useDebugValue = function() {
    };
    react_production_min.useEffect = function(a2, b2) {
      return S$2().useEffect(a2, b2);
    };
    react_production_min.useImperativeHandle = function(a2, b2, c2) {
      return S$2().useImperativeHandle(a2, b2, c2);
    };
    react_production_min.useLayoutEffect = function(a2, b2) {
      return S$2().useLayoutEffect(a2, b2);
    };
    react_production_min.useMemo = function(a2, b2) {
      return S$2().useMemo(a2, b2);
    };
    react_production_min.useReducer = function(a2, b2, c2) {
      return S$2().useReducer(a2, b2, c2);
    };
    react_production_min.useRef = function(a2) {
      return S$2().useRef(a2);
    };
    react_production_min.useState = function(a2) {
      return S$2().useState(a2);
    };
    react_production_min.version = "17.0.2";
    {
      react$1.exports = react_production_min;
    }
    var reactExports = react$1.exports;
    const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
    const React$1 = /* @__PURE__ */ _mergeNamespaces({
      __proto__: null,
      default: React
    }, [reactExports]);
    /** @license React v17.0.2
     * react-jsx-runtime.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var f$3 = reactExports, g$3 = 60103;
    reactJsxRuntime_production_min.Fragment = 60107;
    if ("function" === typeof Symbol && Symbol.for) {
      var h$5 = Symbol.for;
      g$3 = h$5("react.element");
      reactJsxRuntime_production_min.Fragment = h$5("react.fragment");
    }
    var m$5 = f$3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, n$4 = Object.prototype.hasOwnProperty, p$4 = { key: true, ref: true, __self: true, __source: true };
    function q$2(c2, a2, k2) {
      var b2, d2 = {}, e2 = null, l2 = null;
      void 0 !== k2 && (e2 = "" + k2);
      void 0 !== a2.key && (e2 = "" + a2.key);
      void 0 !== a2.ref && (l2 = a2.ref);
      for (b2 in a2)
        n$4.call(a2, b2) && !p$4.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
      if (c2 && c2.defaultProps)
        for (b2 in a2 = c2.defaultProps, a2)
          void 0 === d2[b2] && (d2[b2] = a2[b2]);
      return { $$typeof: g$3, type: c2, key: e2, ref: l2, props: d2, _owner: m$5.current };
    }
    reactJsxRuntime_production_min.jsx = q$2;
    reactJsxRuntime_production_min.jsxs = q$2;
    {
      jsxRuntime$1.exports = reactJsxRuntime_production_min;
    }
    var jsxRuntimeExports = jsxRuntime$1.exports;
    const jsxRuntime = /* @__PURE__ */ getDefaultExportFromCjs(jsxRuntimeExports);
    const ReactRuntime = /* @__PURE__ */ _mergeNamespaces({
      __proto__: null,
      default: jsxRuntime
    }, [jsxRuntimeExports]);
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    var extendStatics = function(d2, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
        d3.__proto__ = b3;
      } || function(d3, b3) {
        for (var p2 in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p2))
            d3[p2] = b3[p2];
      };
      return extendStatics(d2, b2);
    };
    function __extends(d2, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d2, b2);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    }
    var __assign$1 = function() {
      __assign$1 = Object.assign || function __assign2(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      return __assign$1.apply(this, arguments);
    };
    function __rest(s2, e2) {
      var t2 = {};
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s2[p2];
      if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
            t2[p2[i2]] = s2[p2[i2]];
        }
      return t2;
    }
    function __decorate(decorators, target, key, desc) {
      var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r2 = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i2 = decorators.length - 1; i2 >= 0; i2--)
          if (d2 = decorators[i2])
            r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
      return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
    }
    function __spreadArray(to2, from2, pack) {
      if (pack || arguments.length === 2)
        for (var i2 = 0, l2 = from2.length, ar; i2 < l2; i2++) {
          if (ar || !(i2 in from2)) {
            if (!ar)
              ar = Array.prototype.slice.call(from2, 0, i2);
            ar[i2] = from2[i2];
          }
        }
      return to2.concat(ar || from2);
    }
    var packagesCache = {};
    var _win = void 0;
    try {
      _win = window;
    } catch (e2) {
    }
    function setVersion(packageName, packageVersion) {
      if (typeof _win !== "undefined") {
        var packages = _win.__packages__ = _win.__packages__ || {};
        if (!packages[packageName] || !packagesCache[packageName]) {
          packagesCache[packageName] = packageVersion;
          var versions = packages[packageName] = packages[packageName] || [];
          versions.push(packageVersion);
        }
      }
    }
    setVersion("@fluentui/set-version", "6.0.0");
    var InjectionMode = {
      /**
       * Avoids style injection, use getRules() to read the styles.
       */
      none: 0,
      /**
       * Inserts rules using the insertRule api.
       */
      insertNode: 1,
      /**
       * Appends rules using appendChild.
       */
      appendChild: 2
    };
    var STYLESHEET_SETTING = "__stylesheet__";
    var REUSE_STYLE_NODE = typeof navigator !== "undefined" && /rv:11.0/.test(navigator.userAgent);
    var _global$1 = {};
    try {
      _global$1 = window || {};
    } catch (_a2) {
    }
    var _stylesheet;
    var Stylesheet = (
      /** @class */
      function() {
        function Stylesheet2(config2, serializedStylesheet) {
          var _a2, _b, _c, _d, _e, _f;
          this._rules = [];
          this._preservedRules = [];
          this._counter = 0;
          this._keyToClassName = {};
          this._onInsertRuleCallbacks = [];
          this._onResetCallbacks = [];
          this._classNameToArgs = {};
          this._config = __assign$1({
            // If there is no document we won't have an element to inject into.
            injectionMode: typeof document === "undefined" ? InjectionMode.none : InjectionMode.insertNode,
            defaultPrefix: "css",
            namespace: void 0,
            cspSettings: void 0
          }, config2);
          this._classNameToArgs = (_a2 = serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.classNameToArgs) !== null && _a2 !== void 0 ? _a2 : this._classNameToArgs;
          this._counter = (_b = serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.counter) !== null && _b !== void 0 ? _b : this._counter;
          this._keyToClassName = (_d = (_c = this._config.classNameCache) !== null && _c !== void 0 ? _c : serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.keyToClassName) !== null && _d !== void 0 ? _d : this._keyToClassName;
          this._preservedRules = (_e = serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.preservedRules) !== null && _e !== void 0 ? _e : this._preservedRules;
          this._rules = (_f = serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.rules) !== null && _f !== void 0 ? _f : this._rules;
        }
        Stylesheet2.getInstance = function() {
          _stylesheet = _global$1[STYLESHEET_SETTING];
          if (!_stylesheet || _stylesheet._lastStyleElement && _stylesheet._lastStyleElement.ownerDocument !== document) {
            var fabricConfig = (_global$1 === null || _global$1 === void 0 ? void 0 : _global$1.FabricConfig) || {};
            var stylesheet2 = new Stylesheet2(fabricConfig.mergeStyles, fabricConfig.serializedStylesheet);
            _stylesheet = stylesheet2;
            _global$1[STYLESHEET_SETTING] = stylesheet2;
          }
          return _stylesheet;
        };
        Stylesheet2.prototype.serialize = function() {
          return JSON.stringify({
            classNameToArgs: this._classNameToArgs,
            counter: this._counter,
            keyToClassName: this._keyToClassName,
            preservedRules: this._preservedRules,
            rules: this._rules
          });
        };
        Stylesheet2.prototype.setConfig = function(config2) {
          this._config = __assign$1(__assign$1({}, this._config), config2);
        };
        Stylesheet2.prototype.onReset = function(callback) {
          var _this = this;
          this._onResetCallbacks.push(callback);
          return function() {
            _this._onResetCallbacks = _this._onResetCallbacks.filter(function(cb2) {
              return cb2 !== callback;
            });
          };
        };
        Stylesheet2.prototype.onInsertRule = function(callback) {
          var _this = this;
          this._onInsertRuleCallbacks.push(callback);
          return function() {
            _this._onInsertRuleCallbacks = _this._onInsertRuleCallbacks.filter(function(cb2) {
              return cb2 !== callback;
            });
          };
        };
        Stylesheet2.prototype.getClassName = function(displayName) {
          var namespace = this._config.namespace;
          var prefix2 = displayName || this._config.defaultPrefix;
          return (namespace ? namespace + "-" : "") + prefix2 + "-" + this._counter++;
        };
        Stylesheet2.prototype.cacheClassName = function(className, key, args, rules2) {
          this._keyToClassName[key] = className;
          this._classNameToArgs[className] = {
            args,
            rules: rules2
          };
        };
        Stylesheet2.prototype.classNameFromKey = function(key) {
          return this._keyToClassName[key];
        };
        Stylesheet2.prototype.getClassNameCache = function() {
          return this._keyToClassName;
        };
        Stylesheet2.prototype.argsFromClassName = function(className) {
          var entry = this._classNameToArgs[className];
          return entry && entry.args;
        };
        Stylesheet2.prototype.insertedRulesFromClassName = function(className) {
          var entry = this._classNameToArgs[className];
          return entry && entry.rules;
        };
        Stylesheet2.prototype.insertRule = function(rule, preserve) {
          var injectionMode = this._config.injectionMode;
          var element2 = injectionMode !== InjectionMode.none ? this._getStyleElement() : void 0;
          if (preserve) {
            this._preservedRules.push(rule);
          }
          if (element2) {
            switch (injectionMode) {
              case InjectionMode.insertNode:
                var sheet = element2.sheet;
                try {
                  sheet.insertRule(rule, sheet.cssRules.length);
                } catch (e2) {
                }
                break;
              case InjectionMode.appendChild:
                element2.appendChild(document.createTextNode(rule));
                break;
            }
          } else {
            this._rules.push(rule);
          }
          if (this._config.onInsertRule) {
            this._config.onInsertRule(rule);
          }
          this._onInsertRuleCallbacks.forEach(function(callback) {
            return callback();
          });
        };
        Stylesheet2.prototype.getRules = function(includePreservedRules) {
          return (includePreservedRules ? this._preservedRules.join("") : "") + this._rules.join("");
        };
        Stylesheet2.prototype.reset = function() {
          this._rules = [];
          this._counter = 0;
          this._classNameToArgs = {};
          this._keyToClassName = {};
          this._onResetCallbacks.forEach(function(callback) {
            return callback();
          });
        };
        Stylesheet2.prototype.resetKeys = function() {
          this._keyToClassName = {};
        };
        Stylesheet2.prototype._getStyleElement = function() {
          var _this = this;
          if (!this._styleElement && typeof document !== "undefined") {
            this._styleElement = this._createStyleElement();
            if (!REUSE_STYLE_NODE) {
              window.requestAnimationFrame(function() {
                _this._styleElement = void 0;
              });
            }
          }
          return this._styleElement;
        };
        Stylesheet2.prototype._createStyleElement = function() {
          var head = document.head;
          var styleElement = document.createElement("style");
          var nodeToInsertBefore = null;
          styleElement.setAttribute("data-merge-styles", "true");
          var cspSettings = this._config.cspSettings;
          if (cspSettings) {
            if (cspSettings.nonce) {
              styleElement.setAttribute("nonce", cspSettings.nonce);
            }
          }
          if (this._lastStyleElement) {
            nodeToInsertBefore = this._lastStyleElement.nextElementSibling;
          } else {
            var placeholderStyleTag = this._findPlaceholderStyleTag();
            if (placeholderStyleTag) {
              nodeToInsertBefore = placeholderStyleTag.nextElementSibling;
            } else {
              nodeToInsertBefore = head.childNodes[0];
            }
          }
          head.insertBefore(styleElement, head.contains(nodeToInsertBefore) ? nodeToInsertBefore : null);
          this._lastStyleElement = styleElement;
          return styleElement;
        };
        Stylesheet2.prototype._findPlaceholderStyleTag = function() {
          var head = document.head;
          if (head) {
            return head.querySelector("style[data-merge-styles]");
          }
          return null;
        };
        return Stylesheet2;
      }()
    );
    function extractStyleParts() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var classes = [];
      var objects = [];
      var stylesheet2 = Stylesheet.getInstance();
      function _processArgs(argsList) {
        for (var _i2 = 0, argsList_1 = argsList; _i2 < argsList_1.length; _i2++) {
          var arg = argsList_1[_i2];
          if (arg) {
            if (typeof arg === "string") {
              if (arg.indexOf(" ") >= 0) {
                _processArgs(arg.split(" "));
              } else {
                var translatedArgs = stylesheet2.argsFromClassName(arg);
                if (translatedArgs) {
                  _processArgs(translatedArgs);
                } else {
                  if (classes.indexOf(arg) === -1) {
                    classes.push(arg);
                  }
                }
              }
            } else if (Array.isArray(arg)) {
              _processArgs(arg);
            } else if (typeof arg === "object") {
              objects.push(arg);
            }
          }
        }
      }
      _processArgs(args);
      return {
        classes,
        objects
      };
    }
    function setRTL$1(isRTL) {
      if (_rtl !== isRTL) {
        _rtl = isRTL;
      }
    }
    function getRTL$1() {
      if (_rtl === void 0) {
        _rtl = typeof document !== "undefined" && !!document.documentElement && document.documentElement.getAttribute("dir") === "rtl";
      }
      return _rtl;
    }
    var _rtl;
    _rtl = getRTL$1();
    function getStyleOptions() {
      return {
        rtl: getRTL$1()
      };
    }
    var rules = {};
    function kebabRules(rulePairs, index2) {
      var rule = rulePairs[index2];
      if (rule.charAt(0) !== "-") {
        rulePairs[index2] = rules[rule] = rules[rule] || rule.replace(/([A-Z])/g, "-$1").toLowerCase();
      }
    }
    var _vendorSettings;
    function getVendorSettings() {
      var _a2;
      if (!_vendorSettings) {
        var doc = typeof document !== "undefined" ? document : void 0;
        var nav = typeof navigator !== "undefined" ? navigator : void 0;
        var userAgent = (_a2 = nav === null || nav === void 0 ? void 0 : nav.userAgent) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase();
        if (!doc) {
          _vendorSettings = {
            isWebkit: true,
            isMoz: true,
            isOpera: true,
            isMs: true
          };
        } else {
          _vendorSettings = {
            isWebkit: !!(doc && "WebkitAppearance" in doc.documentElement.style),
            isMoz: !!(userAgent && userAgent.indexOf("firefox") > -1),
            isOpera: !!(userAgent && userAgent.indexOf("opera") > -1),
            isMs: !!(nav && (/rv:11.0/i.test(nav.userAgent) || /Edge\/\d./i.test(navigator.userAgent)))
          };
        }
      }
      return _vendorSettings;
    }
    var autoPrefixNames = {
      "user-select": 1
    };
    function prefixRules(rulePairs, index2) {
      var vendorSettings = getVendorSettings();
      var name2 = rulePairs[index2];
      if (autoPrefixNames[name2]) {
        var value = rulePairs[index2 + 1];
        if (autoPrefixNames[name2]) {
          if (vendorSettings.isWebkit) {
            rulePairs.push("-webkit-" + name2, value);
          }
          if (vendorSettings.isMoz) {
            rulePairs.push("-moz-" + name2, value);
          }
          if (vendorSettings.isMs) {
            rulePairs.push("-ms-" + name2, value);
          }
          if (vendorSettings.isOpera) {
            rulePairs.push("-o-" + name2, value);
          }
        }
      }
    }
    var NON_PIXEL_NUMBER_PROPS = [
      "column-count",
      "font-weight",
      "flex",
      "flex-grow",
      "flex-shrink",
      "fill-opacity",
      "opacity",
      "order",
      "z-index",
      "zoom"
    ];
    function provideUnits(rulePairs, index2) {
      var name2 = rulePairs[index2];
      var value = rulePairs[index2 + 1];
      if (typeof value === "number") {
        var isNonPixelProp = NON_PIXEL_NUMBER_PROPS.indexOf(name2) > -1;
        var isVariableOrPrefixed = name2.indexOf("--") > -1;
        var unit = isNonPixelProp || isVariableOrPrefixed ? "" : "px";
        rulePairs[index2 + 1] = "" + value + unit;
      }
    }
    var _a$3;
    var LEFT = "left";
    var RIGHT = "right";
    var NO_FLIP = "@noflip";
    var NAME_REPLACEMENTS = (_a$3 = {}, _a$3[LEFT] = RIGHT, _a$3[RIGHT] = LEFT, _a$3);
    var VALUE_REPLACEMENTS = {
      "w-resize": "e-resize",
      "sw-resize": "se-resize",
      "nw-resize": "ne-resize"
    };
    function rtlifyRules(options, rulePairs, index2) {
      if (options.rtl) {
        var name_1 = rulePairs[index2];
        if (!name_1) {
          return;
        }
        var value = rulePairs[index2 + 1];
        if (typeof value === "string" && value.indexOf(NO_FLIP) >= 0) {
          rulePairs[index2 + 1] = value.replace(/\s*(?:\/\*\s*)?\@noflip\b(?:\s*\*\/)?\s*?/g, "");
        } else if (name_1.indexOf(LEFT) >= 0) {
          rulePairs[index2] = name_1.replace(LEFT, RIGHT);
        } else if (name_1.indexOf(RIGHT) >= 0) {
          rulePairs[index2] = name_1.replace(RIGHT, LEFT);
        } else if (String(value).indexOf(LEFT) >= 0) {
          rulePairs[index2 + 1] = value.replace(LEFT, RIGHT);
        } else if (String(value).indexOf(RIGHT) >= 0) {
          rulePairs[index2 + 1] = value.replace(RIGHT, LEFT);
        } else if (NAME_REPLACEMENTS[name_1]) {
          rulePairs[index2] = NAME_REPLACEMENTS[name_1];
        } else if (VALUE_REPLACEMENTS[value]) {
          rulePairs[index2 + 1] = VALUE_REPLACEMENTS[value];
        } else {
          switch (name_1) {
            case "margin":
            case "padding":
              rulePairs[index2 + 1] = flipQuad(value);
              break;
            case "box-shadow":
              rulePairs[index2 + 1] = negateNum(value, 0);
              break;
          }
        }
      }
    }
    function negateNum(value, partIndex) {
      var parts = value.split(" ");
      var numberVal = parseInt(parts[partIndex], 10);
      parts[0] = parts[0].replace(String(numberVal), String(numberVal * -1));
      return parts.join(" ");
    }
    function flipQuad(value) {
      if (typeof value === "string") {
        var parts = value.split(" ");
        if (parts.length === 4) {
          return parts[0] + " " + parts[3] + " " + parts[2] + " " + parts[1];
        }
      }
      return value;
    }
    function tokenizeWithParentheses(value) {
      var parts = [];
      var partStart = 0;
      var parens = 0;
      for (var i2 = 0; i2 < value.length; i2++) {
        switch (value[i2]) {
          case "(":
            parens++;
            break;
          case ")":
            if (parens) {
              parens--;
            }
            break;
          case "	":
          case " ":
            if (!parens) {
              if (i2 > partStart) {
                parts.push(value.substring(partStart, i2));
              }
              partStart = i2 + 1;
            }
            break;
        }
      }
      if (partStart < value.length) {
        parts.push(value.substring(partStart));
      }
      return parts;
    }
    var DISPLAY_NAME = "displayName";
    function getDisplayName(rules2) {
      var rootStyle = rules2 && rules2["&"];
      return rootStyle ? rootStyle.displayName : void 0;
    }
    var globalSelectorRegExp = /\:global\((.+?)\)/g;
    function expandCommaSeparatedGlobals(selectorWithGlobals) {
      if (!globalSelectorRegExp.test(selectorWithGlobals)) {
        return selectorWithGlobals;
      }
      var replacementInfo = [];
      var findGlobal = /\:global\((.+?)\)/g;
      var match5 = null;
      while (match5 = findGlobal.exec(selectorWithGlobals)) {
        if (match5[1].indexOf(",") > -1) {
          replacementInfo.push([
            match5.index,
            match5.index + match5[0].length,
            // Wrap each of the found selectors in :global()
            match5[1].split(",").map(function(v2) {
              return ":global(" + v2.trim() + ")";
            }).join(", ")
          ]);
        }
      }
      return replacementInfo.reverse().reduce(function(selector, _a2) {
        var matchIndex = _a2[0], matchEndIndex = _a2[1], replacement = _a2[2];
        var prefix2 = selector.slice(0, matchIndex);
        var suffix = selector.slice(matchEndIndex);
        return prefix2 + replacement + suffix;
      }, selectorWithGlobals);
    }
    function expandSelector(newSelector, currentSelector) {
      if (newSelector.indexOf(":global(") >= 0) {
        return newSelector.replace(globalSelectorRegExp, "$1");
      } else if (newSelector.indexOf(":") === 0) {
        return currentSelector + newSelector;
      } else if (newSelector.indexOf("&") < 0) {
        return currentSelector + " " + newSelector;
      }
      return newSelector;
    }
    function extractSelector(currentSelector, rules2, selector, value) {
      if (rules2 === void 0) {
        rules2 = { __order: [] };
      }
      if (selector.indexOf("@") === 0) {
        selector = selector + "{" + currentSelector;
        extractRules([value], rules2, selector);
      } else if (selector.indexOf(",") > -1) {
        expandCommaSeparatedGlobals(selector).split(",").map(function(s2) {
          return s2.trim();
        }).forEach(function(separatedSelector) {
          return extractRules([value], rules2, expandSelector(separatedSelector, currentSelector));
        });
      } else {
        extractRules([value], rules2, expandSelector(selector, currentSelector));
      }
    }
    function extractRules(args, rules2, currentSelector) {
      if (rules2 === void 0) {
        rules2 = { __order: [] };
      }
      if (currentSelector === void 0) {
        currentSelector = "&";
      }
      var stylesheet2 = Stylesheet.getInstance();
      var currentRules = rules2[currentSelector];
      if (!currentRules) {
        currentRules = {};
        rules2[currentSelector] = currentRules;
        rules2.__order.push(currentSelector);
      }
      for (var _i = 0, args_1 = args; _i < args_1.length; _i++) {
        var arg = args_1[_i];
        if (typeof arg === "string") {
          var expandedRules = stylesheet2.argsFromClassName(arg);
          if (expandedRules) {
            extractRules(expandedRules, rules2, currentSelector);
          }
        } else if (Array.isArray(arg)) {
          extractRules(arg, rules2, currentSelector);
        } else {
          for (var prop in arg) {
            if (arg.hasOwnProperty(prop)) {
              var propValue = arg[prop];
              if (prop === "selectors") {
                var selectors = arg.selectors;
                for (var newSelector in selectors) {
                  if (selectors.hasOwnProperty(newSelector)) {
                    extractSelector(currentSelector, rules2, newSelector, selectors[newSelector]);
                  }
                }
              } else if (typeof propValue === "object") {
                if (propValue !== null) {
                  extractSelector(currentSelector, rules2, prop, propValue);
                }
              } else {
                if (propValue !== void 0) {
                  if (prop === "margin" || prop === "padding") {
                    expandQuads(currentRules, prop, propValue);
                  } else {
                    currentRules[prop] = propValue;
                  }
                }
              }
            }
          }
        }
      }
      return rules2;
    }
    function expandQuads(currentRules, name2, value) {
      var parts = typeof value === "string" ? tokenizeWithParentheses(value) : [value];
      if (parts.length === 0) {
        parts.push(value);
      }
      if (parts[parts.length - 1] === "!important") {
        parts = parts.slice(0, -1).map(function(p2) {
          return p2 + " !important";
        });
      }
      currentRules[name2 + "Top"] = parts[0];
      currentRules[name2 + "Right"] = parts[1] || parts[0];
      currentRules[name2 + "Bottom"] = parts[2] || parts[0];
      currentRules[name2 + "Left"] = parts[3] || parts[1] || parts[0];
    }
    function getKeyForRules(options, rules2) {
      var serialized = [options.rtl ? "rtl" : "ltr"];
      var hasProps = false;
      for (var _i = 0, _a2 = rules2.__order; _i < _a2.length; _i++) {
        var selector = _a2[_i];
        serialized.push(selector);
        var rulesForSelector = rules2[selector];
        for (var propName in rulesForSelector) {
          if (rulesForSelector.hasOwnProperty(propName) && rulesForSelector[propName] !== void 0) {
            hasProps = true;
            serialized.push(propName, rulesForSelector[propName]);
          }
        }
      }
      return hasProps ? serialized.join("") : void 0;
    }
    function repeatString$1(target, count) {
      if (count <= 0) {
        return "";
      }
      if (count === 1) {
        return target;
      }
      return target + repeatString$1(target, count - 1);
    }
    function serializeRuleEntries(options, ruleEntries) {
      if (!ruleEntries) {
        return "";
      }
      var allEntries = [];
      for (var entry in ruleEntries) {
        if (ruleEntries.hasOwnProperty(entry) && entry !== DISPLAY_NAME && ruleEntries[entry] !== void 0) {
          allEntries.push(entry, ruleEntries[entry]);
        }
      }
      for (var i2 = 0; i2 < allEntries.length; i2 += 2) {
        kebabRules(allEntries, i2);
        provideUnits(allEntries, i2);
        rtlifyRules(options, allEntries, i2);
        prefixRules(allEntries, i2);
      }
      for (var i2 = 1; i2 < allEntries.length; i2 += 4) {
        allEntries.splice(i2, 1, ":", allEntries[i2], ";");
      }
      return allEntries.join("");
    }
    function styleToRegistration(options) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var rules2 = extractRules(args);
      var key = getKeyForRules(options, rules2);
      if (key) {
        var stylesheet2 = Stylesheet.getInstance();
        var registration = {
          className: stylesheet2.classNameFromKey(key),
          key,
          args
        };
        if (!registration.className) {
          registration.className = stylesheet2.getClassName(getDisplayName(rules2));
          var rulesToInsert = [];
          for (var _a2 = 0, _b = rules2.__order; _a2 < _b.length; _a2++) {
            var selector = _b[_a2];
            rulesToInsert.push(selector, serializeRuleEntries(options, rules2[selector]));
          }
          registration.rulesToInsert = rulesToInsert;
        }
        return registration;
      }
      return void 0;
    }
    function applyRegistration(registration, specificityMultiplier) {
      if (specificityMultiplier === void 0) {
        specificityMultiplier = 1;
      }
      var stylesheet2 = Stylesheet.getInstance();
      var className = registration.className, key = registration.key, args = registration.args, rulesToInsert = registration.rulesToInsert;
      if (rulesToInsert) {
        for (var i2 = 0; i2 < rulesToInsert.length; i2 += 2) {
          var rules2 = rulesToInsert[i2 + 1];
          if (rules2) {
            var selector = rulesToInsert[i2];
            selector = selector.replace(/&/g, repeatString$1("." + registration.className, specificityMultiplier));
            var processedRule = selector + "{" + rules2 + "}" + (selector.indexOf("@") === 0 ? "}" : "");
            stylesheet2.insertRule(processedRule);
          }
        }
        stylesheet2.cacheClassName(className, key, args, rulesToInsert);
      }
    }
    function styleToClassName(options) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var registration = styleToRegistration.apply(void 0, __spreadArray([options], args));
      if (registration) {
        applyRegistration(registration, options.specificityMultiplier);
        return registration.className;
      }
      return "";
    }
    function mergeStyles() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return mergeCss(args, getStyleOptions());
    }
    function mergeCss(args, options) {
      var styleArgs = args instanceof Array ? args : [args];
      var _a2 = extractStyleParts(styleArgs), classes = _a2.classes, objects = _a2.objects;
      if (objects.length) {
        classes.push(styleToClassName(options || {}, objects));
      }
      return classes.join(" ");
    }
    function concatStyleSets() {
      var styleSets = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        styleSets[_i] = arguments[_i];
      }
      if (styleSets && styleSets.length === 1 && styleSets[0] && !styleSets[0].subComponentStyles) {
        return styleSets[0];
      }
      var mergedSet = {};
      var workingSubcomponentStyles = {};
      for (var _a2 = 0, styleSets_1 = styleSets; _a2 < styleSets_1.length; _a2++) {
        var currentSet = styleSets_1[_a2];
        if (currentSet) {
          for (var prop in currentSet) {
            if (currentSet.hasOwnProperty(prop)) {
              if (prop === "subComponentStyles" && currentSet.subComponentStyles !== void 0) {
                var currentComponentStyles = currentSet.subComponentStyles;
                for (var subCompProp in currentComponentStyles) {
                  if (currentComponentStyles.hasOwnProperty(subCompProp)) {
                    if (workingSubcomponentStyles.hasOwnProperty(subCompProp)) {
                      workingSubcomponentStyles[subCompProp].push(currentComponentStyles[subCompProp]);
                    } else {
                      workingSubcomponentStyles[subCompProp] = [currentComponentStyles[subCompProp]];
                    }
                  }
                }
                continue;
              }
              var mergedValue = mergedSet[prop];
              var currentValue = currentSet[prop];
              if (mergedValue === void 0) {
                mergedSet[prop] = currentValue;
              } else {
                mergedSet[prop] = __spreadArray(__spreadArray([], Array.isArray(mergedValue) ? mergedValue : [mergedValue]), Array.isArray(currentValue) ? currentValue : [currentValue]);
              }
            }
          }
        }
      }
      if (Object.keys(workingSubcomponentStyles).length > 0) {
        mergedSet.subComponentStyles = {};
        var mergedSubStyles = mergedSet.subComponentStyles;
        var _loop_1 = function(subCompProp2) {
          if (workingSubcomponentStyles.hasOwnProperty(subCompProp2)) {
            var workingSet_1 = workingSubcomponentStyles[subCompProp2];
            mergedSubStyles[subCompProp2] = function(styleProps) {
              return concatStyleSets.apply(void 0, workingSet_1.map(function(styleFunctionOrObject) {
                return typeof styleFunctionOrObject === "function" ? styleFunctionOrObject(styleProps) : styleFunctionOrObject;
              }));
            };
          }
        };
        for (var subCompProp in workingSubcomponentStyles) {
          _loop_1(subCompProp);
        }
      }
      return mergedSet;
    }
    function mergeStyleSets() {
      var styleSets = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        styleSets[_i] = arguments[_i];
      }
      return mergeCssSets(styleSets, getStyleOptions());
    }
    function mergeCssSets(styleSets, options) {
      var classNameSet = { subComponentStyles: {} };
      var styleSet = styleSets[0];
      if (!styleSet && styleSets.length <= 1) {
        return { subComponentStyles: {} };
      }
      var concatenatedStyleSet = concatStyleSets.apply(void 0, styleSets);
      var registrations = [];
      for (var styleSetArea in concatenatedStyleSet) {
        if (concatenatedStyleSet.hasOwnProperty(styleSetArea)) {
          if (styleSetArea === "subComponentStyles") {
            classNameSet.subComponentStyles = concatenatedStyleSet.subComponentStyles || {};
            continue;
          }
          var styles2 = concatenatedStyleSet[styleSetArea];
          var _a2 = extractStyleParts(styles2), classes = _a2.classes, objects = _a2.objects;
          if (objects === null || objects === void 0 ? void 0 : objects.length) {
            var registration = styleToRegistration(options || {}, { displayName: styleSetArea }, objects);
            if (registration) {
              registrations.push(registration);
              classNameSet[styleSetArea] = classes.concat([registration.className]).join(" ");
            }
          } else {
            classNameSet[styleSetArea] = classes.join(" ");
          }
        }
      }
      for (var _i = 0, registrations_1 = registrations; _i < registrations_1.length; _i++) {
        var registration = registrations_1[_i];
        if (registration) {
          applyRegistration(registration, options === null || options === void 0 ? void 0 : options.specificityMultiplier);
        }
      }
      return classNameSet;
    }
    function concatStyleSetsWithProps(styleProps) {
      var allStyles = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        allStyles[_i - 1] = arguments[_i];
      }
      var result = [];
      for (var _a2 = 0, allStyles_1 = allStyles; _a2 < allStyles_1.length; _a2++) {
        var styles2 = allStyles_1[_a2];
        if (styles2) {
          result.push(typeof styles2 === "function" ? styles2(styleProps) : styles2);
        }
      }
      if (result.length === 1) {
        return result[0];
      } else if (result.length) {
        return concatStyleSets.apply(void 0, result);
      }
      return {};
    }
    function fontFace(font) {
      var stylesheet2 = Stylesheet.getInstance();
      var rule = serializeRuleEntries(getStyleOptions(), font);
      var className = stylesheet2.classNameFromKey(rule);
      if (className) {
        return;
      }
      var name2 = stylesheet2.getClassName();
      stylesheet2.insertRule("@font-face{" + rule + "}", true);
      stylesheet2.cacheClassName(name2, rule, [], ["font-face", rule]);
    }
    function keyframes(timeline) {
      var stylesheet2 = Stylesheet.getInstance();
      var rulesArray = [];
      for (var prop in timeline) {
        if (timeline.hasOwnProperty(prop)) {
          rulesArray.push(prop, "{", serializeRuleEntries(getStyleOptions(), timeline[prop]), "}");
        }
      }
      var rules2 = rulesArray.join("");
      var className = stylesheet2.classNameFromKey(rules2);
      if (className) {
        return className;
      }
      var name2 = stylesheet2.getClassName();
      stylesheet2.insertRule("@keyframes " + name2 + "{" + rules2 + "}", true);
      stylesheet2.cacheClassName(name2, rules2, [], ["keyframes", rules2]);
      return name2;
    }
    function buildClassMap(styles2) {
      var classes = {};
      var _loop_1 = function(styleName2) {
        if (styles2.hasOwnProperty(styleName2)) {
          var className_1;
          Object.defineProperty(classes, styleName2, {
            get: function() {
              if (className_1 === void 0) {
                className_1 = mergeStyles(styles2[styleName2]).toString();
              }
              return className_1;
            },
            enumerable: true,
            configurable: true
          });
        }
      };
      for (var styleName in styles2) {
        _loop_1(styleName);
      }
      return classes;
    }
    var _window = void 0;
    try {
      _window = window;
    } catch (e2) {
    }
    function getWindow(rootElement) {
      if (typeof _window === "undefined") {
        return void 0;
      } else {
        var el = rootElement;
        return el && el.ownerDocument && el.ownerDocument.defaultView ? el.ownerDocument.defaultView : _window;
      }
    }
    var Async = (
      /** @class */
      function() {
        function Async2(parent, onError) {
          this._timeoutIds = null;
          this._immediateIds = null;
          this._intervalIds = null;
          this._animationFrameIds = null;
          this._isDisposed = false;
          this._parent = parent || null;
          this._onErrorHandler = onError;
          this._noop = function() {
          };
        }
        Async2.prototype.dispose = function() {
          var id2;
          this._isDisposed = true;
          this._parent = null;
          if (this._timeoutIds) {
            for (id2 in this._timeoutIds) {
              if (this._timeoutIds.hasOwnProperty(id2)) {
                this.clearTimeout(parseInt(id2, 10));
              }
            }
            this._timeoutIds = null;
          }
          if (this._immediateIds) {
            for (id2 in this._immediateIds) {
              if (this._immediateIds.hasOwnProperty(id2)) {
                this.clearImmediate(parseInt(id2, 10));
              }
            }
            this._immediateIds = null;
          }
          if (this._intervalIds) {
            for (id2 in this._intervalIds) {
              if (this._intervalIds.hasOwnProperty(id2)) {
                this.clearInterval(parseInt(id2, 10));
              }
            }
            this._intervalIds = null;
          }
          if (this._animationFrameIds) {
            for (id2 in this._animationFrameIds) {
              if (this._animationFrameIds.hasOwnProperty(id2)) {
                this.cancelAnimationFrame(parseInt(id2, 10));
              }
            }
            this._animationFrameIds = null;
          }
        };
        Async2.prototype.setTimeout = function(callback, duration) {
          var _this = this;
          var timeoutId = 0;
          if (!this._isDisposed) {
            if (!this._timeoutIds) {
              this._timeoutIds = {};
            }
            timeoutId = setTimeout(function() {
              try {
                if (_this._timeoutIds) {
                  delete _this._timeoutIds[timeoutId];
                }
                callback.apply(_this._parent);
              } catch (e2) {
                _this._logError(e2);
              }
            }, duration);
            this._timeoutIds[timeoutId] = true;
          }
          return timeoutId;
        };
        Async2.prototype.clearTimeout = function(id2) {
          if (this._timeoutIds && this._timeoutIds[id2]) {
            clearTimeout(id2);
            delete this._timeoutIds[id2];
          }
        };
        Async2.prototype.setImmediate = function(callback, targetElement) {
          var _this = this;
          var immediateId = 0;
          var win = getWindow(targetElement);
          if (!this._isDisposed) {
            if (!this._immediateIds) {
              this._immediateIds = {};
            }
            var setImmediateCallback = function() {
              try {
                if (_this._immediateIds) {
                  delete _this._immediateIds[immediateId];
                }
                callback.apply(_this._parent);
              } catch (e2) {
                _this._logError(e2);
              }
            };
            immediateId = win.setTimeout(setImmediateCallback, 0);
            this._immediateIds[immediateId] = true;
          }
          return immediateId;
        };
        Async2.prototype.clearImmediate = function(id2, targetElement) {
          var win = getWindow(targetElement);
          if (this._immediateIds && this._immediateIds[id2]) {
            win.clearTimeout(id2);
            delete this._immediateIds[id2];
          }
        };
        Async2.prototype.setInterval = function(callback, duration) {
          var _this = this;
          var intervalId = 0;
          if (!this._isDisposed) {
            if (!this._intervalIds) {
              this._intervalIds = {};
            }
            intervalId = setInterval(function() {
              try {
                callback.apply(_this._parent);
              } catch (e2) {
                _this._logError(e2);
              }
            }, duration);
            this._intervalIds[intervalId] = true;
          }
          return intervalId;
        };
        Async2.prototype.clearInterval = function(id2) {
          if (this._intervalIds && this._intervalIds[id2]) {
            clearInterval(id2);
            delete this._intervalIds[id2];
          }
        };
        Async2.prototype.throttle = function(func, wait, options) {
          var _this = this;
          if (this._isDisposed) {
            return this._noop;
          }
          var waitMS = wait || 0;
          var leading = true;
          var trailing = true;
          var lastExecuteTime = 0;
          var lastResult;
          var lastArgs;
          var timeoutId = null;
          if (options && typeof options.leading === "boolean") {
            leading = options.leading;
          }
          if (options && typeof options.trailing === "boolean") {
            trailing = options.trailing;
          }
          var callback = function(userCall) {
            var now2 = Date.now();
            var delta = now2 - lastExecuteTime;
            var waitLength = leading ? waitMS - delta : waitMS;
            if (delta >= waitMS && (!userCall || leading)) {
              lastExecuteTime = now2;
              if (timeoutId) {
                _this.clearTimeout(timeoutId);
                timeoutId = null;
              }
              lastResult = func.apply(_this._parent, lastArgs);
            } else if (timeoutId === null && trailing) {
              timeoutId = _this.setTimeout(callback, waitLength);
            }
            return lastResult;
          };
          var resultFunction = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            lastArgs = args;
            return callback(true);
          };
          return resultFunction;
        };
        Async2.prototype.debounce = function(func, wait, options) {
          var _this = this;
          if (this._isDisposed) {
            var noOpFunction = function() {
            };
            noOpFunction.cancel = function() {
              return;
            };
            noOpFunction.flush = function() {
              return null;
            };
            noOpFunction.pending = function() {
              return false;
            };
            return noOpFunction;
          }
          var waitMS = wait || 0;
          var leading = false;
          var trailing = true;
          var maxWait = null;
          var lastCallTime = 0;
          var lastExecuteTime = Date.now();
          var lastResult;
          var lastArgs;
          var timeoutId = null;
          if (options && typeof options.leading === "boolean") {
            leading = options.leading;
          }
          if (options && typeof options.trailing === "boolean") {
            trailing = options.trailing;
          }
          if (options && typeof options.maxWait === "number" && !isNaN(options.maxWait)) {
            maxWait = options.maxWait;
          }
          var markExecuted = function(time) {
            if (timeoutId) {
              _this.clearTimeout(timeoutId);
              timeoutId = null;
            }
            lastExecuteTime = time;
          };
          var invokeFunction = function(time) {
            markExecuted(time);
            lastResult = func.apply(_this._parent, lastArgs);
          };
          var callback = function(userCall) {
            var now2 = Date.now();
            var executeImmediately = false;
            if (userCall) {
              if (leading && now2 - lastCallTime >= waitMS) {
                executeImmediately = true;
              }
              lastCallTime = now2;
            }
            var delta = now2 - lastCallTime;
            var waitLength = waitMS - delta;
            var maxWaitDelta = now2 - lastExecuteTime;
            var maxWaitExpired = false;
            if (maxWait !== null) {
              if (maxWaitDelta >= maxWait && timeoutId) {
                maxWaitExpired = true;
              } else {
                waitLength = Math.min(waitLength, maxWait - maxWaitDelta);
              }
            }
            if (delta >= waitMS || maxWaitExpired || executeImmediately) {
              invokeFunction(now2);
            } else if ((timeoutId === null || !userCall) && trailing) {
              timeoutId = _this.setTimeout(callback, waitLength);
            }
            return lastResult;
          };
          var pending = function() {
            return !!timeoutId;
          };
          var cancel = function() {
            if (pending()) {
              markExecuted(Date.now());
            }
          };
          var flush = function() {
            if (pending()) {
              invokeFunction(Date.now());
            }
            return lastResult;
          };
          var resultFunction = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            lastArgs = args;
            return callback(true);
          };
          resultFunction.cancel = cancel;
          resultFunction.flush = flush;
          resultFunction.pending = pending;
          return resultFunction;
        };
        Async2.prototype.requestAnimationFrame = function(callback, targetElement) {
          var _this = this;
          var animationFrameId = 0;
          var win = getWindow(targetElement);
          if (!this._isDisposed) {
            if (!this._animationFrameIds) {
              this._animationFrameIds = {};
            }
            var animationFrameCallback = function() {
              try {
                if (_this._animationFrameIds) {
                  delete _this._animationFrameIds[animationFrameId];
                }
                callback.apply(_this._parent);
              } catch (e2) {
                _this._logError(e2);
              }
            };
            animationFrameId = win.requestAnimationFrame ? win.requestAnimationFrame(animationFrameCallback) : win.setTimeout(animationFrameCallback, 0);
            this._animationFrameIds[animationFrameId] = true;
          }
          return animationFrameId;
        };
        Async2.prototype.cancelAnimationFrame = function(id2, targetElement) {
          var win = getWindow(targetElement);
          if (this._animationFrameIds && this._animationFrameIds[id2]) {
            win.cancelAnimationFrame ? win.cancelAnimationFrame(id2) : win.clearTimeout(id2);
            delete this._animationFrameIds[id2];
          }
        };
        Async2.prototype._logError = function(e2) {
          if (this._onErrorHandler) {
            this._onErrorHandler(e2);
          }
        };
        return Async2;
      }()
    );
    function shallowCompare(a2, b2) {
      for (var propName in a2) {
        if (a2.hasOwnProperty(propName)) {
          if (!b2.hasOwnProperty(propName) || b2[propName] !== a2[propName]) {
            return false;
          }
        }
      }
      for (var propName in b2) {
        if (b2.hasOwnProperty(propName)) {
          if (!a2.hasOwnProperty(propName)) {
            return false;
          }
        }
      }
      return true;
    }
    function assign$4(target) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      return filteredAssign.apply(this, [null, target].concat(args));
    }
    function filteredAssign(isAllowed, target) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      target = target || {};
      for (var _a2 = 0, args_1 = args; _a2 < args_1.length; _a2++) {
        var sourceObject = args_1[_a2];
        if (sourceObject) {
          for (var propName in sourceObject) {
            if (sourceObject.hasOwnProperty(propName) && (!isAllowed || isAllowed(propName))) {
              target[propName] = sourceObject[propName];
            }
          }
        }
      }
      return target;
    }
    var EventGroup = (
      /** @class */
      function() {
        function EventGroup2(parent) {
          this._id = EventGroup2._uniqueId++;
          this._parent = parent;
          this._eventRecords = [];
        }
        EventGroup2.raise = function(target, eventName, eventArgs, bubbleEvent) {
          var retVal2;
          if (EventGroup2._isElement(target)) {
            if (typeof document !== "undefined" && document.createEvent) {
              var ev = document.createEvent("HTMLEvents");
              ev.initEvent(eventName, bubbleEvent || false, true);
              assign$4(ev, eventArgs);
              retVal2 = target.dispatchEvent(ev);
            } else if (typeof document !== "undefined" && document.createEventObject) {
              var evObj = document.createEventObject(eventArgs);
              target.fireEvent("on" + eventName, evObj);
            }
          } else {
            while (target && retVal2 !== false) {
              var events = target.__events__;
              var eventRecords = events ? events[eventName] : null;
              if (eventRecords) {
                for (var id2 in eventRecords) {
                  if (eventRecords.hasOwnProperty(id2)) {
                    var eventRecordList = eventRecords[id2];
                    for (var listIndex = 0; retVal2 !== false && listIndex < eventRecordList.length; listIndex++) {
                      var record = eventRecordList[listIndex];
                      if (record.objectCallback) {
                        retVal2 = record.objectCallback.call(record.parent, eventArgs);
                      }
                    }
                  }
                }
              }
              target = bubbleEvent ? target.parent : null;
            }
          }
          return retVal2;
        };
        EventGroup2.isObserved = function(target, eventName) {
          var events = target && target.__events__;
          return !!events && !!events[eventName];
        };
        EventGroup2.isDeclared = function(target, eventName) {
          var declaredEvents = target && target.__declaredEvents;
          return !!declaredEvents && !!declaredEvents[eventName];
        };
        EventGroup2.stopPropagation = function(event) {
          if (event.stopPropagation) {
            event.stopPropagation();
          } else {
            event.cancelBubble = true;
          }
        };
        EventGroup2._isElement = function(target) {
          return !!target && (!!target.addEventListener || typeof HTMLElement !== "undefined" && target instanceof HTMLElement);
        };
        EventGroup2.prototype.dispose = function() {
          if (!this._isDisposed) {
            this._isDisposed = true;
            this.off();
            this._parent = null;
          }
        };
        EventGroup2.prototype.onAll = function(target, events, useCapture) {
          for (var eventName in events) {
            if (events.hasOwnProperty(eventName)) {
              this.on(target, eventName, events[eventName], useCapture);
            }
          }
        };
        EventGroup2.prototype.on = function(target, eventName, callback, options) {
          var _this = this;
          if (eventName.indexOf(",") > -1) {
            var events = eventName.split(/[ ,]+/);
            for (var i2 = 0; i2 < events.length; i2++) {
              this.on(target, events[i2], callback, options);
            }
          } else {
            var parent_1 = this._parent;
            var eventRecord = {
              target,
              eventName,
              parent: parent_1,
              callback,
              options
            };
            var events = target.__events__ = target.__events__ || {};
            events[eventName] = events[eventName] || {
              count: 0
            };
            events[eventName][this._id] = events[eventName][this._id] || [];
            events[eventName][this._id].push(eventRecord);
            events[eventName].count++;
            if (EventGroup2._isElement(target)) {
              var processElementEvent = function() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
                }
                if (_this._isDisposed) {
                  return;
                }
                var result;
                try {
                  result = callback.apply(parent_1, args);
                  if (result === false && args[0]) {
                    var e2 = args[0];
                    if (e2.preventDefault) {
                      e2.preventDefault();
                    }
                    if (e2.stopPropagation) {
                      e2.stopPropagation();
                    }
                    e2.cancelBubble = true;
                  }
                } catch (e3) {
                }
                return result;
              };
              eventRecord.elementCallback = processElementEvent;
              if (target.addEventListener) {
                target.addEventListener(eventName, processElementEvent, options);
              } else if (target.attachEvent) {
                target.attachEvent("on" + eventName, processElementEvent);
              }
            } else {
              var processObjectEvent = function() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
                }
                if (_this._isDisposed) {
                  return;
                }
                return callback.apply(parent_1, args);
              };
              eventRecord.objectCallback = processObjectEvent;
            }
            this._eventRecords.push(eventRecord);
          }
        };
        EventGroup2.prototype.off = function(target, eventName, callback, options) {
          for (var i2 = 0; i2 < this._eventRecords.length; i2++) {
            var eventRecord = this._eventRecords[i2];
            if ((!target || target === eventRecord.target) && (!eventName || eventName === eventRecord.eventName) && (!callback || callback === eventRecord.callback) && (typeof options !== "boolean" || options === eventRecord.options)) {
              var events = eventRecord.target.__events__;
              var targetArrayLookup = events[eventRecord.eventName];
              var targetArray = targetArrayLookup ? targetArrayLookup[this._id] : null;
              if (targetArray) {
                if (targetArray.length === 1 || !callback) {
                  targetArrayLookup.count -= targetArray.length;
                  delete events[eventRecord.eventName][this._id];
                } else {
                  targetArrayLookup.count--;
                  targetArray.splice(targetArray.indexOf(eventRecord), 1);
                }
                if (!targetArrayLookup.count) {
                  delete events[eventRecord.eventName];
                }
              }
              if (eventRecord.elementCallback) {
                if (eventRecord.target.removeEventListener) {
                  eventRecord.target.removeEventListener(eventRecord.eventName, eventRecord.elementCallback, eventRecord.options);
                } else if (eventRecord.target.detachEvent) {
                  eventRecord.target.detachEvent("on" + eventRecord.eventName, eventRecord.elementCallback);
                }
              }
              this._eventRecords.splice(i2--, 1);
            }
          }
        };
        EventGroup2.prototype.raise = function(eventName, eventArgs, bubbleEvent) {
          return EventGroup2.raise(this._parent, eventName, eventArgs, bubbleEvent);
        };
        EventGroup2.prototype.declare = function(event) {
          var declaredEvents = this._parent.__declaredEvents = this._parent.__declaredEvents || {};
          if (typeof event === "string") {
            declaredEvents[event] = true;
          } else {
            for (var i2 = 0; i2 < event.length; i2++) {
              declaredEvents[event[i2]] = true;
            }
          }
        };
        EventGroup2._uniqueId = 0;
        return EventGroup2;
      }()
    );
    function getDocument(rootElement) {
      if (typeof document === "undefined") {
        return void 0;
      } else {
        var el = rootElement;
        return el && el.ownerDocument ? el.ownerDocument : document;
      }
    }
    var _scrollbarWidth;
    mergeStyles({
      overflow: "hidden !important"
    });
    var DATA_IS_SCROLLABLE_ATTRIBUTE = "data-is-scrollable";
    function getScrollbarWidth() {
      if (_scrollbarWidth === void 0) {
        var scrollDiv = document.createElement("div");
        scrollDiv.style.setProperty("width", "100px");
        scrollDiv.style.setProperty("height", "100px");
        scrollDiv.style.setProperty("overflow", "scroll");
        scrollDiv.style.setProperty("position", "absolute");
        scrollDiv.style.setProperty("top", "-9999px");
        document.body.appendChild(scrollDiv);
        _scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        document.body.removeChild(scrollDiv);
      }
      return _scrollbarWidth;
    }
    function findScrollableParent(startingElement) {
      var el = startingElement;
      var doc = getDocument(startingElement);
      while (el && el !== doc.body) {
        if (el.getAttribute(DATA_IS_SCROLLABLE_ATTRIBUTE) === "true") {
          return el;
        }
        el = el.parentElement;
      }
      el = startingElement;
      while (el && el !== doc.body) {
        if (el.getAttribute(DATA_IS_SCROLLABLE_ATTRIBUTE) !== "false") {
          var computedStyles = getComputedStyle(el);
          var overflowY = computedStyles ? computedStyles.getPropertyValue("overflow-y") : "";
          if (overflowY && (overflowY === "scroll" || overflowY === "auto")) {
            return el;
          }
        }
        el = el.parentElement;
      }
      if (!el || el === doc.body) {
        el = getWindow(startingElement);
      }
      return el;
    }
    var _warningCallback = void 0;
    function warn$1(message) {
      if (_warningCallback && false) {
        _warningCallback(message);
      } else if (console && console.warn) {
        console.warn(message);
      }
    }
    function warnConditionallyRequiredProps(componentName, props, requiredProps, conditionalPropName, condition) {
      if (condition === true && false) {
        for (var _i = 0, requiredProps_1 = requiredProps; _i < requiredProps_1.length; _i++) {
          var requiredPropName = requiredProps_1[_i];
          if (!(requiredPropName in props)) {
            warn$1(componentName + " property '" + requiredPropName + "' is required when '" + conditionalPropName + "' is used.'");
          }
        }
      }
    }
    function warnMutuallyExclusive(componentName, props, exclusiveMap) {
    }
    function warnDeprecations(componentName, props, deprecationMap) {
    }
    (function(_super) {
      __extends(BaseComponent, _super);
      function BaseComponent(props, context) {
        var _this = _super.call(this, props, context) || this;
        _makeAllSafe(_this, BaseComponent.prototype, [
          "componentDidMount",
          "shouldComponentUpdate",
          "getSnapshotBeforeUpdate",
          "render",
          "componentDidUpdate",
          "componentWillUnmount"
        ]);
        return _this;
      }
      BaseComponent.prototype.componentDidUpdate = function(prevProps, prevState) {
        this._updateComponentRef(prevProps, this.props);
      };
      BaseComponent.prototype.componentDidMount = function() {
        this._setComponentRef(this.props.componentRef, this);
      };
      BaseComponent.prototype.componentWillUnmount = function() {
        this._setComponentRef(this.props.componentRef, null);
        if (this.__disposables) {
          for (var i2 = 0, len = this._disposables.length; i2 < len; i2++) {
            var disposable = this.__disposables[i2];
            if (disposable.dispose) {
              disposable.dispose();
            }
          }
          this.__disposables = null;
        }
      };
      Object.defineProperty(BaseComponent.prototype, "className", {
        /**
         * Gets the object's class name.
         */
        get: function() {
          if (!this.__className) {
            var funcNameRegex = /function (.{1,})\(/;
            var results = funcNameRegex.exec(this.constructor.toString());
            this.__className = results && results.length > 1 ? results[1] : "";
          }
          return this.__className;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseComponent.prototype, "_disposables", {
        /**
         * Allows subclasses to push things to this._disposables to be auto disposed.
         */
        get: function() {
          if (!this.__disposables) {
            this.__disposables = [];
          }
          return this.__disposables;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseComponent.prototype, "_async", {
        /**
         * Gets the async instance associated with the component, created on demand. The async instance gives
         * subclasses a way to execute setTimeout/setInterval async calls safely, where the callbacks
         * will be cleared/ignored automatically after unmounting. The helpers within the async object also
         * preserve the this pointer so that you don't need to "bind" the callbacks.
         */
        get: function() {
          if (!this.__async) {
            this.__async = new Async(this);
            this._disposables.push(this.__async);
          }
          return this.__async;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BaseComponent.prototype, "_events", {
        /**
         * Gets the event group instance assocaited with the component, created on demand. The event instance
         * provides on/off methods for listening to DOM (or regular javascript object) events. The event callbacks
         * will be automatically disconnected after unmounting. The helpers within the events object also
         * preserve the this reference so that you don't need to "bind" the callbacks.
         */
        get: function() {
          if (!this.__events) {
            this.__events = new EventGroup(this);
            this._disposables.push(this.__events);
          }
          return this.__events;
        },
        enumerable: false,
        configurable: true
      });
      BaseComponent.prototype._resolveRef = function(refName) {
        var _this = this;
        if (!this.__resolves) {
          this.__resolves = {};
        }
        if (!this.__resolves[refName]) {
          this.__resolves[refName] = function(ref) {
            return _this[refName] = ref;
          };
        }
        return this.__resolves[refName];
      };
      BaseComponent.prototype._updateComponentRef = function(currentProps, newProps) {
        if (newProps === void 0) {
          newProps = {};
        }
        if (currentProps && newProps && currentProps.componentRef !== newProps.componentRef) {
          this._setComponentRef(currentProps.componentRef, null);
          this._setComponentRef(newProps.componentRef, this);
        }
      };
      BaseComponent.prototype._warnDeprecations = function(deprecationMap) {
        warnDeprecations(this.className, this.props);
      };
      BaseComponent.prototype._warnMutuallyExclusive = function(mutuallyExclusiveMap) {
        warnMutuallyExclusive(this.className, this.props);
      };
      BaseComponent.prototype._warnConditionallyRequiredProps = function(requiredProps, conditionalPropName, condition) {
        warnConditionallyRequiredProps(this.className, this.props, requiredProps, conditionalPropName, condition);
      };
      BaseComponent.prototype._setComponentRef = function(ref, value) {
        if (!this._skipComponentRefResolution && ref) {
          if (typeof ref === "function") {
            ref(value);
          }
          if (typeof ref === "object") {
            ref.current = value;
          }
        }
      };
      return BaseComponent;
    })(reactExports.Component);
    function _makeAllSafe(obj, prototype, methodNames) {
      for (var i2 = 0, len = methodNames.length; i2 < len; i2++) {
        _makeSafe(obj, prototype, methodNames[i2]);
      }
    }
    function _makeSafe(obj, prototype, methodName) {
      var classMethod = obj[methodName];
      var prototypeMethod = prototype[methodName];
      if (classMethod || prototypeMethod) {
        obj[methodName] = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var retVal2;
          if (prototypeMethod) {
            retVal2 = prototypeMethod.apply(this, args);
          }
          if (classMethod !== prototypeMethod) {
            retVal2 = classMethod.apply(this, args);
          }
          return retVal2;
        };
      }
    }
    function nullRender() {
      return null;
    }
    var GLOBAL_SETTINGS_PROP_NAME = "__globalSettings__";
    var CALLBACK_STATE_PROP_NAME = "__callbacks__";
    var _counter = 0;
    var GlobalSettings = (
      /** @class */
      function() {
        function GlobalSettings2() {
        }
        GlobalSettings2.getValue = function(key, defaultValue) {
          var globalSettings = _getGlobalSettings();
          if (globalSettings[key] === void 0) {
            globalSettings[key] = typeof defaultValue === "function" ? defaultValue() : defaultValue;
          }
          return globalSettings[key];
        };
        GlobalSettings2.setValue = function(key, value) {
          var globalSettings = _getGlobalSettings();
          var callbacks = globalSettings[CALLBACK_STATE_PROP_NAME];
          var oldValue = globalSettings[key];
          if (value !== oldValue) {
            globalSettings[key] = value;
            var changeDescription = {
              oldValue,
              value,
              key
            };
            for (var id2 in callbacks) {
              if (callbacks.hasOwnProperty(id2)) {
                callbacks[id2](changeDescription);
              }
            }
          }
          return value;
        };
        GlobalSettings2.addChangeListener = function(cb2) {
          var id2 = cb2.__id__;
          var callbacks = _getCallbacks();
          if (!id2) {
            id2 = cb2.__id__ = String(_counter++);
          }
          callbacks[id2] = cb2;
        };
        GlobalSettings2.removeChangeListener = function(cb2) {
          var callbacks = _getCallbacks();
          delete callbacks[cb2.__id__];
        };
        return GlobalSettings2;
      }()
    );
    function _getGlobalSettings() {
      var _a2;
      var win = getWindow();
      var globalObj = win || {};
      if (!globalObj[GLOBAL_SETTINGS_PROP_NAME]) {
        globalObj[GLOBAL_SETTINGS_PROP_NAME] = (_a2 = {}, _a2[CALLBACK_STATE_PROP_NAME] = {}, _a2);
      }
      return globalObj[GLOBAL_SETTINGS_PROP_NAME];
    }
    function _getCallbacks() {
      var globalSettings = _getGlobalSettings();
      return globalSettings[CALLBACK_STATE_PROP_NAME];
    }
    var KeyCodes = {
      backspace: 8,
      tab: 9,
      enter: 13,
      shift: 16,
      ctrl: 17,
      alt: 18,
      pauseBreak: 19,
      capslock: 20,
      escape: 27,
      space: 32,
      pageUp: 33,
      pageDown: 34,
      end: 35,
      home: 36,
      left: 37,
      up: 38,
      right: 39,
      down: 40,
      insert: 45,
      del: 46,
      zero: 48,
      one: 49,
      two: 50,
      three: 51,
      four: 52,
      five: 53,
      six: 54,
      seven: 55,
      eight: 56,
      nine: 57,
      colon: 58,
      a: 65,
      b: 66,
      c: 67,
      d: 68,
      e: 69,
      f: 70,
      g: 71,
      h: 72,
      i: 73,
      j: 74,
      k: 75,
      l: 76,
      m: 77,
      n: 78,
      o: 79,
      p: 80,
      q: 81,
      r: 82,
      s: 83,
      t: 84,
      u: 85,
      v: 86,
      w: 87,
      x: 88,
      y: 89,
      z: 90,
      leftWindow: 91,
      rightWindow: 92,
      select: 93,
      /* eslint-disable @typescript-eslint/naming-convention */
      zero_numpad: 96,
      one_numpad: 97,
      two_numpad: 98,
      three_numpad: 99,
      four_numpad: 100,
      five_numpad: 101,
      six_numpad: 102,
      seven_numpad: 103,
      eight_numpad: 104,
      nine_numpad: 105,
      /* eslint-enable @typescript-eslint/naming-convention */
      multiply: 106,
      add: 107,
      subtract: 109,
      decimalPoint: 110,
      divide: 111,
      f1: 112,
      f2: 113,
      f3: 114,
      f4: 115,
      f5: 116,
      f6: 117,
      f7: 118,
      f8: 119,
      f9: 120,
      f10: 121,
      f11: 122,
      f12: 123,
      numlock: 144,
      scrollLock: 145,
      semicolon: 186,
      equalSign: 187,
      comma: 188,
      dash: 189,
      period: 190,
      forwardSlash: 191,
      graveAccent: 192,
      openBracket: 219,
      backSlash: 220,
      closeBracket: 221,
      singleQuote: 222
    };
    var Rectangle = (
      /** @class */
      function() {
        function Rectangle2(left, right, top, bottom) {
          if (left === void 0) {
            left = 0;
          }
          if (right === void 0) {
            right = 0;
          }
          if (top === void 0) {
            top = 0;
          }
          if (bottom === void 0) {
            bottom = 0;
          }
          this.top = top;
          this.bottom = bottom;
          this.left = left;
          this.right = right;
        }
        Object.defineProperty(Rectangle2.prototype, "width", {
          /**
           * Calculated automatically by subtracting the right from left
           */
          get: function() {
            return this.right - this.left;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Rectangle2.prototype, "height", {
          /**
           * Calculated automatically by subtracting the bottom from top.
           */
          get: function() {
            return this.bottom - this.top;
          },
          enumerable: false,
          configurable: true
        });
        Rectangle2.prototype.equals = function(rect) {
          return parseFloat(this.top.toFixed(4)) === parseFloat(rect.top.toFixed(4)) && parseFloat(this.bottom.toFixed(4)) === parseFloat(rect.bottom.toFixed(4)) && parseFloat(this.left.toFixed(4)) === parseFloat(rect.left.toFixed(4)) && parseFloat(this.right.toFixed(4)) === parseFloat(rect.right.toFixed(4));
        };
        return Rectangle2;
      }()
    );
    function appendFunction(parent) {
      var functions = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        functions[_i - 1] = arguments[_i];
      }
      if (functions.length < 2) {
        return functions[0];
      }
      return function() {
        var args = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          args[_i2] = arguments[_i2];
        }
        functions.forEach(function(f2) {
          return f2 && f2.apply(parent, args);
        });
      };
    }
    function mergeAriaAttributeValues() {
      var ariaAttributes = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        ariaAttributes[_i] = arguments[_i];
      }
      var mergedAttribute = ariaAttributes.filter(function(arg) {
        return arg;
      }).join(" ").trim();
      return mergedAttribute === "" ? void 0 : mergedAttribute;
    }
    function addElementAtIndex(array, index2, itemToAdd) {
      var copy2 = array.slice();
      copy2.splice(index2, 0, itemToAdd);
      return copy2;
    }
    function arraysEqual(array1, array2) {
      if (array1.length !== array2.length) {
        return false;
      }
      for (var i2 = 0; i2 < array1.length; i2++) {
        if (array1[i2] !== array2[i2]) {
          return false;
        }
      }
      return true;
    }
    function getItem$1(key) {
      var result = null;
      try {
        var win = getWindow();
        result = win ? win.sessionStorage.getItem(key) : null;
      } catch (e2) {
      }
      return result;
    }
    function setItem(key, data) {
      var _a2;
      try {
        (_a2 = getWindow()) === null || _a2 === void 0 ? void 0 : _a2.sessionStorage.setItem(key, data);
      } catch (e2) {
      }
    }
    var RTL_LOCAL_STORAGE_KEY = "isRTL";
    var _isRTL;
    function getRTL(theme) {
      if (theme === void 0) {
        theme = {};
      }
      if (theme.rtl !== void 0) {
        return theme.rtl;
      }
      if (_isRTL === void 0) {
        var savedRTL = getItem$1(RTL_LOCAL_STORAGE_KEY);
        if (savedRTL !== null) {
          _isRTL = savedRTL === "1";
          setRTL(_isRTL);
        }
        var doc = getDocument();
        if (_isRTL === void 0 && doc) {
          _isRTL = (doc.body && doc.body.getAttribute("dir") || doc.documentElement.getAttribute("dir")) === "rtl";
          setRTL$1(_isRTL);
        }
      }
      return !!_isRTL;
    }
    function setRTL(isRTL, persistSetting) {
      if (persistSetting === void 0) {
        persistSetting = false;
      }
      var doc = getDocument();
      if (doc) {
        doc.documentElement.setAttribute("dir", isRTL ? "rtl" : "ltr");
      }
      if (persistSetting) {
        setItem(RTL_LOCAL_STORAGE_KEY, isRTL ? "1" : "0");
      }
      _isRTL = isRTL;
      setRTL$1(_isRTL);
    }
    function isVirtualElement$1(element2) {
      return element2 && !!element2._virtual;
    }
    function getVirtualParent$1(child) {
      var parent;
      if (child && isVirtualElement$1(child)) {
        parent = child._virtual.parent;
      }
      return parent;
    }
    function getParent$1(child, allowVirtualParents) {
      if (allowVirtualParents === void 0) {
        allowVirtualParents = true;
      }
      return child && (allowVirtualParents && getVirtualParent$1(child) || child.parentNode && child.parentNode);
    }
    function elementContains$1(parent, child, allowVirtualParents) {
      if (allowVirtualParents === void 0) {
        allowVirtualParents = true;
      }
      var isContained = false;
      if (parent && child) {
        if (allowVirtualParents) {
          if (parent === child) {
            isContained = true;
          } else {
            isContained = false;
            while (child) {
              var nextParent = getParent$1(child);
              if (nextParent === parent) {
                isContained = true;
                break;
              }
              child = nextParent;
            }
          }
        } else if (parent.contains) {
          isContained = parent.contains(child);
        }
      }
      return isContained;
    }
    function findElementRecursive(element2, matchFunction) {
      if (!element2 || element2 === document.body) {
        return null;
      }
      return matchFunction(element2) ? element2 : findElementRecursive(getParent$1(element2), matchFunction);
    }
    function elementContainsAttribute(element2, attribute) {
      var elementMatch = findElementRecursive(element2, function(testElement) {
        return testElement.hasAttribute(attribute);
      });
      return elementMatch && elementMatch.getAttribute(attribute);
    }
    var DATA_PORTAL_ATTRIBUTE = "data-portal-element";
    function setPortalAttribute(element2) {
      element2.setAttribute(DATA_PORTAL_ATTRIBUTE, "true");
    }
    function portalContainsElement(target, parent) {
      var elementMatch = findElementRecursive(target, function(testElement) {
        return parent === testElement || testElement.hasAttribute(DATA_PORTAL_ATTRIBUTE);
      });
      return elementMatch !== null && elementMatch.hasAttribute(DATA_PORTAL_ATTRIBUTE);
    }
    function setVirtualParent$1(child, parent) {
      var virtualChild = child;
      var virtualParent = parent;
      if (!virtualChild._virtual) {
        virtualChild._virtual = {
          children: []
        };
      }
      var oldParent = virtualChild._virtual.parent;
      if (oldParent && oldParent !== parent) {
        var index2 = oldParent._virtual.children.indexOf(virtualChild);
        if (index2 > -1) {
          oldParent._virtual.children.splice(index2, 1);
        }
      }
      virtualChild._virtual.parent = virtualParent || void 0;
      if (virtualParent) {
        if (!virtualParent._virtual) {
          virtualParent._virtual = {
            children: []
          };
        }
        virtualParent._virtual.children.push(virtualChild);
      }
    }
    var IS_FOCUSABLE_ATTRIBUTE$1 = "data-is-focusable";
    var IS_VISIBLE_ATTRIBUTE = "data-is-visible";
    var FOCUSZONE_ID_ATTRIBUTE$1 = "data-focuszone-id";
    var FOCUSZONE_SUB_ATTRIBUTE = "data-is-sub-focuszone";
    function getFirstFocusable(rootElement, currentElement, includeElementsInFocusZones) {
      return getNextElement(rootElement, currentElement, true, false, false, includeElementsInFocusZones);
    }
    function getLastFocusable(rootElement, currentElement, includeElementsInFocusZones) {
      return getPreviousElement(rootElement, currentElement, true, false, true, includeElementsInFocusZones);
    }
    function focusFirstChild(rootElement) {
      var element2 = getNextElement(rootElement, rootElement, true, false, false, true);
      if (element2) {
        focusAsync(element2);
        return true;
      }
      return false;
    }
    function getPreviousElement(rootElement, currentElement, checkNode, suppressParentTraversal, traverseChildren, includeElementsInFocusZones, allowFocusRoot, tabbable) {
      if (!currentElement || !allowFocusRoot && currentElement === rootElement) {
        return null;
      }
      var isCurrentElementVisible = isElementVisible(currentElement);
      if (traverseChildren && isCurrentElementVisible && (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))) {
        var childMatch = getPreviousElement(rootElement, currentElement.lastElementChild, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);
        if (childMatch) {
          if (tabbable && isElementTabbable(childMatch, true) || !tabbable) {
            return childMatch;
          }
          var childMatchSiblingMatch = getPreviousElement(rootElement, childMatch.previousElementSibling, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);
          if (childMatchSiblingMatch) {
            return childMatchSiblingMatch;
          }
          var childMatchParent = childMatch.parentElement;
          while (childMatchParent && childMatchParent !== currentElement) {
            var childMatchParentMatch = getPreviousElement(rootElement, childMatchParent.previousElementSibling, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);
            if (childMatchParentMatch) {
              return childMatchParentMatch;
            }
            childMatchParent = childMatchParent.parentElement;
          }
        }
      }
      if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable)) {
        return currentElement;
      }
      var siblingMatch = getPreviousElement(rootElement, currentElement.previousElementSibling, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);
      if (siblingMatch) {
        return siblingMatch;
      }
      if (!suppressParentTraversal) {
        return getPreviousElement(rootElement, currentElement.parentElement, true, false, false, includeElementsInFocusZones, allowFocusRoot, tabbable);
      }
      return null;
    }
    function getNextElement(rootElement, currentElement, checkNode, suppressParentTraversal, suppressChildTraversal, includeElementsInFocusZones, allowFocusRoot, tabbable) {
      if (!currentElement || currentElement === rootElement && suppressChildTraversal && !allowFocusRoot) {
        return null;
      }
      var isCurrentElementVisible = isElementVisible(currentElement);
      if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement, tabbable)) {
        return currentElement;
      }
      if (!suppressChildTraversal && isCurrentElementVisible && (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))) {
        var childMatch = getNextElement(rootElement, currentElement.firstElementChild, true, true, false, includeElementsInFocusZones, allowFocusRoot, tabbable);
        if (childMatch) {
          return childMatch;
        }
      }
      if (currentElement === rootElement) {
        return null;
      }
      var siblingMatch = getNextElement(rootElement, currentElement.nextElementSibling, true, true, false, includeElementsInFocusZones, allowFocusRoot, tabbable);
      if (siblingMatch) {
        return siblingMatch;
      }
      if (!suppressParentTraversal) {
        return getNextElement(rootElement, currentElement.parentElement, false, false, true, includeElementsInFocusZones, allowFocusRoot, tabbable);
      }
      return null;
    }
    function isElementVisible(element2) {
      if (!element2 || !element2.getAttribute) {
        return false;
      }
      var visibilityAttribute = element2.getAttribute(IS_VISIBLE_ATTRIBUTE);
      if (visibilityAttribute !== null && visibilityAttribute !== void 0) {
        return visibilityAttribute === "true";
      }
      return element2.offsetHeight !== 0 || element2.offsetParent !== null || // eslint-disable-next-line @typescript-eslint/no-explicit-any
      element2.isVisible === true;
    }
    function isElementTabbable(element2, checkTabIndex) {
      if (!element2 || element2.disabled) {
        return false;
      }
      var tabIndex = 0;
      var tabIndexAttributeValue = null;
      if (element2 && element2.getAttribute) {
        tabIndexAttributeValue = element2.getAttribute("tabIndex");
        if (tabIndexAttributeValue) {
          tabIndex = parseInt(tabIndexAttributeValue, 10);
        }
      }
      var isFocusableAttribute = element2.getAttribute ? element2.getAttribute(IS_FOCUSABLE_ATTRIBUTE$1) : null;
      var isTabIndexSet = tabIndexAttributeValue !== null && tabIndex >= 0;
      var result = !!element2 && isFocusableAttribute !== "false" && (element2.tagName === "A" || element2.tagName === "BUTTON" || element2.tagName === "INPUT" || element2.tagName === "TEXTAREA" || element2.tagName === "SELECT" || isFocusableAttribute === "true" || isTabIndexSet);
      return checkTabIndex ? tabIndex !== -1 && result : result;
    }
    function isElementFocusZone(element2) {
      return !!(element2 && element2.getAttribute && !!element2.getAttribute(FOCUSZONE_ID_ATTRIBUTE$1));
    }
    function isElementFocusSubZone(element2) {
      return !!(element2 && element2.getAttribute && element2.getAttribute(FOCUSZONE_SUB_ATTRIBUTE) === "true");
    }
    function doesElementContainFocus(element2) {
      var document2 = getDocument(element2);
      var currentActiveElement = document2 && document2.activeElement;
      if (currentActiveElement && elementContains$1(element2, currentActiveElement)) {
        return true;
      }
      return false;
    }
    function shouldWrapFocus(element2, noWrapDataAttribute) {
      return elementContainsAttribute(element2, noWrapDataAttribute) === "true" ? false : true;
    }
    var targetToFocusOnNextRepaint = void 0;
    function focusAsync(element2) {
      if (element2) {
        if (targetToFocusOnNextRepaint) {
          targetToFocusOnNextRepaint = element2;
          return;
        }
        targetToFocusOnNextRepaint = element2;
        var win = getWindow(element2);
        if (win) {
          win.requestAnimationFrame(function() {
            targetToFocusOnNextRepaint && targetToFocusOnNextRepaint.focus();
            targetToFocusOnNextRepaint = void 0;
          });
        }
      }
    }
    function getFocusableByIndexPath(parent, path2) {
      var element2 = parent;
      for (var _i = 0, path_1 = path2; _i < path_1.length; _i++) {
        var index2 = path_1[_i];
        var nextChild = element2.children[Math.min(index2, element2.children.length - 1)];
        if (!nextChild) {
          break;
        }
        element2 = nextChild;
      }
      element2 = isElementTabbable(element2) && isElementVisible(element2) ? element2 : getNextElement(parent, element2, true) || getPreviousElement(parent, element2);
      return element2;
    }
    function getElementIndexPath(fromElement, toElement) {
      var path2 = [];
      while (toElement && fromElement && toElement !== fromElement) {
        var parent_1 = getParent$1(toElement, true);
        if (parent_1 === null) {
          return [];
        }
        path2.unshift(Array.prototype.indexOf.call(parent_1.children, toElement));
        toElement = parent_1;
      }
      return path2;
    }
    function on(element2, eventName, callback, options) {
      element2.addEventListener(eventName, callback, options);
      return function() {
        return element2.removeEventListener(eventName, callback, options);
      };
    }
    var MAX_CACHE_COUNT = 50;
    var DEFAULT_SPECIFICITY_MULTIPLIER = 5;
    var _memoizedClassNames = 0;
    var stylesheet$1 = Stylesheet.getInstance();
    if (stylesheet$1 && stylesheet$1.onReset) {
      stylesheet$1.onReset(function() {
        return _memoizedClassNames++;
      });
    }
    var retVal = "__retval__";
    function classNamesFunction(options) {
      if (options === void 0) {
        options = {};
      }
      var map2 = /* @__PURE__ */ new Map();
      var styleCalcCount = 0;
      var getClassNamesCount = 0;
      var currentMemoizedClassNames = _memoizedClassNames;
      var getClassNames2 = function(styleFunctionOrObject, styleProps) {
        var _a2;
        if (styleProps === void 0) {
          styleProps = {};
        }
        if (options.useStaticStyles && typeof styleFunctionOrObject === "function" && styleFunctionOrObject.__noStyleOverride__) {
          return styleFunctionOrObject(styleProps);
        }
        getClassNamesCount++;
        var current = map2;
        var theme = styleProps.theme;
        var rtl = theme && theme.rtl !== void 0 ? theme.rtl : getRTL();
        var disableCaching = options.disableCaching;
        if (currentMemoizedClassNames !== _memoizedClassNames) {
          currentMemoizedClassNames = _memoizedClassNames;
          map2 = /* @__PURE__ */ new Map();
          styleCalcCount = 0;
        }
        if (!options.disableCaching) {
          current = _traverseMap(map2, styleFunctionOrObject);
          current = _traverseMap(current, styleProps);
        }
        if (disableCaching || !current[retVal]) {
          if (styleFunctionOrObject === void 0) {
            current[retVal] = {};
          } else {
            current[retVal] = mergeCssSets([
              typeof styleFunctionOrObject === "function" ? styleFunctionOrObject(styleProps) : styleFunctionOrObject
            ], { rtl: !!rtl, specificityMultiplier: options.useStaticStyles ? DEFAULT_SPECIFICITY_MULTIPLIER : void 0 });
          }
          if (!disableCaching) {
            styleCalcCount++;
          }
        }
        if (styleCalcCount > (options.cacheSize || MAX_CACHE_COUNT)) {
          var win = getWindow();
          if ((_a2 = win === null || win === void 0 ? void 0 : win.FabricConfig) === null || _a2 === void 0 ? void 0 : _a2.enableClassNameCacheFullWarning) {
            console.warn("Styles are being recalculated too frequently. Cache miss rate is " + styleCalcCount + "/" + getClassNamesCount + ".");
            console.trace();
          }
          map2.clear();
          styleCalcCount = 0;
          options.disableCaching = true;
        }
        return current[retVal];
      };
      return getClassNames2;
    }
    function _traverseEdge(current, value) {
      value = _normalizeValue(value);
      if (!current.has(value)) {
        current.set(value, /* @__PURE__ */ new Map());
      }
      return current.get(value);
    }
    function _traverseMap(current, inputs) {
      if (typeof inputs === "function") {
        var cachedInputsFromStyled = inputs.__cachedInputs__;
        if (cachedInputsFromStyled) {
          for (var _i = 0, _a2 = inputs.__cachedInputs__; _i < _a2.length; _i++) {
            var input = _a2[_i];
            current = _traverseEdge(current, input);
          }
        } else {
          current = _traverseEdge(current, inputs);
        }
      } else if (typeof inputs === "object") {
        for (var propName in inputs) {
          if (inputs.hasOwnProperty(propName)) {
            current = _traverseEdge(current, inputs[propName]);
          }
        }
      }
      return current;
    }
    function _normalizeValue(value) {
      switch (value) {
        case void 0:
          return "__undefined__";
        case null:
          return "__null__";
        default:
          return value;
      }
    }
    var _initializedStylesheetResets$1 = false;
    var _resetCounter = 0;
    var _emptyObject = { empty: true };
    var _dictionary = {};
    var _weakMap = typeof WeakMap === "undefined" ? null : WeakMap;
    function resetMemoizations() {
      _resetCounter++;
    }
    function memoizeFunction(cb2, maxCacheSize, ignoreNullOrUndefinedResult) {
      if (maxCacheSize === void 0) {
        maxCacheSize = 100;
      }
      if (ignoreNullOrUndefinedResult === void 0) {
        ignoreNullOrUndefinedResult = false;
      }
      if (!_weakMap) {
        return cb2;
      }
      if (!_initializedStylesheetResets$1) {
        var stylesheet2 = Stylesheet.getInstance();
        if (stylesheet2 && stylesheet2.onReset) {
          Stylesheet.getInstance().onReset(resetMemoizations);
        }
        _initializedStylesheetResets$1 = true;
      }
      var rootNode;
      var cacheSize = 0;
      var localResetCounter = _resetCounter;
      return function memoizedFunction() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var currentNode = rootNode;
        if (rootNode === void 0 || localResetCounter !== _resetCounter || maxCacheSize > 0 && cacheSize > maxCacheSize) {
          rootNode = _createNode();
          cacheSize = 0;
          localResetCounter = _resetCounter;
        }
        currentNode = rootNode;
        for (var i2 = 0; i2 < args.length; i2++) {
          var arg = _normalizeArg(args[i2]);
          if (!currentNode.map.has(arg)) {
            currentNode.map.set(arg, _createNode());
          }
          currentNode = currentNode.map.get(arg);
        }
        if (!currentNode.hasOwnProperty("value")) {
          currentNode.value = cb2.apply(void 0, args);
          cacheSize++;
        }
        if (ignoreNullOrUndefinedResult && (currentNode.value === null || currentNode.value === void 0)) {
          currentNode.value = cb2.apply(void 0, args);
        }
        return currentNode.value;
      };
    }
    function createMemoizer(getValue) {
      if (!_weakMap) {
        return getValue;
      }
      var cache2 = new _weakMap();
      function memoizedGetValue(input) {
        if (!input || typeof input !== "function" && typeof input !== "object") {
          return getValue(input);
        }
        if (cache2.has(input)) {
          return cache2.get(input);
        }
        var value = getValue(input);
        cache2.set(input, value);
        return value;
      }
      return memoizedGetValue;
    }
    function _normalizeArg(val) {
      if (!val) {
        return _emptyObject;
      } else if (typeof val === "object" || typeof val === "function") {
        return val;
      } else if (!_dictionary[val]) {
        _dictionary[val] = { val };
      }
      return _dictionary[val];
    }
    function _createNode() {
      return {
        map: _weakMap ? new _weakMap() : null
      };
    }
    function createComposedComponent(outer) {
      var Outer = outer;
      var outerMemoizer = createMemoizer(function(inner) {
        if (outer === inner) {
          throw new Error("Attempted to compose a component with itself.");
        }
        var Inner = inner;
        var innerMemoizer = createMemoizer(function(defaultRender) {
          var InnerWithDefaultRender = function(innerProps) {
            return reactExports.createElement(Inner, __assign$1({}, innerProps, { defaultRender }));
          };
          return InnerWithDefaultRender;
        });
        var OuterWithDefaultRender = function(outerProps) {
          var defaultRender = outerProps.defaultRender;
          return reactExports.createElement(Outer, __assign$1({}, outerProps, { defaultRender: defaultRender ? innerMemoizer(defaultRender) : Inner }));
        };
        return OuterWithDefaultRender;
      });
      return outerMemoizer;
    }
    var componentAsMemoizer = createMemoizer(createComposedComponent);
    function composeComponentAs(outer, inner) {
      return componentAsMemoizer(outer)(inner);
    }
    function css$1() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var classes = [];
      for (var _a2 = 0, args_1 = args; _a2 < args_1.length; _a2++) {
        var arg = args_1[_a2];
        if (arg) {
          if (typeof arg === "string") {
            classes.push(arg);
          } else if (arg.hasOwnProperty("toString") && typeof arg.toString === "function") {
            classes.push(arg.toString());
          } else {
            for (var key in arg) {
              if (arg[key]) {
                classes.push(key);
              }
            }
          }
        }
      }
      return classes.join(" ");
    }
    var CustomizationsGlobalKey = "customizations";
    var NO_CUSTOMIZATIONS = { settings: {}, scopedSettings: {}, inCustomizerContext: false };
    var _allSettings = GlobalSettings.getValue(CustomizationsGlobalKey, {
      settings: {},
      scopedSettings: {},
      inCustomizerContext: false
    });
    var _events = [];
    var Customizations = (
      /** @class */
      function() {
        function Customizations2() {
        }
        Customizations2.reset = function() {
          _allSettings.settings = {};
          _allSettings.scopedSettings = {};
        };
        Customizations2.applySettings = function(settings) {
          _allSettings.settings = __assign$1(__assign$1({}, _allSettings.settings), settings);
          Customizations2._raiseChange();
        };
        Customizations2.applyScopedSettings = function(scopeName, settings) {
          _allSettings.scopedSettings[scopeName] = __assign$1(__assign$1({}, _allSettings.scopedSettings[scopeName]), settings);
          Customizations2._raiseChange();
        };
        Customizations2.getSettings = function(properties, scopeName, localSettings) {
          if (localSettings === void 0) {
            localSettings = NO_CUSTOMIZATIONS;
          }
          var settings = {};
          var localScopedSettings = scopeName && localSettings.scopedSettings[scopeName] || {};
          var globalScopedSettings = scopeName && _allSettings.scopedSettings[scopeName] || {};
          for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {
            var property = properties_1[_i];
            settings[property] = localScopedSettings[property] || localSettings.settings[property] || globalScopedSettings[property] || _allSettings.settings[property];
          }
          return settings;
        };
        Customizations2.applyBatchedUpdates = function(code2, suppressUpdate) {
          Customizations2._suppressUpdates = true;
          try {
            code2();
          } catch (_a2) {
          }
          Customizations2._suppressUpdates = false;
          if (!suppressUpdate) {
            Customizations2._raiseChange();
          }
        };
        Customizations2.observe = function(onChange) {
          _events.push(onChange);
        };
        Customizations2.unobserve = function(onChange) {
          _events = _events.filter(function(cb2) {
            return cb2 !== onChange;
          });
        };
        Customizations2._raiseChange = function() {
          if (!Customizations2._suppressUpdates) {
            _events.forEach(function(cb2) {
              return cb2();
            });
          }
        };
        return Customizations2;
      }()
    );
    var CustomizerContext = reactExports.createContext({
      customizations: {
        inCustomizerContext: false,
        settings: {},
        scopedSettings: {}
      }
    });
    function mergeSettings(oldSettings, newSettings) {
      if (oldSettings === void 0) {
        oldSettings = {};
      }
      var mergeSettingsWith = _isSettingsFunction(newSettings) ? newSettings : _settingsMergeWith(newSettings);
      return mergeSettingsWith(oldSettings);
    }
    function mergeScopedSettings(oldSettings, newSettings) {
      if (oldSettings === void 0) {
        oldSettings = {};
      }
      var mergeSettingsWith = _isSettingsFunction(newSettings) ? newSettings : _scopedSettingsMergeWith(newSettings);
      return mergeSettingsWith(oldSettings);
    }
    function _isSettingsFunction(settings) {
      return typeof settings === "function";
    }
    function _settingsMergeWith(newSettings) {
      return function(settings) {
        return newSettings ? __assign$1(__assign$1({}, settings), newSettings) : settings;
      };
    }
    function _scopedSettingsMergeWith(scopedSettingsFromProps) {
      if (scopedSettingsFromProps === void 0) {
        scopedSettingsFromProps = {};
      }
      return function(oldScopedSettings) {
        var newScopedSettings = __assign$1({}, oldScopedSettings);
        for (var scopeName in scopedSettingsFromProps) {
          if (scopedSettingsFromProps.hasOwnProperty(scopeName)) {
            newScopedSettings[scopeName] = __assign$1(__assign$1({}, oldScopedSettings[scopeName]), scopedSettingsFromProps[scopeName]);
          }
        }
        return newScopedSettings;
      };
    }
    function mergeCustomizations(props, parentContext) {
      var _a2 = (parentContext || {}).customizations, customizations = _a2 === void 0 ? { settings: {}, scopedSettings: {} } : _a2;
      return {
        customizations: {
          settings: mergeSettings(customizations.settings, props.settings),
          scopedSettings: mergeScopedSettings(customizations.scopedSettings, props.scopedSettings),
          inCustomizerContext: true
        }
      };
    }
    var Customizer = (
      /** @class */
      function(_super) {
        __extends(Customizer2, _super);
        function Customizer2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this._onCustomizationChange = function() {
            return _this.forceUpdate();
          };
          return _this;
        }
        Customizer2.prototype.componentDidMount = function() {
          Customizations.observe(this._onCustomizationChange);
        };
        Customizer2.prototype.componentWillUnmount = function() {
          Customizations.unobserve(this._onCustomizationChange);
        };
        Customizer2.prototype.render = function() {
          var _this = this;
          var contextTransform = this.props.contextTransform;
          return reactExports.createElement(CustomizerContext.Consumer, null, function(parentContext) {
            var newContext = mergeCustomizations(_this.props, parentContext);
            if (contextTransform) {
              newContext = contextTransform(newContext);
            }
            return reactExports.createElement(CustomizerContext.Provider, { value: newContext }, _this.props.children);
          });
        };
        return Customizer2;
      }(reactExports.Component)
    );
    function hoistStatics(source, dest) {
      for (var name_1 in source) {
        if (source.hasOwnProperty(name_1)) {
          dest[name_1] = source[name_1];
        }
      }
      return dest;
    }
    function customizable(scope, fields, concatStyles) {
      return function customizableFactory(ComposedComponent) {
        var _a2;
        var resultClass = (_a2 = /** @class */
        function(_super) {
          __extends(ComponentWithInjectedProps, _super);
          function ComponentWithInjectedProps(props) {
            var _this = _super.call(this, props) || this;
            _this._styleCache = {};
            _this._onSettingChanged = _this._onSettingChanged.bind(_this);
            return _this;
          }
          ComponentWithInjectedProps.prototype.componentDidMount = function() {
            Customizations.observe(this._onSettingChanged);
          };
          ComponentWithInjectedProps.prototype.componentWillUnmount = function() {
            Customizations.unobserve(this._onSettingChanged);
          };
          ComponentWithInjectedProps.prototype.render = function() {
            var _this = this;
            return reactExports.createElement(CustomizerContext.Consumer, null, function(context) {
              var defaultProps = Customizations.getSettings(fields, scope, context.customizations);
              var componentProps = _this.props;
              if (defaultProps.styles && typeof defaultProps.styles === "function") {
                defaultProps.styles = defaultProps.styles(__assign$1(__assign$1({}, defaultProps), componentProps));
              }
              if (concatStyles && defaultProps.styles) {
                if (_this._styleCache.default !== defaultProps.styles || _this._styleCache.component !== componentProps.styles) {
                  var mergedStyles = concatStyleSets(defaultProps.styles, componentProps.styles);
                  _this._styleCache.default = defaultProps.styles;
                  _this._styleCache.component = componentProps.styles;
                  _this._styleCache.merged = mergedStyles;
                }
                return reactExports.createElement(ComposedComponent, __assign$1({}, defaultProps, componentProps, { styles: _this._styleCache.merged }));
              }
              return reactExports.createElement(ComposedComponent, __assign$1({}, defaultProps, componentProps));
            });
          };
          ComponentWithInjectedProps.prototype._onSettingChanged = function() {
            this.forceUpdate();
          };
          return ComponentWithInjectedProps;
        }(reactExports.Component), _a2.displayName = "Customized" + scope, _a2);
        return hoistStatics(ComposedComponent, resultClass);
      };
    }
    function useCustomizationSettings(properties, scopeName) {
      var forceUpdate = useForceUpdate();
      var customizations = reactExports.useContext(CustomizerContext).customizations;
      var inCustomizerContext = customizations.inCustomizerContext;
      reactExports.useEffect(function() {
        if (!inCustomizerContext) {
          Customizations.observe(forceUpdate);
        }
        return function() {
          if (!inCustomizerContext) {
            Customizations.unobserve(forceUpdate);
          }
        };
      }, [inCustomizerContext]);
      return Customizations.getSettings(properties, scopeName, customizations);
    }
    function useForceUpdate() {
      var _a2 = reactExports.useState(0), setValue = _a2[1];
      return function() {
        return setValue(function(value) {
          return ++value;
        });
      };
    }
    function extendComponent(parent, methods) {
      for (var name_1 in methods) {
        if (methods.hasOwnProperty(name_1)) {
          parent[name_1] = appendFunction(parent, parent[name_1], methods[name_1]);
        }
      }
    }
    var CURRENT_ID_PROPERTY = "__currentId__";
    var DEFAULT_ID_STRING = "id__";
    var _global = getWindow() || {};
    if (_global[CURRENT_ID_PROPERTY] === void 0) {
      _global[CURRENT_ID_PROPERTY] = 0;
    }
    var _initializedStylesheetResets = false;
    function getId(prefix2) {
      if (!_initializedStylesheetResets) {
        var stylesheet2 = Stylesheet.getInstance();
        if (stylesheet2 && stylesheet2.onReset) {
          stylesheet2.onReset(resetIds);
        }
        _initializedStylesheetResets = true;
      }
      var index2 = _global[CURRENT_ID_PROPERTY]++;
      return (prefix2 === void 0 ? DEFAULT_ID_STRING : prefix2) + index2;
    }
    function resetIds(counter) {
      if (counter === void 0) {
        counter = 0;
      }
      _global[CURRENT_ID_PROPERTY] = counter;
    }
    var toObjectMap$1 = function() {
      var items = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        items[_i] = arguments[_i];
      }
      var result = {};
      for (var _a2 = 0, items_1 = items; _a2 < items_1.length; _a2++) {
        var item = items_1[_a2];
        var keys2 = Array.isArray(item) ? item : Object.keys(item);
        for (var _b = 0, keys_1 = keys2; _b < keys_1.length; _b++) {
          var key = keys_1[_b];
          result[key] = 1;
        }
      }
      return result;
    };
    var baseElementEvents$1 = toObjectMap$1([
      "onCopy",
      "onCut",
      "onPaste",
      "onCompositionEnd",
      "onCompositionStart",
      "onCompositionUpdate",
      "onFocus",
      "onFocusCapture",
      "onBlur",
      "onBlurCapture",
      "onChange",
      "onInput",
      "onSubmit",
      "onLoad",
      "onError",
      "onKeyDown",
      "onKeyDownCapture",
      "onKeyPress",
      "onKeyUp",
      "onAbort",
      "onCanPlay",
      "onCanPlayThrough",
      "onDurationChange",
      "onEmptied",
      "onEncrypted",
      "onEnded",
      "onLoadedData",
      "onLoadedMetadata",
      "onLoadStart",
      "onPause",
      "onPlay",
      "onPlaying",
      "onProgress",
      "onRateChange",
      "onSeeked",
      "onSeeking",
      "onStalled",
      "onSuspend",
      "onTimeUpdate",
      "onVolumeChange",
      "onWaiting",
      "onClick",
      "onClickCapture",
      "onContextMenu",
      "onDoubleClick",
      "onDrag",
      "onDragEnd",
      "onDragEnter",
      "onDragExit",
      "onDragLeave",
      "onDragOver",
      "onDragStart",
      "onDrop",
      "onMouseDown",
      "onMouseDownCapture",
      "onMouseEnter",
      "onMouseLeave",
      "onMouseMove",
      "onMouseOut",
      "onMouseOver",
      "onMouseUp",
      "onMouseUpCapture",
      "onSelect",
      "onTouchCancel",
      "onTouchEnd",
      "onTouchMove",
      "onTouchStart",
      "onScroll",
      "onWheel",
      "onPointerCancel",
      "onPointerDown",
      "onPointerEnter",
      "onPointerLeave",
      "onPointerMove",
      "onPointerOut",
      "onPointerOver",
      "onPointerUp",
      "onGotPointerCapture",
      "onLostPointerCapture"
    ]);
    var baseElementProperties$1 = toObjectMap$1([
      "accessKey",
      "children",
      "className",
      "contentEditable",
      "dir",
      "draggable",
      "hidden",
      "htmlFor",
      "id",
      "lang",
      "ref",
      "role",
      "style",
      "tabIndex",
      "title",
      "translate",
      "spellCheck",
      "name"
      // global
    ]);
    var htmlElementProperties$1 = toObjectMap$1(baseElementProperties$1, baseElementEvents$1);
    toObjectMap$1(htmlElementProperties$1, [
      "form"
      // button, fieldset, input, label, meter, object, output, select, textarea
    ]);
    var audioProperties$1 = toObjectMap$1(htmlElementProperties$1, [
      "height",
      "loop",
      "muted",
      "preload",
      "src",
      "width"
      // canvas, embed, iframe, img, input, object, video
    ]);
    toObjectMap$1(audioProperties$1, [
      "poster"
      // video
    ]);
    toObjectMap$1(htmlElementProperties$1, [
      "start"
      // ol
    ]);
    toObjectMap$1(htmlElementProperties$1, [
      "value"
      // button, input, li, option, meter, progress, param
    ]);
    var anchorProperties$1 = toObjectMap$1(htmlElementProperties$1, [
      "download",
      "href",
      "hrefLang",
      "media",
      "rel",
      "target",
      "type"
      // a, button, input, link, menu, object, script, source, style
    ]);
    var buttonProperties$1 = toObjectMap$1(htmlElementProperties$1, [
      "autoFocus",
      "disabled",
      "form",
      "formAction",
      "formEncType",
      "formMethod",
      "formNoValidate",
      "formTarget",
      "type",
      "value"
      // button, input, li, option, meter, progress, param,
    ]);
    toObjectMap$1(buttonProperties$1, [
      "accept",
      "alt",
      "autoCapitalize",
      "autoComplete",
      "checked",
      "dirname",
      "form",
      "height",
      "inputMode",
      "list",
      "max",
      "maxLength",
      "min",
      "minLength",
      "multiple",
      "pattern",
      "placeholder",
      "readOnly",
      "required",
      "src",
      "step",
      "size",
      "type",
      "value",
      "width"
      // canvas, embed, iframe, img, input, object, video
    ]);
    toObjectMap$1(buttonProperties$1, [
      "autoCapitalize",
      "cols",
      "dirname",
      "form",
      "maxLength",
      "minLength",
      "placeholder",
      "readOnly",
      "required",
      "rows",
      "wrap"
      // textarea
    ]);
    toObjectMap$1(buttonProperties$1, [
      "form",
      "multiple",
      "required"
      // input, select, textarea
    ]);
    toObjectMap$1(htmlElementProperties$1, [
      "selected",
      "value"
      // button, input, li, option, meter, progress, param
    ]);
    toObjectMap$1(htmlElementProperties$1, [
      "cellPadding",
      "cellSpacing"
      // table
    ]);
    toObjectMap$1(htmlElementProperties$1, [
      "rowSpan",
      "scope"
      // th
    ]);
    toObjectMap$1(htmlElementProperties$1, [
      "colSpan",
      "headers",
      "rowSpan",
      "scope"
      // th
    ]);
    toObjectMap$1(htmlElementProperties$1, [
      "span"
      // col, colgroup
    ]);
    toObjectMap$1(htmlElementProperties$1, [
      "span"
      // col, colgroup
    ]);
    toObjectMap$1(htmlElementProperties$1, [
      "acceptCharset",
      "action",
      "encType",
      "encType",
      "method",
      "noValidate",
      "target"
      // form
    ]);
    toObjectMap$1(htmlElementProperties$1, [
      "allow",
      "allowFullScreen",
      "allowPaymentRequest",
      "allowTransparency",
      "csp",
      "height",
      "importance",
      "referrerPolicy",
      "sandbox",
      "src",
      "srcDoc",
      "width"
      // canvas, embed, iframe, img, input, object, video,
    ]);
    var imgProperties$1 = toObjectMap$1(htmlElementProperties$1, [
      "alt",
      "crossOrigin",
      "height",
      "src",
      "srcSet",
      "useMap",
      "width"
      // canvas, embed, iframe, img, input, object, video
    ]);
    var divProperties = htmlElementProperties$1;
    function getNativeProps$1(props, allowedPropNames, excludedPropNames) {
      var isArray2 = Array.isArray(allowedPropNames);
      var result = {};
      var keys2 = Object.keys(props);
      for (var _i = 0, keys_2 = keys2; _i < keys_2.length; _i++) {
        var key = keys_2[_i];
        var isNativeProp = !isArray2 && allowedPropNames[key] || isArray2 && allowedPropNames.indexOf(key) >= 0 || key.indexOf("data-") === 0 || key.indexOf("aria-") === 0;
        if (isNativeProp && (!excludedPropNames || (excludedPropNames === null || excludedPropNames === void 0 ? void 0 : excludedPropNames.indexOf(key)) === -1)) {
          result[key] = props[key];
        }
      }
      return result;
    }
    function initializeComponentRef(obj) {
      extendComponent(obj, {
        componentDidMount: _onMount,
        componentDidUpdate: _onUpdate,
        componentWillUnmount: _onUnmount
      });
    }
    function _onMount() {
      _setComponentRef(this.props.componentRef, this);
    }
    function _onUpdate(prevProps) {
      if (prevProps.componentRef !== this.props.componentRef) {
        _setComponentRef(prevProps.componentRef, null);
        _setComponentRef(this.props.componentRef, this);
      }
    }
    function _onUnmount() {
      _setComponentRef(this.props.componentRef, null);
    }
    function _setComponentRef(componentRef, value) {
      if (componentRef) {
        if (typeof componentRef === "object") {
          componentRef.current = value;
        } else if (typeof componentRef === "function") {
          componentRef(value);
        }
      }
    }
    var _a$2;
    var DirectionalKeyCodes = (_a$2 = {}, _a$2[KeyCodes.up] = 1, _a$2[KeyCodes.down] = 1, _a$2[KeyCodes.left] = 1, _a$2[KeyCodes.right] = 1, _a$2[KeyCodes.home] = 1, _a$2[KeyCodes.end] = 1, _a$2[KeyCodes.tab] = 1, _a$2[KeyCodes.pageUp] = 1, _a$2[KeyCodes.pageDown] = 1, _a$2);
    function isDirectionalKeyCode(which) {
      return !!DirectionalKeyCodes[which];
    }
    var IsFocusVisibleClassName = "ms-Fabric--isFocusVisible";
    var IsFocusHiddenClassName = "ms-Fabric--isFocusHidden";
    function setFocusVisibility(enabled, target) {
      var win = target ? getWindow(target) : getWindow();
      if (win) {
        var classList = win.document.body.classList;
        classList.add(enabled ? IsFocusVisibleClassName : IsFocusHiddenClassName);
        classList.remove(enabled ? IsFocusHiddenClassName : IsFocusVisibleClassName);
      }
    }
    var mountCounters = /* @__PURE__ */ new WeakMap();
    function setMountCounters(key, delta) {
      var newValue;
      var currValue = mountCounters.get(key);
      if (currValue) {
        newValue = currValue + delta;
      } else {
        newValue = 1;
      }
      mountCounters.set(key, newValue);
      return newValue;
    }
    function useFocusRects(rootRef) {
      reactExports.useEffect(function() {
        var _a2;
        var win = getWindow(rootRef === null || rootRef === void 0 ? void 0 : rootRef.current);
        if (!win || ((_a2 = win.FabricConfig) === null || _a2 === void 0 ? void 0 : _a2.disableFocusRects) === true) {
          return void 0;
        }
        var count = setMountCounters(win, 1);
        if (count <= 1) {
          win.addEventListener("mousedown", _onMouseDown, true);
          win.addEventListener("pointerdown", _onPointerDown, true);
          win.addEventListener("keydown", _onKeyDown, true);
        }
        return function() {
          var _a3;
          if (!win || ((_a3 = win.FabricConfig) === null || _a3 === void 0 ? void 0 : _a3.disableFocusRects) === true) {
            return;
          }
          count = setMountCounters(win, -1);
          if (count === 0) {
            win.removeEventListener("mousedown", _onMouseDown, true);
            win.removeEventListener("pointerdown", _onPointerDown, true);
            win.removeEventListener("keydown", _onKeyDown, true);
          }
        };
      }, [rootRef]);
    }
    var FocusRects = function(props) {
      useFocusRects(props.rootRef);
      return null;
    };
    function _onMouseDown(ev) {
      setFocusVisibility(false, ev.target);
    }
    function _onPointerDown(ev) {
      if (ev.pointerType !== "mouse") {
        setFocusVisibility(false, ev.target);
      }
    }
    function _onKeyDown(ev) {
      if (isDirectionalKeyCode(ev.which)) {
        setFocusVisibility(true, ev.target);
      }
    }
    function getItem(key) {
      var result = null;
      try {
        var win = getWindow();
        result = win ? win.localStorage.getItem(key) : null;
      } catch (e2) {
      }
      return result;
    }
    var _language;
    var STORAGE_KEY = "language";
    function getLanguage(persistenceType) {
      if (persistenceType === void 0) {
        persistenceType = "sessionStorage";
      }
      if (_language === void 0) {
        var doc = getDocument();
        var savedLanguage = persistenceType === "localStorage" ? getItem(STORAGE_KEY) : persistenceType === "sessionStorage" ? getItem$1(STORAGE_KEY) : void 0;
        if (savedLanguage) {
          _language = savedLanguage;
        }
        if (_language === void 0 && doc) {
          _language = doc.documentElement.getAttribute("lang");
        }
        if (_language === void 0) {
          _language = "en";
        }
      }
      return _language;
    }
    function merge$2(target) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      for (var _a2 = 0, args_1 = args; _a2 < args_1.length; _a2++) {
        var arg = args_1[_a2];
        _merge(target || {}, arg);
      }
      return target;
    }
    function _merge(target, source, circularReferences) {
      if (circularReferences === void 0) {
        circularReferences = [];
      }
      circularReferences.push(source);
      for (var name_1 in source) {
        if (source.hasOwnProperty(name_1)) {
          if (name_1 !== "__proto__" && name_1 !== "constructor" && name_1 !== "prototype") {
            var value = source[name_1];
            if (typeof value === "object" && value !== null && !Array.isArray(value)) {
              var isCircularReference = circularReferences.indexOf(value) > -1;
              target[name_1] = isCircularReference ? value : _merge(target[name_1] || {}, value, circularReferences);
            } else {
              target[name_1] = value;
            }
          }
        }
      }
      circularReferences.pop();
      return target;
    }
    var isIOS = function() {
      if (!window || !window.navigator || !window.navigator.userAgent) {
        return false;
      }
      return /iPad|iPhone|iPod/i.test(window.navigator.userAgent);
    };
    var tagsToIgnore = ["TEMPLATE", "STYLE", "SCRIPT"];
    function modalize(target) {
      var targetDocument = getDocument(target);
      if (!targetDocument) {
        return function() {
          return void 0;
        };
      }
      var affectedNodes = [];
      while (target !== targetDocument.body && target.parentElement) {
        for (var _i = 0, _a2 = target.parentElement.children; _i < _a2.length; _i++) {
          var sibling = _a2[_i];
          var ariaHidden = sibling.getAttribute("aria-hidden");
          if (sibling !== target && (ariaHidden === null || ariaHidden === void 0 ? void 0 : ariaHidden.toLowerCase()) !== "true" && tagsToIgnore.indexOf(sibling.tagName) === -1) {
            affectedNodes.push([sibling, ariaHidden]);
          }
        }
        target = target.parentElement;
      }
      affectedNodes.forEach(function(_a3) {
        var node2 = _a3[0];
        node2.setAttribute("aria-hidden", "true");
      });
      return function() {
        unmodalize(affectedNodes);
        affectedNodes = [];
      };
    }
    function unmodalize(affectedNodes) {
      affectedNodes.forEach(function(_a2) {
        var node2 = _a2[0], originalValue = _a2[1];
        if (originalValue) {
          node2.setAttribute("aria-hidden", originalValue);
        } else {
          node2.removeAttribute("aria-hidden");
        }
      });
    }
    var isMacResult;
    function isMac(reset) {
      var _a2;
      if (typeof isMacResult === "undefined" || reset) {
        var win = getWindow();
        var userAgent = (_a2 = win === null || win === void 0 ? void 0 : win.navigator) === null || _a2 === void 0 ? void 0 : _a2.userAgent;
        isMacResult = !!userAgent && userAgent.indexOf("Macintosh") !== -1;
      }
      return !!isMacResult;
    }
    function createComposedRenderFunction(outer) {
      var outerMemoizer = createMemoizer(function(inner) {
        var innerMemoizer = createMemoizer(function(defaultRender) {
          return function(innerProps) {
            return inner(innerProps, defaultRender);
          };
        });
        return function(outerProps, defaultRender) {
          return outer(outerProps, defaultRender ? innerMemoizer(defaultRender) : inner);
        };
      });
      return outerMemoizer;
    }
    var memoizer = createMemoizer(createComposedRenderFunction);
    function composeRenderFunction(outer, inner) {
      return memoizer(outer)(inner);
    }
    var DefaultFields = ["theme", "styles"];
    function styled(Component, baseStyles, getProps, customizable2, pure) {
      customizable2 = customizable2 || { scope: "", fields: void 0 };
      var scope = customizable2.scope, _a2 = customizable2.fields, fields = _a2 === void 0 ? DefaultFields : _a2;
      var Wrapped = reactExports.forwardRef(function(props, forwardedRef) {
        var styles2 = reactExports.useRef();
        var settings = useCustomizationSettings(fields, scope);
        var customizedStyles = settings.styles;
        settings.dir;
        var rest = __rest(settings, ["styles", "dir"]);
        var additionalProps = getProps ? getProps(props) : void 0;
        var cache2 = styles2.current && styles2.current.__cachedInputs__ || [];
        var propStyles = props.styles;
        if (!styles2.current || customizedStyles !== cache2[1] || propStyles !== cache2[2]) {
          var concatenatedStyles = function(styleProps) {
            return concatStyleSetsWithProps(styleProps, baseStyles, customizedStyles, propStyles);
          };
          concatenatedStyles.__cachedInputs__ = [
            baseStyles,
            customizedStyles,
            propStyles
          ];
          concatenatedStyles.__noStyleOverride__ = !customizedStyles && !propStyles;
          styles2.current = concatenatedStyles;
        }
        return reactExports.createElement(Component, __assign$1({ ref: forwardedRef }, rest, additionalProps, props, { styles: styles2.current }));
      });
      Wrapped.displayName = "Styled" + (Component.displayName || Component.name);
      var pureComponent = pure ? reactExports.memo(Wrapped) : Wrapped;
      if (Wrapped.displayName) {
        pureComponent.displayName = Wrapped.displayName;
      }
      return pureComponent;
    }
    function getPropsWithDefaults(defaultProps, propsWithoutDefaults) {
      var props = __assign$1({}, propsWithoutDefaults);
      for (var _i = 0, _a2 = Object.keys(defaultProps); _i < _a2.length; _i++) {
        var key = _a2[_i];
        if (props[key] === void 0) {
          props[key] = defaultProps[key];
        }
      }
      return props;
    }
    var createResolver$1 = function(local) {
      return function(newValue) {
        for (var _i = 0, _a2 = local.refs; _i < _a2.length; _i++) {
          var ref = _a2[_i];
          if (typeof ref === "function") {
            ref(newValue);
          } else if (ref) {
            ref.current = newValue;
          }
        }
      };
    };
    var createMergedRef = function(value) {
      var local = {
        refs: []
      };
      return function() {
        var newRefs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          newRefs[_i] = arguments[_i];
        }
        if (!local.resolver || !arraysEqual(local.refs, newRefs)) {
          local.resolver = createResolver$1(local);
        }
        local.refs = newRefs;
        return local.resolver;
      };
    };
    var useIsomorphicLayoutEffect$1 = reactExports.useLayoutEffect;
    var ICON_SETTING_NAME = "icons";
    var _iconSettings = GlobalSettings.getValue(ICON_SETTING_NAME, {
      __options: {
        disableWarnings: false,
        warnOnMissingIcons: true
      },
      __remapped: {}
    });
    var stylesheet = Stylesheet.getInstance();
    if (stylesheet && stylesheet.onReset) {
      stylesheet.onReset(function() {
        for (var name_1 in _iconSettings) {
          if (_iconSettings.hasOwnProperty(name_1) && !!_iconSettings[name_1].subset) {
            _iconSettings[name_1].subset.className = void 0;
          }
        }
      });
    }
    var normalizeIconName = function(name2) {
      return name2.toLowerCase();
    };
    function registerIcons(iconSubset, options) {
      var subset = __assign$1(__assign$1({}, iconSubset), { isRegistered: false, className: void 0 });
      var icons = iconSubset.icons;
      options = options ? __assign$1(__assign$1({}, _iconSettings.__options), options) : _iconSettings.__options;
      for (var iconName in icons) {
        if (icons.hasOwnProperty(iconName)) {
          var code2 = icons[iconName];
          var normalizedIconName = normalizeIconName(iconName);
          if (_iconSettings[normalizedIconName]) {
            _warnDuplicateIcon(iconName);
          } else {
            _iconSettings[normalizedIconName] = {
              code: code2,
              subset
            };
          }
        }
      }
    }
    function registerIconAlias(iconName, mappedToName) {
      _iconSettings.__remapped[normalizeIconName(iconName)] = normalizeIconName(mappedToName);
    }
    function getIcon(name2) {
      var icon = void 0;
      var options = _iconSettings.__options;
      name2 = name2 ? normalizeIconName(name2) : "";
      name2 = _iconSettings.__remapped[name2] || name2;
      if (name2) {
        icon = _iconSettings[name2];
        if (icon) {
          var subset = icon.subset;
          if (subset && subset.fontFace) {
            if (!subset.isRegistered) {
              fontFace(subset.fontFace);
              subset.isRegistered = true;
            }
            if (!subset.className) {
              subset.className = mergeStyles(subset.style, {
                fontFamily: subset.fontFace.fontFamily,
                fontWeight: subset.fontFace.fontWeight || "normal",
                fontStyle: subset.fontFace.fontStyle || "normal"
              });
            }
          }
        } else {
          if (!options.disableWarnings && options.warnOnMissingIcons) {
            warn$1('The icon "' + name2 + '" was used but not registered. See https://github.com/microsoft/fluentui/wiki/Using-icons for more information.');
          }
        }
      }
      return icon;
    }
    var _missingIcons = [];
    var _missingIconsTimer = void 0;
    function _warnDuplicateIcon(iconName) {
      var options = _iconSettings.__options;
      var warningDelay = 2e3;
      var maxIconsInMessage = 10;
      if (!options.disableWarnings) {
        _missingIcons.push(iconName);
        if (_missingIconsTimer === void 0) {
          _missingIconsTimer = setTimeout(function() {
            warn$1("Some icons were re-registered. Applications should only call registerIcons for any given icon once. Redefining what an icon is may have unintended consequences. Duplicates include: \n" + _missingIcons.slice(0, maxIconsInMessage).join(", ") + (_missingIcons.length > maxIconsInMessage ? " (+ " + (_missingIcons.length - maxIconsInMessage) + " more)" : ""));
            _missingIconsTimer = void 0;
            _missingIcons = [];
          }, warningDelay);
        }
      }
    }
    function makeSemanticColors$1(p2, e2, s2, isInverted, depComments) {
      if (depComments === void 0) {
        depComments = false;
      }
      var semanticColors = __assign$1({
        primaryButtonBorder: "transparent",
        errorText: !isInverted ? "#a4262c" : "#F1707B",
        messageText: !isInverted ? "#323130" : "#F3F2F1",
        messageLink: !isInverted ? "#005A9E" : "#6CB8F6",
        messageLinkHovered: !isInverted ? "#004578" : "#82C7FF",
        infoIcon: !isInverted ? "#605e5c" : "#C8C6C4",
        errorIcon: !isInverted ? "#A80000" : "#F1707B",
        blockingIcon: !isInverted ? "#FDE7E9" : "#442726",
        warningIcon: !isInverted ? "#797775" : "#C8C6C4",
        severeWarningIcon: !isInverted ? "#D83B01" : "#FCE100",
        successIcon: !isInverted ? "#107C10" : "#92C353",
        infoBackground: !isInverted ? "#f3f2f1" : "#323130",
        errorBackground: !isInverted ? "#FDE7E9" : "#442726",
        blockingBackground: !isInverted ? "#FDE7E9" : "#442726",
        warningBackground: !isInverted ? "#FFF4CE" : "#433519",
        severeWarningBackground: !isInverted ? "#FED9CC" : "#4F2A0F",
        successBackground: !isInverted ? "#DFF6DD" : "#393D1B",
        // deprecated
        warningHighlight: !isInverted ? "#ffb900" : "#fff100",
        successText: !isInverted ? "#107C10" : "#92c353"
      }, s2);
      var fullSemanticColors = getSemanticColors$1(p2, e2, semanticColors, isInverted);
      return _fixDeprecatedSlots$1(fullSemanticColors, depComments);
    }
    function getSemanticColors$1(p2, e2, s2, isInverted, depComments) {
      var result = {};
      var _a2 = p2 || {}, white2 = _a2.white, black2 = _a2.black, themePrimary = _a2.themePrimary, themeDark = _a2.themeDark, themeDarker = _a2.themeDarker, themeDarkAlt = _a2.themeDarkAlt, themeLighter = _a2.themeLighter, neutralLight = _a2.neutralLight, neutralLighter = _a2.neutralLighter, neutralDark = _a2.neutralDark, neutralQuaternary = _a2.neutralQuaternary, neutralQuaternaryAlt = _a2.neutralQuaternaryAlt, neutralPrimary = _a2.neutralPrimary, neutralSecondary = _a2.neutralSecondary, neutralSecondaryAlt = _a2.neutralSecondaryAlt, neutralTertiary = _a2.neutralTertiary, neutralTertiaryAlt = _a2.neutralTertiaryAlt, neutralLighterAlt = _a2.neutralLighterAlt, accent = _a2.accent;
      if (white2) {
        result.bodyBackground = white2;
        result.bodyFrameBackground = white2;
        result.accentButtonText = white2;
        result.buttonBackground = white2;
        result.primaryButtonText = white2;
        result.primaryButtonTextHovered = white2;
        result.primaryButtonTextPressed = white2;
        result.inputBackground = white2;
        result.inputForegroundChecked = white2;
        result.listBackground = white2;
        result.menuBackground = white2;
        result.cardStandoutBackground = white2;
      }
      if (black2) {
        result.bodyTextChecked = black2;
        result.buttonTextCheckedHovered = black2;
      }
      if (themePrimary) {
        result.link = themePrimary;
        result.primaryButtonBackground = themePrimary;
        result.inputBackgroundChecked = themePrimary;
        result.inputIcon = themePrimary;
        result.inputFocusBorderAlt = themePrimary;
        result.menuIcon = themePrimary;
        result.menuHeader = themePrimary;
        result.accentButtonBackground = themePrimary;
      }
      if (themeDark) {
        result.primaryButtonBackgroundPressed = themeDark;
        result.inputBackgroundCheckedHovered = themeDark;
        result.inputIconHovered = themeDark;
      }
      if (themeDarker) {
        result.linkHovered = themeDarker;
      }
      if (themeDarkAlt) {
        result.primaryButtonBackgroundHovered = themeDarkAlt;
      }
      if (themeLighter) {
        result.inputPlaceholderBackgroundChecked = themeLighter;
      }
      if (neutralLight) {
        result.bodyBackgroundChecked = neutralLight;
        result.bodyFrameDivider = neutralLight;
        result.bodyDivider = neutralLight;
        result.variantBorder = neutralLight;
        result.buttonBackgroundCheckedHovered = neutralLight;
        result.buttonBackgroundPressed = neutralLight;
        result.listItemBackgroundChecked = neutralLight;
        result.listHeaderBackgroundPressed = neutralLight;
        result.menuItemBackgroundPressed = neutralLight;
        result.menuItemBackgroundChecked = neutralLight;
      }
      if (neutralLighter) {
        result.bodyBackgroundHovered = neutralLighter;
        result.buttonBackgroundHovered = neutralLighter;
        result.buttonBackgroundDisabled = neutralLighter;
        result.buttonBorderDisabled = neutralLighter;
        result.primaryButtonBackgroundDisabled = neutralLighter;
        result.disabledBackground = neutralLighter;
        result.listItemBackgroundHovered = neutralLighter;
        result.listHeaderBackgroundHovered = neutralLighter;
        result.menuItemBackgroundHovered = neutralLighter;
      }
      if (neutralQuaternary) {
        result.primaryButtonTextDisabled = neutralQuaternary;
        result.disabledSubtext = neutralQuaternary;
      }
      if (neutralQuaternaryAlt) {
        result.listItemBackgroundCheckedHovered = neutralQuaternaryAlt;
      }
      if (neutralTertiary) {
        result.disabledBodyText = neutralTertiary;
        result.variantBorderHovered = (s2 === null || s2 === void 0 ? void 0 : s2.variantBorderHovered) || neutralTertiary;
        result.buttonTextDisabled = neutralTertiary;
        result.inputIconDisabled = neutralTertiary;
        result.disabledText = neutralTertiary;
      }
      if (neutralPrimary) {
        result.bodyText = neutralPrimary;
        result.actionLink = neutralPrimary;
        result.buttonText = neutralPrimary;
        result.inputBorderHovered = neutralPrimary;
        result.inputText = neutralPrimary;
        result.listText = neutralPrimary;
        result.menuItemText = neutralPrimary;
      }
      if (neutralLighterAlt) {
        result.bodyStandoutBackground = neutralLighterAlt;
        result.defaultStateBackground = neutralLighterAlt;
      }
      if (neutralDark) {
        result.actionLinkHovered = neutralDark;
        result.buttonTextHovered = neutralDark;
        result.buttonTextChecked = neutralDark;
        result.buttonTextPressed = neutralDark;
        result.inputTextHovered = neutralDark;
        result.menuItemTextHovered = neutralDark;
      }
      if (neutralSecondary) {
        result.bodySubtext = neutralSecondary;
        result.focusBorder = neutralSecondary;
        result.inputBorder = neutralSecondary;
        result.smallInputBorder = neutralSecondary;
        result.inputPlaceholderText = neutralSecondary;
      }
      if (neutralSecondaryAlt) {
        result.buttonBorder = neutralSecondaryAlt;
      }
      if (neutralTertiaryAlt) {
        result.disabledBodySubtext = neutralTertiaryAlt;
        result.disabledBorder = neutralTertiaryAlt;
        result.buttonBackgroundChecked = neutralTertiaryAlt;
        result.menuDivider = neutralTertiaryAlt;
      }
      if (accent) {
        result.accentButtonBackground = accent;
      }
      if (e2 === null || e2 === void 0 ? void 0 : e2.elevation4) {
        result.cardShadow = e2.elevation4;
      }
      if (!isInverted && (e2 === null || e2 === void 0 ? void 0 : e2.elevation8)) {
        result.cardShadowHovered = e2.elevation8;
      } else if (result.variantBorderHovered) {
        result.cardShadowHovered = "0 0 1px " + result.variantBorderHovered;
      }
      result = __assign$1(__assign$1({}, result), s2);
      return result;
    }
    function _fixDeprecatedSlots$1(s2, depComments) {
      var dep = "";
      if (depComments === true) {
        dep = " /* @deprecated */";
      }
      s2.listTextColor = s2.listText + dep;
      s2.menuItemBackgroundChecked += dep;
      s2.warningHighlight += dep;
      s2.warningText = s2.messageText + dep;
      s2.successText += dep;
      return s2;
    }
    function mergeThemes$1(theme, partialTheme) {
      var _a2, _b, _c;
      if (partialTheme === void 0) {
        partialTheme = {};
      }
      var mergedTheme = merge$2({}, theme, partialTheme, {
        semanticColors: getSemanticColors$1(partialTheme.palette, partialTheme.effects, partialTheme.semanticColors, partialTheme.isInverted === void 0 ? theme.isInverted : partialTheme.isInverted)
      });
      if (((_a2 = partialTheme.palette) === null || _a2 === void 0 ? void 0 : _a2.themePrimary) && !((_b = partialTheme.palette) === null || _b === void 0 ? void 0 : _b.accent)) {
        mergedTheme.palette.accent = partialTheme.palette.themePrimary;
      }
      if (partialTheme.defaultFontStyle) {
        for (var _i = 0, _d = Object.keys(mergedTheme.fonts); _i < _d.length; _i++) {
          var fontStyle = _d[_i];
          mergedTheme.fonts[fontStyle] = merge$2(mergedTheme.fonts[fontStyle], partialTheme.defaultFontStyle, (_c = partialTheme === null || partialTheme === void 0 ? void 0 : partialTheme.fonts) === null || _c === void 0 ? void 0 : _c[fontStyle]);
        }
      }
      return mergedTheme;
    }
    var DefaultPalette$1 = {
      themeDarker: "#004578",
      themeDark: "#005a9e",
      themeDarkAlt: "#106ebe",
      themePrimary: "#0078d4",
      themeSecondary: "#2b88d8",
      themeTertiary: "#71afe5",
      themeLight: "#c7e0f4",
      themeLighter: "#deecf9",
      themeLighterAlt: "#eff6fc",
      black: "#000000",
      blackTranslucent40: "rgba(0,0,0,.4)",
      neutralDark: "#201f1e",
      neutralPrimary: "#323130",
      neutralPrimaryAlt: "#3b3a39",
      neutralSecondary: "#605e5c",
      neutralSecondaryAlt: "#8a8886",
      neutralTertiary: "#a19f9d",
      neutralTertiaryAlt: "#c8c6c4",
      neutralQuaternary: "#d2d0ce",
      neutralQuaternaryAlt: "#e1dfdd",
      neutralLight: "#edebe9",
      neutralLighter: "#f3f2f1",
      neutralLighterAlt: "#faf9f8",
      accent: "#0078d4",
      white: "#ffffff",
      whiteTranslucent40: "rgba(255,255,255,.4)",
      yellowDark: "#d29200",
      yellow: "#ffb900",
      yellowLight: "#fff100",
      orange: "#d83b01",
      orangeLight: "#ea4300",
      orangeLighter: "#ff8c00",
      redDark: "#a4262c",
      red: "#e81123",
      magentaDark: "#5c005c",
      magenta: "#b4009e",
      magentaLight: "#e3008c",
      purpleDark: "#32145a",
      purple: "#5c2d91",
      purpleLight: "#b4a0ff",
      blueDark: "#002050",
      blueMid: "#00188f",
      blue: "#0078d4",
      blueLight: "#00bcf2",
      tealDark: "#004b50",
      teal: "#008272",
      tealLight: "#00b294",
      greenDark: "#004b1c",
      green: "#107c10",
      greenLight: "#bad80a"
    };
    var Depths$1;
    (function(Depths2) {
      Depths2.depth0 = "0 0 0 0 transparent";
      Depths2.depth4 = "0 1.6px 3.6px 0 rgba(0, 0, 0, 0.132), 0 0.3px 0.9px 0 rgba(0, 0, 0, 0.108)";
      Depths2.depth8 = "0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132), 0 0.6px 1.8px 0 rgba(0, 0, 0, 0.108)";
      Depths2.depth16 = "0 6.4px 14.4px 0 rgba(0, 0, 0, 0.132), 0 1.2px 3.6px 0 rgba(0, 0, 0, 0.108)";
      Depths2.depth64 = "0 25.6px 57.6px 0 rgba(0, 0, 0, 0.22), 0 4.8px 14.4px 0 rgba(0, 0, 0, 0.18)";
    })(Depths$1 || (Depths$1 = {}));
    var DefaultEffects$1 = {
      elevation4: Depths$1.depth4,
      elevation8: Depths$1.depth8,
      elevation16: Depths$1.depth16,
      elevation64: Depths$1.depth64,
      roundedCorner2: "2px",
      roundedCorner4: "4px",
      roundedCorner6: "6px"
    };
    var DefaultSpacing$1 = {
      s2: "4px",
      s1: "8px",
      m: "16px",
      l1: "20px",
      l2: "32px"
    };
    var EASING_FUNCTION_1 = "cubic-bezier(.1,.9,.2,1)";
    var EASING_FUNCTION_2 = "cubic-bezier(.1,.25,.75,.9)";
    var DURATION_1 = "0.167s";
    var DURATION_2 = "0.267s";
    var DURATION_3 = "0.367s";
    var DURATION_4 = "0.467s";
    var FADE_IN = keyframes({
      from: { opacity: 0 },
      to: { opacity: 1 }
    });
    var FADE_OUT = keyframes({
      from: { opacity: 1 },
      to: { opacity: 0, visibility: "hidden" }
    });
    var SLIDE_RIGHT_IN10 = _createSlideInX(-10);
    var SLIDE_RIGHT_IN20 = _createSlideInX(-20);
    var SLIDE_RIGHT_IN40 = _createSlideInX(-40);
    var SLIDE_RIGHT_IN400 = _createSlideInX(-400);
    var SLIDE_LEFT_IN10 = _createSlideInX(10);
    var SLIDE_LEFT_IN20 = _createSlideInX(20);
    var SLIDE_LEFT_IN40 = _createSlideInX(40);
    var SLIDE_LEFT_IN400 = _createSlideInX(400);
    var SLIDE_UP_IN10 = _createSlideInY(10);
    var SLIDE_UP_IN20 = _createSlideInY(20);
    var SLIDE_DOWN_IN10 = _createSlideInY(-10);
    var SLIDE_DOWN_IN20 = _createSlideInY(-20);
    var SLIDE_RIGHT_OUT10 = _createSlideOutX(10);
    var SLIDE_RIGHT_OUT20 = _createSlideOutX(20);
    var SLIDE_RIGHT_OUT40 = _createSlideOutX(40);
    var SLIDE_RIGHT_OUT400 = _createSlideOutX(400);
    var SLIDE_LEFT_OUT10 = _createSlideOutX(-10);
    var SLIDE_LEFT_OUT20 = _createSlideOutX(-20);
    var SLIDE_LEFT_OUT40 = _createSlideOutX(-40);
    var SLIDE_LEFT_OUT400 = _createSlideOutX(-400);
    var SLIDE_UP_OUT10 = _createSlideOutY(-10);
    var SLIDE_UP_OUT20 = _createSlideOutY(-20);
    var SLIDE_DOWN_OUT10 = _createSlideOutY(10);
    var SLIDE_DOWN_OUT20 = _createSlideOutY(20);
    var SCALE_UP100 = keyframes({
      from: { transform: "scale3d(.98,.98,1)" },
      to: { transform: "scale3d(1,1,1)" }
    });
    var SCALE_DOWN98 = keyframes({
      from: { transform: "scale3d(1,1,1)" },
      to: { transform: "scale3d(.98,.98,1)" }
    });
    var SCALE_DOWN100 = keyframes({
      from: { transform: "scale3d(1.03,1.03,1)" },
      to: { transform: "scale3d(1,1,1)" }
    });
    var SCALE_UP103 = keyframes({
      from: { transform: "scale3d(1,1,1)" },
      to: { transform: "scale3d(1.03,1.03,1)" }
    });
    var ROTATE90 = keyframes({
      from: { transform: "rotateZ(0deg)" },
      to: { transform: "rotateZ(90deg)" }
    });
    var ROTATE_N90 = keyframes({
      from: { transform: "rotateZ(0deg)" },
      to: { transform: "rotateZ(-90deg)" }
    });
    var AnimationStyles = {
      slideRightIn10: _createAnimation(FADE_IN + "," + SLIDE_RIGHT_IN10, DURATION_3, EASING_FUNCTION_1),
      slideRightIn20: _createAnimation(FADE_IN + "," + SLIDE_RIGHT_IN20, DURATION_3, EASING_FUNCTION_1),
      slideRightIn40: _createAnimation(FADE_IN + "," + SLIDE_RIGHT_IN40, DURATION_3, EASING_FUNCTION_1),
      slideRightIn400: _createAnimation(FADE_IN + "," + SLIDE_RIGHT_IN400, DURATION_3, EASING_FUNCTION_1),
      slideLeftIn10: _createAnimation(FADE_IN + "," + SLIDE_LEFT_IN10, DURATION_3, EASING_FUNCTION_1),
      slideLeftIn20: _createAnimation(FADE_IN + "," + SLIDE_LEFT_IN20, DURATION_3, EASING_FUNCTION_1),
      slideLeftIn40: _createAnimation(FADE_IN + "," + SLIDE_LEFT_IN40, DURATION_3, EASING_FUNCTION_1),
      slideLeftIn400: _createAnimation(FADE_IN + "," + SLIDE_LEFT_IN400, DURATION_3, EASING_FUNCTION_1),
      slideUpIn10: _createAnimation(FADE_IN + "," + SLIDE_UP_IN10, DURATION_3, EASING_FUNCTION_1),
      slideUpIn20: _createAnimation(FADE_IN + "," + SLIDE_UP_IN20, DURATION_3, EASING_FUNCTION_1),
      slideDownIn10: _createAnimation(FADE_IN + "," + SLIDE_DOWN_IN10, DURATION_3, EASING_FUNCTION_1),
      slideDownIn20: _createAnimation(FADE_IN + "," + SLIDE_DOWN_IN20, DURATION_3, EASING_FUNCTION_1),
      slideRightOut10: _createAnimation(FADE_OUT + "," + SLIDE_RIGHT_OUT10, DURATION_3, EASING_FUNCTION_1),
      slideRightOut20: _createAnimation(FADE_OUT + "," + SLIDE_RIGHT_OUT20, DURATION_3, EASING_FUNCTION_1),
      slideRightOut40: _createAnimation(FADE_OUT + "," + SLIDE_RIGHT_OUT40, DURATION_3, EASING_FUNCTION_1),
      slideRightOut400: _createAnimation(FADE_OUT + "," + SLIDE_RIGHT_OUT400, DURATION_3, EASING_FUNCTION_1),
      slideLeftOut10: _createAnimation(FADE_OUT + "," + SLIDE_LEFT_OUT10, DURATION_3, EASING_FUNCTION_1),
      slideLeftOut20: _createAnimation(FADE_OUT + "," + SLIDE_LEFT_OUT20, DURATION_3, EASING_FUNCTION_1),
      slideLeftOut40: _createAnimation(FADE_OUT + "," + SLIDE_LEFT_OUT40, DURATION_3, EASING_FUNCTION_1),
      slideLeftOut400: _createAnimation(FADE_OUT + "," + SLIDE_LEFT_OUT400, DURATION_3, EASING_FUNCTION_1),
      slideUpOut10: _createAnimation(FADE_OUT + "," + SLIDE_UP_OUT10, DURATION_3, EASING_FUNCTION_1),
      slideUpOut20: _createAnimation(FADE_OUT + "," + SLIDE_UP_OUT20, DURATION_3, EASING_FUNCTION_1),
      slideDownOut10: _createAnimation(FADE_OUT + "," + SLIDE_DOWN_OUT10, DURATION_3, EASING_FUNCTION_1),
      slideDownOut20: _createAnimation(FADE_OUT + "," + SLIDE_DOWN_OUT20, DURATION_3, EASING_FUNCTION_1),
      scaleUpIn100: _createAnimation(FADE_IN + "," + SCALE_UP100, DURATION_3, EASING_FUNCTION_1),
      scaleDownIn100: _createAnimation(FADE_IN + "," + SCALE_DOWN100, DURATION_3, EASING_FUNCTION_1),
      scaleUpOut103: _createAnimation(FADE_OUT + "," + SCALE_UP103, DURATION_1, EASING_FUNCTION_2),
      scaleDownOut98: _createAnimation(FADE_OUT + "," + SCALE_DOWN98, DURATION_1, EASING_FUNCTION_2),
      fadeIn100: _createAnimation(FADE_IN, DURATION_1, EASING_FUNCTION_2),
      fadeIn200: _createAnimation(FADE_IN, DURATION_2, EASING_FUNCTION_2),
      fadeIn400: _createAnimation(FADE_IN, DURATION_3, EASING_FUNCTION_2),
      fadeIn500: _createAnimation(FADE_IN, DURATION_4, EASING_FUNCTION_2),
      fadeOut100: _createAnimation(FADE_OUT, DURATION_1, EASING_FUNCTION_2),
      fadeOut200: _createAnimation(FADE_OUT, DURATION_2, EASING_FUNCTION_2),
      fadeOut400: _createAnimation(FADE_OUT, DURATION_3, EASING_FUNCTION_2),
      fadeOut500: _createAnimation(FADE_OUT, DURATION_4, EASING_FUNCTION_2),
      rotate90deg: _createAnimation(ROTATE90, "0.1s", EASING_FUNCTION_2),
      rotateN90deg: _createAnimation(ROTATE_N90, "0.1s", EASING_FUNCTION_2)
      // expandCollapse 100/200/400, delay 100/200
    };
    function _createAnimation(animationName, animationDuration, animationTimingFunction) {
      return {
        animationName,
        animationDuration,
        animationTimingFunction,
        animationFillMode: "both"
      };
    }
    function _createSlideInX(fromX) {
      return keyframes({
        from: { transform: "translate3d(" + fromX + "px,0,0)", pointerEvents: "none" },
        to: { transform: "translate3d(0,0,0)", pointerEvents: "auto" }
      });
    }
    function _createSlideInY(fromY) {
      return keyframes({
        from: { transform: "translate3d(0," + fromY + "px,0)", pointerEvents: "none" },
        to: { transform: "translate3d(0,0,0)", pointerEvents: "auto" }
      });
    }
    function _createSlideOutX(toX) {
      return keyframes({
        from: { transform: "translate3d(0,0,0)" },
        to: { transform: "translate3d(" + toX + "px,0,0)" }
      });
    }
    function _createSlideOutY(toY) {
      return keyframes({
        from: { transform: "translate3d(0,0,0)" },
        to: { transform: "translate3d(0," + toY + "px,0)" }
      });
    }
    var LocalizedFontNames$1;
    (function(LocalizedFontNames2) {
      LocalizedFontNames2.Arabic = "Segoe UI Web (Arabic)";
      LocalizedFontNames2.Cyrillic = "Segoe UI Web (Cyrillic)";
      LocalizedFontNames2.EastEuropean = "Segoe UI Web (East European)";
      LocalizedFontNames2.Greek = "Segoe UI Web (Greek)";
      LocalizedFontNames2.Hebrew = "Segoe UI Web (Hebrew)";
      LocalizedFontNames2.Thai = "Leelawadee UI Web";
      LocalizedFontNames2.Vietnamese = "Segoe UI Web (Vietnamese)";
      LocalizedFontNames2.WestEuropean = "Segoe UI Web (West European)";
      LocalizedFontNames2.Selawik = "Selawik Web";
      LocalizedFontNames2.Armenian = "Segoe UI Web (Armenian)";
      LocalizedFontNames2.Georgian = "Segoe UI Web (Georgian)";
    })(LocalizedFontNames$1 || (LocalizedFontNames$1 = {}));
    var LocalizedFontFamilies$1;
    (function(LocalizedFontFamilies2) {
      LocalizedFontFamilies2.Arabic = "'" + LocalizedFontNames$1.Arabic + "'";
      LocalizedFontFamilies2.ChineseSimplified = "'Microsoft Yahei UI', Verdana, Simsun";
      LocalizedFontFamilies2.ChineseTraditional = "'Microsoft Jhenghei UI', Pmingliu";
      LocalizedFontFamilies2.Cyrillic = "'" + LocalizedFontNames$1.Cyrillic + "'";
      LocalizedFontFamilies2.EastEuropean = "'" + LocalizedFontNames$1.EastEuropean + "'";
      LocalizedFontFamilies2.Greek = "'" + LocalizedFontNames$1.Greek + "'";
      LocalizedFontFamilies2.Hebrew = "'" + LocalizedFontNames$1.Hebrew + "'";
      LocalizedFontFamilies2.Hindi = "'Nirmala UI'";
      LocalizedFontFamilies2.Japanese = "'Yu Gothic UI', 'Meiryo UI', Meiryo, 'MS Pgothic', Osaka";
      LocalizedFontFamilies2.Korean = "'Malgun Gothic', Gulim";
      LocalizedFontFamilies2.Selawik = "'" + LocalizedFontNames$1.Selawik + "'";
      LocalizedFontFamilies2.Thai = "'Leelawadee UI Web', 'Kmer UI'";
      LocalizedFontFamilies2.Vietnamese = "'" + LocalizedFontNames$1.Vietnamese + "'";
      LocalizedFontFamilies2.WestEuropean = "'" + LocalizedFontNames$1.WestEuropean + "'";
      LocalizedFontFamilies2.Armenian = "'" + LocalizedFontNames$1.Armenian + "'";
      LocalizedFontFamilies2.Georgian = "'" + LocalizedFontNames$1.Georgian + "'";
    })(LocalizedFontFamilies$1 || (LocalizedFontFamilies$1 = {}));
    var FontSizes$1;
    (function(FontSizes2) {
      FontSizes2.size10 = "10px";
      FontSizes2.size12 = "12px";
      FontSizes2.size14 = "14px";
      FontSizes2.size16 = "16px";
      FontSizes2.size18 = "18px";
      FontSizes2.size20 = "20px";
      FontSizes2.size24 = "24px";
      FontSizes2.size28 = "28px";
      FontSizes2.size32 = "32px";
      FontSizes2.size42 = "42px";
      FontSizes2.size68 = "68px";
      FontSizes2.mini = "10px";
      FontSizes2.xSmall = "10px";
      FontSizes2.small = "12px";
      FontSizes2.smallPlus = "12px";
      FontSizes2.medium = "14px";
      FontSizes2.mediumPlus = "16px";
      FontSizes2.icon = "16px";
      FontSizes2.large = "18px";
      FontSizes2.xLarge = "20px";
      FontSizes2.xLargePlus = "24px";
      FontSizes2.xxLarge = "28px";
      FontSizes2.xxLargePlus = "32px";
      FontSizes2.superLarge = "42px";
      FontSizes2.mega = "68px";
    })(FontSizes$1 || (FontSizes$1 = {}));
    var FontWeights$1;
    (function(FontWeights2) {
      FontWeights2.light = 100;
      FontWeights2.semilight = 300;
      FontWeights2.regular = 400;
      FontWeights2.semibold = 600;
      FontWeights2.bold = 700;
    })(FontWeights$1 || (FontWeights$1 = {}));
    var IconFontSizes$1;
    (function(IconFontSizes2) {
      IconFontSizes2.xSmall = "10px";
      IconFontSizes2.small = "12px";
      IconFontSizes2.medium = "16px";
      IconFontSizes2.large = "20px";
    })(IconFontSizes$1 || (IconFontSizes$1 = {}));
    var FontFamilyFallbacks$1 = "'Segoe UI', -apple-system, BlinkMacSystemFont, 'Roboto', 'Helvetica Neue', sans-serif";
    var defaultFontFamily$1 = "'Segoe UI', '" + LocalizedFontNames$1.WestEuropean + "'";
    var LanguageToFontMap$1 = {
      ar: LocalizedFontFamilies$1.Arabic,
      bg: LocalizedFontFamilies$1.Cyrillic,
      cs: LocalizedFontFamilies$1.EastEuropean,
      el: LocalizedFontFamilies$1.Greek,
      et: LocalizedFontFamilies$1.EastEuropean,
      he: LocalizedFontFamilies$1.Hebrew,
      hi: LocalizedFontFamilies$1.Hindi,
      hr: LocalizedFontFamilies$1.EastEuropean,
      hu: LocalizedFontFamilies$1.EastEuropean,
      ja: LocalizedFontFamilies$1.Japanese,
      kk: LocalizedFontFamilies$1.EastEuropean,
      ko: LocalizedFontFamilies$1.Korean,
      lt: LocalizedFontFamilies$1.EastEuropean,
      lv: LocalizedFontFamilies$1.EastEuropean,
      pl: LocalizedFontFamilies$1.EastEuropean,
      ru: LocalizedFontFamilies$1.Cyrillic,
      sk: LocalizedFontFamilies$1.EastEuropean,
      "sr-latn": LocalizedFontFamilies$1.EastEuropean,
      th: LocalizedFontFamilies$1.Thai,
      tr: LocalizedFontFamilies$1.EastEuropean,
      uk: LocalizedFontFamilies$1.Cyrillic,
      vi: LocalizedFontFamilies$1.Vietnamese,
      "zh-hans": LocalizedFontFamilies$1.ChineseSimplified,
      "zh-hant": LocalizedFontFamilies$1.ChineseTraditional,
      hy: LocalizedFontFamilies$1.Armenian,
      ka: LocalizedFontFamilies$1.Georgian
    };
    function _fontFamilyWithFallbacks$1(fontFamily) {
      return fontFamily + ", " + FontFamilyFallbacks$1;
    }
    function _getLocalizedFontFamily$1(language) {
      for (var lang2 in LanguageToFontMap$1) {
        if (LanguageToFontMap$1.hasOwnProperty(lang2) && language && lang2.indexOf(language) === 0) {
          return LanguageToFontMap$1[lang2];
        }
      }
      return defaultFontFamily$1;
    }
    function _createFont$1(size, weight, fontFamily) {
      return {
        fontFamily,
        MozOsxFontSmoothing: "grayscale",
        WebkitFontSmoothing: "antialiased",
        fontSize: size,
        fontWeight: weight
      };
    }
    function createFontStyles$1(localeCode) {
      var localizedFont = _getLocalizedFontFamily$1(localeCode);
      var fontFamilyWithFallback = _fontFamilyWithFallbacks$1(localizedFont);
      var fontStyles = {
        tiny: _createFont$1(FontSizes$1.mini, FontWeights$1.regular, fontFamilyWithFallback),
        xSmall: _createFont$1(FontSizes$1.xSmall, FontWeights$1.regular, fontFamilyWithFallback),
        small: _createFont$1(FontSizes$1.small, FontWeights$1.regular, fontFamilyWithFallback),
        smallPlus: _createFont$1(FontSizes$1.smallPlus, FontWeights$1.regular, fontFamilyWithFallback),
        medium: _createFont$1(FontSizes$1.medium, FontWeights$1.regular, fontFamilyWithFallback),
        mediumPlus: _createFont$1(FontSizes$1.mediumPlus, FontWeights$1.regular, fontFamilyWithFallback),
        large: _createFont$1(FontSizes$1.large, FontWeights$1.regular, fontFamilyWithFallback),
        xLarge: _createFont$1(FontSizes$1.xLarge, FontWeights$1.semibold, fontFamilyWithFallback),
        xLargePlus: _createFont$1(FontSizes$1.xLargePlus, FontWeights$1.semibold, fontFamilyWithFallback),
        xxLarge: _createFont$1(FontSizes$1.xxLarge, FontWeights$1.semibold, fontFamilyWithFallback),
        xxLargePlus: _createFont$1(FontSizes$1.xxLargePlus, FontWeights$1.semibold, fontFamilyWithFallback),
        superLarge: _createFont$1(FontSizes$1.superLarge, FontWeights$1.semibold, fontFamilyWithFallback),
        mega: _createFont$1(FontSizes$1.mega, FontWeights$1.semibold, fontFamilyWithFallback)
      };
      return fontStyles;
    }
    var DefaultBaseUrl$1 = "https://static2.sharepointonline.com/files/fabric/assets";
    var DefaultFontStyles$1 = createFontStyles$1(getLanguage());
    function _registerFontFace$1(fontFamily, url, fontWeight, localFontName) {
      fontFamily = "'" + fontFamily + "'";
      var localFontSrc = localFontName !== void 0 ? "local('" + localFontName + "')," : "";
      fontFace({
        fontFamily,
        src: localFontSrc + ("url('" + url + ".woff2') format('woff2'),") + ("url('" + url + ".woff') format('woff')"),
        fontWeight,
        fontStyle: "normal",
        fontDisplay: "swap"
      });
    }
    function _registerFontFaceSet$1(baseUrl, fontFamily, cdnFolder, cdnFontName, localFontName) {
      if (cdnFontName === void 0) {
        cdnFontName = "segoeui";
      }
      var urlBase = baseUrl + "/" + cdnFolder + "/" + cdnFontName;
      _registerFontFace$1(fontFamily, urlBase + "-light", FontWeights$1.light, localFontName && localFontName + " Light");
      _registerFontFace$1(fontFamily, urlBase + "-semilight", FontWeights$1.semilight, localFontName && localFontName + " SemiLight");
      _registerFontFace$1(fontFamily, urlBase + "-regular", FontWeights$1.regular, localFontName);
      _registerFontFace$1(fontFamily, urlBase + "-semibold", FontWeights$1.semibold, localFontName && localFontName + " SemiBold");
      _registerFontFace$1(fontFamily, urlBase + "-bold", FontWeights$1.bold, localFontName && localFontName + " Bold");
    }
    function registerDefaultFontFaces$1(baseUrl) {
      if (baseUrl) {
        var fontUrl = baseUrl + "/fonts";
        _registerFontFaceSet$1(fontUrl, LocalizedFontNames$1.Thai, "leelawadeeui-thai", "leelawadeeui");
        _registerFontFaceSet$1(fontUrl, LocalizedFontNames$1.Arabic, "segoeui-arabic");
        _registerFontFaceSet$1(fontUrl, LocalizedFontNames$1.Cyrillic, "segoeui-cyrillic");
        _registerFontFaceSet$1(fontUrl, LocalizedFontNames$1.EastEuropean, "segoeui-easteuropean");
        _registerFontFaceSet$1(fontUrl, LocalizedFontNames$1.Greek, "segoeui-greek");
        _registerFontFaceSet$1(fontUrl, LocalizedFontNames$1.Hebrew, "segoeui-hebrew");
        _registerFontFaceSet$1(fontUrl, LocalizedFontNames$1.Vietnamese, "segoeui-vietnamese");
        _registerFontFaceSet$1(fontUrl, LocalizedFontNames$1.WestEuropean, "segoeui-westeuropean", "segoeui", "Segoe UI");
        _registerFontFaceSet$1(fontUrl, LocalizedFontFamilies$1.Selawik, "selawik", "selawik");
        _registerFontFaceSet$1(fontUrl, LocalizedFontNames$1.Armenian, "segoeui-armenian");
        _registerFontFaceSet$1(fontUrl, LocalizedFontNames$1.Georgian, "segoeui-georgian");
        _registerFontFace$1("Leelawadee UI Web", fontUrl + "/leelawadeeui-thai/leelawadeeui-semilight", FontWeights$1.light);
        _registerFontFace$1("Leelawadee UI Web", fontUrl + "/leelawadeeui-thai/leelawadeeui-bold", FontWeights$1.semibold);
      }
    }
    function _getFontBaseUrl$1() {
      var _a2, _b;
      var fabricConfig = (_a2 = getWindow()) === null || _a2 === void 0 ? void 0 : _a2.FabricConfig;
      return (_b = fabricConfig === null || fabricConfig === void 0 ? void 0 : fabricConfig.fontBaseUrl) !== null && _b !== void 0 ? _b : DefaultBaseUrl$1;
    }
    registerDefaultFontFaces$1(_getFontBaseUrl$1());
    function createTheme$1(theme, depComments) {
      if (theme === void 0) {
        theme = {};
      }
      if (depComments === void 0) {
        depComments = false;
      }
      var isInverted = !!theme.isInverted;
      var baseTheme = {
        palette: DefaultPalette$1,
        effects: DefaultEffects$1,
        fonts: DefaultFontStyles$1,
        spacing: DefaultSpacing$1,
        isInverted,
        disableGlobalClassNames: false,
        semanticColors: makeSemanticColors$1(DefaultPalette$1, DefaultEffects$1, void 0, isInverted, depComments),
        rtl: void 0
      };
      return mergeThemes$1(baseTheme, theme);
    }
    var HighContrastSelector = "@media screen and (-ms-high-contrast: active), (forced-colors: active)";
    var ScreenWidthMinLarge = 640;
    var ScreenWidthMaxMedium = ScreenWidthMinLarge - 1;
    function getScreenSelector(min2, max2) {
      var minSelector = typeof min2 === "number" ? " and (min-width: " + min2 + "px)" : "";
      var maxSelector = typeof max2 === "number" ? " and (max-width: " + max2 + "px)" : "";
      return "@media only screen" + minSelector + maxSelector;
    }
    function getHighContrastNoAdjustStyle() {
      return {
        forcedColorAdjust: "none",
        MsHighContrastAdjust: "none"
      };
    }
    var ZIndexes;
    (function(ZIndexes2) {
      ZIndexes2.Nav = 1;
      ZIndexes2.ScrollablePane = 1;
      ZIndexes2.FocusStyle = 1;
      ZIndexes2.Coachmark = 1e3;
      ZIndexes2.Layer = 1e6;
      ZIndexes2.KeytipLayer = 1000001;
    })(ZIndexes || (ZIndexes = {}));
    function getFocusStyle(theme, insetOrOptions, position2, highContrastStyle, borderColor2, outlineColor, isFocusedOnly) {
      if (typeof insetOrOptions === "number" || !insetOrOptions) {
        return _getFocusStyleInternal(theme, {
          inset: insetOrOptions,
          position: position2,
          highContrastStyle,
          borderColor: borderColor2,
          outlineColor,
          isFocusedOnly
        });
      } else {
        return _getFocusStyleInternal(theme, insetOrOptions);
      }
    }
    function _getFocusStyleInternal(theme, options) {
      var _a2, _b;
      if (options === void 0) {
        options = {};
      }
      var _c = options.inset, inset2 = _c === void 0 ? 0 : _c, _d = options.width, width = _d === void 0 ? 1 : _d, _e = options.position, position2 = _e === void 0 ? "relative" : _e, highContrastStyle = options.highContrastStyle, _f = options.borderColor, borderColor2 = _f === void 0 ? theme.palette.white : _f, _g = options.outlineColor, outlineColor = _g === void 0 ? theme.palette.neutralSecondary : _g, _h = options.isFocusedOnly, isFocusedOnly = _h === void 0 ? true : _h;
      return {
        // Clear browser-specific focus styles and use 'transparent' as placeholder for focus style.
        outline: "transparent",
        // Requirement because pseudo-element is absolutely positioned.
        position: position2,
        selectors: (_a2 = {
          // Clear the focus border in Firefox.
          // Reference: http://stackoverflow.com/a/199319/1436671
          "::-moz-focus-inner": {
            border: "0"
          }
        }, // When the element that uses this mixin is in a :focus state, add a pseudo-element to
        // create a border.
        _a2["." + IsFocusVisibleClassName + " &" + (isFocusedOnly ? ":focus" : "") + ":after"] = {
          content: '""',
          position: "absolute",
          left: inset2 + 1,
          top: inset2 + 1,
          bottom: inset2 + 1,
          right: inset2 + 1,
          border: width + "px solid " + borderColor2,
          outline: width + "px solid " + outlineColor,
          zIndex: ZIndexes.FocusStyle,
          selectors: (_b = {}, _b[HighContrastSelector] = highContrastStyle, _b)
        }, _a2)
      };
    }
    function focusClear() {
      return {
        selectors: {
          "&::-moz-focus-inner": {
            // Clear the focus border in Firefox. Reference: http://stackoverflow.com/a/199319/1436671
            border: 0
          },
          "&": {
            // Clear browser specific focus styles and use transparent as placeholder for focus style
            outline: "transparent"
          }
        }
      };
    }
    var hiddenContentStyle = {
      position: "absolute",
      width: 1,
      height: 1,
      margin: -1,
      padding: 0,
      border: 0,
      overflow: "hidden",
      whiteSpace: "nowrap"
    };
    var _getGlobalClassNames = memoizeFunction(function(classNames2, disableGlobalClassNames) {
      var styleSheet = Stylesheet.getInstance();
      if (disableGlobalClassNames) {
        return Object.keys(classNames2).reduce(function(acc, className) {
          acc[className] = styleSheet.getClassName(classNames2[className]);
          return acc;
        }, {});
      }
      return classNames2;
    });
    function getGlobalClassNames(classNames2, theme, disableGlobalClassNames) {
      return _getGlobalClassNames(classNames2, disableGlobalClassNames !== void 0 ? disableGlobalClassNames : theme.disableGlobalClassNames);
    }
    var __assign = globalThis && globalThis.__assign || function() {
      __assign = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    var _root = typeof window === "undefined" ? global : window;
    var _styleNonce = _root && _root.CSPSettings && _root.CSPSettings.nonce;
    var _themeState = initializeThemeState();
    function initializeThemeState() {
      var state = _root.__themeState__ || {
        theme: void 0,
        lastStyleElement: void 0,
        registeredStyles: []
      };
      if (!state.runState) {
        state = __assign({}, state, { perf: {
          count: 0,
          duration: 0
        }, runState: {
          flushTimer: 0,
          mode: 0,
          buffer: []
        } });
      }
      if (!state.registeredThemableStyles) {
        state = __assign({}, state, { registeredThemableStyles: [] });
      }
      _root.__themeState__ = state;
      return state;
    }
    function applyThemableStyles(stylesArray, styleRecord) {
      if (_themeState.loadStyles) {
        _themeState.loadStyles(resolveThemableArray(stylesArray).styleString, stylesArray);
      } else {
        registerStyles(stylesArray);
      }
    }
    function loadTheme$1(theme) {
      _themeState.theme = theme;
      reloadStyles();
    }
    function clearStyles(option) {
      if (option === void 0) {
        option = 3;
      }
      if (option === 3 || option === 2) {
        clearStylesInternal(_themeState.registeredStyles);
        _themeState.registeredStyles = [];
      }
      if (option === 3 || option === 1) {
        clearStylesInternal(_themeState.registeredThemableStyles);
        _themeState.registeredThemableStyles = [];
      }
    }
    function clearStylesInternal(records) {
      records.forEach(function(styleRecord) {
        var styleElement = styleRecord && styleRecord.styleElement;
        if (styleElement && styleElement.parentElement) {
          styleElement.parentElement.removeChild(styleElement);
        }
      });
    }
    function reloadStyles() {
      if (_themeState.theme) {
        var themableStyles = [];
        for (var _i = 0, _a2 = _themeState.registeredThemableStyles; _i < _a2.length; _i++) {
          var styleRecord = _a2[_i];
          themableStyles.push(styleRecord.themableStyle);
        }
        if (themableStyles.length > 0) {
          clearStyles(
            1
            /* onlyThemable */
          );
          applyThemableStyles([].concat.apply([], themableStyles));
        }
      }
    }
    function resolveThemableArray(splitStyleArray) {
      var theme = _themeState.theme;
      var themable = false;
      var resolvedArray = (splitStyleArray || []).map(function(currentValue) {
        var themeSlot = currentValue.theme;
        if (themeSlot) {
          themable = true;
          var themedValue = theme ? theme[themeSlot] : void 0;
          var defaultValue = currentValue.defaultValue || "inherit";
          if (theme && !themedValue && console && !(themeSlot in theme) && typeof DEBUG !== "undefined" && DEBUG) {
            console.warn('Theming value not provided for "' + themeSlot + '". Falling back to "' + defaultValue + '".');
          }
          return themedValue || defaultValue;
        } else {
          return currentValue.rawString;
        }
      });
      return {
        styleString: resolvedArray.join(""),
        themable
      };
    }
    function registerStyles(styleArray) {
      if (typeof document === "undefined") {
        return;
      }
      var head = document.getElementsByTagName("head")[0];
      var styleElement = document.createElement("style");
      var _a2 = resolveThemableArray(styleArray), styleString = _a2.styleString, themable = _a2.themable;
      styleElement.setAttribute("data-load-themed-styles", "true");
      if (_styleNonce) {
        styleElement.setAttribute("nonce", _styleNonce);
      }
      styleElement.appendChild(document.createTextNode(styleString));
      _themeState.perf.count++;
      head.appendChild(styleElement);
      var ev = document.createEvent("HTMLEvents");
      ev.initEvent(
        "styleinsert",
        true,
        false
        /* cancelable */
      );
      ev.args = {
        newStyle: styleElement
      };
      document.dispatchEvent(ev);
      var record = {
        styleElement,
        themableStyle: styleArray
      };
      if (themable) {
        _themeState.registeredThemableStyles.push(record);
      } else {
        _themeState.registeredStyles.push(record);
      }
    }
    var _theme = createTheme$1({});
    var _onThemeChangeCallbacks = [];
    var ThemeSettingName = "theme";
    function initializeThemeInCustomizations() {
      var _a2;
      var _b, _c;
      var win = getWindow();
      if ((_b = win === null || win === void 0 ? void 0 : win.FabricConfig) === null || _b === void 0 ? void 0 : _b.legacyTheme) {
        loadTheme(win.FabricConfig.legacyTheme);
      } else if (!Customizations.getSettings([ThemeSettingName]).theme) {
        if ((_c = win === null || win === void 0 ? void 0 : win.FabricConfig) === null || _c === void 0 ? void 0 : _c.theme) {
          _theme = createTheme$1(win.FabricConfig.theme);
        }
        Customizations.applySettings((_a2 = {}, _a2[ThemeSettingName] = _theme, _a2));
      }
    }
    initializeThemeInCustomizations();
    function getTheme(depComments) {
      if (depComments === void 0) {
        depComments = false;
      }
      if (depComments === true) {
        _theme = createTheme$1({}, depComments);
      }
      return _theme;
    }
    function loadTheme(theme, depComments) {
      var _a2;
      if (depComments === void 0) {
        depComments = false;
      }
      _theme = createTheme$1(theme, depComments);
      loadTheme$1(__assign$1(__assign$1(__assign$1(__assign$1({}, _theme.palette), _theme.semanticColors), _theme.effects), _loadFonts(_theme)));
      Customizations.applySettings((_a2 = {}, _a2[ThemeSettingName] = _theme, _a2));
      _onThemeChangeCallbacks.forEach(function(callback) {
        try {
          callback(_theme);
        } catch (e2) {
        }
      });
      return _theme;
    }
    function _loadFonts(theme) {
      var lines = {};
      for (var _i = 0, _a2 = Object.keys(theme.fonts); _i < _a2.length; _i++) {
        var fontName = _a2[_i];
        var font = theme.fonts[fontName];
        for (var _b = 0, _c = Object.keys(font); _b < _c.length; _b++) {
          var propName = _c[_b];
          var name_1 = fontName + propName.charAt(0).toUpperCase() + propName.slice(1);
          var value = font[propName];
          if (propName === "fontSize" && typeof value === "number") {
            value = value + "px";
          }
          lines[name_1] = value;
        }
      }
      return lines;
    }
    var AnimationClassNames = buildClassMap(AnimationStyles);
    setVersion("@fluentui/style-utilities", "8.6.0");
    initializeThemeInCustomizations();
    function makeSemanticColors(p2, e2, s2, isInverted, depComments) {
      if (depComments === void 0) {
        depComments = false;
      }
      var semanticColors = __assign$1({
        primaryButtonBorder: "transparent",
        errorText: !isInverted ? "#a4262c" : "#F1707B",
        messageText: !isInverted ? "#323130" : "#F3F2F1",
        messageLink: !isInverted ? "#005A9E" : "#6CB8F6",
        messageLinkHovered: !isInverted ? "#004578" : "#82C7FF",
        infoIcon: !isInverted ? "#605e5c" : "#C8C6C4",
        errorIcon: !isInverted ? "#A80000" : "#F1707B",
        blockingIcon: !isInverted ? "#FDE7E9" : "#442726",
        warningIcon: !isInverted ? "#797775" : "#C8C6C4",
        severeWarningIcon: !isInverted ? "#D83B01" : "#FCE100",
        successIcon: !isInverted ? "#107C10" : "#92C353",
        infoBackground: !isInverted ? "#f3f2f1" : "#323130",
        errorBackground: !isInverted ? "#FDE7E9" : "#442726",
        blockingBackground: !isInverted ? "#FDE7E9" : "#442726",
        warningBackground: !isInverted ? "#FFF4CE" : "#433519",
        severeWarningBackground: !isInverted ? "#FED9CC" : "#4F2A0F",
        successBackground: !isInverted ? "#DFF6DD" : "#393D1B",
        // deprecated
        warningHighlight: !isInverted ? "#ffb900" : "#fff100",
        successText: !isInverted ? "#107C10" : "#92c353"
      }, s2);
      var fullSemanticColors = getSemanticColors(p2, e2, semanticColors, isInverted);
      return _fixDeprecatedSlots(fullSemanticColors, depComments);
    }
    function getSemanticColors(p2, e2, s2, isInverted, depComments) {
      var result = {};
      var _a2 = p2 || {}, white2 = _a2.white, black2 = _a2.black, themePrimary = _a2.themePrimary, themeDark = _a2.themeDark, themeDarker = _a2.themeDarker, themeDarkAlt = _a2.themeDarkAlt, themeLighter = _a2.themeLighter, neutralLight = _a2.neutralLight, neutralLighter = _a2.neutralLighter, neutralDark = _a2.neutralDark, neutralQuaternary = _a2.neutralQuaternary, neutralQuaternaryAlt = _a2.neutralQuaternaryAlt, neutralPrimary = _a2.neutralPrimary, neutralSecondary = _a2.neutralSecondary, neutralSecondaryAlt = _a2.neutralSecondaryAlt, neutralTertiary = _a2.neutralTertiary, neutralTertiaryAlt = _a2.neutralTertiaryAlt, neutralLighterAlt = _a2.neutralLighterAlt, accent = _a2.accent;
      if (white2) {
        result.bodyBackground = white2;
        result.bodyFrameBackground = white2;
        result.accentButtonText = white2;
        result.buttonBackground = white2;
        result.primaryButtonText = white2;
        result.primaryButtonTextHovered = white2;
        result.primaryButtonTextPressed = white2;
        result.inputBackground = white2;
        result.inputForegroundChecked = white2;
        result.listBackground = white2;
        result.menuBackground = white2;
        result.cardStandoutBackground = white2;
      }
      if (black2) {
        result.bodyTextChecked = black2;
        result.buttonTextCheckedHovered = black2;
      }
      if (themePrimary) {
        result.link = themePrimary;
        result.primaryButtonBackground = themePrimary;
        result.inputBackgroundChecked = themePrimary;
        result.inputIcon = themePrimary;
        result.inputFocusBorderAlt = themePrimary;
        result.menuIcon = themePrimary;
        result.menuHeader = themePrimary;
        result.accentButtonBackground = themePrimary;
      }
      if (themeDark) {
        result.primaryButtonBackgroundPressed = themeDark;
        result.inputBackgroundCheckedHovered = themeDark;
        result.inputIconHovered = themeDark;
      }
      if (themeDarker) {
        result.linkHovered = themeDarker;
      }
      if (themeDarkAlt) {
        result.primaryButtonBackgroundHovered = themeDarkAlt;
      }
      if (themeLighter) {
        result.inputPlaceholderBackgroundChecked = themeLighter;
      }
      if (neutralLight) {
        result.bodyBackgroundChecked = neutralLight;
        result.bodyFrameDivider = neutralLight;
        result.bodyDivider = neutralLight;
        result.variantBorder = neutralLight;
        result.buttonBackgroundCheckedHovered = neutralLight;
        result.buttonBackgroundPressed = neutralLight;
        result.listItemBackgroundChecked = neutralLight;
        result.listHeaderBackgroundPressed = neutralLight;
        result.menuItemBackgroundPressed = neutralLight;
        result.menuItemBackgroundChecked = neutralLight;
      }
      if (neutralLighter) {
        result.bodyBackgroundHovered = neutralLighter;
        result.buttonBackgroundHovered = neutralLighter;
        result.buttonBackgroundDisabled = neutralLighter;
        result.buttonBorderDisabled = neutralLighter;
        result.primaryButtonBackgroundDisabled = neutralLighter;
        result.disabledBackground = neutralLighter;
        result.listItemBackgroundHovered = neutralLighter;
        result.listHeaderBackgroundHovered = neutralLighter;
        result.menuItemBackgroundHovered = neutralLighter;
      }
      if (neutralQuaternary) {
        result.primaryButtonTextDisabled = neutralQuaternary;
        result.disabledSubtext = neutralQuaternary;
      }
      if (neutralQuaternaryAlt) {
        result.listItemBackgroundCheckedHovered = neutralQuaternaryAlt;
      }
      if (neutralTertiary) {
        result.disabledBodyText = neutralTertiary;
        result.variantBorderHovered = (s2 === null || s2 === void 0 ? void 0 : s2.variantBorderHovered) || neutralTertiary;
        result.buttonTextDisabled = neutralTertiary;
        result.inputIconDisabled = neutralTertiary;
        result.disabledText = neutralTertiary;
      }
      if (neutralPrimary) {
        result.bodyText = neutralPrimary;
        result.actionLink = neutralPrimary;
        result.buttonText = neutralPrimary;
        result.inputBorderHovered = neutralPrimary;
        result.inputText = neutralPrimary;
        result.listText = neutralPrimary;
        result.menuItemText = neutralPrimary;
      }
      if (neutralLighterAlt) {
        result.bodyStandoutBackground = neutralLighterAlt;
        result.defaultStateBackground = neutralLighterAlt;
      }
      if (neutralDark) {
        result.actionLinkHovered = neutralDark;
        result.buttonTextHovered = neutralDark;
        result.buttonTextChecked = neutralDark;
        result.buttonTextPressed = neutralDark;
        result.inputTextHovered = neutralDark;
        result.menuItemTextHovered = neutralDark;
      }
      if (neutralSecondary) {
        result.bodySubtext = neutralSecondary;
        result.focusBorder = neutralSecondary;
        result.inputBorder = neutralSecondary;
        result.smallInputBorder = neutralSecondary;
        result.inputPlaceholderText = neutralSecondary;
      }
      if (neutralSecondaryAlt) {
        result.buttonBorder = neutralSecondaryAlt;
      }
      if (neutralTertiaryAlt) {
        result.disabledBodySubtext = neutralTertiaryAlt;
        result.disabledBorder = neutralTertiaryAlt;
        result.buttonBackgroundChecked = neutralTertiaryAlt;
        result.menuDivider = neutralTertiaryAlt;
      }
      if (accent) {
        result.accentButtonBackground = accent;
      }
      if (e2 === null || e2 === void 0 ? void 0 : e2.elevation4) {
        result.cardShadow = e2.elevation4;
      }
      if (!isInverted && (e2 === null || e2 === void 0 ? void 0 : e2.elevation8)) {
        result.cardShadowHovered = e2.elevation8;
      } else if (result.variantBorderHovered) {
        result.cardShadowHovered = "0 0 1px " + result.variantBorderHovered;
      }
      result = __assign$1(__assign$1({}, result), s2);
      return result;
    }
    function _fixDeprecatedSlots(s2, depComments) {
      var dep = "";
      if (depComments === true) {
        dep = " /* @deprecated */";
      }
      s2.listTextColor = s2.listText + dep;
      s2.menuItemBackgroundChecked += dep;
      s2.warningHighlight += dep;
      s2.warningText = s2.messageText + dep;
      s2.successText += dep;
      return s2;
    }
    function mergeThemes(theme, partialTheme) {
      var _a2, _b, _c;
      if (partialTheme === void 0) {
        partialTheme = {};
      }
      var mergedTheme = merge$2({}, theme, partialTheme, {
        semanticColors: getSemanticColors(partialTheme.palette, partialTheme.effects, partialTheme.semanticColors, partialTheme.isInverted === void 0 ? theme.isInverted : partialTheme.isInverted)
      });
      if (((_a2 = partialTheme.palette) === null || _a2 === void 0 ? void 0 : _a2.themePrimary) && !((_b = partialTheme.palette) === null || _b === void 0 ? void 0 : _b.accent)) {
        mergedTheme.palette.accent = partialTheme.palette.themePrimary;
      }
      if (partialTheme.defaultFontStyle) {
        for (var _i = 0, _d = Object.keys(mergedTheme.fonts); _i < _d.length; _i++) {
          var fontStyle = _d[_i];
          mergedTheme.fonts[fontStyle] = merge$2(mergedTheme.fonts[fontStyle], partialTheme.defaultFontStyle, (_c = partialTheme === null || partialTheme === void 0 ? void 0 : partialTheme.fonts) === null || _c === void 0 ? void 0 : _c[fontStyle]);
        }
      }
      return mergedTheme;
    }
    var DefaultPalette = {
      themeDarker: "#004578",
      themeDark: "#005a9e",
      themeDarkAlt: "#106ebe",
      themePrimary: "#0078d4",
      themeSecondary: "#2b88d8",
      themeTertiary: "#71afe5",
      themeLight: "#c7e0f4",
      themeLighter: "#deecf9",
      themeLighterAlt: "#eff6fc",
      black: "#000000",
      blackTranslucent40: "rgba(0,0,0,.4)",
      neutralDark: "#201f1e",
      neutralPrimary: "#323130",
      neutralPrimaryAlt: "#3b3a39",
      neutralSecondary: "#605e5c",
      neutralSecondaryAlt: "#8a8886",
      neutralTertiary: "#a19f9d",
      neutralTertiaryAlt: "#c8c6c4",
      neutralQuaternary: "#d2d0ce",
      neutralQuaternaryAlt: "#e1dfdd",
      neutralLight: "#edebe9",
      neutralLighter: "#f3f2f1",
      neutralLighterAlt: "#faf9f8",
      accent: "#0078d4",
      white: "#ffffff",
      whiteTranslucent40: "rgba(255,255,255,.4)",
      yellowDark: "#d29200",
      yellow: "#ffb900",
      yellowLight: "#fff100",
      orange: "#d83b01",
      orangeLight: "#ea4300",
      orangeLighter: "#ff8c00",
      redDark: "#a4262c",
      red: "#e81123",
      magentaDark: "#5c005c",
      magenta: "#b4009e",
      magentaLight: "#e3008c",
      purpleDark: "#32145a",
      purple: "#5c2d91",
      purpleLight: "#b4a0ff",
      blueDark: "#002050",
      blueMid: "#00188f",
      blue: "#0078d4",
      blueLight: "#00bcf2",
      tealDark: "#004b50",
      teal: "#008272",
      tealLight: "#00b294",
      greenDark: "#004b1c",
      green: "#107c10",
      greenLight: "#bad80a"
    };
    var Depths;
    (function(Depths2) {
      Depths2.depth0 = "0 0 0 0 transparent";
      Depths2.depth4 = "0 1.6px 3.6px 0 rgba(0, 0, 0, 0.132), 0 0.3px 0.9px 0 rgba(0, 0, 0, 0.108)";
      Depths2.depth8 = "0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132), 0 0.6px 1.8px 0 rgba(0, 0, 0, 0.108)";
      Depths2.depth16 = "0 6.4px 14.4px 0 rgba(0, 0, 0, 0.132), 0 1.2px 3.6px 0 rgba(0, 0, 0, 0.108)";
      Depths2.depth64 = "0 25.6px 57.6px 0 rgba(0, 0, 0, 0.22), 0 4.8px 14.4px 0 rgba(0, 0, 0, 0.18)";
    })(Depths || (Depths = {}));
    var DefaultEffects = {
      elevation4: Depths.depth4,
      elevation8: Depths.depth8,
      elevation16: Depths.depth16,
      elevation64: Depths.depth64,
      roundedCorner2: "2px",
      roundedCorner4: "4px",
      roundedCorner6: "6px"
    };
    var DefaultSpacing = {
      s2: "4px",
      s1: "8px",
      m: "16px",
      l1: "20px",
      l2: "32px"
    };
    var LocalizedFontNames;
    (function(LocalizedFontNames2) {
      LocalizedFontNames2.Arabic = "Segoe UI Web (Arabic)";
      LocalizedFontNames2.Cyrillic = "Segoe UI Web (Cyrillic)";
      LocalizedFontNames2.EastEuropean = "Segoe UI Web (East European)";
      LocalizedFontNames2.Greek = "Segoe UI Web (Greek)";
      LocalizedFontNames2.Hebrew = "Segoe UI Web (Hebrew)";
      LocalizedFontNames2.Thai = "Leelawadee UI Web";
      LocalizedFontNames2.Vietnamese = "Segoe UI Web (Vietnamese)";
      LocalizedFontNames2.WestEuropean = "Segoe UI Web (West European)";
      LocalizedFontNames2.Selawik = "Selawik Web";
      LocalizedFontNames2.Armenian = "Segoe UI Web (Armenian)";
      LocalizedFontNames2.Georgian = "Segoe UI Web (Georgian)";
    })(LocalizedFontNames || (LocalizedFontNames = {}));
    var LocalizedFontFamilies;
    (function(LocalizedFontFamilies2) {
      LocalizedFontFamilies2.Arabic = "'" + LocalizedFontNames.Arabic + "'";
      LocalizedFontFamilies2.ChineseSimplified = "'Microsoft Yahei UI', Verdana, Simsun";
      LocalizedFontFamilies2.ChineseTraditional = "'Microsoft Jhenghei UI', Pmingliu";
      LocalizedFontFamilies2.Cyrillic = "'" + LocalizedFontNames.Cyrillic + "'";
      LocalizedFontFamilies2.EastEuropean = "'" + LocalizedFontNames.EastEuropean + "'";
      LocalizedFontFamilies2.Greek = "'" + LocalizedFontNames.Greek + "'";
      LocalizedFontFamilies2.Hebrew = "'" + LocalizedFontNames.Hebrew + "'";
      LocalizedFontFamilies2.Hindi = "'Nirmala UI'";
      LocalizedFontFamilies2.Japanese = "'Yu Gothic UI', 'Meiryo UI', Meiryo, 'MS Pgothic', Osaka";
      LocalizedFontFamilies2.Korean = "'Malgun Gothic', Gulim";
      LocalizedFontFamilies2.Selawik = "'" + LocalizedFontNames.Selawik + "'";
      LocalizedFontFamilies2.Thai = "'Leelawadee UI Web', 'Kmer UI'";
      LocalizedFontFamilies2.Vietnamese = "'" + LocalizedFontNames.Vietnamese + "'";
      LocalizedFontFamilies2.WestEuropean = "'" + LocalizedFontNames.WestEuropean + "'";
      LocalizedFontFamilies2.Armenian = "'" + LocalizedFontNames.Armenian + "'";
      LocalizedFontFamilies2.Georgian = "'" + LocalizedFontNames.Georgian + "'";
    })(LocalizedFontFamilies || (LocalizedFontFamilies = {}));
    var FontSizes;
    (function(FontSizes2) {
      FontSizes2.size10 = "10px";
      FontSizes2.size12 = "12px";
      FontSizes2.size14 = "14px";
      FontSizes2.size16 = "16px";
      FontSizes2.size18 = "18px";
      FontSizes2.size20 = "20px";
      FontSizes2.size24 = "24px";
      FontSizes2.size28 = "28px";
      FontSizes2.size32 = "32px";
      FontSizes2.size42 = "42px";
      FontSizes2.size68 = "68px";
      FontSizes2.mini = "10px";
      FontSizes2.xSmall = "10px";
      FontSizes2.small = "12px";
      FontSizes2.smallPlus = "12px";
      FontSizes2.medium = "14px";
      FontSizes2.mediumPlus = "16px";
      FontSizes2.icon = "16px";
      FontSizes2.large = "18px";
      FontSizes2.xLarge = "20px";
      FontSizes2.xLargePlus = "24px";
      FontSizes2.xxLarge = "28px";
      FontSizes2.xxLargePlus = "32px";
      FontSizes2.superLarge = "42px";
      FontSizes2.mega = "68px";
    })(FontSizes || (FontSizes = {}));
    var FontWeights;
    (function(FontWeights2) {
      FontWeights2.light = 100;
      FontWeights2.semilight = 300;
      FontWeights2.regular = 400;
      FontWeights2.semibold = 600;
      FontWeights2.bold = 700;
    })(FontWeights || (FontWeights = {}));
    var IconFontSizes;
    (function(IconFontSizes2) {
      IconFontSizes2.xSmall = "10px";
      IconFontSizes2.small = "12px";
      IconFontSizes2.medium = "16px";
      IconFontSizes2.large = "20px";
    })(IconFontSizes || (IconFontSizes = {}));
    var FontFamilyFallbacks = "'Segoe UI', -apple-system, BlinkMacSystemFont, 'Roboto', 'Helvetica Neue', sans-serif";
    var defaultFontFamily = "'Segoe UI', '" + LocalizedFontNames.WestEuropean + "'";
    var LanguageToFontMap = {
      ar: LocalizedFontFamilies.Arabic,
      bg: LocalizedFontFamilies.Cyrillic,
      cs: LocalizedFontFamilies.EastEuropean,
      el: LocalizedFontFamilies.Greek,
      et: LocalizedFontFamilies.EastEuropean,
      he: LocalizedFontFamilies.Hebrew,
      hi: LocalizedFontFamilies.Hindi,
      hr: LocalizedFontFamilies.EastEuropean,
      hu: LocalizedFontFamilies.EastEuropean,
      ja: LocalizedFontFamilies.Japanese,
      kk: LocalizedFontFamilies.EastEuropean,
      ko: LocalizedFontFamilies.Korean,
      lt: LocalizedFontFamilies.EastEuropean,
      lv: LocalizedFontFamilies.EastEuropean,
      pl: LocalizedFontFamilies.EastEuropean,
      ru: LocalizedFontFamilies.Cyrillic,
      sk: LocalizedFontFamilies.EastEuropean,
      "sr-latn": LocalizedFontFamilies.EastEuropean,
      th: LocalizedFontFamilies.Thai,
      tr: LocalizedFontFamilies.EastEuropean,
      uk: LocalizedFontFamilies.Cyrillic,
      vi: LocalizedFontFamilies.Vietnamese,
      "zh-hans": LocalizedFontFamilies.ChineseSimplified,
      "zh-hant": LocalizedFontFamilies.ChineseTraditional,
      hy: LocalizedFontFamilies.Armenian,
      ka: LocalizedFontFamilies.Georgian
    };
    function _fontFamilyWithFallbacks(fontFamily) {
      return fontFamily + ", " + FontFamilyFallbacks;
    }
    function _getLocalizedFontFamily(language) {
      for (var lang2 in LanguageToFontMap) {
        if (LanguageToFontMap.hasOwnProperty(lang2) && language && lang2.indexOf(language) === 0) {
          return LanguageToFontMap[lang2];
        }
      }
      return defaultFontFamily;
    }
    function _createFont(size, weight, fontFamily) {
      return {
        fontFamily,
        MozOsxFontSmoothing: "grayscale",
        WebkitFontSmoothing: "antialiased",
        fontSize: size,
        fontWeight: weight
      };
    }
    function createFontStyles(localeCode) {
      var localizedFont = _getLocalizedFontFamily(localeCode);
      var fontFamilyWithFallback = _fontFamilyWithFallbacks(localizedFont);
      var fontStyles = {
        tiny: _createFont(FontSizes.mini, FontWeights.regular, fontFamilyWithFallback),
        xSmall: _createFont(FontSizes.xSmall, FontWeights.regular, fontFamilyWithFallback),
        small: _createFont(FontSizes.small, FontWeights.regular, fontFamilyWithFallback),
        smallPlus: _createFont(FontSizes.smallPlus, FontWeights.regular, fontFamilyWithFallback),
        medium: _createFont(FontSizes.medium, FontWeights.regular, fontFamilyWithFallback),
        mediumPlus: _createFont(FontSizes.mediumPlus, FontWeights.regular, fontFamilyWithFallback),
        large: _createFont(FontSizes.large, FontWeights.regular, fontFamilyWithFallback),
        xLarge: _createFont(FontSizes.xLarge, FontWeights.semibold, fontFamilyWithFallback),
        xLargePlus: _createFont(FontSizes.xLargePlus, FontWeights.semibold, fontFamilyWithFallback),
        xxLarge: _createFont(FontSizes.xxLarge, FontWeights.semibold, fontFamilyWithFallback),
        xxLargePlus: _createFont(FontSizes.xxLargePlus, FontWeights.semibold, fontFamilyWithFallback),
        superLarge: _createFont(FontSizes.superLarge, FontWeights.semibold, fontFamilyWithFallback),
        mega: _createFont(FontSizes.mega, FontWeights.semibold, fontFamilyWithFallback)
      };
      return fontStyles;
    }
    var DefaultBaseUrl = "https://static2.sharepointonline.com/files/fabric/assets";
    var DefaultFontStyles = createFontStyles(getLanguage());
    function _registerFontFace(fontFamily, url, fontWeight, localFontName) {
      fontFamily = "'" + fontFamily + "'";
      var localFontSrc = localFontName !== void 0 ? "local('" + localFontName + "')," : "";
      fontFace({
        fontFamily,
        src: localFontSrc + ("url('" + url + ".woff2') format('woff2'),") + ("url('" + url + ".woff') format('woff')"),
        fontWeight,
        fontStyle: "normal",
        fontDisplay: "swap"
      });
    }
    function _registerFontFaceSet(baseUrl, fontFamily, cdnFolder, cdnFontName, localFontName) {
      if (cdnFontName === void 0) {
        cdnFontName = "segoeui";
      }
      var urlBase = baseUrl + "/" + cdnFolder + "/" + cdnFontName;
      _registerFontFace(fontFamily, urlBase + "-light", FontWeights.light, localFontName && localFontName + " Light");
      _registerFontFace(fontFamily, urlBase + "-semilight", FontWeights.semilight, localFontName && localFontName + " SemiLight");
      _registerFontFace(fontFamily, urlBase + "-regular", FontWeights.regular, localFontName);
      _registerFontFace(fontFamily, urlBase + "-semibold", FontWeights.semibold, localFontName && localFontName + " SemiBold");
      _registerFontFace(fontFamily, urlBase + "-bold", FontWeights.bold, localFontName && localFontName + " Bold");
    }
    function registerDefaultFontFaces(baseUrl) {
      if (baseUrl) {
        var fontUrl = baseUrl + "/fonts";
        _registerFontFaceSet(fontUrl, LocalizedFontNames.Thai, "leelawadeeui-thai", "leelawadeeui");
        _registerFontFaceSet(fontUrl, LocalizedFontNames.Arabic, "segoeui-arabic");
        _registerFontFaceSet(fontUrl, LocalizedFontNames.Cyrillic, "segoeui-cyrillic");
        _registerFontFaceSet(fontUrl, LocalizedFontNames.EastEuropean, "segoeui-easteuropean");
        _registerFontFaceSet(fontUrl, LocalizedFontNames.Greek, "segoeui-greek");
        _registerFontFaceSet(fontUrl, LocalizedFontNames.Hebrew, "segoeui-hebrew");
        _registerFontFaceSet(fontUrl, LocalizedFontNames.Vietnamese, "segoeui-vietnamese");
        _registerFontFaceSet(fontUrl, LocalizedFontNames.WestEuropean, "segoeui-westeuropean", "segoeui", "Segoe UI");
        _registerFontFaceSet(fontUrl, LocalizedFontFamilies.Selawik, "selawik", "selawik");
        _registerFontFaceSet(fontUrl, LocalizedFontNames.Armenian, "segoeui-armenian");
        _registerFontFaceSet(fontUrl, LocalizedFontNames.Georgian, "segoeui-georgian");
        _registerFontFace("Leelawadee UI Web", fontUrl + "/leelawadeeui-thai/leelawadeeui-semilight", FontWeights.light);
        _registerFontFace("Leelawadee UI Web", fontUrl + "/leelawadeeui-thai/leelawadeeui-bold", FontWeights.semibold);
      }
    }
    function _getFontBaseUrl() {
      var _a2, _b;
      var fabricConfig = (_a2 = getWindow()) === null || _a2 === void 0 ? void 0 : _a2.FabricConfig;
      return (_b = fabricConfig === null || fabricConfig === void 0 ? void 0 : fabricConfig.fontBaseUrl) !== null && _b !== void 0 ? _b : DefaultBaseUrl;
    }
    registerDefaultFontFaces(_getFontBaseUrl());
    function createTheme(theme, depComments) {
      if (theme === void 0) {
        theme = {};
      }
      if (depComments === void 0) {
        depComments = false;
      }
      var isInverted = !!theme.isInverted;
      var baseTheme = {
        palette: DefaultPalette,
        effects: DefaultEffects,
        fonts: DefaultFontStyles,
        spacing: DefaultSpacing,
        isInverted,
        disableGlobalClassNames: false,
        semanticColors: makeSemanticColors(DefaultPalette, DefaultEffects, void 0, isInverted, depComments),
        rtl: void 0
      };
      return mergeThemes(baseTheme, theme);
    }
    var DirectionalHint = {
      /**
       * Appear above the target element, with the left edges of the callout and target aligning.
       */
      topLeftEdge: 0,
      /**
       * Appear above the target element, with the centers of the callout and target aligning.
       */
      topCenter: 1,
      /**
       * Appear above the target element, with the right edges of the callout and target aligning.
       */
      topRightEdge: 2,
      /**
       * Appear above the target element, aligning with the target element such that the callout tends toward
       * the center of the screen.
       */
      topAutoEdge: 3,
      /**
       * Appear below the target element, with the left edges of the callout and target aligning.
       */
      bottomLeftEdge: 4,
      /**
       * Appear below the target element, with the centers of the callout and target aligning.
       */
      bottomCenter: 5,
      /**
       * Appear below the target element, with the right edges of the callout and target aligning.
       */
      bottomRightEdge: 6,
      /**
       * Appear below the target element, aligning with the target element such that the callout tends toward
       * the center of the screen.
       */
      bottomAutoEdge: 7,
      /**
       * Appear to the left of the target element, with the top edges of the callout and target aligning.
       */
      leftTopEdge: 8,
      /**
       * Appear to the left of the target element, with the centers of the callout and target aligning.
       */
      leftCenter: 9,
      /**
       * Appear to the left of the target element, with the bottom edges of the callout and target aligning.
       */
      leftBottomEdge: 10,
      /**
       * Appear to the right of the target element, with the top edges of the callout and target aligning.
       */
      rightTopEdge: 11,
      /**
       * Appear to the right of the target element, with the centers of the callout and target aligning.
       */
      rightCenter: 12,
      /**
       * Appear to the right of the target element, with the bottom edges of the callout and target aligning.
       */
      rightBottomEdge: 13
    };
    var RectangleEdge;
    (function(RectangleEdge2) {
      RectangleEdge2[RectangleEdge2["top"] = 1] = "top";
      RectangleEdge2[RectangleEdge2["bottom"] = -1] = "bottom";
      RectangleEdge2[RectangleEdge2["left"] = 2] = "left";
      RectangleEdge2[RectangleEdge2["right"] = -2] = "right";
    })(RectangleEdge || (RectangleEdge = {}));
    var Position;
    (function(Position2) {
      Position2[Position2["top"] = 0] = "top";
      Position2[Position2["bottom"] = 1] = "bottom";
      Position2[Position2["start"] = 2] = "start";
      Position2[Position2["end"] = 3] = "end";
    })(Position || (Position = {}));
    var _a$1;
    function _createPositionData(targetEdge, alignmentEdge, isAuto2) {
      return {
        targetEdge,
        alignmentEdge,
        isAuto: isAuto2
      };
    }
    var DirectionalDictionary = (_a$1 = {}, _a$1[DirectionalHint.topLeftEdge] = _createPositionData(RectangleEdge.top, RectangleEdge.left), _a$1[DirectionalHint.topCenter] = _createPositionData(RectangleEdge.top), _a$1[DirectionalHint.topRightEdge] = _createPositionData(RectangleEdge.top, RectangleEdge.right), _a$1[DirectionalHint.topAutoEdge] = _createPositionData(RectangleEdge.top, void 0, true), _a$1[DirectionalHint.bottomLeftEdge] = _createPositionData(RectangleEdge.bottom, RectangleEdge.left), _a$1[DirectionalHint.bottomCenter] = _createPositionData(RectangleEdge.bottom), _a$1[DirectionalHint.bottomRightEdge] = _createPositionData(RectangleEdge.bottom, RectangleEdge.right), _a$1[DirectionalHint.bottomAutoEdge] = _createPositionData(RectangleEdge.bottom, void 0, true), _a$1[DirectionalHint.leftTopEdge] = _createPositionData(RectangleEdge.left, RectangleEdge.top), _a$1[DirectionalHint.leftCenter] = _createPositionData(RectangleEdge.left), _a$1[DirectionalHint.leftBottomEdge] = _createPositionData(RectangleEdge.left, RectangleEdge.bottom), _a$1[DirectionalHint.rightTopEdge] = _createPositionData(RectangleEdge.right, RectangleEdge.top), _a$1[DirectionalHint.rightCenter] = _createPositionData(RectangleEdge.right), _a$1[DirectionalHint.rightBottomEdge] = _createPositionData(RectangleEdge.right, RectangleEdge.bottom), _a$1);
    function _isRectangleWithinBounds(rect, boundingRect) {
      if (rect.top < boundingRect.top) {
        return false;
      }
      if (rect.bottom > boundingRect.bottom) {
        return false;
      }
      if (rect.left < boundingRect.left) {
        return false;
      }
      if (rect.right > boundingRect.right) {
        return false;
      }
      return true;
    }
    function _getOutOfBoundsEdges(rect, boundingRect) {
      var outOfBounds = [];
      if (rect.top < boundingRect.top) {
        outOfBounds.push(RectangleEdge.top);
      }
      if (rect.bottom > boundingRect.bottom) {
        outOfBounds.push(RectangleEdge.bottom);
      }
      if (rect.left < boundingRect.left) {
        outOfBounds.push(RectangleEdge.left);
      }
      if (rect.right > boundingRect.right) {
        outOfBounds.push(RectangleEdge.right);
      }
      return outOfBounds;
    }
    function _getEdgeValue(rect, edge) {
      return rect[RectangleEdge[edge]];
    }
    function _setEdgeValue(rect, edge, value) {
      rect[RectangleEdge[edge]] = value;
      return rect;
    }
    function _getCenterValue(rect, edge) {
      var edges = _getFlankingEdges(edge);
      return (_getEdgeValue(rect, edges.positiveEdge) + _getEdgeValue(rect, edges.negativeEdge)) / 2;
    }
    function _getRelativeEdgeValue(edge, value) {
      if (edge > 0) {
        return value;
      } else {
        return value * -1;
      }
    }
    function _getRelativeRectEdgeValue(edge, rect) {
      return _getRelativeEdgeValue(edge, _getEdgeValue(rect, edge));
    }
    function _getRelativeEdgeDifference(rect, hostRect, edge) {
      var edgeDifference = _getEdgeValue(rect, edge) - _getEdgeValue(hostRect, edge);
      return _getRelativeEdgeValue(edge, edgeDifference);
    }
    function _moveEdge(rect, edge, newValue, maintainSize) {
      if (maintainSize === void 0) {
        maintainSize = true;
      }
      var difference = _getEdgeValue(rect, edge) - newValue;
      var returnRect = _setEdgeValue(rect, edge, newValue);
      if (maintainSize) {
        returnRect = _setEdgeValue(rect, edge * -1, _getEdgeValue(rect, edge * -1) - difference);
      }
      return returnRect;
    }
    function _alignEdges(rect, target, edge, gap2) {
      if (gap2 === void 0) {
        gap2 = 0;
      }
      return _moveEdge(rect, edge, _getEdgeValue(target, edge) + _getRelativeEdgeValue(edge, gap2));
    }
    function _alignOppositeEdges(rect, target, targetEdge, gap2) {
      if (gap2 === void 0) {
        gap2 = 0;
      }
      var oppositeEdge = targetEdge * -1;
      var adjustedGap = _getRelativeEdgeValue(oppositeEdge, gap2);
      return _moveEdge(rect, targetEdge * -1, _getEdgeValue(target, targetEdge) + adjustedGap);
    }
    function _isEdgeInBounds(rect, bounds, edge) {
      var adjustedRectValue = _getRelativeRectEdgeValue(edge, rect);
      return adjustedRectValue > _getRelativeRectEdgeValue(edge, bounds);
    }
    function _getOutOfBoundsDegree(rect, bounds) {
      var breakingEdges = _getOutOfBoundsEdges(rect, bounds);
      var total = 0;
      for (var _i = 0, breakingEdges_1 = breakingEdges; _i < breakingEdges_1.length; _i++) {
        var edge = breakingEdges_1[_i];
        total += Math.pow(_getRelativeEdgeDifference(rect, bounds, edge), 2);
      }
      return total;
    }
    function _flipToFit(rect, target, bounding, positionData, gap2) {
      if (gap2 === void 0) {
        gap2 = 0;
      }
      var directions = [
        RectangleEdge.left,
        RectangleEdge.right,
        RectangleEdge.bottom,
        RectangleEdge.top
      ];
      if (getRTL()) {
        directions[0] *= -1;
        directions[1] *= -1;
      }
      var currentEstimate = rect;
      var currentEdge = positionData.targetEdge;
      var currentAlignment = positionData.alignmentEdge;
      var oobDegree;
      var bestEdge = currentEdge;
      var bestAlignment = currentAlignment;
      for (var i2 = 0; i2 < 4; i2++) {
        if (!_isEdgeInBounds(currentEstimate, bounding, currentEdge)) {
          var currentOOBDegree = _getOutOfBoundsDegree(currentEstimate, bounding);
          if (!oobDegree || currentOOBDegree < oobDegree) {
            oobDegree = currentOOBDegree;
            bestEdge = currentEdge;
            bestAlignment = currentAlignment;
          }
          directions.splice(directions.indexOf(currentEdge), 1);
          if (directions.length > 0) {
            if (directions.indexOf(currentEdge * -1) > -1) {
              currentEdge = currentEdge * -1;
            } else {
              currentAlignment = currentEdge;
              currentEdge = directions.slice(-1)[0];
            }
            currentEstimate = _estimatePosition(rect, target, { targetEdge: currentEdge, alignmentEdge: currentAlignment }, gap2);
          }
        } else {
          return {
            elementRectangle: currentEstimate,
            targetEdge: currentEdge,
            alignmentEdge: currentAlignment
          };
        }
      }
      currentEstimate = _estimatePosition(rect, target, { targetEdge: bestEdge, alignmentEdge: bestAlignment }, gap2);
      return {
        elementRectangle: currentEstimate,
        targetEdge: bestEdge,
        alignmentEdge: bestAlignment
      };
    }
    function _flipAlignmentEdge(elementEstimate, target, gap2, coverTarget2) {
      var alignmentEdge = elementEstimate.alignmentEdge, targetEdge = elementEstimate.targetEdge, elementRectangle = elementEstimate.elementRectangle;
      var oppositeEdge = alignmentEdge * -1;
      var newEstimate = _estimatePosition(elementRectangle, target, { targetEdge, alignmentEdge: oppositeEdge }, gap2, coverTarget2);
      return {
        elementRectangle: newEstimate,
        targetEdge,
        alignmentEdge: oppositeEdge
      };
    }
    function _adjustFitWithinBounds(element2, target, bounding, positionData, gap2, directionalHintFixed, coverTarget2) {
      if (gap2 === void 0) {
        gap2 = 0;
      }
      var alignmentEdge = positionData.alignmentEdge, alignTargetEdge = positionData.alignTargetEdge;
      var elementEstimate = {
        elementRectangle: element2,
        targetEdge: positionData.targetEdge,
        alignmentEdge
      };
      if (!directionalHintFixed && !coverTarget2) {
        elementEstimate = _flipToFit(element2, target, bounding, positionData, gap2);
      }
      var outOfBounds = _getOutOfBoundsEdges(elementEstimate.elementRectangle, bounding);
      var fixedEdge = directionalHintFixed ? -elementEstimate.targetEdge : void 0;
      if (outOfBounds.length > 0) {
        if (alignTargetEdge) {
          if (elementEstimate.alignmentEdge && outOfBounds.indexOf(elementEstimate.alignmentEdge * -1) > -1) {
            var flippedElementEstimate = _flipAlignmentEdge(elementEstimate, target, gap2, coverTarget2);
            if (_isRectangleWithinBounds(flippedElementEstimate.elementRectangle, bounding)) {
              return flippedElementEstimate;
            } else {
              elementEstimate = _alignOutOfBoundsEdges(_getOutOfBoundsEdges(flippedElementEstimate.elementRectangle, bounding), elementEstimate, bounding, fixedEdge);
            }
          } else {
            elementEstimate = _alignOutOfBoundsEdges(outOfBounds, elementEstimate, bounding, fixedEdge);
          }
        } else {
          elementEstimate = _alignOutOfBoundsEdges(outOfBounds, elementEstimate, bounding, fixedEdge);
        }
      }
      return elementEstimate;
    }
    function _alignOutOfBoundsEdges(outOfBoundsEdges, elementEstimate, bounding, preserveEdge) {
      for (var _i = 0, outOfBoundsEdges_1 = outOfBoundsEdges; _i < outOfBoundsEdges_1.length; _i++) {
        var direction = outOfBoundsEdges_1[_i];
        var edgeAttempt = void 0;
        if (preserveEdge && preserveEdge === direction * -1) {
          edgeAttempt = _moveEdge(elementEstimate.elementRectangle, direction, _getEdgeValue(bounding, direction), false);
          elementEstimate.forcedInBounds = true;
        } else {
          edgeAttempt = _alignEdges(elementEstimate.elementRectangle, bounding, direction);
          var inBounds = _isEdgeInBounds(edgeAttempt, bounding, direction * -1);
          if (!inBounds) {
            edgeAttempt = _moveEdge(edgeAttempt, direction * -1, _getEdgeValue(bounding, direction * -1), false);
            elementEstimate.forcedInBounds = true;
          }
        }
        elementEstimate.elementRectangle = edgeAttempt;
      }
      return elementEstimate;
    }
    function _centerEdgeToPoint(rect, edge, point2) {
      var positiveEdge = _getFlankingEdges(edge).positiveEdge;
      var elementMiddle = _getCenterValue(rect, edge);
      var distanceToMiddle = elementMiddle - _getEdgeValue(rect, positiveEdge);
      return _moveEdge(rect, positiveEdge, point2 - distanceToMiddle);
    }
    function _estimatePosition(elementToPosition, target, positionData, gap2, coverTarget2) {
      if (gap2 === void 0) {
        gap2 = 0;
      }
      var estimatedElementPosition = new Rectangle(elementToPosition.left, elementToPosition.right, elementToPosition.top, elementToPosition.bottom);
      var alignmentEdge = positionData.alignmentEdge, targetEdge = positionData.targetEdge;
      var elementEdge = coverTarget2 ? targetEdge : targetEdge * -1;
      estimatedElementPosition = coverTarget2 ? _alignEdges(estimatedElementPosition, target, targetEdge, gap2) : _alignOppositeEdges(estimatedElementPosition, target, targetEdge, gap2);
      if (!alignmentEdge) {
        var targetMiddlePoint = _getCenterValue(target, targetEdge);
        estimatedElementPosition = _centerEdgeToPoint(estimatedElementPosition, elementEdge, targetMiddlePoint);
      } else {
        estimatedElementPosition = _alignEdges(estimatedElementPosition, target, alignmentEdge);
      }
      return estimatedElementPosition;
    }
    function _getFlankingEdges(edge) {
      if (edge === RectangleEdge.top || edge === RectangleEdge.bottom) {
        return {
          positiveEdge: RectangleEdge.left,
          negativeEdge: RectangleEdge.right
        };
      } else {
        return {
          positiveEdge: RectangleEdge.top,
          negativeEdge: RectangleEdge.bottom
        };
      }
    }
    function _finalizeReturnEdge(elementRectangle, returnEdge, bounds) {
      if (bounds && Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge)) > Math.abs(_getRelativeEdgeDifference(elementRectangle, bounds, returnEdge * -1))) {
        return returnEdge * -1;
      }
      return returnEdge;
    }
    function _isEdgeOnBounds(elementRectangle, edge, bounds) {
      return bounds !== void 0 && _getEdgeValue(elementRectangle, edge) === _getEdgeValue(bounds, edge);
    }
    function _finalizeElementPosition(elementRectangle, hostElement, targetEdge, bounds, alignmentEdge, coverTarget2, doNotFinalizeReturnEdge, forceWithinBounds) {
      var returnValue = {};
      var hostRect = _getRectangleFromElement(hostElement);
      var elementEdge = coverTarget2 ? targetEdge : targetEdge * -1;
      var returnEdge = alignmentEdge ? alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge;
      if (!doNotFinalizeReturnEdge || _isEdgeOnBounds(elementRectangle, getOppositeEdge(returnEdge), bounds)) {
        returnEdge = _finalizeReturnEdge(elementRectangle, returnEdge, bounds);
      }
      returnValue[RectangleEdge[elementEdge]] = _getRelativeEdgeDifference(elementRectangle, hostRect, elementEdge);
      returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(elementRectangle, hostRect, returnEdge);
      if (forceWithinBounds) {
        returnValue[RectangleEdge[elementEdge * -1]] = _getRelativeEdgeDifference(elementRectangle, hostRect, elementEdge * -1);
        returnValue[RectangleEdge[returnEdge * -1]] = _getRelativeEdgeDifference(elementRectangle, hostRect, returnEdge * -1);
      }
      return returnValue;
    }
    function _calculateActualBeakWidthInPixels(beakWidth) {
      return Math.sqrt(beakWidth * beakWidth * 2);
    }
    function _getPositionData(directionalHint, directionalHintForRTL, previousPositions) {
      if (directionalHint === void 0) {
        directionalHint = DirectionalHint.bottomAutoEdge;
      }
      if (previousPositions) {
        return {
          alignmentEdge: previousPositions.alignmentEdge,
          isAuto: previousPositions.isAuto,
          targetEdge: previousPositions.targetEdge
        };
      }
      var positionInformation = __assign$1({}, DirectionalDictionary[directionalHint]);
      if (getRTL()) {
        if (positionInformation.alignmentEdge && positionInformation.alignmentEdge % 2 === 0) {
          positionInformation.alignmentEdge = positionInformation.alignmentEdge * -1;
        }
        return directionalHintForRTL !== void 0 ? DirectionalDictionary[directionalHintForRTL] : positionInformation;
      }
      return positionInformation;
    }
    function _getAlignmentData(positionData, target, boundingRect, coverTarget2, alignTargetEdge) {
      if (positionData.isAuto) {
        positionData.alignmentEdge = getClosestEdge(positionData.targetEdge, target, boundingRect);
      }
      positionData.alignTargetEdge = alignTargetEdge;
      return positionData;
    }
    function getClosestEdge(targetEdge, target, boundingRect) {
      var targetCenter = _getCenterValue(target, targetEdge);
      var boundingCenter = _getCenterValue(boundingRect, targetEdge);
      var _a2 = _getFlankingEdges(targetEdge), positiveEdge = _a2.positiveEdge, negativeEdge = _a2.negativeEdge;
      if (targetCenter <= boundingCenter) {
        return positiveEdge;
      } else {
        return negativeEdge;
      }
    }
    function _positionElementWithinBounds(elementToPosition, target, bounding, positionData, gap2, directionalHintFixed, coverTarget2) {
      var estimatedElementPosition = _estimatePosition(elementToPosition, target, positionData, gap2, coverTarget2);
      if (_isRectangleWithinBounds(estimatedElementPosition, bounding)) {
        return {
          elementRectangle: estimatedElementPosition,
          targetEdge: positionData.targetEdge,
          alignmentEdge: positionData.alignmentEdge
        };
      } else {
        return _adjustFitWithinBounds(estimatedElementPosition, target, bounding, positionData, gap2, directionalHintFixed, coverTarget2);
      }
    }
    function _finalizeBeakPosition(elementPosition, positionedBeak, bounds) {
      var targetEdge = elementPosition.targetEdge * -1;
      var actualElement = new Rectangle(0, elementPosition.elementRectangle.width, 0, elementPosition.elementRectangle.height);
      var returnValue = {};
      var returnEdge = _finalizeReturnEdge(elementPosition.elementRectangle, elementPosition.alignmentEdge ? elementPosition.alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge, bounds);
      var beakEdgeDifference = _getRelativeEdgeDifference(elementPosition.elementRectangle, elementPosition.targetRectangle, targetEdge);
      var showBeak = beakEdgeDifference > Math.abs(_getEdgeValue(positionedBeak, targetEdge));
      returnValue[RectangleEdge[targetEdge]] = _getEdgeValue(positionedBeak, targetEdge);
      returnValue[RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(positionedBeak, actualElement, returnEdge);
      return {
        elementPosition: __assign$1({}, returnValue),
        closestEdge: getClosestEdge(elementPosition.targetEdge, positionedBeak, actualElement),
        targetEdge,
        hideBeak: !showBeak
      };
    }
    function _positionBeak(beakWidth, elementPosition) {
      var target = elementPosition.targetRectangle;
      var _a2 = _getFlankingEdges(elementPosition.targetEdge), positiveEdge = _a2.positiveEdge, negativeEdge = _a2.negativeEdge;
      var beakTargetPoint = _getCenterValue(target, elementPosition.targetEdge);
      var elementBounds = new Rectangle(beakWidth / 2, elementPosition.elementRectangle.width - beakWidth / 2, beakWidth / 2, elementPosition.elementRectangle.height - beakWidth / 2);
      var beakPosition = new Rectangle(0, beakWidth, 0, beakWidth);
      beakPosition = _moveEdge(beakPosition, elementPosition.targetEdge * -1, -beakWidth / 2);
      beakPosition = _centerEdgeToPoint(beakPosition, elementPosition.targetEdge * -1, beakTargetPoint - _getRelativeRectEdgeValue(positiveEdge, elementPosition.elementRectangle));
      if (!_isEdgeInBounds(beakPosition, elementBounds, positiveEdge)) {
        beakPosition = _alignEdges(beakPosition, elementBounds, positiveEdge);
      } else if (!_isEdgeInBounds(beakPosition, elementBounds, negativeEdge)) {
        beakPosition = _alignEdges(beakPosition, elementBounds, negativeEdge);
      }
      return beakPosition;
    }
    function _getRectangleFromElement(element2) {
      var clientRect = element2.getBoundingClientRect();
      return new Rectangle(clientRect.left, clientRect.right, clientRect.top, clientRect.bottom);
    }
    function _getRectangleFromIRect(rect) {
      return new Rectangle(rect.left, rect.right, rect.top, rect.bottom);
    }
    function _getTargetRect(bounds, target) {
      var targetRectangle;
      if (target) {
        if (!!target.preventDefault) {
          var ev = target;
          targetRectangle = new Rectangle(ev.clientX, ev.clientX, ev.clientY, ev.clientY);
        } else if (!!target.getBoundingClientRect) {
          targetRectangle = _getRectangleFromElement(target);
        } else {
          var rectOrPoint = target;
          var left = rectOrPoint.left || rectOrPoint.x;
          var top_1 = rectOrPoint.top || rectOrPoint.y;
          var right = rectOrPoint.right || left;
          var bottom = rectOrPoint.bottom || top_1;
          targetRectangle = new Rectangle(left, right, top_1, bottom);
        }
        if (!_isRectangleWithinBounds(targetRectangle, bounds)) {
          var outOfBounds = _getOutOfBoundsEdges(targetRectangle, bounds);
          for (var _i = 0, outOfBounds_1 = outOfBounds; _i < outOfBounds_1.length; _i++) {
            var direction = outOfBounds_1[_i];
            targetRectangle[RectangleEdge[direction]] = bounds[RectangleEdge[direction]];
          }
        }
      } else {
        targetRectangle = new Rectangle(0, 0, 0, 0);
      }
      return targetRectangle;
    }
    function _positionElementRelative(props, elementToPosition, boundingRect, previousPositions) {
      var gap2 = props.gapSpace ? props.gapSpace : 0;
      var targetRect = _getTargetRect(boundingRect, props.target);
      var positionData = _getAlignmentData(_getPositionData(props.directionalHint, props.directionalHintForRTL, previousPositions), targetRect, boundingRect, props.coverTarget, props.alignTargetEdge);
      var positionedElement = _positionElementWithinBounds(_getRectangleFromElement(elementToPosition), targetRect, boundingRect, positionData, gap2, props.directionalHintFixed, props.coverTarget);
      return __assign$1(__assign$1({}, positionedElement), { targetRectangle: targetRect });
    }
    function _finalizePositionData(positionedElement, hostElement, bounds, coverTarget2, doNotFinalizeReturnEdge) {
      var finalizedElement = _finalizeElementPosition(positionedElement.elementRectangle, hostElement, positionedElement.targetEdge, bounds, positionedElement.alignmentEdge, coverTarget2, doNotFinalizeReturnEdge, positionedElement.forcedInBounds);
      return {
        elementPosition: finalizedElement,
        targetEdge: positionedElement.targetEdge,
        alignmentEdge: positionedElement.alignmentEdge
      };
    }
    function _positionCallout(props, hostElement, callout, previousPositions, doNotFinalizeReturnEdge) {
      var beakWidth = props.isBeakVisible ? props.beakWidth || 0 : 0;
      var gap2 = _calculateActualBeakWidthInPixels(beakWidth) / 2 + (props.gapSpace ? props.gapSpace : 0);
      var positionProps = props;
      positionProps.gapSpace = gap2;
      var boundingRect = props.bounds ? _getRectangleFromIRect(props.bounds) : new Rectangle(0, window.innerWidth - getScrollbarWidth(), 0, window.innerHeight);
      var positionedElement = _positionElementRelative(positionProps, callout, boundingRect, previousPositions);
      var beakPositioned = _positionBeak(beakWidth, positionedElement);
      var finalizedBeakPosition = _finalizeBeakPosition(positionedElement, beakPositioned, boundingRect);
      return __assign$1(__assign$1({}, _finalizePositionData(positionedElement, hostElement, boundingRect, props.coverTarget, doNotFinalizeReturnEdge)), { beakPosition: finalizedBeakPosition });
    }
    function _positionCard(props, hostElement, callout, previousPositions) {
      return _positionCallout(props, hostElement, callout, previousPositions, true);
    }
    function positionCallout(props, hostElement, elementToPosition, previousPositions) {
      return _positionCallout(props, hostElement, elementToPosition, previousPositions);
    }
    function positionCard(props, hostElement, elementToPosition, previousPositions) {
      return _positionCard(props, hostElement, elementToPosition, previousPositions);
    }
    function getOppositeEdge(edge) {
      return edge * -1;
    }
    function _getBoundsFromTargetWindow(target, targetWindow) {
      var segments = void 0;
      if (targetWindow.getWindowSegments) {
        segments = targetWindow.getWindowSegments();
      }
      if (segments === void 0 || segments.length <= 1) {
        return {
          top: 0,
          left: 0,
          right: targetWindow.innerWidth,
          bottom: targetWindow.innerHeight,
          width: targetWindow.innerWidth,
          height: targetWindow.innerHeight
        };
      }
      var x2 = 0;
      var y2 = 0;
      if (target !== null && !!target.getBoundingClientRect) {
        var clientRect = target.getBoundingClientRect();
        x2 = (clientRect.left + clientRect.right) / 2;
        y2 = (clientRect.top + clientRect.bottom) / 2;
      } else if (target !== null) {
        x2 = target.left || target.x;
        y2 = target.top || target.y;
      }
      var bounds = { top: 0, left: 0, right: 0, bottom: 0, width: 0, height: 0 };
      for (var _i = 0, segments_1 = segments; _i < segments_1.length; _i++) {
        var segment = segments_1[_i];
        if (x2 && segment.left <= x2 && segment.right >= x2 && y2 && segment.top <= y2 && segment.bottom >= y2) {
          bounds = {
            top: segment.top,
            left: segment.left,
            right: segment.right,
            bottom: segment.bottom,
            width: segment.width,
            height: segment.height
          };
        }
      }
      return bounds;
    }
    function getBoundsFromTargetWindow(target, targetWindow) {
      return _getBoundsFromTargetWindow(target, targetWindow);
    }
    function useConst(initialValue) {
      var ref = reactExports.useRef();
      if (ref.current === void 0) {
        ref.current = {
          value: typeof initialValue === "function" ? initialValue() : initialValue
        };
      }
      return ref.current.value;
    }
    function useAsync() {
      var async = useConst(function() {
        return new Async();
      });
      reactExports.useEffect(function() {
        return function() {
          return async.dispose();
        };
      }, [async]);
      return async;
    }
    function useId$1(prefix2, providedId) {
      var ref = reactExports.useRef(providedId);
      if (!ref.current) {
        ref.current = getId(prefix2);
      }
      return ref.current;
    }
    function useMergedRefs$1() {
      var refs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        refs[_i] = arguments[_i];
      }
      var mergedCallback = reactExports.useCallback(function(value) {
        mergedCallback.current = value;
        for (var _i2 = 0, refs_1 = refs; _i2 < refs_1.length; _i2++) {
          var ref = refs_1[_i2];
          if (typeof ref === "function") {
            ref(value);
          } else if (ref) {
            ref.current = value;
          }
        }
      }, __spreadArray([], refs));
      return mergedCallback;
    }
    function useOnEvent(element2, eventName, callback, useCapture) {
      var callbackRef = reactExports.useRef(callback);
      callbackRef.current = callback;
      reactExports.useEffect(function() {
        var actualElement = element2 && "current" in element2 ? element2.current : element2;
        if (!actualElement) {
          return;
        }
        var dispose = on(actualElement, eventName, function(ev) {
          return callbackRef.current(ev);
        }, useCapture);
        return dispose;
      }, [element2, eventName, useCapture]);
    }
    function usePrevious(value) {
      var ref = reactExports.useRef();
      reactExports.useEffect(function() {
        ref.current = value;
      });
      return ref.current;
    }
    var WindowContext = reactExports.createContext({
      window: typeof window === "object" ? window : void 0
    });
    var useWindow = function() {
      return reactExports.useContext(WindowContext).window;
    };
    var useDocument = function() {
      var _a2;
      return (_a2 = reactExports.useContext(WindowContext).window) === null || _a2 === void 0 ? void 0 : _a2.document;
    };
    function useTarget(target, hostElement) {
      var previousTargetProp = reactExports.useRef();
      var targetRef = reactExports.useRef(null);
      var targetWindow = useWindow();
      if (!target || target !== previousTargetProp.current || typeof target === "string") {
        var currentElement = hostElement === null || hostElement === void 0 ? void 0 : hostElement.current;
        if (target) {
          if (typeof target === "string") {
            var currentDoc = getDocument(currentElement);
            targetRef.current = currentDoc ? currentDoc.querySelector(target) : null;
          } else if ("stopPropagation" in target) {
            targetRef.current = target;
          } else if ("getBoundingClientRect" in target) {
            targetRef.current = target;
          } else if ("current" in target) {
            targetRef.current = target.current;
          } else {
            targetRef.current = target;
          }
        }
        previousTargetProp.current = target;
      }
      return [targetRef, targetWindow];
    }
    function useScrollbarAsync(props, root2) {
      var async = useAsync();
      var _a2 = reactExports.useState(false), needsVerticalScrollBarState = _a2[0], setNeedsVerticalScrollBar = _a2[1];
      reactExports.useEffect(function() {
        async.requestAnimationFrame(function() {
          var _a3;
          if (props.style && props.style.overflowY) {
            return;
          }
          var needsVerticalScrollBar = false;
          if (root2 && root2.current && ((_a3 = root2.current) === null || _a3 === void 0 ? void 0 : _a3.firstElementChild)) {
            var rootHeight = root2.current.clientHeight;
            var firstChildHeight = root2.current.firstElementChild.clientHeight;
            if (rootHeight > 0 && firstChildHeight > rootHeight) {
              needsVerticalScrollBar = firstChildHeight - rootHeight > 1;
            }
          }
          if (needsVerticalScrollBarState !== needsVerticalScrollBar) {
            setNeedsVerticalScrollBar(needsVerticalScrollBar);
          }
        });
        return function() {
          return async.dispose();
        };
      });
      return needsVerticalScrollBarState;
    }
    function defaultFocusRestorer(options) {
      var originalElement = options.originalElement, containsFocus = options.containsFocus;
      if (originalElement && containsFocus && originalElement !== getWindow()) {
        setTimeout(function() {
          var _a2;
          (_a2 = originalElement.focus) === null || _a2 === void 0 ? void 0 : _a2.call(originalElement);
        }, 0);
      }
    }
    function useRestoreFocus(props, root2) {
      var _a2 = props.onRestoreFocus, onRestoreFocus = _a2 === void 0 ? defaultFocusRestorer : _a2;
      var originalFocusedElement = reactExports.useRef();
      var containsFocus = reactExports.useRef(false);
      reactExports.useEffect(function() {
        originalFocusedElement.current = getDocument().activeElement;
        if (doesElementContainFocus(root2.current)) {
          containsFocus.current = true;
        }
        return function() {
          var _a3;
          onRestoreFocus === null || onRestoreFocus === void 0 ? void 0 : onRestoreFocus({
            originalElement: originalFocusedElement.current,
            containsFocus: containsFocus.current,
            documentContainsFocus: ((_a3 = getDocument()) === null || _a3 === void 0 ? void 0 : _a3.hasFocus()) || false
          });
          originalFocusedElement.current = void 0;
        };
      }, []);
      useOnEvent(root2, "focus", reactExports.useCallback(function() {
        containsFocus.current = true;
      }, []), true);
      useOnEvent(root2, "blur", reactExports.useCallback(function(ev) {
        if (root2.current && ev.relatedTarget && !root2.current.contains(ev.relatedTarget)) {
          containsFocus.current = false;
        }
      }, []), true);
    }
    function useHideSiblingNodes(props, root2) {
      var shouldHideSiblings = String(props["aria-modal"]).toLowerCase() === "true" && props.enableAriaHiddenSiblings;
      reactExports.useEffect(function() {
        if (!(shouldHideSiblings && root2.current)) {
          return;
        }
        var unmodalize2 = modalize(root2.current);
        return unmodalize2;
      }, [root2, shouldHideSiblings]);
    }
    var Popup = reactExports.forwardRef(function(propsWithoutDefaults, forwardedRef) {
      var props = getPropsWithDefaults({ shouldRestoreFocus: true, enableAriaHiddenSiblings: true }, propsWithoutDefaults);
      var root2 = reactExports.useRef();
      var mergedRootRef = useMergedRefs$1(root2, forwardedRef);
      useHideSiblingNodes(props, root2);
      useRestoreFocus(props, root2);
      var role = props.role, className = props.className, ariaLabel = props.ariaLabel, ariaLabelledBy = props.ariaLabelledBy, ariaDescribedBy = props.ariaDescribedBy, style2 = props.style, children = props.children, onDismiss = props.onDismiss;
      var needsVerticalScrollBar = useScrollbarAsync(props, root2);
      var onKeyDown = reactExports.useCallback(function(ev) {
        switch (ev.which) {
          case KeyCodes.escape:
            if (onDismiss) {
              onDismiss(ev);
              ev.preventDefault();
              ev.stopPropagation();
            }
            break;
        }
      }, [onDismiss]);
      var win = useWindow();
      useOnEvent(win, "keydown", onKeyDown);
      return reactExports.createElement("div", __assign$1({ ref: mergedRootRef }, getNativeProps$1(props, divProperties), { className, role, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy, onKeyDown, style: __assign$1({ overflowY: needsVerticalScrollBar ? "scroll" : void 0, outline: "none" }, style2) }), children);
    });
    Popup.displayName = "Popup";
    var _a;
    var COMPONENT_NAME$2 = "CalloutContentBase";
    var ANIMATIONS = (_a = {}, _a[RectangleEdge.top] = AnimationClassNames.slideUpIn10, _a[RectangleEdge.bottom] = AnimationClassNames.slideDownIn10, _a[RectangleEdge.left] = AnimationClassNames.slideLeftIn10, _a[RectangleEdge.right] = AnimationClassNames.slideRightIn10, _a);
    var BEAK_ORIGIN_POSITION = { top: 0, left: 0 };
    var OFF_SCREEN_STYLE = {
      opacity: 0,
      filter: "opacity(0)",
      pointerEvents: "none"
    };
    var ARIA_ROLE_ATTRIBUTES = ["role", "aria-roledescription"];
    var DEFAULT_PROPS$1 = {
      preventDismissOnLostFocus: false,
      preventDismissOnScroll: false,
      preventDismissOnResize: false,
      isBeakVisible: true,
      beakWidth: 16,
      gapSpace: 0,
      minPagePadding: 8,
      directionalHint: DirectionalHint.bottomAutoEdge
    };
    var getClassNames$7 = classNamesFunction({
      disableCaching: true
      // disabling caching because stylesProp.position mutates often
    });
    function useBounds(_a2, targetRef, targetWindow) {
      var bounds = _a2.bounds, _b = _a2.minPagePadding, minPagePadding = _b === void 0 ? DEFAULT_PROPS$1.minPagePadding : _b, target = _a2.target;
      var _c = reactExports.useState(false), targetWindowResized = _c[0], setTargetWindowResized = _c[1];
      var cachedBounds = reactExports.useRef();
      var getBounds = reactExports.useCallback(function() {
        if (!cachedBounds.current || targetWindowResized) {
          var currentBounds = typeof bounds === "function" ? targetWindow ? bounds(target, targetWindow) : void 0 : bounds;
          if (!currentBounds && targetWindow) {
            currentBounds = getBoundsFromTargetWindow(targetRef.current, targetWindow);
            currentBounds = {
              top: currentBounds.top + minPagePadding,
              left: currentBounds.left + minPagePadding,
              right: currentBounds.right - minPagePadding,
              bottom: currentBounds.bottom - minPagePadding,
              width: currentBounds.width - minPagePadding * 2,
              height: currentBounds.height - minPagePadding * 2
            };
          }
          cachedBounds.current = currentBounds;
          targetWindowResized && setTargetWindowResized(false);
        }
        return cachedBounds.current;
      }, [bounds, minPagePadding, target, targetRef, targetWindow, targetWindowResized]);
      var async = useAsync();
      useOnEvent(targetWindow, "resize", async.debounce(function() {
        setTargetWindowResized(true);
      }, 500, { leading: true }));
      return getBounds;
    }
    function useMaxHeight(_a2, getBounds, positions) {
      var _b;
      var calloutMaxHeight = _a2.calloutMaxHeight, finalHeight = _a2.finalHeight, directionalHint = _a2.directionalHint, directionalHintFixed = _a2.directionalHintFixed, hidden = _a2.hidden;
      var _c = reactExports.useState(), maxHeight = _c[0], setMaxHeight = _c[1];
      var _d = (_b = positions === null || positions === void 0 ? void 0 : positions.elementPosition) !== null && _b !== void 0 ? _b : {}, top = _d.top, bottom = _d.bottom;
      reactExports.useEffect(function() {
        var _a3;
        var _b2 = (_a3 = getBounds()) !== null && _a3 !== void 0 ? _a3 : {}, topBounds = _b2.top, bottomBounds = _b2.bottom;
        if (!calloutMaxHeight && !hidden) {
          if (typeof top === "number" && bottomBounds) {
            setMaxHeight(bottomBounds - top);
          } else if (typeof bottom === "number" && typeof topBounds === "number" && bottomBounds) {
            setMaxHeight(bottomBounds - topBounds - bottom);
          }
        } else if (calloutMaxHeight) {
          setMaxHeight(calloutMaxHeight);
        } else {
          setMaxHeight(void 0);
        }
      }, [bottom, calloutMaxHeight, finalHeight, directionalHint, directionalHintFixed, getBounds, hidden, positions, top]);
      return maxHeight;
    }
    function usePositions(props, hostElement, calloutElement, targetRef, getBounds) {
      var _a2 = reactExports.useState(), positions = _a2[0], setPositions = _a2[1];
      var positionAttempts = reactExports.useRef(0);
      var previousTarget = reactExports.useRef();
      var async = useAsync();
      var hidden = props.hidden, target = props.target, finalHeight = props.finalHeight, calloutMaxHeight = props.calloutMaxHeight, onPositioned = props.onPositioned, directionalHint = props.directionalHint;
      reactExports.useEffect(function() {
        if (!hidden) {
          var timerId_1 = async.requestAnimationFrame(function() {
            var _a3, _b;
            if (hostElement.current && calloutElement) {
              var currentProps = __assign$1(__assign$1({}, props), { target: targetRef.current, bounds: getBounds() });
              var dupeCalloutElement = calloutElement.cloneNode(true);
              dupeCalloutElement.style.maxHeight = calloutMaxHeight ? "" + calloutMaxHeight : "";
              dupeCalloutElement.style.visibility = "hidden";
              (_a3 = calloutElement.parentElement) === null || _a3 === void 0 ? void 0 : _a3.appendChild(dupeCalloutElement);
              var previousPositions = previousTarget.current === target ? positions : void 0;
              var newPositions = finalHeight ? positionCard(currentProps, hostElement.current, dupeCalloutElement, previousPositions) : positionCallout(currentProps, hostElement.current, dupeCalloutElement, previousPositions);
              (_b = calloutElement.parentElement) === null || _b === void 0 ? void 0 : _b.removeChild(dupeCalloutElement);
              if (!positions && newPositions || positions && newPositions && !arePositionsEqual(positions, newPositions) && positionAttempts.current < 5) {
                positionAttempts.current++;
                setPositions(newPositions);
              } else if (positionAttempts.current > 0) {
                positionAttempts.current = 0;
                onPositioned === null || onPositioned === void 0 ? void 0 : onPositioned(positions);
              }
            }
          }, calloutElement);
          previousTarget.current = target;
          return function() {
            async.cancelAnimationFrame(timerId_1);
            previousTarget.current = void 0;
          };
        } else {
          setPositions(void 0);
          positionAttempts.current = 0;
        }
      }, [
        hidden,
        directionalHint,
        async,
        calloutElement,
        calloutMaxHeight,
        hostElement,
        targetRef,
        finalHeight,
        getBounds,
        onPositioned,
        positions,
        props,
        target
      ]);
      return positions;
    }
    function useAutoFocus(_a2, positions, calloutElement) {
      var hidden = _a2.hidden, setInitialFocus = _a2.setInitialFocus;
      var async = useAsync();
      var hasPositions = !!positions;
      reactExports.useEffect(function() {
        if (!hidden && setInitialFocus && hasPositions && calloutElement) {
          var timerId_2 = async.requestAnimationFrame(function() {
            return focusFirstChild(calloutElement);
          }, calloutElement);
          return function() {
            return async.cancelAnimationFrame(timerId_2);
          };
        }
      }, [hidden, hasPositions, async, calloutElement, setInitialFocus]);
    }
    function useDismissHandlers(_a2, positions, hostElement, targetRef, targetWindow) {
      var hidden = _a2.hidden, onDismiss = _a2.onDismiss, preventDismissOnScroll = _a2.preventDismissOnScroll, preventDismissOnResize = _a2.preventDismissOnResize, preventDismissOnLostFocus = _a2.preventDismissOnLostFocus, dismissOnTargetClick = _a2.dismissOnTargetClick, shouldDismissOnWindowFocus = _a2.shouldDismissOnWindowFocus, preventDismissOnEvent = _a2.preventDismissOnEvent;
      var isMouseDownOnPopup = reactExports.useRef(false);
      var async = useAsync();
      var mouseDownHandlers = useConst([
        function() {
          isMouseDownOnPopup.current = true;
        },
        function() {
          isMouseDownOnPopup.current = false;
        }
      ]);
      var positionsExists = !!positions;
      reactExports.useEffect(function() {
        var dismissOnScroll = function(ev) {
          if (positionsExists && !preventDismissOnScroll) {
            dismissOnClickOrScroll(ev);
          }
        };
        var dismissOnResize = function(ev) {
          if (!preventDismissOnResize && !(preventDismissOnEvent && preventDismissOnEvent(ev))) {
            onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(ev);
          }
        };
        var dismissOnLostFocus = function(ev) {
          if (!preventDismissOnLostFocus) {
            dismissOnClickOrScroll(ev);
          }
        };
        var dismissOnClickOrScroll = function(ev) {
          var eventPaths = ev.composedPath ? ev.composedPath() : [];
          var target = eventPaths.length > 0 ? eventPaths[0] : ev.target;
          var isEventTargetOutsideCallout = hostElement.current && !elementContains$1(hostElement.current, target);
          if (isEventTargetOutsideCallout && isMouseDownOnPopup.current) {
            isMouseDownOnPopup.current = false;
            return;
          }
          if (!targetRef.current && isEventTargetOutsideCallout || ev.target !== targetWindow && isEventTargetOutsideCallout && (!targetRef.current || "stopPropagation" in targetRef.current || dismissOnTargetClick || target !== targetRef.current && !elementContains$1(targetRef.current, target))) {
            if (preventDismissOnEvent && preventDismissOnEvent(ev)) {
              return;
            }
            onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(ev);
          }
        };
        var dismissOnTargetWindowBlur = function(ev) {
          if (!shouldDismissOnWindowFocus) {
            return;
          }
          if ((preventDismissOnEvent && !preventDismissOnEvent(ev) || !preventDismissOnEvent && !preventDismissOnLostFocus) && !(targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.hasFocus()) && ev.relatedTarget === null) {
            onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(ev);
          }
        };
        var disposablesPromise = new Promise(function(resolve) {
          async.setTimeout(function() {
            if (!hidden && targetWindow) {
              var disposables_1 = [
                on(targetWindow, "scroll", dismissOnScroll, true),
                on(targetWindow, "resize", dismissOnResize, true),
                on(targetWindow.document.documentElement, "focus", dismissOnLostFocus, true),
                on(targetWindow.document.documentElement, "click", dismissOnLostFocus, true),
                on(targetWindow, "blur", dismissOnTargetWindowBlur, true)
              ];
              resolve(function() {
                disposables_1.forEach(function(dispose) {
                  return dispose();
                });
              });
            }
          }, 0);
        });
        return function() {
          disposablesPromise.then(function(dispose) {
            return dispose();
          });
        };
      }, [
        hidden,
        async,
        hostElement,
        targetRef,
        targetWindow,
        onDismiss,
        shouldDismissOnWindowFocus,
        dismissOnTargetClick,
        preventDismissOnLostFocus,
        preventDismissOnResize,
        preventDismissOnScroll,
        positionsExists,
        preventDismissOnEvent
      ]);
      return mouseDownHandlers;
    }
    var CalloutContentBase = reactExports.memo(reactExports.forwardRef(function(propsWithoutDefaults, forwardedRef) {
      var props = getPropsWithDefaults(DEFAULT_PROPS$1, propsWithoutDefaults);
      var styles2 = props.styles, style2 = props.style, ariaLabel = props.ariaLabel, ariaDescribedBy = props.ariaDescribedBy, ariaLabelledBy = props.ariaLabelledBy, className = props.className, isBeakVisible = props.isBeakVisible, children = props.children, beakWidth = props.beakWidth, calloutWidth = props.calloutWidth, calloutMaxWidth = props.calloutMaxWidth, calloutMinWidth = props.calloutMinWidth, doNotLayer = props.doNotLayer, finalHeight = props.finalHeight, _a2 = props.hideOverflow, hideOverflow = _a2 === void 0 ? !!finalHeight : _a2, backgroundColor = props.backgroundColor, calloutMaxHeight = props.calloutMaxHeight, onScroll = props.onScroll, _b = props.shouldRestoreFocus, shouldRestoreFocus = _b === void 0 ? true : _b, target = props.target, hidden = props.hidden, onLayerMounted = props.onLayerMounted;
      var hostElement = reactExports.useRef(null);
      var _c = reactExports.useState(null), calloutElement = _c[0], setCalloutElement = _c[1];
      var calloutCallback = reactExports.useCallback(function(calloutEl) {
        setCalloutElement(calloutEl);
      }, []);
      var rootRef = useMergedRefs$1(hostElement, forwardedRef);
      var _d = useTarget(props.target, {
        current: calloutElement
      }), targetRef = _d[0], targetWindow = _d[1];
      var getBounds = useBounds(props, targetRef, targetWindow);
      var positions = usePositions(props, hostElement, calloutElement, targetRef, getBounds);
      var maxHeight = useMaxHeight(props, getBounds, positions);
      var _e = useDismissHandlers(props, positions, hostElement, targetRef, targetWindow), mouseDownOnPopup = _e[0], mouseUpOnPopup = _e[1];
      var isForcedInBounds = (positions === null || positions === void 0 ? void 0 : positions.elementPosition.top) && (positions === null || positions === void 0 ? void 0 : positions.elementPosition.bottom);
      var cssPositions = __assign$1(__assign$1({}, positions === null || positions === void 0 ? void 0 : positions.elementPosition), { maxHeight });
      if (isForcedInBounds) {
        cssPositions.bottom = void 0;
      }
      useAutoFocus(props, positions, calloutElement);
      reactExports.useEffect(function() {
        if (!hidden) {
          onLayerMounted === null || onLayerMounted === void 0 ? void 0 : onLayerMounted();
        }
      }, [hidden]);
      if (!targetWindow) {
        return null;
      }
      var overflowYHidden = hideOverflow;
      var beakVisible = isBeakVisible && !!target;
      var classNames2 = getClassNames$7(styles2, {
        theme: props.theme,
        className,
        overflowYHidden,
        calloutWidth,
        positions,
        beakWidth,
        backgroundColor,
        calloutMaxWidth,
        calloutMinWidth,
        doNotLayer
      });
      var overflowStyle = __assign$1(__assign$1({ maxHeight: calloutMaxHeight ? calloutMaxHeight : "100%" }, style2), overflowYHidden && { overflowY: "hidden" });
      var visibilityStyle = props.hidden ? { visibility: "hidden" } : void 0;
      return reactExports.createElement(
        "div",
        { ref: rootRef, className: classNames2.container, style: visibilityStyle },
        reactExports.createElement(
          "div",
          __assign$1({}, getNativeProps$1(props, divProperties, ARIA_ROLE_ATTRIBUTES), {
            className: css$1(classNames2.root, positions && positions.targetEdge && ANIMATIONS[positions.targetEdge]),
            style: positions ? __assign$1({}, cssPositions) : OFF_SCREEN_STYLE,
            // Safari and Firefox on Mac OS requires this to back-stop click events so focus remains in the Callout.
            // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus
            tabIndex: -1,
            ref: calloutCallback
          }),
          beakVisible && reactExports.createElement("div", { className: classNames2.beak, style: getBeakPosition(positions) }),
          beakVisible && reactExports.createElement("div", { className: classNames2.beakCurtain }),
          reactExports.createElement(
            Popup,
            {
              // don't use getNativeElementProps for role and roledescription because it will also
              // pass through data-* props (resulting in them being used in two places)
              role: props.role,
              "aria-roledescription": props["aria-roledescription"],
              ariaDescribedBy,
              ariaLabel,
              ariaLabelledBy,
              className: classNames2.calloutMain,
              onDismiss: props.onDismiss,
              onMouseDown: mouseDownOnPopup,
              onMouseUp: mouseUpOnPopup,
              onRestoreFocus: props.onRestoreFocus,
              onScroll,
              shouldRestoreFocus,
              style: overflowStyle
            },
            children
          )
        )
      );
    }), function(previousProps, nextProps) {
      if (!nextProps.shouldUpdateWhenHidden && previousProps.hidden && nextProps.hidden) {
        return true;
      }
      return shallowCompare(previousProps, nextProps);
    });
    function getBeakPosition(positions) {
      var _a2, _b;
      var beakPositionStyle = __assign$1(__assign$1({}, (_a2 = positions === null || positions === void 0 ? void 0 : positions.beakPosition) === null || _a2 === void 0 ? void 0 : _a2.elementPosition), { display: ((_b = positions === null || positions === void 0 ? void 0 : positions.beakPosition) === null || _b === void 0 ? void 0 : _b.hideBeak) ? "none" : void 0 });
      if (!beakPositionStyle.top && !beakPositionStyle.bottom && !beakPositionStyle.left && !beakPositionStyle.right) {
        beakPositionStyle.left = BEAK_ORIGIN_POSITION.left;
        beakPositionStyle.top = BEAK_ORIGIN_POSITION.top;
      }
      return beakPositionStyle;
    }
    function arePositionsEqual(prevElementPositions, newElementPosition) {
      return comparePositions(prevElementPositions.elementPosition, newElementPosition.elementPosition) && comparePositions(prevElementPositions.beakPosition.elementPosition, newElementPosition.beakPosition.elementPosition);
    }
    function comparePositions(prevElementPositions, newElementPositions) {
      for (var key in newElementPositions) {
        if (newElementPositions.hasOwnProperty(key)) {
          var oldPositionEdge = prevElementPositions[key];
          var newPositionEdge = newElementPositions[key];
          if (oldPositionEdge !== void 0 && newPositionEdge !== void 0) {
            if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {
              return false;
            }
          } else {
            return false;
          }
        }
      }
      return true;
    }
    CalloutContentBase.displayName = COMPONENT_NAME$2;
    function getBeakStyle(beakWidth) {
      return {
        height: beakWidth,
        width: beakWidth
      };
    }
    var GlobalClassNames$8 = {
      container: "ms-Callout-container",
      root: "ms-Callout",
      beak: "ms-Callout-beak",
      beakCurtain: "ms-Callout-beakCurtain",
      calloutMain: "ms-Callout-main"
    };
    var getStyles$9 = function(props) {
      var _a2;
      var theme = props.theme, className = props.className, overflowYHidden = props.overflowYHidden, calloutWidth = props.calloutWidth, beakWidth = props.beakWidth, backgroundColor = props.backgroundColor, calloutMaxWidth = props.calloutMaxWidth, calloutMinWidth = props.calloutMinWidth, doNotLayer = props.doNotLayer;
      var classNames2 = getGlobalClassNames(GlobalClassNames$8, theme);
      var semanticColors = theme.semanticColors, effects = theme.effects;
      return {
        container: [
          classNames2.container,
          {
            position: "relative"
          }
        ],
        root: [
          classNames2.root,
          theme.fonts.medium,
          {
            position: "absolute",
            display: "flex",
            zIndex: doNotLayer ? ZIndexes.Layer : void 0,
            boxSizing: "border-box",
            borderRadius: effects.roundedCorner2,
            boxShadow: effects.elevation16,
            selectors: (_a2 = {}, _a2[HighContrastSelector] = {
              borderWidth: 1,
              borderStyle: "solid",
              borderColor: "WindowText"
            }, _a2)
          },
          focusClear(),
          className,
          !!calloutWidth && { width: calloutWidth },
          !!calloutMaxWidth && { maxWidth: calloutMaxWidth },
          !!calloutMinWidth && { minWidth: calloutMinWidth }
        ],
        beak: [
          classNames2.beak,
          {
            position: "absolute",
            backgroundColor: semanticColors.menuBackground,
            boxShadow: "inherit",
            border: "inherit",
            boxSizing: "border-box",
            transform: "rotate(45deg)"
          },
          getBeakStyle(beakWidth),
          backgroundColor && {
            backgroundColor
          }
        ],
        beakCurtain: [
          classNames2.beakCurtain,
          {
            position: "absolute",
            top: 0,
            right: 0,
            bottom: 0,
            left: 0,
            backgroundColor: semanticColors.menuBackground,
            borderRadius: effects.roundedCorner2
          }
        ],
        calloutMain: [
          classNames2.calloutMain,
          {
            backgroundColor: semanticColors.menuBackground,
            overflowX: "hidden",
            overflowY: "auto",
            position: "relative",
            width: "100%",
            borderRadius: effects.roundedCorner2
          },
          overflowYHidden && {
            overflowY: "hidden"
          },
          backgroundColor && {
            backgroundColor
          }
        ]
      };
    };
    var CalloutContent = styled(CalloutContentBase, getStyles$9, void 0, {
      scope: "CalloutContent"
    });
    var reactDom = { exports: {} };
    var reactDom_production_min = {};
    var scheduler = { exports: {} };
    var scheduler_production_min = {};
    /** @license React v0.20.2
     * scheduler.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    (function(exports2) {
      var f2, g2, h2, k2;
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var l2 = performance;
        exports2.unstable_now = function() {
          return l2.now();
        };
      } else {
        var p2 = Date, q2 = p2.now();
        exports2.unstable_now = function() {
          return p2.now() - q2;
        };
      }
      if ("undefined" === typeof window || "function" !== typeof MessageChannel) {
        var t2 = null, u2 = null, w2 = function() {
          if (null !== t2)
            try {
              var a2 = exports2.unstable_now();
              t2(true, a2);
              t2 = null;
            } catch (b2) {
              throw setTimeout(w2, 0), b2;
            }
        };
        f2 = function(a2) {
          null !== t2 ? setTimeout(f2, 0, a2) : (t2 = a2, setTimeout(w2, 0));
        };
        g2 = function(a2, b2) {
          u2 = setTimeout(a2, b2);
        };
        h2 = function() {
          clearTimeout(u2);
        };
        exports2.unstable_shouldYield = function() {
          return false;
        };
        k2 = exports2.unstable_forceFrameRate = function() {
        };
      } else {
        var x2 = window.setTimeout, y2 = window.clearTimeout;
        if ("undefined" !== typeof console) {
          var z2 = window.cancelAnimationFrame;
          "function" !== typeof window.requestAnimationFrame && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
          "function" !== typeof z2 && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
        }
        var A2 = false, B2 = null, C2 = -1, D2 = 5, E2 = 0;
        exports2.unstable_shouldYield = function() {
          return exports2.unstable_now() >= E2;
        };
        k2 = function() {
        };
        exports2.unstable_forceFrameRate = function(a2) {
          0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : D2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
        };
        var F2 = new MessageChannel(), G2 = F2.port2;
        F2.port1.onmessage = function() {
          if (null !== B2) {
            var a2 = exports2.unstable_now();
            E2 = a2 + D2;
            try {
              B2(true, a2) ? G2.postMessage(null) : (A2 = false, B2 = null);
            } catch (b2) {
              throw G2.postMessage(null), b2;
            }
          } else
            A2 = false;
        };
        f2 = function(a2) {
          B2 = a2;
          A2 || (A2 = true, G2.postMessage(null));
        };
        g2 = function(a2, b2) {
          C2 = x2(function() {
            a2(exports2.unstable_now());
          }, b2);
        };
        h2 = function() {
          y2(C2);
          C2 = -1;
        };
      }
      function H2(a2, b2) {
        var c2 = a2.length;
        a2.push(b2);
        a:
          for (; ; ) {
            var d2 = c2 - 1 >>> 1, e2 = a2[d2];
            if (void 0 !== e2 && 0 < I2(e2, b2))
              a2[d2] = b2, a2[c2] = e2, c2 = d2;
            else
              break a;
          }
      }
      function J2(a2) {
        a2 = a2[0];
        return void 0 === a2 ? null : a2;
      }
      function K2(a2) {
        var b2 = a2[0];
        if (void 0 !== b2) {
          var c2 = a2.pop();
          if (c2 !== b2) {
            a2[0] = c2;
            a:
              for (var d2 = 0, e2 = a2.length; d2 < e2; ) {
                var m2 = 2 * (d2 + 1) - 1, n2 = a2[m2], v2 = m2 + 1, r2 = a2[v2];
                if (void 0 !== n2 && 0 > I2(n2, c2))
                  void 0 !== r2 && 0 > I2(r2, n2) ? (a2[d2] = r2, a2[v2] = c2, d2 = v2) : (a2[d2] = n2, a2[m2] = c2, d2 = m2);
                else if (void 0 !== r2 && 0 > I2(r2, c2))
                  a2[d2] = r2, a2[v2] = c2, d2 = v2;
                else
                  break a;
              }
          }
          return b2;
        }
        return null;
      }
      function I2(a2, b2) {
        var c2 = a2.sortIndex - b2.sortIndex;
        return 0 !== c2 ? c2 : a2.id - b2.id;
      }
      var L2 = [], M2 = [], N2 = 1, O2 = null, P2 = 3, Q2 = false, R2 = false, S2 = false;
      function T2(a2) {
        for (var b2 = J2(M2); null !== b2; ) {
          if (null === b2.callback)
            K2(M2);
          else if (b2.startTime <= a2)
            K2(M2), b2.sortIndex = b2.expirationTime, H2(L2, b2);
          else
            break;
          b2 = J2(M2);
        }
      }
      function U2(a2) {
        S2 = false;
        T2(a2);
        if (!R2)
          if (null !== J2(L2))
            R2 = true, f2(V2);
          else {
            var b2 = J2(M2);
            null !== b2 && g2(U2, b2.startTime - a2);
          }
      }
      function V2(a2, b2) {
        R2 = false;
        S2 && (S2 = false, h2());
        Q2 = true;
        var c2 = P2;
        try {
          T2(b2);
          for (O2 = J2(L2); null !== O2 && (!(O2.expirationTime > b2) || a2 && !exports2.unstable_shouldYield()); ) {
            var d2 = O2.callback;
            if ("function" === typeof d2) {
              O2.callback = null;
              P2 = O2.priorityLevel;
              var e2 = d2(O2.expirationTime <= b2);
              b2 = exports2.unstable_now();
              "function" === typeof e2 ? O2.callback = e2 : O2 === J2(L2) && K2(L2);
              T2(b2);
            } else
              K2(L2);
            O2 = J2(L2);
          }
          if (null !== O2)
            var m2 = true;
          else {
            var n2 = J2(M2);
            null !== n2 && g2(U2, n2.startTime - b2);
            m2 = false;
          }
          return m2;
        } finally {
          O2 = null, P2 = c2, Q2 = false;
        }
      }
      var W2 = k2;
      exports2.unstable_IdlePriority = 5;
      exports2.unstable_ImmediatePriority = 1;
      exports2.unstable_LowPriority = 4;
      exports2.unstable_NormalPriority = 3;
      exports2.unstable_Profiling = null;
      exports2.unstable_UserBlockingPriority = 2;
      exports2.unstable_cancelCallback = function(a2) {
        a2.callback = null;
      };
      exports2.unstable_continueExecution = function() {
        R2 || Q2 || (R2 = true, f2(V2));
      };
      exports2.unstable_getCurrentPriorityLevel = function() {
        return P2;
      };
      exports2.unstable_getFirstCallbackNode = function() {
        return J2(L2);
      };
      exports2.unstable_next = function(a2) {
        switch (P2) {
          case 1:
          case 2:
          case 3:
            var b2 = 3;
            break;
          default:
            b2 = P2;
        }
        var c2 = P2;
        P2 = b2;
        try {
          return a2();
        } finally {
          P2 = c2;
        }
      };
      exports2.unstable_pauseExecution = function() {
      };
      exports2.unstable_requestPaint = W2;
      exports2.unstable_runWithPriority = function(a2, b2) {
        switch (a2) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            a2 = 3;
        }
        var c2 = P2;
        P2 = a2;
        try {
          return b2();
        } finally {
          P2 = c2;
        }
      };
      exports2.unstable_scheduleCallback = function(a2, b2, c2) {
        var d2 = exports2.unstable_now();
        "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
        switch (a2) {
          case 1:
            var e2 = -1;
            break;
          case 2:
            e2 = 250;
            break;
          case 5:
            e2 = 1073741823;
            break;
          case 4:
            e2 = 1e4;
            break;
          default:
            e2 = 5e3;
        }
        e2 = c2 + e2;
        a2 = { id: N2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 };
        c2 > d2 ? (a2.sortIndex = c2, H2(M2, a2), null === J2(L2) && a2 === J2(M2) && (S2 ? h2() : S2 = true, g2(U2, c2 - d2))) : (a2.sortIndex = e2, H2(L2, a2), R2 || Q2 || (R2 = true, f2(V2)));
        return a2;
      };
      exports2.unstable_wrapCallback = function(a2) {
        var b2 = P2;
        return function() {
          var c2 = P2;
          P2 = b2;
          try {
            return a2.apply(this, arguments);
          } finally {
            P2 = c2;
          }
        };
      };
    })(scheduler_production_min);
    {
      scheduler.exports = scheduler_production_min;
    }
    var schedulerExports = scheduler.exports;
    /** @license React v17.0.2
     * react-dom.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var aa = reactExports, m$4 = objectAssign, r$5 = schedulerExports;
    function y$2(a2) {
      for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
        b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
      return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    if (!aa)
      throw Error(y$2(227));
    var ba = /* @__PURE__ */ new Set(), ca = {};
    function da(a2, b2) {
      ea(a2, b2);
      ea(a2 + "Capture", b2);
    }
    function ea(a2, b2) {
      ca[a2] = b2;
      for (a2 = 0; a2 < b2.length; a2++)
        ba.add(b2[a2]);
    }
    var fa = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ha = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, ia = Object.prototype.hasOwnProperty, ja = {}, ka = {};
    function la(a2) {
      if (ia.call(ka, a2))
        return true;
      if (ia.call(ja, a2))
        return false;
      if (ha.test(a2))
        return ka[a2] = true;
      ja[a2] = true;
      return false;
    }
    function ma(a2, b2, c2, d2) {
      if (null !== c2 && 0 === c2.type)
        return false;
      switch (typeof b2) {
        case "function":
        case "symbol":
          return true;
        case "boolean":
          if (d2)
            return false;
          if (null !== c2)
            return !c2.acceptsBooleans;
          a2 = a2.toLowerCase().slice(0, 5);
          return "data-" !== a2 && "aria-" !== a2;
        default:
          return false;
      }
    }
    function na(a2, b2, c2, d2) {
      if (null === b2 || "undefined" === typeof b2 || ma(a2, b2, c2, d2))
        return true;
      if (d2)
        return false;
      if (null !== c2)
        switch (c2.type) {
          case 3:
            return !b2;
          case 4:
            return false === b2;
          case 5:
            return isNaN(b2);
          case 6:
            return isNaN(b2) || 1 > b2;
        }
      return false;
    }
    function B$1(a2, b2, c2, d2, e2, f2, g2) {
      this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
      this.attributeName = d2;
      this.attributeNamespace = e2;
      this.mustUseProperty = c2;
      this.propertyName = a2;
      this.type = b2;
      this.sanitizeURL = f2;
      this.removeEmptyString = g2;
    }
    var D$2 = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
      D$2[a2] = new B$1(a2, 0, false, a2, null, false, false);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
      var b2 = a2[0];
      D$2[b2] = new B$1(b2, 1, false, a2[1], null, false, false);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
      D$2[a2] = new B$1(a2, 2, false, a2.toLowerCase(), null, false, false);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
      D$2[a2] = new B$1(a2, 2, false, a2, null, false, false);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
      D$2[a2] = new B$1(a2, 3, false, a2.toLowerCase(), null, false, false);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a2) {
      D$2[a2] = new B$1(a2, 3, true, a2, null, false, false);
    });
    ["capture", "download"].forEach(function(a2) {
      D$2[a2] = new B$1(a2, 4, false, a2, null, false, false);
    });
    ["cols", "rows", "size", "span"].forEach(function(a2) {
      D$2[a2] = new B$1(a2, 6, false, a2, null, false, false);
    });
    ["rowSpan", "start"].forEach(function(a2) {
      D$2[a2] = new B$1(a2, 5, false, a2.toLowerCase(), null, false, false);
    });
    var oa = /[\-:]([a-z])/g;
    function pa(a2) {
      return a2[1].toUpperCase();
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
      var b2 = a2.replace(
        oa,
        pa
      );
      D$2[b2] = new B$1(b2, 1, false, a2, null, false, false);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
      var b2 = a2.replace(oa, pa);
      D$2[b2] = new B$1(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
      var b2 = a2.replace(oa, pa);
      D$2[b2] = new B$1(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a2) {
      D$2[a2] = new B$1(a2, 1, false, a2.toLowerCase(), null, false, false);
    });
    D$2.xlinkHref = new B$1("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
    ["src", "href", "action", "formAction"].forEach(function(a2) {
      D$2[a2] = new B$1(a2, 1, false, a2.toLowerCase(), null, true, true);
    });
    function qa(a2, b2, c2, d2) {
      var e2 = D$2.hasOwnProperty(b2) ? D$2[b2] : null;
      var f2 = null !== e2 ? 0 === e2.type : d2 ? false : !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1] ? false : true;
      f2 || (na(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? la(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2))));
    }
    var ra = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, sa = 60103, ta = 60106, ua = 60107, wa = 60108, xa = 60114, ya = 60109, za = 60110, Aa = 60112, Ba = 60113, Ca = 60120, Da = 60115, Ea = 60116, Fa = 60121, Ga = 60128, Ha = 60129, Ia = 60130, Ja = 60131;
    if ("function" === typeof Symbol && Symbol.for) {
      var E$1 = Symbol.for;
      sa = E$1("react.element");
      ta = E$1("react.portal");
      ua = E$1("react.fragment");
      wa = E$1("react.strict_mode");
      xa = E$1("react.profiler");
      ya = E$1("react.provider");
      za = E$1("react.context");
      Aa = E$1("react.forward_ref");
      Ba = E$1("react.suspense");
      Ca = E$1("react.suspense_list");
      Da = E$1("react.memo");
      Ea = E$1("react.lazy");
      Fa = E$1("react.block");
      E$1("react.scope");
      Ga = E$1("react.opaque.id");
      Ha = E$1("react.debug_trace_mode");
      Ia = E$1("react.offscreen");
      Ja = E$1("react.legacy_hidden");
    }
    var Ka = "function" === typeof Symbol && Symbol.iterator;
    function La(a2) {
      if (null === a2 || "object" !== typeof a2)
        return null;
      a2 = Ka && a2[Ka] || a2["@@iterator"];
      return "function" === typeof a2 ? a2 : null;
    }
    var Ma;
    function Na(a2) {
      if (void 0 === Ma)
        try {
          throw Error();
        } catch (c2) {
          var b2 = c2.stack.trim().match(/\n( *(at )?)/);
          Ma = b2 && b2[1] || "";
        }
      return "\n" + Ma + a2;
    }
    var Oa = false;
    function Pa(a2, b2) {
      if (!a2 || Oa)
        return "";
      Oa = true;
      var c2 = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (b2)
          if (b2 = function() {
            throw Error();
          }, Object.defineProperty(b2.prototype, "props", { set: function() {
            throw Error();
          } }), "object" === typeof Reflect && Reflect.construct) {
            try {
              Reflect.construct(b2, []);
            } catch (k2) {
              var d2 = k2;
            }
            Reflect.construct(a2, [], b2);
          } else {
            try {
              b2.call();
            } catch (k2) {
              d2 = k2;
            }
            a2.call(b2.prototype);
          }
        else {
          try {
            throw Error();
          } catch (k2) {
            d2 = k2;
          }
          a2();
        }
      } catch (k2) {
        if (k2 && d2 && "string" === typeof k2.stack) {
          for (var e2 = k2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
            h2--;
          for (; 1 <= g2 && 0 <= h2; g2--, h2--)
            if (e2[g2] !== f2[h2]) {
              if (1 !== g2 || 1 !== h2) {
                do
                  if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2])
                    return "\n" + e2[g2].replace(" at new ", " at ");
                while (1 <= g2 && 0 <= h2);
              }
              break;
            }
        }
      } finally {
        Oa = false, Error.prepareStackTrace = c2;
      }
      return (a2 = a2 ? a2.displayName || a2.name : "") ? Na(a2) : "";
    }
    function Qa(a2) {
      switch (a2.tag) {
        case 5:
          return Na(a2.type);
        case 16:
          return Na("Lazy");
        case 13:
          return Na("Suspense");
        case 19:
          return Na("SuspenseList");
        case 0:
        case 2:
        case 15:
          return a2 = Pa(a2.type, false), a2;
        case 11:
          return a2 = Pa(a2.type.render, false), a2;
        case 22:
          return a2 = Pa(a2.type._render, false), a2;
        case 1:
          return a2 = Pa(a2.type, true), a2;
        default:
          return "";
      }
    }
    function Ra(a2) {
      if (null == a2)
        return null;
      if ("function" === typeof a2)
        return a2.displayName || a2.name || null;
      if ("string" === typeof a2)
        return a2;
      switch (a2) {
        case ua:
          return "Fragment";
        case ta:
          return "Portal";
        case xa:
          return "Profiler";
        case wa:
          return "StrictMode";
        case Ba:
          return "Suspense";
        case Ca:
          return "SuspenseList";
      }
      if ("object" === typeof a2)
        switch (a2.$$typeof) {
          case za:
            return (a2.displayName || "Context") + ".Consumer";
          case ya:
            return (a2._context.displayName || "Context") + ".Provider";
          case Aa:
            var b2 = a2.render;
            b2 = b2.displayName || b2.name || "";
            return a2.displayName || ("" !== b2 ? "ForwardRef(" + b2 + ")" : "ForwardRef");
          case Da:
            return Ra(a2.type);
          case Fa:
            return Ra(a2._render);
          case Ea:
            b2 = a2._payload;
            a2 = a2._init;
            try {
              return Ra(a2(b2));
            } catch (c2) {
            }
        }
      return null;
    }
    function Sa(a2) {
      switch (typeof a2) {
        case "boolean":
        case "number":
        case "object":
        case "string":
        case "undefined":
          return a2;
        default:
          return "";
      }
    }
    function Ta(a2) {
      var b2 = a2.type;
      return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
    }
    function Ua(a2) {
      var b2 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
      if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
        var e2 = c2.get, f2 = c2.set;
        Object.defineProperty(a2, b2, { configurable: true, get: function() {
          return e2.call(this);
        }, set: function(a3) {
          d2 = "" + a3;
          f2.call(this, a3);
        } });
        Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
        return { getValue: function() {
          return d2;
        }, setValue: function(a3) {
          d2 = "" + a3;
        }, stopTracking: function() {
          a2._valueTracker = null;
          delete a2[b2];
        } };
      }
    }
    function Va(a2) {
      a2._valueTracker || (a2._valueTracker = Ua(a2));
    }
    function Wa(a2) {
      if (!a2)
        return false;
      var b2 = a2._valueTracker;
      if (!b2)
        return true;
      var c2 = b2.getValue();
      var d2 = "";
      a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
      a2 = d2;
      return a2 !== c2 ? (b2.setValue(a2), true) : false;
    }
    function Xa(a2) {
      a2 = a2 || ("undefined" !== typeof document ? document : void 0);
      if ("undefined" === typeof a2)
        return null;
      try {
        return a2.activeElement || a2.body;
      } catch (b2) {
        return a2.body;
      }
    }
    function Ya(a2, b2) {
      var c2 = b2.checked;
      return m$4({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
    }
    function Za(a2, b2) {
      var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
      c2 = Sa(null != b2.value ? b2.value : c2);
      a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
    }
    function $a(a2, b2) {
      b2 = b2.checked;
      null != b2 && qa(a2, "checked", b2, false);
    }
    function ab(a2, b2) {
      $a(a2, b2);
      var c2 = Sa(b2.value), d2 = b2.type;
      if (null != c2)
        if ("number" === d2) {
          if (0 === c2 && "" === a2.value || a2.value != c2)
            a2.value = "" + c2;
        } else
          a2.value !== "" + c2 && (a2.value = "" + c2);
      else if ("submit" === d2 || "reset" === d2) {
        a2.removeAttribute("value");
        return;
      }
      b2.hasOwnProperty("value") ? bb(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && bb(a2, b2.type, Sa(b2.defaultValue));
      null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
    }
    function cb(a2, b2, c2) {
      if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
        var d2 = b2.type;
        if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
          return;
        b2 = "" + a2._wrapperState.initialValue;
        c2 || b2 === a2.value || (a2.value = b2);
        a2.defaultValue = b2;
      }
      c2 = a2.name;
      "" !== c2 && (a2.name = "");
      a2.defaultChecked = !!a2._wrapperState.initialChecked;
      "" !== c2 && (a2.name = c2);
    }
    function bb(a2, b2, c2) {
      if ("number" !== b2 || Xa(a2.ownerDocument) !== a2)
        null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
    }
    function db(a2) {
      var b2 = "";
      aa.Children.forEach(a2, function(a3) {
        null != a3 && (b2 += a3);
      });
      return b2;
    }
    function eb(a2, b2) {
      a2 = m$4({ children: void 0 }, b2);
      if (b2 = db(b2.children))
        a2.children = b2;
      return a2;
    }
    function fb(a2, b2, c2, d2) {
      a2 = a2.options;
      if (b2) {
        b2 = {};
        for (var e2 = 0; e2 < c2.length; e2++)
          b2["$" + c2[e2]] = true;
        for (c2 = 0; c2 < a2.length; c2++)
          e2 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d2 && (a2[c2].defaultSelected = true);
      } else {
        c2 = "" + Sa(c2);
        b2 = null;
        for (e2 = 0; e2 < a2.length; e2++) {
          if (a2[e2].value === c2) {
            a2[e2].selected = true;
            d2 && (a2[e2].defaultSelected = true);
            return;
          }
          null !== b2 || a2[e2].disabled || (b2 = a2[e2]);
        }
        null !== b2 && (b2.selected = true);
      }
    }
    function gb(a2, b2) {
      if (null != b2.dangerouslySetInnerHTML)
        throw Error(y$2(91));
      return m$4({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
    }
    function hb(a2, b2) {
      var c2 = b2.value;
      if (null == c2) {
        c2 = b2.children;
        b2 = b2.defaultValue;
        if (null != c2) {
          if (null != b2)
            throw Error(y$2(92));
          if (Array.isArray(c2)) {
            if (!(1 >= c2.length))
              throw Error(y$2(93));
            c2 = c2[0];
          }
          b2 = c2;
        }
        null == b2 && (b2 = "");
        c2 = b2;
      }
      a2._wrapperState = { initialValue: Sa(c2) };
    }
    function ib(a2, b2) {
      var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
      null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
      null != d2 && (a2.defaultValue = "" + d2);
    }
    function jb(a2) {
      var b2 = a2.textContent;
      b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
    }
    var kb = { html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg" };
    function lb(a2) {
      switch (a2) {
        case "svg":
          return "http://www.w3.org/2000/svg";
        case "math":
          return "http://www.w3.org/1998/Math/MathML";
        default:
          return "http://www.w3.org/1999/xhtml";
      }
    }
    function mb(a2, b2) {
      return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? lb(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
    }
    var nb, ob = function(a2) {
      return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
        MSApp.execUnsafeLocalFunction(function() {
          return a2(b2, c2, d2, e2);
        });
      } : a2;
    }(function(a2, b2) {
      if (a2.namespaceURI !== kb.svg || "innerHTML" in a2)
        a2.innerHTML = b2;
      else {
        nb = nb || document.createElement("div");
        nb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
        for (b2 = nb.firstChild; a2.firstChild; )
          a2.removeChild(a2.firstChild);
        for (; b2.firstChild; )
          a2.appendChild(b2.firstChild);
      }
    });
    function pb(a2, b2) {
      if (b2) {
        var c2 = a2.firstChild;
        if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
          c2.nodeValue = b2;
          return;
        }
      }
      a2.textContent = b2;
    }
    var qb = {
      animationIterationCount: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridArea: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true
    }, rb = ["Webkit", "ms", "Moz", "O"];
    Object.keys(qb).forEach(function(a2) {
      rb.forEach(function(b2) {
        b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
        qb[b2] = qb[a2];
      });
    });
    function sb(a2, b2, c2) {
      return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || qb.hasOwnProperty(a2) && qb[a2] ? ("" + b2).trim() : b2 + "px";
    }
    function tb(a2, b2) {
      a2 = a2.style;
      for (var c2 in b2)
        if (b2.hasOwnProperty(c2)) {
          var d2 = 0 === c2.indexOf("--"), e2 = sb(c2, b2[c2], d2);
          "float" === c2 && (c2 = "cssFloat");
          d2 ? a2.setProperty(c2, e2) : a2[c2] = e2;
        }
    }
    var ub = m$4({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
    function vb(a2, b2) {
      if (b2) {
        if (ub[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
          throw Error(y$2(137, a2));
        if (null != b2.dangerouslySetInnerHTML) {
          if (null != b2.children)
            throw Error(y$2(60));
          if (!("object" === typeof b2.dangerouslySetInnerHTML && "__html" in b2.dangerouslySetInnerHTML))
            throw Error(y$2(61));
        }
        if (null != b2.style && "object" !== typeof b2.style)
          throw Error(y$2(62));
      }
    }
    function wb(a2, b2) {
      if (-1 === a2.indexOf("-"))
        return "string" === typeof b2.is;
      switch (a2) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    function xb(a2) {
      a2 = a2.target || a2.srcElement || window;
      a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
      return 3 === a2.nodeType ? a2.parentNode : a2;
    }
    var yb = null, zb = null, Ab = null;
    function Bb(a2) {
      if (a2 = Cb(a2)) {
        if ("function" !== typeof yb)
          throw Error(y$2(280));
        var b2 = a2.stateNode;
        b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
      }
    }
    function Eb(a2) {
      zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
    }
    function Fb() {
      if (zb) {
        var a2 = zb, b2 = Ab;
        Ab = zb = null;
        Bb(a2);
        if (b2)
          for (a2 = 0; a2 < b2.length; a2++)
            Bb(b2[a2]);
      }
    }
    function Gb(a2, b2) {
      return a2(b2);
    }
    function Hb(a2, b2, c2, d2, e2) {
      return a2(b2, c2, d2, e2);
    }
    function Ib() {
    }
    var Jb = Gb, Kb = false, Lb = false;
    function Mb() {
      if (null !== zb || null !== Ab)
        Ib(), Fb();
    }
    function Nb(a2, b2, c2) {
      if (Lb)
        return a2(b2, c2);
      Lb = true;
      try {
        return Jb(a2, b2, c2);
      } finally {
        Lb = false, Mb();
      }
    }
    function Ob(a2, b2) {
      var c2 = a2.stateNode;
      if (null === c2)
        return null;
      var d2 = Db(c2);
      if (null === d2)
        return null;
      c2 = d2[b2];
      a:
        switch (b2) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
            a2 = !d2;
            break a;
          default:
            a2 = false;
        }
      if (a2)
        return null;
      if (c2 && "function" !== typeof c2)
        throw Error(y$2(231, b2, typeof c2));
      return c2;
    }
    var Pb = false;
    if (fa)
      try {
        var Qb = {};
        Object.defineProperty(Qb, "passive", { get: function() {
          Pb = true;
        } });
        window.addEventListener("test", Qb, Qb);
        window.removeEventListener("test", Qb, Qb);
      } catch (a2) {
        Pb = false;
      }
    function Rb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
      var l2 = Array.prototype.slice.call(arguments, 3);
      try {
        b2.apply(c2, l2);
      } catch (n2) {
        this.onError(n2);
      }
    }
    var Sb = false, Tb = null, Ub = false, Vb = null, Wb = { onError: function(a2) {
      Sb = true;
      Tb = a2;
    } };
    function Xb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
      Sb = false;
      Tb = null;
      Rb.apply(Wb, arguments);
    }
    function Yb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
      Xb.apply(this, arguments);
      if (Sb) {
        if (Sb) {
          var l2 = Tb;
          Sb = false;
          Tb = null;
        } else
          throw Error(y$2(198));
        Ub || (Ub = true, Vb = l2);
      }
    }
    function Zb(a2) {
      var b2 = a2, c2 = a2;
      if (a2.alternate)
        for (; b2.return; )
          b2 = b2.return;
      else {
        a2 = b2;
        do
          b2 = a2, 0 !== (b2.flags & 1026) && (c2 = b2.return), a2 = b2.return;
        while (a2);
      }
      return 3 === b2.tag ? c2 : null;
    }
    function $b(a2) {
      if (13 === a2.tag) {
        var b2 = a2.memoizedState;
        null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
        if (null !== b2)
          return b2.dehydrated;
      }
      return null;
    }
    function ac(a2) {
      if (Zb(a2) !== a2)
        throw Error(y$2(188));
    }
    function bc(a2) {
      var b2 = a2.alternate;
      if (!b2) {
        b2 = Zb(a2);
        if (null === b2)
          throw Error(y$2(188));
        return b2 !== a2 ? null : a2;
      }
      for (var c2 = a2, d2 = b2; ; ) {
        var e2 = c2.return;
        if (null === e2)
          break;
        var f2 = e2.alternate;
        if (null === f2) {
          d2 = e2.return;
          if (null !== d2) {
            c2 = d2;
            continue;
          }
          break;
        }
        if (e2.child === f2.child) {
          for (f2 = e2.child; f2; ) {
            if (f2 === c2)
              return ac(e2), a2;
            if (f2 === d2)
              return ac(e2), b2;
            f2 = f2.sibling;
          }
          throw Error(y$2(188));
        }
        if (c2.return !== d2.return)
          c2 = e2, d2 = f2;
        else {
          for (var g2 = false, h2 = e2.child; h2; ) {
            if (h2 === c2) {
              g2 = true;
              c2 = e2;
              d2 = f2;
              break;
            }
            if (h2 === d2) {
              g2 = true;
              d2 = e2;
              c2 = f2;
              break;
            }
            h2 = h2.sibling;
          }
          if (!g2) {
            for (h2 = f2.child; h2; ) {
              if (h2 === c2) {
                g2 = true;
                c2 = f2;
                d2 = e2;
                break;
              }
              if (h2 === d2) {
                g2 = true;
                d2 = f2;
                c2 = e2;
                break;
              }
              h2 = h2.sibling;
            }
            if (!g2)
              throw Error(y$2(189));
          }
        }
        if (c2.alternate !== d2)
          throw Error(y$2(190));
      }
      if (3 !== c2.tag)
        throw Error(y$2(188));
      return c2.stateNode.current === c2 ? a2 : b2;
    }
    function cc(a2) {
      a2 = bc(a2);
      if (!a2)
        return null;
      for (var b2 = a2; ; ) {
        if (5 === b2.tag || 6 === b2.tag)
          return b2;
        if (b2.child)
          b2.child.return = b2, b2 = b2.child;
        else {
          if (b2 === a2)
            break;
          for (; !b2.sibling; ) {
            if (!b2.return || b2.return === a2)
              return null;
            b2 = b2.return;
          }
          b2.sibling.return = b2.return;
          b2 = b2.sibling;
        }
      }
      return null;
    }
    function dc(a2, b2) {
      for (var c2 = a2.alternate; null !== b2; ) {
        if (b2 === a2 || b2 === c2)
          return true;
        b2 = b2.return;
      }
      return false;
    }
    var ec, fc, gc, hc, ic = false, jc = [], kc = null, lc = null, mc = null, nc = /* @__PURE__ */ new Map(), oc = /* @__PURE__ */ new Map(), pc = [], qc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
    function rc(a2, b2, c2, d2, e2) {
      return { blockedOn: a2, domEventName: b2, eventSystemFlags: c2 | 16, nativeEvent: e2, targetContainers: [d2] };
    }
    function sc(a2, b2) {
      switch (a2) {
        case "focusin":
        case "focusout":
          kc = null;
          break;
        case "dragenter":
        case "dragleave":
          lc = null;
          break;
        case "mouseover":
        case "mouseout":
          mc = null;
          break;
        case "pointerover":
        case "pointerout":
          nc.delete(b2.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          oc.delete(b2.pointerId);
      }
    }
    function tc(a2, b2, c2, d2, e2, f2) {
      if (null === a2 || a2.nativeEvent !== f2)
        return a2 = rc(b2, c2, d2, e2, f2), null !== b2 && (b2 = Cb(b2), null !== b2 && fc(b2)), a2;
      a2.eventSystemFlags |= d2;
      b2 = a2.targetContainers;
      null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
      return a2;
    }
    function uc(a2, b2, c2, d2, e2) {
      switch (b2) {
        case "focusin":
          return kc = tc(kc, a2, b2, c2, d2, e2), true;
        case "dragenter":
          return lc = tc(lc, a2, b2, c2, d2, e2), true;
        case "mouseover":
          return mc = tc(mc, a2, b2, c2, d2, e2), true;
        case "pointerover":
          var f2 = e2.pointerId;
          nc.set(f2, tc(nc.get(f2) || null, a2, b2, c2, d2, e2));
          return true;
        case "gotpointercapture":
          return f2 = e2.pointerId, oc.set(f2, tc(oc.get(f2) || null, a2, b2, c2, d2, e2)), true;
      }
      return false;
    }
    function vc(a2) {
      var b2 = wc(a2.target);
      if (null !== b2) {
        var c2 = Zb(b2);
        if (null !== c2) {
          if (b2 = c2.tag, 13 === b2) {
            if (b2 = $b(c2), null !== b2) {
              a2.blockedOn = b2;
              hc(a2.lanePriority, function() {
                r$5.unstable_runWithPriority(a2.priority, function() {
                  gc(c2);
                });
              });
              return;
            }
          } else if (3 === b2 && c2.stateNode.hydrate) {
            a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
            return;
          }
        }
      }
      a2.blockedOn = null;
    }
    function xc(a2) {
      if (null !== a2.blockedOn)
        return false;
      for (var b2 = a2.targetContainers; 0 < b2.length; ) {
        var c2 = yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
        if (null !== c2)
          return b2 = Cb(c2), null !== b2 && fc(b2), a2.blockedOn = c2, false;
        b2.shift();
      }
      return true;
    }
    function zc(a2, b2, c2) {
      xc(a2) && c2.delete(b2);
    }
    function Ac() {
      for (ic = false; 0 < jc.length; ) {
        var a2 = jc[0];
        if (null !== a2.blockedOn) {
          a2 = Cb(a2.blockedOn);
          null !== a2 && ec(a2);
          break;
        }
        for (var b2 = a2.targetContainers; 0 < b2.length; ) {
          var c2 = yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
          if (null !== c2) {
            a2.blockedOn = c2;
            break;
          }
          b2.shift();
        }
        null === a2.blockedOn && jc.shift();
      }
      null !== kc && xc(kc) && (kc = null);
      null !== lc && xc(lc) && (lc = null);
      null !== mc && xc(mc) && (mc = null);
      nc.forEach(zc);
      oc.forEach(zc);
    }
    function Bc(a2, b2) {
      a2.blockedOn === b2 && (a2.blockedOn = null, ic || (ic = true, r$5.unstable_scheduleCallback(r$5.unstable_NormalPriority, Ac)));
    }
    function Cc(a2) {
      function b2(b3) {
        return Bc(b3, a2);
      }
      if (0 < jc.length) {
        Bc(jc[0], a2);
        for (var c2 = 1; c2 < jc.length; c2++) {
          var d2 = jc[c2];
          d2.blockedOn === a2 && (d2.blockedOn = null);
        }
      }
      null !== kc && Bc(kc, a2);
      null !== lc && Bc(lc, a2);
      null !== mc && Bc(mc, a2);
      nc.forEach(b2);
      oc.forEach(b2);
      for (c2 = 0; c2 < pc.length; c2++)
        d2 = pc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
      for (; 0 < pc.length && (c2 = pc[0], null === c2.blockedOn); )
        vc(c2), null === c2.blockedOn && pc.shift();
    }
    function Dc(a2, b2) {
      var c2 = {};
      c2[a2.toLowerCase()] = b2.toLowerCase();
      c2["Webkit" + a2] = "webkit" + b2;
      c2["Moz" + a2] = "moz" + b2;
      return c2;
    }
    var Ec = { animationend: Dc("Animation", "AnimationEnd"), animationiteration: Dc("Animation", "AnimationIteration"), animationstart: Dc("Animation", "AnimationStart"), transitionend: Dc("Transition", "TransitionEnd") }, Fc = {}, Gc = {};
    fa && (Gc = document.createElement("div").style, "AnimationEvent" in window || (delete Ec.animationend.animation, delete Ec.animationiteration.animation, delete Ec.animationstart.animation), "TransitionEvent" in window || delete Ec.transitionend.transition);
    function Hc(a2) {
      if (Fc[a2])
        return Fc[a2];
      if (!Ec[a2])
        return a2;
      var b2 = Ec[a2], c2;
      for (c2 in b2)
        if (b2.hasOwnProperty(c2) && c2 in Gc)
          return Fc[a2] = b2[c2];
      return a2;
    }
    var Ic = Hc("animationend"), Jc = Hc("animationiteration"), Kc = Hc("animationstart"), Lc = Hc("transitionend"), Mc = /* @__PURE__ */ new Map(), Nc = /* @__PURE__ */ new Map(), Oc = [
      "abort",
      "abort",
      Ic,
      "animationEnd",
      Jc,
      "animationIteration",
      Kc,
      "animationStart",
      "canplay",
      "canPlay",
      "canplaythrough",
      "canPlayThrough",
      "durationchange",
      "durationChange",
      "emptied",
      "emptied",
      "encrypted",
      "encrypted",
      "ended",
      "ended",
      "error",
      "error",
      "gotpointercapture",
      "gotPointerCapture",
      "load",
      "load",
      "loadeddata",
      "loadedData",
      "loadedmetadata",
      "loadedMetadata",
      "loadstart",
      "loadStart",
      "lostpointercapture",
      "lostPointerCapture",
      "playing",
      "playing",
      "progress",
      "progress",
      "seeking",
      "seeking",
      "stalled",
      "stalled",
      "suspend",
      "suspend",
      "timeupdate",
      "timeUpdate",
      Lc,
      "transitionEnd",
      "waiting",
      "waiting"
    ];
    function Pc(a2, b2) {
      for (var c2 = 0; c2 < a2.length; c2 += 2) {
        var d2 = a2[c2], e2 = a2[c2 + 1];
        e2 = "on" + (e2[0].toUpperCase() + e2.slice(1));
        Nc.set(d2, b2);
        Mc.set(d2, e2);
        da(e2, [d2]);
      }
    }
    var Qc = r$5.unstable_now;
    Qc();
    var F$1 = 8;
    function Rc(a2) {
      if (0 !== (1 & a2))
        return F$1 = 15, 1;
      if (0 !== (2 & a2))
        return F$1 = 14, 2;
      if (0 !== (4 & a2))
        return F$1 = 13, 4;
      var b2 = 24 & a2;
      if (0 !== b2)
        return F$1 = 12, b2;
      if (0 !== (a2 & 32))
        return F$1 = 11, 32;
      b2 = 192 & a2;
      if (0 !== b2)
        return F$1 = 10, b2;
      if (0 !== (a2 & 256))
        return F$1 = 9, 256;
      b2 = 3584 & a2;
      if (0 !== b2)
        return F$1 = 8, b2;
      if (0 !== (a2 & 4096))
        return F$1 = 7, 4096;
      b2 = 4186112 & a2;
      if (0 !== b2)
        return F$1 = 6, b2;
      b2 = 62914560 & a2;
      if (0 !== b2)
        return F$1 = 5, b2;
      if (a2 & 67108864)
        return F$1 = 4, 67108864;
      if (0 !== (a2 & 134217728))
        return F$1 = 3, 134217728;
      b2 = 805306368 & a2;
      if (0 !== b2)
        return F$1 = 2, b2;
      if (0 !== (1073741824 & a2))
        return F$1 = 1, 1073741824;
      F$1 = 8;
      return a2;
    }
    function Sc(a2) {
      switch (a2) {
        case 99:
          return 15;
        case 98:
          return 10;
        case 97:
        case 96:
          return 8;
        case 95:
          return 2;
        default:
          return 0;
      }
    }
    function Tc(a2) {
      switch (a2) {
        case 15:
        case 14:
          return 99;
        case 13:
        case 12:
        case 11:
        case 10:
          return 98;
        case 9:
        case 8:
        case 7:
        case 6:
        case 4:
        case 5:
          return 97;
        case 3:
        case 2:
        case 1:
          return 95;
        case 0:
          return 90;
        default:
          throw Error(y$2(358, a2));
      }
    }
    function Uc(a2, b2) {
      var c2 = a2.pendingLanes;
      if (0 === c2)
        return F$1 = 0;
      var d2 = 0, e2 = 0, f2 = a2.expiredLanes, g2 = a2.suspendedLanes, h2 = a2.pingedLanes;
      if (0 !== f2)
        d2 = f2, e2 = F$1 = 15;
      else if (f2 = c2 & 134217727, 0 !== f2) {
        var k2 = f2 & ~g2;
        0 !== k2 ? (d2 = Rc(k2), e2 = F$1) : (h2 &= f2, 0 !== h2 && (d2 = Rc(h2), e2 = F$1));
      } else
        f2 = c2 & ~g2, 0 !== f2 ? (d2 = Rc(f2), e2 = F$1) : 0 !== h2 && (d2 = Rc(h2), e2 = F$1);
      if (0 === d2)
        return 0;
      d2 = 31 - Vc(d2);
      d2 = c2 & ((0 > d2 ? 0 : 1 << d2) << 1) - 1;
      if (0 !== b2 && b2 !== d2 && 0 === (b2 & g2)) {
        Rc(b2);
        if (e2 <= F$1)
          return b2;
        F$1 = e2;
      }
      b2 = a2.entangledLanes;
      if (0 !== b2)
        for (a2 = a2.entanglements, b2 &= d2; 0 < b2; )
          c2 = 31 - Vc(b2), e2 = 1 << c2, d2 |= a2[c2], b2 &= ~e2;
      return d2;
    }
    function Wc(a2) {
      a2 = a2.pendingLanes & -1073741825;
      return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
    }
    function Xc(a2, b2) {
      switch (a2) {
        case 15:
          return 1;
        case 14:
          return 2;
        case 12:
          return a2 = Yc(24 & ~b2), 0 === a2 ? Xc(10, b2) : a2;
        case 10:
          return a2 = Yc(192 & ~b2), 0 === a2 ? Xc(8, b2) : a2;
        case 8:
          return a2 = Yc(3584 & ~b2), 0 === a2 && (a2 = Yc(4186112 & ~b2), 0 === a2 && (a2 = 512)), a2;
        case 2:
          return b2 = Yc(805306368 & ~b2), 0 === b2 && (b2 = 268435456), b2;
      }
      throw Error(y$2(358, a2));
    }
    function Yc(a2) {
      return a2 & -a2;
    }
    function Zc(a2) {
      for (var b2 = [], c2 = 0; 31 > c2; c2++)
        b2.push(a2);
      return b2;
    }
    function $c(a2, b2, c2) {
      a2.pendingLanes |= b2;
      var d2 = b2 - 1;
      a2.suspendedLanes &= d2;
      a2.pingedLanes &= d2;
      a2 = a2.eventTimes;
      b2 = 31 - Vc(b2);
      a2[b2] = c2;
    }
    var Vc = Math.clz32 ? Math.clz32 : ad, bd = Math.log, cd = Math.LN2;
    function ad(a2) {
      return 0 === a2 ? 32 : 31 - (bd(a2) / cd | 0) | 0;
    }
    var dd = r$5.unstable_UserBlockingPriority, ed = r$5.unstable_runWithPriority, fd = true;
    function gd(a2, b2, c2, d2) {
      Kb || Ib();
      var e2 = hd, f2 = Kb;
      Kb = true;
      try {
        Hb(e2, a2, b2, c2, d2);
      } finally {
        (Kb = f2) || Mb();
      }
    }
    function id(a2, b2, c2, d2) {
      ed(dd, hd.bind(null, a2, b2, c2, d2));
    }
    function hd(a2, b2, c2, d2) {
      if (fd) {
        var e2;
        if ((e2 = 0 === (b2 & 4)) && 0 < jc.length && -1 < qc.indexOf(a2))
          a2 = rc(null, a2, b2, c2, d2), jc.push(a2);
        else {
          var f2 = yc(a2, b2, c2, d2);
          if (null === f2)
            e2 && sc(a2, d2);
          else {
            if (e2) {
              if (-1 < qc.indexOf(a2)) {
                a2 = rc(f2, a2, b2, c2, d2);
                jc.push(a2);
                return;
              }
              if (uc(f2, a2, b2, c2, d2))
                return;
              sc(a2, d2);
            }
            jd(a2, b2, d2, null, c2);
          }
        }
      }
    }
    function yc(a2, b2, c2, d2) {
      var e2 = xb(d2);
      e2 = wc(e2);
      if (null !== e2) {
        var f2 = Zb(e2);
        if (null === f2)
          e2 = null;
        else {
          var g2 = f2.tag;
          if (13 === g2) {
            e2 = $b(f2);
            if (null !== e2)
              return e2;
            e2 = null;
          } else if (3 === g2) {
            if (f2.stateNode.hydrate)
              return 3 === f2.tag ? f2.stateNode.containerInfo : null;
            e2 = null;
          } else
            f2 !== e2 && (e2 = null);
        }
      }
      jd(a2, b2, d2, e2, c2);
      return null;
    }
    var kd = null, ld = null, md = null;
    function nd() {
      if (md)
        return md;
      var a2, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
      for (a2 = 0; a2 < c2 && b2[a2] === e2[a2]; a2++)
        ;
      var g2 = c2 - a2;
      for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++)
        ;
      return md = e2.slice(a2, 1 < d2 ? 1 - d2 : void 0);
    }
    function od(a2) {
      var b2 = a2.keyCode;
      "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
      10 === a2 && (a2 = 13);
      return 32 <= a2 || 13 === a2 ? a2 : 0;
    }
    function pd() {
      return true;
    }
    function qd() {
      return false;
    }
    function rd(a2) {
      function b2(b3, d2, e2, f2, g2) {
        this._reactName = b3;
        this._targetInst = e2;
        this.type = d2;
        this.nativeEvent = f2;
        this.target = g2;
        this.currentTarget = null;
        for (var c2 in a2)
          a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
        this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
        this.isPropagationStopped = qd;
        return this;
      }
      m$4(b2.prototype, { preventDefault: function() {
        this.defaultPrevented = true;
        var a3 = this.nativeEvent;
        a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
      }, stopPropagation: function() {
        var a3 = this.nativeEvent;
        a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
      }, persist: function() {
      }, isPersistent: pd });
      return b2;
    }
    var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
      return a2.timeStamp || Date.now();
    }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = m$4({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = m$4({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
      return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
    }, movementX: function(a2) {
      if ("movementX" in a2)
        return a2.movementX;
      a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
      return wd;
    }, movementY: function(a2) {
      return "movementY" in a2 ? a2.movementY : xd;
    } }), Bd = rd(Ad), Cd = m$4({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = m$4({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = m$4({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = m$4({}, sd, { clipboardData: function(a2) {
      return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
    } }), Jd = rd(Id), Kd = m$4({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, Nd = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
    function Pd(a2) {
      var b2 = this.nativeEvent;
      return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : false;
    }
    function zd() {
      return Pd;
    }
    var Qd = m$4({}, ud, { key: function(a2) {
      if (a2.key) {
        var b2 = Md[a2.key] || a2.key;
        if ("Unidentified" !== b2)
          return b2;
      }
      return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
    }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
      return "keypress" === a2.type ? od(a2) : 0;
    }, keyCode: function(a2) {
      return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
    }, which: function(a2) {
      return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
    } }), Rd = rd(Qd), Sd = m$4({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = m$4({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = m$4({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = m$4({}, Ad, {
      deltaX: function(a2) {
        return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
      },
      deltaY: function(a2) {
        return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = fa && "CompositionEvent" in window, be = null;
    fa && "documentMode" in document && (be = document.documentMode);
    var ce = fa && "TextEvent" in window && !be, de = fa && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
    function ge(a2, b2) {
      switch (a2) {
        case "keyup":
          return -1 !== $d.indexOf(b2.keyCode);
        case "keydown":
          return 229 !== b2.keyCode;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    function he(a2) {
      a2 = a2.detail;
      return "object" === typeof a2 && "data" in a2 ? a2.data : null;
    }
    var ie = false;
    function je(a2, b2) {
      switch (a2) {
        case "compositionend":
          return he(b2);
        case "keypress":
          if (32 !== b2.which)
            return null;
          fe = true;
          return ee;
        case "textInput":
          return a2 = b2.data, a2 === ee && fe ? null : a2;
        default:
          return null;
      }
    }
    function ke(a2, b2) {
      if (ie)
        return "compositionend" === a2 || !ae && ge(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie = false, a2) : null;
      switch (a2) {
        case "paste":
          return null;
        case "keypress":
          if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
            if (b2.char && 1 < b2.char.length)
              return b2.char;
            if (b2.which)
              return String.fromCharCode(b2.which);
          }
          return null;
        case "compositionend":
          return de && "ko" !== b2.locale ? null : b2.data;
        default:
          return null;
      }
    }
    var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
    function me(a2) {
      var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
      return "input" === b2 ? !!le[a2.type] : "textarea" === b2 ? true : false;
    }
    function ne(a2, b2, c2, d2) {
      Eb(d2);
      b2 = oe(b2, "onChange");
      0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
    }
    var pe = null, qe = null;
    function re(a2) {
      se(a2, 0);
    }
    function te(a2) {
      var b2 = ue(a2);
      if (Wa(b2))
        return a2;
    }
    function ve(a2, b2) {
      if ("change" === a2)
        return b2;
    }
    var we = false;
    if (fa) {
      var xe;
      if (fa) {
        var ye = "oninput" in document;
        if (!ye) {
          var ze = document.createElement("div");
          ze.setAttribute("oninput", "return;");
          ye = "function" === typeof ze.oninput;
        }
        xe = ye;
      } else
        xe = false;
      we = xe && (!document.documentMode || 9 < document.documentMode);
    }
    function Ae() {
      pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
    }
    function Be(a2) {
      if ("value" === a2.propertyName && te(qe)) {
        var b2 = [];
        ne(b2, qe, a2, xb(a2));
        a2 = re;
        if (Kb)
          a2(b2);
        else {
          Kb = true;
          try {
            Gb(a2, b2);
          } finally {
            Kb = false, Mb();
          }
        }
      }
    }
    function Ce(a2, b2, c2) {
      "focusin" === a2 ? (Ae(), pe = b2, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a2 && Ae();
    }
    function De(a2) {
      if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2)
        return te(qe);
    }
    function Ee(a2, b2) {
      if ("click" === a2)
        return te(b2);
    }
    function Fe(a2, b2) {
      if ("input" === a2 || "change" === a2)
        return te(b2);
    }
    function Ge(a2, b2) {
      return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
    }
    var He = "function" === typeof Object.is ? Object.is : Ge, Ie = Object.prototype.hasOwnProperty;
    function Je(a2, b2) {
      if (He(a2, b2))
        return true;
      if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2)
        return false;
      var c2 = Object.keys(a2), d2 = Object.keys(b2);
      if (c2.length !== d2.length)
        return false;
      for (d2 = 0; d2 < c2.length; d2++)
        if (!Ie.call(b2, c2[d2]) || !He(a2[c2[d2]], b2[c2[d2]]))
          return false;
      return true;
    }
    function Ke(a2) {
      for (; a2 && a2.firstChild; )
        a2 = a2.firstChild;
      return a2;
    }
    function Le(a2, b2) {
      var c2 = Ke(a2);
      a2 = 0;
      for (var d2; c2; ) {
        if (3 === c2.nodeType) {
          d2 = a2 + c2.textContent.length;
          if (a2 <= b2 && d2 >= b2)
            return { node: c2, offset: b2 - a2 };
          a2 = d2;
        }
        a: {
          for (; c2; ) {
            if (c2.nextSibling) {
              c2 = c2.nextSibling;
              break a;
            }
            c2 = c2.parentNode;
          }
          c2 = void 0;
        }
        c2 = Ke(c2);
      }
    }
    function Me(a2, b2) {
      return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Me(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
    }
    function Ne() {
      for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
        try {
          var c2 = "string" === typeof b2.contentWindow.location.href;
        } catch (d2) {
          c2 = false;
        }
        if (c2)
          a2 = b2.contentWindow;
        else
          break;
        b2 = Xa(a2.document);
      }
      return b2;
    }
    function Oe(a2) {
      var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
      return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
    }
    var Pe = fa && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
    function Ue(a2, b2, c2) {
      var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
      Te || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Oe(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Je(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe)));
    }
    Pc(
      "cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
      0
    );
    Pc("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "), 1);
    Pc(Oc, 2);
    for (var Ve = "change selectionchange textInput compositionstart compositionend compositionupdate".split(" "), We = 0; We < Ve.length; We++)
      Nc.set(Ve[We], 0);
    ea("onMouseEnter", ["mouseout", "mouseover"]);
    ea("onMouseLeave", ["mouseout", "mouseover"]);
    ea("onPointerEnter", ["pointerout", "pointerover"]);
    ea("onPointerLeave", ["pointerout", "pointerover"]);
    da("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
    da("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
    da("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
    da("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
    da("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
    da("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var Xe = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Ye = new Set("cancel close invalid load scroll toggle".split(" ").concat(Xe));
    function Ze(a2, b2, c2) {
      var d2 = a2.type || "unknown-event";
      a2.currentTarget = c2;
      Yb(d2, b2, void 0, a2);
      a2.currentTarget = null;
    }
    function se(a2, b2) {
      b2 = 0 !== (b2 & 4);
      for (var c2 = 0; c2 < a2.length; c2++) {
        var d2 = a2[c2], e2 = d2.event;
        d2 = d2.listeners;
        a: {
          var f2 = void 0;
          if (b2)
            for (var g2 = d2.length - 1; 0 <= g2; g2--) {
              var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
              h2 = h2.listener;
              if (k2 !== f2 && e2.isPropagationStopped())
                break a;
              Ze(e2, h2, l2);
              f2 = k2;
            }
          else
            for (g2 = 0; g2 < d2.length; g2++) {
              h2 = d2[g2];
              k2 = h2.instance;
              l2 = h2.currentTarget;
              h2 = h2.listener;
              if (k2 !== f2 && e2.isPropagationStopped())
                break a;
              Ze(e2, h2, l2);
              f2 = k2;
            }
        }
      }
      if (Ub)
        throw a2 = Vb, Ub = false, Vb = null, a2;
    }
    function G(a2, b2) {
      var c2 = $e(b2), d2 = a2 + "__bubble";
      c2.has(d2) || (af(b2, a2, 2, false), c2.add(d2));
    }
    var bf = "_reactListening" + Math.random().toString(36).slice(2);
    function cf(a2) {
      a2[bf] || (a2[bf] = true, ba.forEach(function(b2) {
        Ye.has(b2) || df(b2, false, a2, null);
        df(b2, true, a2, null);
      }));
    }
    function df(a2, b2, c2, d2) {
      var e2 = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0, f2 = c2;
      "selectionchange" === a2 && 9 !== c2.nodeType && (f2 = c2.ownerDocument);
      if (null !== d2 && !b2 && Ye.has(a2)) {
        if ("scroll" !== a2)
          return;
        e2 |= 2;
        f2 = d2;
      }
      var g2 = $e(f2), h2 = a2 + "__" + (b2 ? "capture" : "bubble");
      g2.has(h2) || (b2 && (e2 |= 4), af(f2, a2, e2, b2), g2.add(h2));
    }
    function af(a2, b2, c2, d2) {
      var e2 = Nc.get(b2);
      switch (void 0 === e2 ? 2 : e2) {
        case 0:
          e2 = gd;
          break;
        case 1:
          e2 = id;
          break;
        default:
          e2 = hd;
      }
      c2 = e2.bind(null, b2, c2, a2);
      e2 = void 0;
      !Pb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
      d2 ? void 0 !== e2 ? a2.addEventListener(b2, c2, { capture: true, passive: e2 }) : a2.addEventListener(b2, c2, true) : void 0 !== e2 ? a2.addEventListener(b2, c2, { passive: e2 }) : a2.addEventListener(b2, c2, false);
    }
    function jd(a2, b2, c2, d2, e2) {
      var f2 = d2;
      if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
        a:
          for (; ; ) {
            if (null === d2)
              return;
            var g2 = d2.tag;
            if (3 === g2 || 4 === g2) {
              var h2 = d2.stateNode.containerInfo;
              if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
                break;
              if (4 === g2)
                for (g2 = d2.return; null !== g2; ) {
                  var k2 = g2.tag;
                  if (3 === k2 || 4 === k2) {
                    if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                      return;
                  }
                  g2 = g2.return;
                }
              for (; null !== h2; ) {
                g2 = wc(h2);
                if (null === g2)
                  return;
                k2 = g2.tag;
                if (5 === k2 || 6 === k2) {
                  d2 = f2 = g2;
                  continue a;
                }
                h2 = h2.parentNode;
              }
            }
            d2 = d2.return;
          }
      Nb(function() {
        var d3 = f2, e3 = xb(c2), g3 = [];
        a: {
          var h3 = Mc.get(a2);
          if (void 0 !== h3) {
            var k3 = td, x2 = a2;
            switch (a2) {
              case "keypress":
                if (0 === od(c2))
                  break a;
              case "keydown":
              case "keyup":
                k3 = Rd;
                break;
              case "focusin":
                x2 = "focus";
                k3 = Fd;
                break;
              case "focusout":
                x2 = "blur";
                k3 = Fd;
                break;
              case "beforeblur":
              case "afterblur":
                k3 = Fd;
                break;
              case "click":
                if (2 === c2.button)
                  break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                k3 = Bd;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                k3 = Dd;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                k3 = Vd;
                break;
              case Ic:
              case Jc:
              case Kc:
                k3 = Hd;
                break;
              case Lc:
                k3 = Xd;
                break;
              case "scroll":
                k3 = vd;
                break;
              case "wheel":
                k3 = Zd;
                break;
              case "copy":
              case "cut":
              case "paste":
                k3 = Jd;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                k3 = Td;
            }
            var w2 = 0 !== (b2 & 4), z2 = !w2 && "scroll" === a2, u2 = w2 ? null !== h3 ? h3 + "Capture" : null : h3;
            w2 = [];
            for (var t2 = d3, q2; null !== t2; ) {
              q2 = t2;
              var v2 = q2.stateNode;
              5 === q2.tag && null !== v2 && (q2 = v2, null !== u2 && (v2 = Ob(t2, u2), null != v2 && w2.push(ef(t2, v2, q2))));
              if (z2)
                break;
              t2 = t2.return;
            }
            0 < w2.length && (h3 = new k3(h3, x2, null, c2, e3), g3.push({ event: h3, listeners: w2 }));
          }
        }
        if (0 === (b2 & 7)) {
          a: {
            h3 = "mouseover" === a2 || "pointerover" === a2;
            k3 = "mouseout" === a2 || "pointerout" === a2;
            if (h3 && 0 === (b2 & 16) && (x2 = c2.relatedTarget || c2.fromElement) && (wc(x2) || x2[ff]))
              break a;
            if (k3 || h3) {
              h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
              if (k3) {
                if (x2 = c2.relatedTarget || c2.toElement, k3 = d3, x2 = x2 ? wc(x2) : null, null !== x2 && (z2 = Zb(x2), x2 !== z2 || 5 !== x2.tag && 6 !== x2.tag))
                  x2 = null;
              } else
                k3 = null, x2 = d3;
              if (k3 !== x2) {
                w2 = Bd;
                v2 = "onMouseLeave";
                u2 = "onMouseEnter";
                t2 = "mouse";
                if ("pointerout" === a2 || "pointerover" === a2)
                  w2 = Td, v2 = "onPointerLeave", u2 = "onPointerEnter", t2 = "pointer";
                z2 = null == k3 ? h3 : ue(k3);
                q2 = null == x2 ? h3 : ue(x2);
                h3 = new w2(v2, t2 + "leave", k3, c2, e3);
                h3.target = z2;
                h3.relatedTarget = q2;
                v2 = null;
                wc(e3) === d3 && (w2 = new w2(u2, t2 + "enter", x2, c2, e3), w2.target = q2, w2.relatedTarget = z2, v2 = w2);
                z2 = v2;
                if (k3 && x2)
                  b: {
                    w2 = k3;
                    u2 = x2;
                    t2 = 0;
                    for (q2 = w2; q2; q2 = gf(q2))
                      t2++;
                    q2 = 0;
                    for (v2 = u2; v2; v2 = gf(v2))
                      q2++;
                    for (; 0 < t2 - q2; )
                      w2 = gf(w2), t2--;
                    for (; 0 < q2 - t2; )
                      u2 = gf(u2), q2--;
                    for (; t2--; ) {
                      if (w2 === u2 || null !== u2 && w2 === u2.alternate)
                        break b;
                      w2 = gf(w2);
                      u2 = gf(u2);
                    }
                    w2 = null;
                  }
                else
                  w2 = null;
                null !== k3 && hf(g3, h3, k3, w2, false);
                null !== x2 && null !== z2 && hf(g3, z2, x2, w2, true);
              }
            }
          }
          a: {
            h3 = d3 ? ue(d3) : window;
            k3 = h3.nodeName && h3.nodeName.toLowerCase();
            if ("select" === k3 || "input" === k3 && "file" === h3.type)
              var J2 = ve;
            else if (me(h3))
              if (we)
                J2 = Fe;
              else {
                J2 = De;
                var K2 = Ce;
              }
            else
              (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (J2 = Ee);
            if (J2 && (J2 = J2(a2, d3))) {
              ne(g3, J2, c2, e3);
              break a;
            }
            K2 && K2(a2, h3, d3);
            "focusout" === a2 && (K2 = h3._wrapperState) && K2.controlled && "number" === h3.type && bb(h3, "number", h3.value);
          }
          K2 = d3 ? ue(d3) : window;
          switch (a2) {
            case "focusin":
              if (me(K2) || "true" === K2.contentEditable)
                Qe = K2, Re = d3, Se = null;
              break;
            case "focusout":
              Se = Re = Qe = null;
              break;
            case "mousedown":
              Te = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              Te = false;
              Ue(g3, c2, e3);
              break;
            case "selectionchange":
              if (Pe)
                break;
            case "keydown":
            case "keyup":
              Ue(g3, c2, e3);
          }
          var Q2;
          if (ae)
            b: {
              switch (a2) {
                case "compositionstart":
                  var L2 = "onCompositionStart";
                  break b;
                case "compositionend":
                  L2 = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  L2 = "onCompositionUpdate";
                  break b;
              }
              L2 = void 0;
            }
          else
            ie ? ge(a2, c2) && (L2 = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (L2 = "onCompositionStart");
          L2 && (de && "ko" !== c2.locale && (ie || "onCompositionStart" !== L2 ? "onCompositionEnd" === L2 && ie && (Q2 = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), K2 = oe(d3, L2), 0 < K2.length && (L2 = new Ld(L2, a2, null, c2, e3), g3.push({ event: L2, listeners: K2 }), Q2 ? L2.data = Q2 : (Q2 = he(c2), null !== Q2 && (L2.data = Q2))));
          if (Q2 = ce ? je(a2, c2) : ke(a2, c2))
            d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld(
              "onBeforeInput",
              "beforeinput",
              null,
              c2,
              e3
            ), g3.push({ event: e3, listeners: d3 }), e3.data = Q2);
        }
        se(g3, b2);
      });
    }
    function ef(a2, b2, c2) {
      return { instance: a2, listener: b2, currentTarget: c2 };
    }
    function oe(a2, b2) {
      for (var c2 = b2 + "Capture", d2 = []; null !== a2; ) {
        var e2 = a2, f2 = e2.stateNode;
        5 === e2.tag && null !== f2 && (e2 = f2, f2 = Ob(a2, c2), null != f2 && d2.unshift(ef(a2, f2, e2)), f2 = Ob(a2, b2), null != f2 && d2.push(ef(a2, f2, e2)));
        a2 = a2.return;
      }
      return d2;
    }
    function gf(a2) {
      if (null === a2)
        return null;
      do
        a2 = a2.return;
      while (a2 && 5 !== a2.tag);
      return a2 ? a2 : null;
    }
    function hf(a2, b2, c2, d2, e2) {
      for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
        var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
        if (null !== k2 && k2 === d2)
          break;
        5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Ob(c2, f2), null != k2 && g2.unshift(ef(c2, k2, h2))) : e2 || (k2 = Ob(c2, f2), null != k2 && g2.push(ef(c2, k2, h2))));
        c2 = c2.return;
      }
      0 !== g2.length && a2.push({ event: b2, listeners: g2 });
    }
    function jf() {
    }
    var kf = null, lf = null;
    function mf(a2, b2) {
      switch (a2) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!b2.autoFocus;
      }
      return false;
    }
    function nf(a2, b2) {
      return "textarea" === a2 || "option" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
    }
    var of = "function" === typeof setTimeout ? setTimeout : void 0, pf = "function" === typeof clearTimeout ? clearTimeout : void 0;
    function qf(a2) {
      1 === a2.nodeType ? a2.textContent = "" : 9 === a2.nodeType && (a2 = a2.body, null != a2 && (a2.textContent = ""));
    }
    function rf(a2) {
      for (; null != a2; a2 = a2.nextSibling) {
        var b2 = a2.nodeType;
        if (1 === b2 || 3 === b2)
          break;
      }
      return a2;
    }
    function sf(a2) {
      a2 = a2.previousSibling;
      for (var b2 = 0; a2; ) {
        if (8 === a2.nodeType) {
          var c2 = a2.data;
          if ("$" === c2 || "$!" === c2 || "$?" === c2) {
            if (0 === b2)
              return a2;
            b2--;
          } else
            "/$" === c2 && b2++;
        }
        a2 = a2.previousSibling;
      }
      return null;
    }
    var tf = 0;
    function uf(a2) {
      return { $$typeof: Ga, toString: a2, valueOf: a2 };
    }
    var vf = Math.random().toString(36).slice(2), wf = "__reactFiber$" + vf, xf = "__reactProps$" + vf, ff = "__reactContainer$" + vf, yf = "__reactEvents$" + vf;
    function wc(a2) {
      var b2 = a2[wf];
      if (b2)
        return b2;
      for (var c2 = a2.parentNode; c2; ) {
        if (b2 = c2[ff] || c2[wf]) {
          c2 = b2.alternate;
          if (null !== b2.child || null !== c2 && null !== c2.child)
            for (a2 = sf(a2); null !== a2; ) {
              if (c2 = a2[wf])
                return c2;
              a2 = sf(a2);
            }
          return b2;
        }
        a2 = c2;
        c2 = a2.parentNode;
      }
      return null;
    }
    function Cb(a2) {
      a2 = a2[wf] || a2[ff];
      return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
    }
    function ue(a2) {
      if (5 === a2.tag || 6 === a2.tag)
        return a2.stateNode;
      throw Error(y$2(33));
    }
    function Db(a2) {
      return a2[xf] || null;
    }
    function $e(a2) {
      var b2 = a2[yf];
      void 0 === b2 && (b2 = a2[yf] = /* @__PURE__ */ new Set());
      return b2;
    }
    var zf = [], Af = -1;
    function Bf(a2) {
      return { current: a2 };
    }
    function H$1(a2) {
      0 > Af || (a2.current = zf[Af], zf[Af] = null, Af--);
    }
    function I(a2, b2) {
      Af++;
      zf[Af] = a2.current;
      a2.current = b2;
    }
    var Cf = {}, M = Bf(Cf), N = Bf(false), Df = Cf;
    function Ef(a2, b2) {
      var c2 = a2.type.contextTypes;
      if (!c2)
        return Cf;
      var d2 = a2.stateNode;
      if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
        return d2.__reactInternalMemoizedMaskedChildContext;
      var e2 = {}, f2;
      for (f2 in c2)
        e2[f2] = b2[f2];
      d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e2);
      return e2;
    }
    function Ff(a2) {
      a2 = a2.childContextTypes;
      return null !== a2 && void 0 !== a2;
    }
    function Gf() {
      H$1(N);
      H$1(M);
    }
    function Hf(a2, b2, c2) {
      if (M.current !== Cf)
        throw Error(y$2(168));
      I(M, b2);
      I(N, c2);
    }
    function If(a2, b2, c2) {
      var d2 = a2.stateNode;
      a2 = b2.childContextTypes;
      if ("function" !== typeof d2.getChildContext)
        return c2;
      d2 = d2.getChildContext();
      for (var e2 in d2)
        if (!(e2 in a2))
          throw Error(y$2(108, Ra(b2) || "Unknown", e2));
      return m$4({}, c2, d2);
    }
    function Jf(a2) {
      a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Cf;
      Df = M.current;
      I(M, a2);
      I(N, N.current);
      return true;
    }
    function Kf(a2, b2, c2) {
      var d2 = a2.stateNode;
      if (!d2)
        throw Error(y$2(169));
      c2 ? (a2 = If(a2, b2, Df), d2.__reactInternalMemoizedMergedChildContext = a2, H$1(N), H$1(M), I(M, a2)) : H$1(N);
      I(N, c2);
    }
    var Lf = null, Mf = null, Nf = r$5.unstable_runWithPriority, Of = r$5.unstable_scheduleCallback, Pf = r$5.unstable_cancelCallback, Qf = r$5.unstable_shouldYield, Rf = r$5.unstable_requestPaint, Sf = r$5.unstable_now, Tf = r$5.unstable_getCurrentPriorityLevel, Uf = r$5.unstable_ImmediatePriority, Vf = r$5.unstable_UserBlockingPriority, Wf = r$5.unstable_NormalPriority, Xf = r$5.unstable_LowPriority, Yf = r$5.unstable_IdlePriority, Zf = {}, $f = void 0 !== Rf ? Rf : function() {
    }, ag = null, bg = null, cg = false, dg = Sf(), O$2 = 1e4 > dg ? Sf : function() {
      return Sf() - dg;
    };
    function eg() {
      switch (Tf()) {
        case Uf:
          return 99;
        case Vf:
          return 98;
        case Wf:
          return 97;
        case Xf:
          return 96;
        case Yf:
          return 95;
        default:
          throw Error(y$2(332));
      }
    }
    function fg(a2) {
      switch (a2) {
        case 99:
          return Uf;
        case 98:
          return Vf;
        case 97:
          return Wf;
        case 96:
          return Xf;
        case 95:
          return Yf;
        default:
          throw Error(y$2(332));
      }
    }
    function gg(a2, b2) {
      a2 = fg(a2);
      return Nf(a2, b2);
    }
    function hg(a2, b2, c2) {
      a2 = fg(a2);
      return Of(a2, b2, c2);
    }
    function ig() {
      if (null !== bg) {
        var a2 = bg;
        bg = null;
        Pf(a2);
      }
      jg();
    }
    function jg() {
      if (!cg && null !== ag) {
        cg = true;
        var a2 = 0;
        try {
          var b2 = ag;
          gg(99, function() {
            for (; a2 < b2.length; a2++) {
              var c2 = b2[a2];
              do
                c2 = c2(true);
              while (null !== c2);
            }
          });
          ag = null;
        } catch (c2) {
          throw null !== ag && (ag = ag.slice(a2 + 1)), Of(Uf, ig), c2;
        } finally {
          cg = false;
        }
      }
    }
    var kg = ra.ReactCurrentBatchConfig;
    function lg(a2, b2) {
      if (a2 && a2.defaultProps) {
        b2 = m$4({}, b2);
        a2 = a2.defaultProps;
        for (var c2 in a2)
          void 0 === b2[c2] && (b2[c2] = a2[c2]);
        return b2;
      }
      return b2;
    }
    var mg = Bf(null), ng = null, og = null, pg = null;
    function qg() {
      pg = og = ng = null;
    }
    function rg(a2) {
      var b2 = mg.current;
      H$1(mg);
      a2.type._context._currentValue = b2;
    }
    function sg(a2, b2) {
      for (; null !== a2; ) {
        var c2 = a2.alternate;
        if ((a2.childLanes & b2) === b2)
          if (null === c2 || (c2.childLanes & b2) === b2)
            break;
          else
            c2.childLanes |= b2;
        else
          a2.childLanes |= b2, null !== c2 && (c2.childLanes |= b2);
        a2 = a2.return;
      }
    }
    function tg(a2, b2) {
      ng = a2;
      pg = og = null;
      a2 = a2.dependencies;
      null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (ug = true), a2.firstContext = null);
    }
    function vg(a2, b2) {
      if (pg !== a2 && false !== b2 && 0 !== b2) {
        if ("number" !== typeof b2 || 1073741823 === b2)
          pg = a2, b2 = 1073741823;
        b2 = { context: a2, observedBits: b2, next: null };
        if (null === og) {
          if (null === ng)
            throw Error(y$2(308));
          og = b2;
          ng.dependencies = { lanes: 0, firstContext: b2, responders: null };
        } else
          og = og.next = b2;
      }
      return a2._currentValue;
    }
    var wg = false;
    function xg(a2) {
      a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null }, effects: null };
    }
    function yg(a2, b2) {
      a2 = a2.updateQueue;
      b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
    }
    function zg(a2, b2) {
      return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
    }
    function Ag(a2, b2) {
      a2 = a2.updateQueue;
      if (null !== a2) {
        a2 = a2.shared;
        var c2 = a2.pending;
        null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
        a2.pending = b2;
      }
    }
    function Bg(a2, b2) {
      var c2 = a2.updateQueue, d2 = a2.alternate;
      if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
        var e2 = null, f2 = null;
        c2 = c2.firstBaseUpdate;
        if (null !== c2) {
          do {
            var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
            null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
            c2 = c2.next;
          } while (null !== c2);
          null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
        } else
          e2 = f2 = b2;
        c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
        a2.updateQueue = c2;
        return;
      }
      a2 = c2.lastBaseUpdate;
      null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
      c2.lastBaseUpdate = b2;
    }
    function Cg(a2, b2, c2, d2) {
      var e2 = a2.updateQueue;
      wg = false;
      var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
      if (null !== h2) {
        e2.shared.pending = null;
        var k2 = h2, l2 = k2.next;
        k2.next = null;
        null === g2 ? f2 = l2 : g2.next = l2;
        g2 = k2;
        var n2 = a2.alternate;
        if (null !== n2) {
          n2 = n2.updateQueue;
          var A2 = n2.lastBaseUpdate;
          A2 !== g2 && (null === A2 ? n2.firstBaseUpdate = l2 : A2.next = l2, n2.lastBaseUpdate = k2);
        }
      }
      if (null !== f2) {
        A2 = e2.baseState;
        g2 = 0;
        n2 = l2 = k2 = null;
        do {
          h2 = f2.lane;
          var p2 = f2.eventTime;
          if ((d2 & h2) === h2) {
            null !== n2 && (n2 = n2.next = {
              eventTime: p2,
              lane: 0,
              tag: f2.tag,
              payload: f2.payload,
              callback: f2.callback,
              next: null
            });
            a: {
              var C2 = a2, x2 = f2;
              h2 = b2;
              p2 = c2;
              switch (x2.tag) {
                case 1:
                  C2 = x2.payload;
                  if ("function" === typeof C2) {
                    A2 = C2.call(p2, A2, h2);
                    break a;
                  }
                  A2 = C2;
                  break a;
                case 3:
                  C2.flags = C2.flags & -4097 | 64;
                case 0:
                  C2 = x2.payload;
                  h2 = "function" === typeof C2 ? C2.call(p2, A2, h2) : C2;
                  if (null === h2 || void 0 === h2)
                    break a;
                  A2 = m$4({}, A2, h2);
                  break a;
                case 2:
                  wg = true;
              }
            }
            null !== f2.callback && (a2.flags |= 32, h2 = e2.effects, null === h2 ? e2.effects = [f2] : h2.push(f2));
          } else
            p2 = { eventTime: p2, lane: h2, tag: f2.tag, payload: f2.payload, callback: f2.callback, next: null }, null === n2 ? (l2 = n2 = p2, k2 = A2) : n2 = n2.next = p2, g2 |= h2;
          f2 = f2.next;
          if (null === f2)
            if (h2 = e2.shared.pending, null === h2)
              break;
            else
              f2 = h2.next, h2.next = null, e2.lastBaseUpdate = h2, e2.shared.pending = null;
        } while (1);
        null === n2 && (k2 = A2);
        e2.baseState = k2;
        e2.firstBaseUpdate = l2;
        e2.lastBaseUpdate = n2;
        Dg |= g2;
        a2.lanes = g2;
        a2.memoizedState = A2;
      }
    }
    function Eg(a2, b2, c2) {
      a2 = b2.effects;
      b2.effects = null;
      if (null !== a2)
        for (b2 = 0; b2 < a2.length; b2++) {
          var d2 = a2[b2], e2 = d2.callback;
          if (null !== e2) {
            d2.callback = null;
            d2 = c2;
            if ("function" !== typeof e2)
              throw Error(y$2(191, e2));
            e2.call(d2);
          }
        }
    }
    var Fg = new aa.Component().refs;
    function Gg(a2, b2, c2, d2) {
      b2 = a2.memoizedState;
      c2 = c2(d2, b2);
      c2 = null === c2 || void 0 === c2 ? b2 : m$4({}, b2, c2);
      a2.memoizedState = c2;
      0 === a2.lanes && (a2.updateQueue.baseState = c2);
    }
    var Kg = { isMounted: function(a2) {
      return (a2 = a2._reactInternals) ? Zb(a2) === a2 : false;
    }, enqueueSetState: function(a2, b2, c2) {
      a2 = a2._reactInternals;
      var d2 = Hg(), e2 = Ig(a2), f2 = zg(d2, e2);
      f2.payload = b2;
      void 0 !== c2 && null !== c2 && (f2.callback = c2);
      Ag(a2, f2);
      Jg(a2, e2, d2);
    }, enqueueReplaceState: function(a2, b2, c2) {
      a2 = a2._reactInternals;
      var d2 = Hg(), e2 = Ig(a2), f2 = zg(d2, e2);
      f2.tag = 1;
      f2.payload = b2;
      void 0 !== c2 && null !== c2 && (f2.callback = c2);
      Ag(a2, f2);
      Jg(a2, e2, d2);
    }, enqueueForceUpdate: function(a2, b2) {
      a2 = a2._reactInternals;
      var c2 = Hg(), d2 = Ig(a2), e2 = zg(c2, d2);
      e2.tag = 2;
      void 0 !== b2 && null !== b2 && (e2.callback = b2);
      Ag(a2, e2);
      Jg(a2, d2, c2);
    } };
    function Lg(a2, b2, c2, d2, e2, f2, g2) {
      a2 = a2.stateNode;
      return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Je(c2, d2) || !Je(e2, f2) : true;
    }
    function Mg(a2, b2, c2) {
      var d2 = false, e2 = Cf;
      var f2 = b2.contextType;
      "object" === typeof f2 && null !== f2 ? f2 = vg(f2) : (e2 = Ff(b2) ? Df : M.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Ef(a2, e2) : Cf);
      b2 = new b2(c2, f2);
      a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
      b2.updater = Kg;
      a2.stateNode = b2;
      b2._reactInternals = a2;
      d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f2);
      return b2;
    }
    function Ng(a2, b2, c2, d2) {
      a2 = b2.state;
      "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
      "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
      b2.state !== a2 && Kg.enqueueReplaceState(b2, b2.state, null);
    }
    function Og(a2, b2, c2, d2) {
      var e2 = a2.stateNode;
      e2.props = c2;
      e2.state = a2.memoizedState;
      e2.refs = Fg;
      xg(a2);
      var f2 = b2.contextType;
      "object" === typeof f2 && null !== f2 ? e2.context = vg(f2) : (f2 = Ff(b2) ? Df : M.current, e2.context = Ef(a2, f2));
      Cg(a2, c2, e2, d2);
      e2.state = a2.memoizedState;
      f2 = b2.getDerivedStateFromProps;
      "function" === typeof f2 && (Gg(a2, b2, f2, c2), e2.state = a2.memoizedState);
      "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && Kg.enqueueReplaceState(e2, e2.state, null), Cg(a2, c2, e2, d2), e2.state = a2.memoizedState);
      "function" === typeof e2.componentDidMount && (a2.flags |= 4);
    }
    var Pg = Array.isArray;
    function Qg(a2, b2, c2) {
      a2 = c2.ref;
      if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
        if (c2._owner) {
          c2 = c2._owner;
          if (c2) {
            if (1 !== c2.tag)
              throw Error(y$2(309));
            var d2 = c2.stateNode;
          }
          if (!d2)
            throw Error(y$2(147, a2));
          var e2 = "" + a2;
          if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === e2)
            return b2.ref;
          b2 = function(a3) {
            var b3 = d2.refs;
            b3 === Fg && (b3 = d2.refs = {});
            null === a3 ? delete b3[e2] : b3[e2] = a3;
          };
          b2._stringRef = e2;
          return b2;
        }
        if ("string" !== typeof a2)
          throw Error(y$2(284));
        if (!c2._owner)
          throw Error(y$2(290, a2));
      }
      return a2;
    }
    function Rg(a2, b2) {
      if ("textarea" !== a2.type)
        throw Error(y$2(31, "[object Object]" === Object.prototype.toString.call(b2) ? "object with keys {" + Object.keys(b2).join(", ") + "}" : b2));
    }
    function Sg(a2) {
      function b2(b3, c3) {
        if (a2) {
          var d3 = b3.lastEffect;
          null !== d3 ? (d3.nextEffect = c3, b3.lastEffect = c3) : b3.firstEffect = b3.lastEffect = c3;
          c3.nextEffect = null;
          c3.flags = 8;
        }
      }
      function c2(c3, d3) {
        if (!a2)
          return null;
        for (; null !== d3; )
          b2(c3, d3), d3 = d3.sibling;
        return null;
      }
      function d2(a3, b3) {
        for (a3 = /* @__PURE__ */ new Map(); null !== b3; )
          null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
        return a3;
      }
      function e2(a3, b3) {
        a3 = Tg(a3, b3);
        a3.index = 0;
        a3.sibling = null;
        return a3;
      }
      function f2(b3, c3, d3) {
        b3.index = d3;
        if (!a2)
          return c3;
        d3 = b3.alternate;
        if (null !== d3)
          return d3 = d3.index, d3 < c3 ? (b3.flags = 2, c3) : d3;
        b3.flags = 2;
        return c3;
      }
      function g2(b3) {
        a2 && null === b3.alternate && (b3.flags = 2);
        return b3;
      }
      function h2(a3, b3, c3, d3) {
        if (null === b3 || 6 !== b3.tag)
          return b3 = Ug(c3, a3.mode, d3), b3.return = a3, b3;
        b3 = e2(b3, c3);
        b3.return = a3;
        return b3;
      }
      function k2(a3, b3, c3, d3) {
        if (null !== b3 && b3.elementType === c3.type)
          return d3 = e2(b3, c3.props), d3.ref = Qg(a3, b3, c3), d3.return = a3, d3;
        d3 = Vg(c3.type, c3.key, c3.props, null, a3.mode, d3);
        d3.ref = Qg(a3, b3, c3);
        d3.return = a3;
        return d3;
      }
      function l2(a3, b3, c3, d3) {
        if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
          return b3 = Wg(c3, a3.mode, d3), b3.return = a3, b3;
        b3 = e2(b3, c3.children || []);
        b3.return = a3;
        return b3;
      }
      function n2(a3, b3, c3, d3, f3) {
        if (null === b3 || 7 !== b3.tag)
          return b3 = Xg(c3, a3.mode, d3, f3), b3.return = a3, b3;
        b3 = e2(b3, c3);
        b3.return = a3;
        return b3;
      }
      function A2(a3, b3, c3) {
        if ("string" === typeof b3 || "number" === typeof b3)
          return b3 = Ug("" + b3, a3.mode, c3), b3.return = a3, b3;
        if ("object" === typeof b3 && null !== b3) {
          switch (b3.$$typeof) {
            case sa:
              return c3 = Vg(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = Qg(a3, null, b3), c3.return = a3, c3;
            case ta:
              return b3 = Wg(b3, a3.mode, c3), b3.return = a3, b3;
          }
          if (Pg(b3) || La(b3))
            return b3 = Xg(
              b3,
              a3.mode,
              c3,
              null
            ), b3.return = a3, b3;
          Rg(a3, b3);
        }
        return null;
      }
      function p2(a3, b3, c3, d3) {
        var e3 = null !== b3 ? b3.key : null;
        if ("string" === typeof c3 || "number" === typeof c3)
          return null !== e3 ? null : h2(a3, b3, "" + c3, d3);
        if ("object" === typeof c3 && null !== c3) {
          switch (c3.$$typeof) {
            case sa:
              return c3.key === e3 ? c3.type === ua ? n2(a3, b3, c3.props.children, d3, e3) : k2(a3, b3, c3, d3) : null;
            case ta:
              return c3.key === e3 ? l2(a3, b3, c3, d3) : null;
          }
          if (Pg(c3) || La(c3))
            return null !== e3 ? null : n2(a3, b3, c3, d3, null);
          Rg(a3, c3);
        }
        return null;
      }
      function C2(a3, b3, c3, d3, e3) {
        if ("string" === typeof d3 || "number" === typeof d3)
          return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e3);
        if ("object" === typeof d3 && null !== d3) {
          switch (d3.$$typeof) {
            case sa:
              return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, d3.type === ua ? n2(b3, a3, d3.props.children, e3, d3.key) : k2(b3, a3, d3, e3);
            case ta:
              return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a3, d3, e3);
          }
          if (Pg(d3) || La(d3))
            return a3 = a3.get(c3) || null, n2(b3, a3, d3, e3, null);
          Rg(b3, d3);
        }
        return null;
      }
      function x2(e3, g3, h3, k3) {
        for (var l3 = null, t2 = null, u2 = g3, z2 = g3 = 0, q2 = null; null !== u2 && z2 < h3.length; z2++) {
          u2.index > z2 ? (q2 = u2, u2 = null) : q2 = u2.sibling;
          var n3 = p2(e3, u2, h3[z2], k3);
          if (null === n3) {
            null === u2 && (u2 = q2);
            break;
          }
          a2 && u2 && null === n3.alternate && b2(e3, u2);
          g3 = f2(n3, g3, z2);
          null === t2 ? l3 = n3 : t2.sibling = n3;
          t2 = n3;
          u2 = q2;
        }
        if (z2 === h3.length)
          return c2(e3, u2), l3;
        if (null === u2) {
          for (; z2 < h3.length; z2++)
            u2 = A2(e3, h3[z2], k3), null !== u2 && (g3 = f2(u2, g3, z2), null === t2 ? l3 = u2 : t2.sibling = u2, t2 = u2);
          return l3;
        }
        for (u2 = d2(e3, u2); z2 < h3.length; z2++)
          q2 = C2(u2, e3, z2, h3[z2], k3), null !== q2 && (a2 && null !== q2.alternate && u2.delete(null === q2.key ? z2 : q2.key), g3 = f2(q2, g3, z2), null === t2 ? l3 = q2 : t2.sibling = q2, t2 = q2);
        a2 && u2.forEach(function(a3) {
          return b2(e3, a3);
        });
        return l3;
      }
      function w2(e3, g3, h3, k3) {
        var l3 = La(h3);
        if ("function" !== typeof l3)
          throw Error(y$2(150));
        h3 = l3.call(h3);
        if (null == h3)
          throw Error(y$2(151));
        for (var t2 = l3 = null, u2 = g3, z2 = g3 = 0, q2 = null, n3 = h3.next(); null !== u2 && !n3.done; z2++, n3 = h3.next()) {
          u2.index > z2 ? (q2 = u2, u2 = null) : q2 = u2.sibling;
          var w3 = p2(e3, u2, n3.value, k3);
          if (null === w3) {
            null === u2 && (u2 = q2);
            break;
          }
          a2 && u2 && null === w3.alternate && b2(e3, u2);
          g3 = f2(w3, g3, z2);
          null === t2 ? l3 = w3 : t2.sibling = w3;
          t2 = w3;
          u2 = q2;
        }
        if (n3.done)
          return c2(e3, u2), l3;
        if (null === u2) {
          for (; !n3.done; z2++, n3 = h3.next())
            n3 = A2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, z2), null === t2 ? l3 = n3 : t2.sibling = n3, t2 = n3);
          return l3;
        }
        for (u2 = d2(e3, u2); !n3.done; z2++, n3 = h3.next())
          n3 = C2(u2, e3, z2, n3.value, k3), null !== n3 && (a2 && null !== n3.alternate && u2.delete(null === n3.key ? z2 : n3.key), g3 = f2(n3, g3, z2), null === t2 ? l3 = n3 : t2.sibling = n3, t2 = n3);
        a2 && u2.forEach(function(a3) {
          return b2(e3, a3);
        });
        return l3;
      }
      return function(a3, d3, f3, h3) {
        var k3 = "object" === typeof f3 && null !== f3 && f3.type === ua && null === f3.key;
        k3 && (f3 = f3.props.children);
        var l3 = "object" === typeof f3 && null !== f3;
        if (l3)
          switch (f3.$$typeof) {
            case sa:
              a: {
                l3 = f3.key;
                for (k3 = d3; null !== k3; ) {
                  if (k3.key === l3) {
                    switch (k3.tag) {
                      case 7:
                        if (f3.type === ua) {
                          c2(a3, k3.sibling);
                          d3 = e2(k3, f3.props.children);
                          d3.return = a3;
                          a3 = d3;
                          break a;
                        }
                        break;
                      default:
                        if (k3.elementType === f3.type) {
                          c2(a3, k3.sibling);
                          d3 = e2(k3, f3.props);
                          d3.ref = Qg(a3, k3, f3);
                          d3.return = a3;
                          a3 = d3;
                          break a;
                        }
                    }
                    c2(a3, k3);
                    break;
                  } else
                    b2(a3, k3);
                  k3 = k3.sibling;
                }
                f3.type === ua ? (d3 = Xg(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = Vg(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = Qg(a3, d3, f3), h3.return = a3, a3 = h3);
              }
              return g2(a3);
            case ta:
              a: {
                for (k3 = f3.key; null !== d3; ) {
                  if (d3.key === k3)
                    if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                      c2(a3, d3.sibling);
                      d3 = e2(d3, f3.children || []);
                      d3.return = a3;
                      a3 = d3;
                      break a;
                    } else {
                      c2(a3, d3);
                      break;
                    }
                  else
                    b2(a3, d3);
                  d3 = d3.sibling;
                }
                d3 = Wg(f3, a3.mode, h3);
                d3.return = a3;
                a3 = d3;
              }
              return g2(a3);
          }
        if ("string" === typeof f3 || "number" === typeof f3)
          return f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e2(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = Ug(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3);
        if (Pg(f3))
          return x2(a3, d3, f3, h3);
        if (La(f3))
          return w2(a3, d3, f3, h3);
        l3 && Rg(a3, f3);
        if ("undefined" === typeof f3 && !k3)
          switch (a3.tag) {
            case 1:
            case 22:
            case 0:
            case 11:
            case 15:
              throw Error(y$2(152, Ra(a3.type) || "Component"));
          }
        return c2(a3, d3);
      };
    }
    var Yg = Sg(true), Zg = Sg(false), $g = {}, ah = Bf($g), bh = Bf($g), ch = Bf($g);
    function dh(a2) {
      if (a2 === $g)
        throw Error(y$2(174));
      return a2;
    }
    function eh(a2, b2) {
      I(ch, b2);
      I(bh, a2);
      I(ah, $g);
      a2 = b2.nodeType;
      switch (a2) {
        case 9:
        case 11:
          b2 = (b2 = b2.documentElement) ? b2.namespaceURI : mb(null, "");
          break;
        default:
          a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = mb(b2, a2);
      }
      H$1(ah);
      I(ah, b2);
    }
    function fh() {
      H$1(ah);
      H$1(bh);
      H$1(ch);
    }
    function gh(a2) {
      dh(ch.current);
      var b2 = dh(ah.current);
      var c2 = mb(b2, a2.type);
      b2 !== c2 && (I(bh, a2), I(ah, c2));
    }
    function hh(a2) {
      bh.current === a2 && (H$1(ah), H$1(bh));
    }
    var P$1 = Bf(0);
    function ih(a2) {
      for (var b2 = a2; null !== b2; ) {
        if (13 === b2.tag) {
          var c2 = b2.memoizedState;
          if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
            return b2;
        } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
          if (0 !== (b2.flags & 64))
            return b2;
        } else if (null !== b2.child) {
          b2.child.return = b2;
          b2 = b2.child;
          continue;
        }
        if (b2 === a2)
          break;
        for (; null === b2.sibling; ) {
          if (null === b2.return || b2.return === a2)
            return null;
          b2 = b2.return;
        }
        b2.sibling.return = b2.return;
        b2 = b2.sibling;
      }
      return null;
    }
    var jh = null, kh = null, lh = false;
    function mh(a2, b2) {
      var c2 = nh(5, null, null, 0);
      c2.elementType = "DELETED";
      c2.type = "DELETED";
      c2.stateNode = b2;
      c2.return = a2;
      c2.flags = 8;
      null !== a2.lastEffect ? (a2.lastEffect.nextEffect = c2, a2.lastEffect = c2) : a2.firstEffect = a2.lastEffect = c2;
    }
    function oh(a2, b2) {
      switch (a2.tag) {
        case 5:
          var c2 = a2.type;
          b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
          return null !== b2 ? (a2.stateNode = b2, true) : false;
        case 6:
          return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, true) : false;
        case 13:
          return false;
        default:
          return false;
      }
    }
    function ph(a2) {
      if (lh) {
        var b2 = kh;
        if (b2) {
          var c2 = b2;
          if (!oh(a2, b2)) {
            b2 = rf(c2.nextSibling);
            if (!b2 || !oh(a2, b2)) {
              a2.flags = a2.flags & -1025 | 2;
              lh = false;
              jh = a2;
              return;
            }
            mh(jh, c2);
          }
          jh = a2;
          kh = rf(b2.firstChild);
        } else
          a2.flags = a2.flags & -1025 | 2, lh = false, jh = a2;
      }
    }
    function qh(a2) {
      for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; )
        a2 = a2.return;
      jh = a2;
    }
    function rh(a2) {
      if (a2 !== jh)
        return false;
      if (!lh)
        return qh(a2), lh = true, false;
      var b2 = a2.type;
      if (5 !== a2.tag || "head" !== b2 && "body" !== b2 && !nf(b2, a2.memoizedProps))
        for (b2 = kh; b2; )
          mh(a2, b2), b2 = rf(b2.nextSibling);
      qh(a2);
      if (13 === a2.tag) {
        a2 = a2.memoizedState;
        a2 = null !== a2 ? a2.dehydrated : null;
        if (!a2)
          throw Error(y$2(317));
        a: {
          a2 = a2.nextSibling;
          for (b2 = 0; a2; ) {
            if (8 === a2.nodeType) {
              var c2 = a2.data;
              if ("/$" === c2) {
                if (0 === b2) {
                  kh = rf(a2.nextSibling);
                  break a;
                }
                b2--;
              } else
                "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
            }
            a2 = a2.nextSibling;
          }
          kh = null;
        }
      } else
        kh = jh ? rf(a2.stateNode.nextSibling) : null;
      return true;
    }
    function sh() {
      kh = jh = null;
      lh = false;
    }
    var th = [];
    function uh() {
      for (var a2 = 0; a2 < th.length; a2++)
        th[a2]._workInProgressVersionPrimary = null;
      th.length = 0;
    }
    var vh = ra.ReactCurrentDispatcher, wh = ra.ReactCurrentBatchConfig, xh = 0, R$3 = null, S$1 = null, T$1 = null, yh = false, zh = false;
    function Ah() {
      throw Error(y$2(321));
    }
    function Bh(a2, b2) {
      if (null === b2)
        return false;
      for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++)
        if (!He(a2[c2], b2[c2]))
          return false;
      return true;
    }
    function Ch(a2, b2, c2, d2, e2, f2) {
      xh = f2;
      R$3 = b2;
      b2.memoizedState = null;
      b2.updateQueue = null;
      b2.lanes = 0;
      vh.current = null === a2 || null === a2.memoizedState ? Dh : Eh;
      a2 = c2(d2, e2);
      if (zh) {
        f2 = 0;
        do {
          zh = false;
          if (!(25 > f2))
            throw Error(y$2(301));
          f2 += 1;
          T$1 = S$1 = null;
          b2.updateQueue = null;
          vh.current = Fh;
          a2 = c2(d2, e2);
        } while (zh);
      }
      vh.current = Gh;
      b2 = null !== S$1 && null !== S$1.next;
      xh = 0;
      T$1 = S$1 = R$3 = null;
      yh = false;
      if (b2)
        throw Error(y$2(300));
      return a2;
    }
    function Hh() {
      var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      null === T$1 ? R$3.memoizedState = T$1 = a2 : T$1 = T$1.next = a2;
      return T$1;
    }
    function Ih() {
      if (null === S$1) {
        var a2 = R$3.alternate;
        a2 = null !== a2 ? a2.memoizedState : null;
      } else
        a2 = S$1.next;
      var b2 = null === T$1 ? R$3.memoizedState : T$1.next;
      if (null !== b2)
        T$1 = b2, S$1 = a2;
      else {
        if (null === a2)
          throw Error(y$2(310));
        S$1 = a2;
        a2 = { memoizedState: S$1.memoizedState, baseState: S$1.baseState, baseQueue: S$1.baseQueue, queue: S$1.queue, next: null };
        null === T$1 ? R$3.memoizedState = T$1 = a2 : T$1 = T$1.next = a2;
      }
      return T$1;
    }
    function Jh(a2, b2) {
      return "function" === typeof b2 ? b2(a2) : b2;
    }
    function Kh(a2) {
      var b2 = Ih(), c2 = b2.queue;
      if (null === c2)
        throw Error(y$2(311));
      c2.lastRenderedReducer = a2;
      var d2 = S$1, e2 = d2.baseQueue, f2 = c2.pending;
      if (null !== f2) {
        if (null !== e2) {
          var g2 = e2.next;
          e2.next = f2.next;
          f2.next = g2;
        }
        d2.baseQueue = e2 = f2;
        c2.pending = null;
      }
      if (null !== e2) {
        e2 = e2.next;
        d2 = d2.baseState;
        var h2 = g2 = f2 = null, k2 = e2;
        do {
          var l2 = k2.lane;
          if ((xh & l2) === l2)
            null !== h2 && (h2 = h2.next = { lane: 0, action: k2.action, eagerReducer: k2.eagerReducer, eagerState: k2.eagerState, next: null }), d2 = k2.eagerReducer === a2 ? k2.eagerState : a2(d2, k2.action);
          else {
            var n2 = {
              lane: l2,
              action: k2.action,
              eagerReducer: k2.eagerReducer,
              eagerState: k2.eagerState,
              next: null
            };
            null === h2 ? (g2 = h2 = n2, f2 = d2) : h2 = h2.next = n2;
            R$3.lanes |= l2;
            Dg |= l2;
          }
          k2 = k2.next;
        } while (null !== k2 && k2 !== e2);
        null === h2 ? f2 = d2 : h2.next = g2;
        He(d2, b2.memoizedState) || (ug = true);
        b2.memoizedState = d2;
        b2.baseState = f2;
        b2.baseQueue = h2;
        c2.lastRenderedState = d2;
      }
      return [b2.memoizedState, c2.dispatch];
    }
    function Lh(a2) {
      var b2 = Ih(), c2 = b2.queue;
      if (null === c2)
        throw Error(y$2(311));
      c2.lastRenderedReducer = a2;
      var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
      if (null !== e2) {
        c2.pending = null;
        var g2 = e2 = e2.next;
        do
          f2 = a2(f2, g2.action), g2 = g2.next;
        while (g2 !== e2);
        He(f2, b2.memoizedState) || (ug = true);
        b2.memoizedState = f2;
        null === b2.baseQueue && (b2.baseState = f2);
        c2.lastRenderedState = f2;
      }
      return [f2, d2];
    }
    function Mh(a2, b2, c2) {
      var d2 = b2._getVersion;
      d2 = d2(b2._source);
      var e2 = b2._workInProgressVersionPrimary;
      if (null !== e2)
        a2 = e2 === d2;
      else if (a2 = a2.mutableReadLanes, a2 = (xh & a2) === a2)
        b2._workInProgressVersionPrimary = d2, th.push(b2);
      if (a2)
        return c2(b2._source);
      th.push(b2);
      throw Error(y$2(350));
    }
    function Nh(a2, b2, c2, d2) {
      var e2 = U;
      if (null === e2)
        throw Error(y$2(349));
      var f2 = b2._getVersion, g2 = f2(b2._source), h2 = vh.current, k2 = h2.useState(function() {
        return Mh(e2, b2, c2);
      }), l2 = k2[1], n2 = k2[0];
      k2 = T$1;
      var A2 = a2.memoizedState, p2 = A2.refs, C2 = p2.getSnapshot, x2 = A2.source;
      A2 = A2.subscribe;
      var w2 = R$3;
      a2.memoizedState = { refs: p2, source: b2, subscribe: d2 };
      h2.useEffect(function() {
        p2.getSnapshot = c2;
        p2.setSnapshot = l2;
        var a3 = f2(b2._source);
        if (!He(g2, a3)) {
          a3 = c2(b2._source);
          He(n2, a3) || (l2(a3), a3 = Ig(w2), e2.mutableReadLanes |= a3 & e2.pendingLanes);
          a3 = e2.mutableReadLanes;
          e2.entangledLanes |= a3;
          for (var d3 = e2.entanglements, h3 = a3; 0 < h3; ) {
            var k3 = 31 - Vc(h3), v2 = 1 << k3;
            d3[k3] |= a3;
            h3 &= ~v2;
          }
        }
      }, [c2, b2, d2]);
      h2.useEffect(function() {
        return d2(b2._source, function() {
          var a3 = p2.getSnapshot, c3 = p2.setSnapshot;
          try {
            c3(a3(b2._source));
            var d3 = Ig(w2);
            e2.mutableReadLanes |= d3 & e2.pendingLanes;
          } catch (q2) {
            c3(function() {
              throw q2;
            });
          }
        });
      }, [b2, d2]);
      He(C2, c2) && He(x2, b2) && He(A2, d2) || (a2 = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: n2 }, a2.dispatch = l2 = Oh.bind(null, R$3, a2), k2.queue = a2, k2.baseQueue = null, n2 = Mh(e2, b2, c2), k2.memoizedState = k2.baseState = n2);
      return n2;
    }
    function Ph(a2, b2, c2) {
      var d2 = Ih();
      return Nh(d2, a2, b2, c2);
    }
    function Qh(a2) {
      var b2 = Hh();
      "function" === typeof a2 && (a2 = a2());
      b2.memoizedState = b2.baseState = a2;
      a2 = b2.queue = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: a2 };
      a2 = a2.dispatch = Oh.bind(null, R$3, a2);
      return [b2.memoizedState, a2];
    }
    function Rh(a2, b2, c2, d2) {
      a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null };
      b2 = R$3.updateQueue;
      null === b2 ? (b2 = { lastEffect: null }, R$3.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
      return a2;
    }
    function Sh(a2) {
      var b2 = Hh();
      a2 = { current: a2 };
      return b2.memoizedState = a2;
    }
    function Th() {
      return Ih().memoizedState;
    }
    function Uh(a2, b2, c2, d2) {
      var e2 = Hh();
      R$3.flags |= a2;
      e2.memoizedState = Rh(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
    }
    function Vh(a2, b2, c2, d2) {
      var e2 = Ih();
      d2 = void 0 === d2 ? null : d2;
      var f2 = void 0;
      if (null !== S$1) {
        var g2 = S$1.memoizedState;
        f2 = g2.destroy;
        if (null !== d2 && Bh(d2, g2.deps)) {
          Rh(b2, c2, f2, d2);
          return;
        }
      }
      R$3.flags |= a2;
      e2.memoizedState = Rh(1 | b2, c2, f2, d2);
    }
    function Wh(a2, b2) {
      return Uh(516, 4, a2, b2);
    }
    function Xh(a2, b2) {
      return Vh(516, 4, a2, b2);
    }
    function Yh(a2, b2) {
      return Vh(4, 2, a2, b2);
    }
    function Zh(a2, b2) {
      if ("function" === typeof b2)
        return a2 = a2(), b2(a2), function() {
          b2(null);
        };
      if (null !== b2 && void 0 !== b2)
        return a2 = a2(), b2.current = a2, function() {
          b2.current = null;
        };
    }
    function $h(a2, b2, c2) {
      c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
      return Vh(4, 2, Zh.bind(null, b2, a2), c2);
    }
    function ai() {
    }
    function bi(a2, b2) {
      var c2 = Ih();
      b2 = void 0 === b2 ? null : b2;
      var d2 = c2.memoizedState;
      if (null !== d2 && null !== b2 && Bh(b2, d2[1]))
        return d2[0];
      c2.memoizedState = [a2, b2];
      return a2;
    }
    function ci(a2, b2) {
      var c2 = Ih();
      b2 = void 0 === b2 ? null : b2;
      var d2 = c2.memoizedState;
      if (null !== d2 && null !== b2 && Bh(b2, d2[1]))
        return d2[0];
      a2 = a2();
      c2.memoizedState = [a2, b2];
      return a2;
    }
    function di(a2, b2) {
      var c2 = eg();
      gg(98 > c2 ? 98 : c2, function() {
        a2(true);
      });
      gg(97 < c2 ? 97 : c2, function() {
        var c3 = wh.transition;
        wh.transition = 1;
        try {
          a2(false), b2();
        } finally {
          wh.transition = c3;
        }
      });
    }
    function Oh(a2, b2, c2) {
      var d2 = Hg(), e2 = Ig(a2), f2 = { lane: e2, action: c2, eagerReducer: null, eagerState: null, next: null }, g2 = b2.pending;
      null === g2 ? f2.next = f2 : (f2.next = g2.next, g2.next = f2);
      b2.pending = f2;
      g2 = a2.alternate;
      if (a2 === R$3 || null !== g2 && g2 === R$3)
        zh = yh = true;
      else {
        if (0 === a2.lanes && (null === g2 || 0 === g2.lanes) && (g2 = b2.lastRenderedReducer, null !== g2))
          try {
            var h2 = b2.lastRenderedState, k2 = g2(h2, c2);
            f2.eagerReducer = g2;
            f2.eagerState = k2;
            if (He(k2, h2))
              return;
          } catch (l2) {
          } finally {
          }
        Jg(a2, e2, d2);
      }
    }
    var Gh = { readContext: vg, useCallback: Ah, useContext: Ah, useEffect: Ah, useImperativeHandle: Ah, useLayoutEffect: Ah, useMemo: Ah, useReducer: Ah, useRef: Ah, useState: Ah, useDebugValue: Ah, useDeferredValue: Ah, useTransition: Ah, useMutableSource: Ah, useOpaqueIdentifier: Ah, unstable_isNewReconciler: false }, Dh = { readContext: vg, useCallback: function(a2, b2) {
      Hh().memoizedState = [a2, void 0 === b2 ? null : b2];
      return a2;
    }, useContext: vg, useEffect: Wh, useImperativeHandle: function(a2, b2, c2) {
      c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
      return Uh(4, 2, Zh.bind(
        null,
        b2,
        a2
      ), c2);
    }, useLayoutEffect: function(a2, b2) {
      return Uh(4, 2, a2, b2);
    }, useMemo: function(a2, b2) {
      var c2 = Hh();
      b2 = void 0 === b2 ? null : b2;
      a2 = a2();
      c2.memoizedState = [a2, b2];
      return a2;
    }, useReducer: function(a2, b2, c2) {
      var d2 = Hh();
      b2 = void 0 !== c2 ? c2(b2) : b2;
      d2.memoizedState = d2.baseState = b2;
      a2 = d2.queue = { pending: null, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
      a2 = a2.dispatch = Oh.bind(null, R$3, a2);
      return [d2.memoizedState, a2];
    }, useRef: Sh, useState: Qh, useDebugValue: ai, useDeferredValue: function(a2) {
      var b2 = Qh(a2), c2 = b2[0], d2 = b2[1];
      Wh(function() {
        var b3 = wh.transition;
        wh.transition = 1;
        try {
          d2(a2);
        } finally {
          wh.transition = b3;
        }
      }, [a2]);
      return c2;
    }, useTransition: function() {
      var a2 = Qh(false), b2 = a2[0];
      a2 = di.bind(null, a2[1]);
      Sh(a2);
      return [a2, b2];
    }, useMutableSource: function(a2, b2, c2) {
      var d2 = Hh();
      d2.memoizedState = { refs: { getSnapshot: b2, setSnapshot: null }, source: a2, subscribe: c2 };
      return Nh(d2, a2, b2, c2);
    }, useOpaqueIdentifier: function() {
      if (lh) {
        var a2 = false, b2 = uf(function() {
          a2 || (a2 = true, c2("r:" + (tf++).toString(36)));
          throw Error(y$2(355));
        }), c2 = Qh(b2)[1];
        0 === (R$3.mode & 2) && (R$3.flags |= 516, Rh(
          5,
          function() {
            c2("r:" + (tf++).toString(36));
          },
          void 0,
          null
        ));
        return b2;
      }
      b2 = "r:" + (tf++).toString(36);
      Qh(b2);
      return b2;
    }, unstable_isNewReconciler: false }, Eh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Kh, useRef: Th, useState: function() {
      return Kh(Jh);
    }, useDebugValue: ai, useDeferredValue: function(a2) {
      var b2 = Kh(Jh), c2 = b2[0], d2 = b2[1];
      Xh(function() {
        var b3 = wh.transition;
        wh.transition = 1;
        try {
          d2(a2);
        } finally {
          wh.transition = b3;
        }
      }, [a2]);
      return c2;
    }, useTransition: function() {
      var a2 = Kh(Jh)[0];
      return [
        Th().current,
        a2
      ];
    }, useMutableSource: Ph, useOpaqueIdentifier: function() {
      return Kh(Jh)[0];
    }, unstable_isNewReconciler: false }, Fh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Lh, useRef: Th, useState: function() {
      return Lh(Jh);
    }, useDebugValue: ai, useDeferredValue: function(a2) {
      var b2 = Lh(Jh), c2 = b2[0], d2 = b2[1];
      Xh(function() {
        var b3 = wh.transition;
        wh.transition = 1;
        try {
          d2(a2);
        } finally {
          wh.transition = b3;
        }
      }, [a2]);
      return c2;
    }, useTransition: function() {
      var a2 = Lh(Jh)[0];
      return [
        Th().current,
        a2
      ];
    }, useMutableSource: Ph, useOpaqueIdentifier: function() {
      return Lh(Jh)[0];
    }, unstable_isNewReconciler: false }, ei = ra.ReactCurrentOwner, ug = false;
    function fi(a2, b2, c2, d2) {
      b2.child = null === a2 ? Zg(b2, null, c2, d2) : Yg(b2, a2.child, c2, d2);
    }
    function gi(a2, b2, c2, d2, e2) {
      c2 = c2.render;
      var f2 = b2.ref;
      tg(b2, e2);
      d2 = Ch(a2, b2, c2, d2, f2, e2);
      if (null !== a2 && !ug)
        return b2.updateQueue = a2.updateQueue, b2.flags &= -517, a2.lanes &= ~e2, hi(a2, b2, e2);
      b2.flags |= 1;
      fi(a2, b2, d2, e2);
      return b2.child;
    }
    function ii(a2, b2, c2, d2, e2, f2) {
      if (null === a2) {
        var g2 = c2.type;
        if ("function" === typeof g2 && !ji(g2) && void 0 === g2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
          return b2.tag = 15, b2.type = g2, ki(a2, b2, g2, d2, e2, f2);
        a2 = Vg(c2.type, null, d2, b2, b2.mode, f2);
        a2.ref = b2.ref;
        a2.return = b2;
        return b2.child = a2;
      }
      g2 = a2.child;
      if (0 === (e2 & f2) && (e2 = g2.memoizedProps, c2 = c2.compare, c2 = null !== c2 ? c2 : Je, c2(e2, d2) && a2.ref === b2.ref))
        return hi(a2, b2, f2);
      b2.flags |= 1;
      a2 = Tg(g2, d2);
      a2.ref = b2.ref;
      a2.return = b2;
      return b2.child = a2;
    }
    function ki(a2, b2, c2, d2, e2, f2) {
      if (null !== a2 && Je(a2.memoizedProps, d2) && a2.ref === b2.ref)
        if (ug = false, 0 !== (f2 & e2))
          0 !== (a2.flags & 16384) && (ug = true);
        else
          return b2.lanes = a2.lanes, hi(a2, b2, f2);
      return li(a2, b2, c2, d2, f2);
    }
    function mi(a2, b2, c2) {
      var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a2 ? a2.memoizedState : null;
      if ("hidden" === d2.mode || "unstable-defer-without-hiding" === d2.mode)
        if (0 === (b2.mode & 4))
          b2.memoizedState = { baseLanes: 0 }, ni(b2, c2);
        else if (0 !== (c2 & 1073741824))
          b2.memoizedState = { baseLanes: 0 }, ni(b2, null !== f2 ? f2.baseLanes : c2);
        else
          return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2 }, ni(b2, a2), null;
      else
        null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, ni(b2, d2);
      fi(a2, b2, e2, c2);
      return b2.child;
    }
    function oi(a2, b2) {
      var c2 = b2.ref;
      if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2)
        b2.flags |= 128;
    }
    function li(a2, b2, c2, d2, e2) {
      var f2 = Ff(c2) ? Df : M.current;
      f2 = Ef(b2, f2);
      tg(b2, e2);
      c2 = Ch(a2, b2, c2, d2, f2, e2);
      if (null !== a2 && !ug)
        return b2.updateQueue = a2.updateQueue, b2.flags &= -517, a2.lanes &= ~e2, hi(a2, b2, e2);
      b2.flags |= 1;
      fi(a2, b2, c2, e2);
      return b2.child;
    }
    function pi(a2, b2, c2, d2, e2) {
      if (Ff(c2)) {
        var f2 = true;
        Jf(b2);
      } else
        f2 = false;
      tg(b2, e2);
      if (null === b2.stateNode)
        null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2), Mg(b2, c2, d2), Og(b2, c2, d2, e2), d2 = true;
      else if (null === a2) {
        var g2 = b2.stateNode, h2 = b2.memoizedProps;
        g2.props = h2;
        var k2 = g2.context, l2 = c2.contextType;
        "object" === typeof l2 && null !== l2 ? l2 = vg(l2) : (l2 = Ff(c2) ? Df : M.current, l2 = Ef(b2, l2));
        var n2 = c2.getDerivedStateFromProps, A2 = "function" === typeof n2 || "function" === typeof g2.getSnapshotBeforeUpdate;
        A2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && Ng(b2, g2, d2, l2);
        wg = false;
        var p2 = b2.memoizedState;
        g2.state = p2;
        Cg(b2, d2, g2, e2);
        k2 = b2.memoizedState;
        h2 !== d2 || p2 !== k2 || N.current || wg ? ("function" === typeof n2 && (Gg(b2, c2, n2, d2), k2 = b2.memoizedState), (h2 = wg || Lg(b2, c2, h2, d2, p2, k2, l2)) ? (A2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4), d2 = false);
      } else {
        g2 = b2.stateNode;
        yg(a2, b2);
        h2 = b2.memoizedProps;
        l2 = b2.type === b2.elementType ? h2 : lg(b2.type, h2);
        g2.props = l2;
        A2 = b2.pendingProps;
        p2 = g2.context;
        k2 = c2.contextType;
        "object" === typeof k2 && null !== k2 ? k2 = vg(k2) : (k2 = Ff(c2) ? Df : M.current, k2 = Ef(b2, k2));
        var C2 = c2.getDerivedStateFromProps;
        (n2 = "function" === typeof C2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== A2 || p2 !== k2) && Ng(b2, g2, d2, k2);
        wg = false;
        p2 = b2.memoizedState;
        g2.state = p2;
        Cg(b2, d2, g2, e2);
        var x2 = b2.memoizedState;
        h2 !== A2 || p2 !== x2 || N.current || wg ? ("function" === typeof C2 && (Gg(b2, c2, C2, d2), x2 = b2.memoizedState), (l2 = wg || Lg(b2, c2, l2, d2, p2, x2, k2)) ? (n2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(
          d2,
          x2,
          k2
        ), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, x2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 256)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && p2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && p2 === a2.memoizedState || (b2.flags |= 256), b2.memoizedProps = d2, b2.memoizedState = x2), g2.props = d2, g2.state = x2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && p2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && p2 === a2.memoizedState || (b2.flags |= 256), d2 = false);
      }
      return qi(a2, b2, c2, d2, f2, e2);
    }
    function qi(a2, b2, c2, d2, e2, f2) {
      oi(a2, b2);
      var g2 = 0 !== (b2.flags & 64);
      if (!d2 && !g2)
        return e2 && Kf(b2, c2, false), hi(a2, b2, f2);
      d2 = b2.stateNode;
      ei.current = b2;
      var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
      b2.flags |= 1;
      null !== a2 && g2 ? (b2.child = Yg(b2, a2.child, null, f2), b2.child = Yg(b2, null, h2, f2)) : fi(a2, b2, h2, f2);
      b2.memoizedState = d2.state;
      e2 && Kf(b2, c2, true);
      return b2.child;
    }
    function ri(a2) {
      var b2 = a2.stateNode;
      b2.pendingContext ? Hf(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && Hf(a2, b2.context, false);
      eh(a2, b2.containerInfo);
    }
    var si = { dehydrated: null, retryLane: 0 };
    function ti(a2, b2, c2) {
      var d2 = b2.pendingProps, e2 = P$1.current, f2 = false, g2;
      (g2 = 0 !== (b2.flags & 64)) || (g2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e2 & 2));
      g2 ? (f2 = true, b2.flags &= -65) : null !== a2 && null === a2.memoizedState || void 0 === d2.fallback || true === d2.unstable_avoidThisFallback || (e2 |= 1);
      I(P$1, e2 & 1);
      if (null === a2) {
        void 0 !== d2.fallback && ph(b2);
        a2 = d2.children;
        e2 = d2.fallback;
        if (f2)
          return a2 = ui(b2, a2, e2, c2), b2.child.memoizedState = { baseLanes: c2 }, b2.memoizedState = si, a2;
        if ("number" === typeof d2.unstable_expectedLoadTime)
          return a2 = ui(b2, a2, e2, c2), b2.child.memoizedState = { baseLanes: c2 }, b2.memoizedState = si, b2.lanes = 33554432, a2;
        c2 = vi({ mode: "visible", children: a2 }, b2.mode, c2, null);
        c2.return = b2;
        return b2.child = c2;
      }
      if (null !== a2.memoizedState) {
        if (f2)
          return d2 = wi(a2, b2, d2.children, d2.fallback, c2), f2 = b2.child, e2 = a2.child.memoizedState, f2.memoizedState = null === e2 ? { baseLanes: c2 } : { baseLanes: e2.baseLanes | c2 }, f2.childLanes = a2.childLanes & ~c2, b2.memoizedState = si, d2;
        c2 = xi(a2, b2, d2.children, c2);
        b2.memoizedState = null;
        return c2;
      }
      if (f2)
        return d2 = wi(a2, b2, d2.children, d2.fallback, c2), f2 = b2.child, e2 = a2.child.memoizedState, f2.memoizedState = null === e2 ? { baseLanes: c2 } : { baseLanes: e2.baseLanes | c2 }, f2.childLanes = a2.childLanes & ~c2, b2.memoizedState = si, d2;
      c2 = xi(a2, b2, d2.children, c2);
      b2.memoizedState = null;
      return c2;
    }
    function ui(a2, b2, c2, d2) {
      var e2 = a2.mode, f2 = a2.child;
      b2 = { mode: "hidden", children: b2 };
      0 === (e2 & 2) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = b2) : f2 = vi(b2, e2, 0, null);
      c2 = Xg(c2, e2, d2, null);
      f2.return = a2;
      c2.return = a2;
      f2.sibling = c2;
      a2.child = f2;
      return c2;
    }
    function xi(a2, b2, c2, d2) {
      var e2 = a2.child;
      a2 = e2.sibling;
      c2 = Tg(e2, { mode: "visible", children: c2 });
      0 === (b2.mode & 2) && (c2.lanes = d2);
      c2.return = b2;
      c2.sibling = null;
      null !== a2 && (a2.nextEffect = null, a2.flags = 8, b2.firstEffect = b2.lastEffect = a2);
      return b2.child = c2;
    }
    function wi(a2, b2, c2, d2, e2) {
      var f2 = b2.mode, g2 = a2.child;
      a2 = g2.sibling;
      var h2 = { mode: "hidden", children: c2 };
      0 === (f2 & 2) && b2.child !== g2 ? (c2 = b2.child, c2.childLanes = 0, c2.pendingProps = h2, g2 = c2.lastEffect, null !== g2 ? (b2.firstEffect = c2.firstEffect, b2.lastEffect = g2, g2.nextEffect = null) : b2.firstEffect = b2.lastEffect = null) : c2 = Tg(g2, h2);
      null !== a2 ? d2 = Tg(a2, d2) : (d2 = Xg(d2, f2, e2, null), d2.flags |= 2);
      d2.return = b2;
      c2.return = b2;
      c2.sibling = d2;
      b2.child = c2;
      return d2;
    }
    function yi(a2, b2) {
      a2.lanes |= b2;
      var c2 = a2.alternate;
      null !== c2 && (c2.lanes |= b2);
      sg(a2.return, b2);
    }
    function zi(a2, b2, c2, d2, e2, f2) {
      var g2 = a2.memoizedState;
      null === g2 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2, lastEffect: f2 } : (g2.isBackwards = b2, g2.rendering = null, g2.renderingStartTime = 0, g2.last = d2, g2.tail = c2, g2.tailMode = e2, g2.lastEffect = f2);
    }
    function Ai(a2, b2, c2) {
      var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
      fi(a2, b2, d2.children, c2);
      d2 = P$1.current;
      if (0 !== (d2 & 2))
        d2 = d2 & 1 | 2, b2.flags |= 64;
      else {
        if (null !== a2 && 0 !== (a2.flags & 64))
          a:
            for (a2 = b2.child; null !== a2; ) {
              if (13 === a2.tag)
                null !== a2.memoizedState && yi(a2, c2);
              else if (19 === a2.tag)
                yi(a2, c2);
              else if (null !== a2.child) {
                a2.child.return = a2;
                a2 = a2.child;
                continue;
              }
              if (a2 === b2)
                break a;
              for (; null === a2.sibling; ) {
                if (null === a2.return || a2.return === b2)
                  break a;
                a2 = a2.return;
              }
              a2.sibling.return = a2.return;
              a2 = a2.sibling;
            }
        d2 &= 1;
      }
      I(P$1, d2);
      if (0 === (b2.mode & 2))
        b2.memoizedState = null;
      else
        switch (e2) {
          case "forwards":
            c2 = b2.child;
            for (e2 = null; null !== c2; )
              a2 = c2.alternate, null !== a2 && null === ih(a2) && (e2 = c2), c2 = c2.sibling;
            c2 = e2;
            null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
            zi(b2, false, e2, c2, f2, b2.lastEffect);
            break;
          case "backwards":
            c2 = null;
            e2 = b2.child;
            for (b2.child = null; null !== e2; ) {
              a2 = e2.alternate;
              if (null !== a2 && null === ih(a2)) {
                b2.child = e2;
                break;
              }
              a2 = e2.sibling;
              e2.sibling = c2;
              c2 = e2;
              e2 = a2;
            }
            zi(b2, true, c2, null, f2, b2.lastEffect);
            break;
          case "together":
            zi(b2, false, null, null, void 0, b2.lastEffect);
            break;
          default:
            b2.memoizedState = null;
        }
      return b2.child;
    }
    function hi(a2, b2, c2) {
      null !== a2 && (b2.dependencies = a2.dependencies);
      Dg |= b2.lanes;
      if (0 !== (c2 & b2.childLanes)) {
        if (null !== a2 && b2.child !== a2.child)
          throw Error(y$2(153));
        if (null !== b2.child) {
          a2 = b2.child;
          c2 = Tg(a2, a2.pendingProps);
          b2.child = c2;
          for (c2.return = b2; null !== a2.sibling; )
            a2 = a2.sibling, c2 = c2.sibling = Tg(a2, a2.pendingProps), c2.return = b2;
          c2.sibling = null;
        }
        return b2.child;
      }
      return null;
    }
    var Bi, Ci, Di, Ei;
    Bi = function(a2, b2) {
      for (var c2 = b2.child; null !== c2; ) {
        if (5 === c2.tag || 6 === c2.tag)
          a2.appendChild(c2.stateNode);
        else if (4 !== c2.tag && null !== c2.child) {
          c2.child.return = c2;
          c2 = c2.child;
          continue;
        }
        if (c2 === b2)
          break;
        for (; null === c2.sibling; ) {
          if (null === c2.return || c2.return === b2)
            return;
          c2 = c2.return;
        }
        c2.sibling.return = c2.return;
        c2 = c2.sibling;
      }
    };
    Ci = function() {
    };
    Di = function(a2, b2, c2, d2) {
      var e2 = a2.memoizedProps;
      if (e2 !== d2) {
        a2 = b2.stateNode;
        dh(ah.current);
        var f2 = null;
        switch (c2) {
          case "input":
            e2 = Ya(a2, e2);
            d2 = Ya(a2, d2);
            f2 = [];
            break;
          case "option":
            e2 = eb(a2, e2);
            d2 = eb(a2, d2);
            f2 = [];
            break;
          case "select":
            e2 = m$4({}, e2, { value: void 0 });
            d2 = m$4({}, d2, { value: void 0 });
            f2 = [];
            break;
          case "textarea":
            e2 = gb(a2, e2);
            d2 = gb(a2, d2);
            f2 = [];
            break;
          default:
            "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a2.onclick = jf);
        }
        vb(c2, d2);
        var g2;
        c2 = null;
        for (l2 in e2)
          if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
            if ("style" === l2) {
              var h2 = e2[l2];
              for (g2 in h2)
                h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
            } else
              "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ca.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
        for (l2 in d2) {
          var k2 = d2[l2];
          h2 = null != e2 ? e2[l2] : void 0;
          if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
            if ("style" === l2)
              if (h2) {
                for (g2 in h2)
                  !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
                for (g2 in k2)
                  k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
              } else
                c2 || (f2 || (f2 = []), f2.push(l2, c2)), c2 = k2;
            else
              "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ca.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && G("scroll", a2), f2 || h2 === k2 || (f2 = [])) : "object" === typeof k2 && null !== k2 && k2.$$typeof === Ga ? k2.toString() : (f2 = f2 || []).push(l2, k2));
        }
        c2 && (f2 = f2 || []).push(
          "style",
          c2
        );
        var l2 = f2;
        if (b2.updateQueue = l2)
          b2.flags |= 4;
      }
    };
    Ei = function(a2, b2, c2, d2) {
      c2 !== d2 && (b2.flags |= 4);
    };
    function Fi(a2, b2) {
      if (!lh)
        switch (a2.tailMode) {
          case "hidden":
            b2 = a2.tail;
            for (var c2 = null; null !== b2; )
              null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
            null === c2 ? a2.tail = null : c2.sibling = null;
            break;
          case "collapsed":
            c2 = a2.tail;
            for (var d2 = null; null !== c2; )
              null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
            null === d2 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
        }
    }
    function Gi(a2, b2, c2) {
      var d2 = b2.pendingProps;
      switch (b2.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return null;
        case 1:
          return Ff(b2.type) && Gf(), null;
        case 3:
          fh();
          H$1(N);
          H$1(M);
          uh();
          d2 = b2.stateNode;
          d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
          if (null === a2 || null === a2.child)
            rh(b2) ? b2.flags |= 4 : d2.hydrate || (b2.flags |= 256);
          Ci(b2);
          return null;
        case 5:
          hh(b2);
          var e2 = dh(ch.current);
          c2 = b2.type;
          if (null !== a2 && null != b2.stateNode)
            Di(a2, b2, c2, d2, e2), a2.ref !== b2.ref && (b2.flags |= 128);
          else {
            if (!d2) {
              if (null === b2.stateNode)
                throw Error(y$2(166));
              return null;
            }
            a2 = dh(ah.current);
            if (rh(b2)) {
              d2 = b2.stateNode;
              c2 = b2.type;
              var f2 = b2.memoizedProps;
              d2[wf] = b2;
              d2[xf] = f2;
              switch (c2) {
                case "dialog":
                  G("cancel", d2);
                  G("close", d2);
                  break;
                case "iframe":
                case "object":
                case "embed":
                  G("load", d2);
                  break;
                case "video":
                case "audio":
                  for (a2 = 0; a2 < Xe.length; a2++)
                    G(Xe[a2], d2);
                  break;
                case "source":
                  G("error", d2);
                  break;
                case "img":
                case "image":
                case "link":
                  G("error", d2);
                  G("load", d2);
                  break;
                case "details":
                  G("toggle", d2);
                  break;
                case "input":
                  Za(d2, f2);
                  G("invalid", d2);
                  break;
                case "select":
                  d2._wrapperState = { wasMultiple: !!f2.multiple };
                  G("invalid", d2);
                  break;
                case "textarea":
                  hb(d2, f2), G("invalid", d2);
              }
              vb(c2, f2);
              a2 = null;
              for (var g2 in f2)
                f2.hasOwnProperty(g2) && (e2 = f2[g2], "children" === g2 ? "string" === typeof e2 ? d2.textContent !== e2 && (a2 = ["children", e2]) : "number" === typeof e2 && d2.textContent !== "" + e2 && (a2 = ["children", "" + e2]) : ca.hasOwnProperty(g2) && null != e2 && "onScroll" === g2 && G("scroll", d2));
              switch (c2) {
                case "input":
                  Va(d2);
                  cb(d2, f2, true);
                  break;
                case "textarea":
                  Va(d2);
                  jb(d2);
                  break;
                case "select":
                case "option":
                  break;
                default:
                  "function" === typeof f2.onClick && (d2.onclick = jf);
              }
              d2 = a2;
              b2.updateQueue = d2;
              null !== d2 && (b2.flags |= 4);
            } else {
              g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
              a2 === kb.html && (a2 = lb(c2));
              a2 === kb.html ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2);
              a2[wf] = b2;
              a2[xf] = d2;
              Bi(a2, b2, false, false);
              b2.stateNode = a2;
              g2 = wb(c2, d2);
              switch (c2) {
                case "dialog":
                  G("cancel", a2);
                  G("close", a2);
                  e2 = d2;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  G("load", a2);
                  e2 = d2;
                  break;
                case "video":
                case "audio":
                  for (e2 = 0; e2 < Xe.length; e2++)
                    G(Xe[e2], a2);
                  e2 = d2;
                  break;
                case "source":
                  G("error", a2);
                  e2 = d2;
                  break;
                case "img":
                case "image":
                case "link":
                  G("error", a2);
                  G("load", a2);
                  e2 = d2;
                  break;
                case "details":
                  G("toggle", a2);
                  e2 = d2;
                  break;
                case "input":
                  Za(a2, d2);
                  e2 = Ya(a2, d2);
                  G("invalid", a2);
                  break;
                case "option":
                  e2 = eb(a2, d2);
                  break;
                case "select":
                  a2._wrapperState = { wasMultiple: !!d2.multiple };
                  e2 = m$4({}, d2, { value: void 0 });
                  G("invalid", a2);
                  break;
                case "textarea":
                  hb(a2, d2);
                  e2 = gb(a2, d2);
                  G("invalid", a2);
                  break;
                default:
                  e2 = d2;
              }
              vb(c2, e2);
              var h2 = e2;
              for (f2 in h2)
                if (h2.hasOwnProperty(f2)) {
                  var k2 = h2[f2];
                  "style" === f2 ? tb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && ob(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && pb(a2, k2) : "number" === typeof k2 && pb(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ca.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && G("scroll", a2) : null != k2 && qa(a2, f2, k2, g2));
                }
              switch (c2) {
                case "input":
                  Va(a2);
                  cb(a2, d2, false);
                  break;
                case "textarea":
                  Va(a2);
                  jb(a2);
                  break;
                case "option":
                  null != d2.value && a2.setAttribute("value", "" + Sa(d2.value));
                  break;
                case "select":
                  a2.multiple = !!d2.multiple;
                  f2 = d2.value;
                  null != f2 ? fb(a2, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(a2, !!d2.multiple, d2.defaultValue, true);
                  break;
                default:
                  "function" === typeof e2.onClick && (a2.onclick = jf);
              }
              mf(c2, d2) && (b2.flags |= 4);
            }
            null !== b2.ref && (b2.flags |= 128);
          }
          return null;
        case 6:
          if (a2 && null != b2.stateNode)
            Ei(a2, b2, a2.memoizedProps, d2);
          else {
            if ("string" !== typeof d2 && null === b2.stateNode)
              throw Error(y$2(166));
            c2 = dh(ch.current);
            dh(ah.current);
            rh(b2) ? (d2 = b2.stateNode, c2 = b2.memoizedProps, d2[wf] = b2, d2.nodeValue !== c2 && (b2.flags |= 4)) : (d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[wf] = b2, b2.stateNode = d2);
          }
          return null;
        case 13:
          H$1(P$1);
          d2 = b2.memoizedState;
          if (0 !== (b2.flags & 64))
            return b2.lanes = c2, b2;
          d2 = null !== d2;
          c2 = false;
          null === a2 ? void 0 !== b2.memoizedProps.fallback && rh(b2) : c2 = null !== a2.memoizedState;
          if (d2 && !c2 && 0 !== (b2.mode & 2))
            if (null === a2 && true !== b2.memoizedProps.unstable_avoidThisFallback || 0 !== (P$1.current & 1))
              0 === V$1 && (V$1 = 3);
            else {
              if (0 === V$1 || 3 === V$1)
                V$1 = 4;
              null === U || 0 === (Dg & 134217727) && 0 === (Hi & 134217727) || Ii(U, W$1);
            }
          if (d2 || c2)
            b2.flags |= 4;
          return null;
        case 4:
          return fh(), Ci(b2), null === a2 && cf(b2.stateNode.containerInfo), null;
        case 10:
          return rg(b2), null;
        case 17:
          return Ff(b2.type) && Gf(), null;
        case 19:
          H$1(P$1);
          d2 = b2.memoizedState;
          if (null === d2)
            return null;
          f2 = 0 !== (b2.flags & 64);
          g2 = d2.rendering;
          if (null === g2)
            if (f2)
              Fi(d2, false);
            else {
              if (0 !== V$1 || null !== a2 && 0 !== (a2.flags & 64))
                for (a2 = b2.child; null !== a2; ) {
                  g2 = ih(a2);
                  if (null !== g2) {
                    b2.flags |= 64;
                    Fi(d2, false);
                    f2 = g2.updateQueue;
                    null !== f2 && (b2.updateQueue = f2, b2.flags |= 4);
                    null === d2.lastEffect && (b2.firstEffect = null);
                    b2.lastEffect = d2.lastEffect;
                    d2 = c2;
                    for (c2 = b2.child; null !== c2; )
                      f2 = c2, a2 = d2, f2.flags &= 2, f2.nextEffect = null, f2.firstEffect = null, f2.lastEffect = null, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
                    I(P$1, P$1.current & 1 | 2);
                    return b2.child;
                  }
                  a2 = a2.sibling;
                }
              null !== d2.tail && O$2() > Ji && (b2.flags |= 64, f2 = true, Fi(d2, false), b2.lanes = 33554432);
            }
          else {
            if (!f2)
              if (a2 = ih(g2), null !== a2) {
                if (b2.flags |= 64, f2 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Fi(d2, true), null === d2.tail && "hidden" === d2.tailMode && !g2.alternate && !lh)
                  return b2 = b2.lastEffect = d2.lastEffect, null !== b2 && (b2.nextEffect = null), null;
              } else
                2 * O$2() - d2.renderingStartTime > Ji && 1073741824 !== c2 && (b2.flags |= 64, f2 = true, Fi(d2, false), b2.lanes = 33554432);
            d2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = d2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, d2.last = g2);
          }
          return null !== d2.tail ? (c2 = d2.tail, d2.rendering = c2, d2.tail = c2.sibling, d2.lastEffect = b2.lastEffect, d2.renderingStartTime = O$2(), c2.sibling = null, b2 = P$1.current, I(P$1, f2 ? b2 & 1 | 2 : b2 & 1), c2) : null;
        case 23:
        case 24:
          return Ki(), null !== a2 && null !== a2.memoizedState !== (null !== b2.memoizedState) && "unstable-defer-without-hiding" !== d2.mode && (b2.flags |= 4), null;
      }
      throw Error(y$2(156, b2.tag));
    }
    function Li(a2) {
      switch (a2.tag) {
        case 1:
          Ff(a2.type) && Gf();
          var b2 = a2.flags;
          return b2 & 4096 ? (a2.flags = b2 & -4097 | 64, a2) : null;
        case 3:
          fh();
          H$1(N);
          H$1(M);
          uh();
          b2 = a2.flags;
          if (0 !== (b2 & 64))
            throw Error(y$2(285));
          a2.flags = b2 & -4097 | 64;
          return a2;
        case 5:
          return hh(a2), null;
        case 13:
          return H$1(P$1), b2 = a2.flags, b2 & 4096 ? (a2.flags = b2 & -4097 | 64, a2) : null;
        case 19:
          return H$1(P$1), null;
        case 4:
          return fh(), null;
        case 10:
          return rg(a2), null;
        case 23:
        case 24:
          return Ki(), null;
        default:
          return null;
      }
    }
    function Mi(a2, b2) {
      try {
        var c2 = "", d2 = b2;
        do
          c2 += Qa(d2), d2 = d2.return;
        while (d2);
        var e2 = c2;
      } catch (f2) {
        e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
      }
      return { value: a2, source: b2, stack: e2 };
    }
    function Ni(a2, b2) {
      try {
        console.error(b2.value);
      } catch (c2) {
        setTimeout(function() {
          throw c2;
        });
      }
    }
    var Oi = "function" === typeof WeakMap ? WeakMap : Map;
    function Pi(a2, b2, c2) {
      c2 = zg(-1, c2);
      c2.tag = 3;
      c2.payload = { element: null };
      var d2 = b2.value;
      c2.callback = function() {
        Qi || (Qi = true, Ri = d2);
        Ni(a2, b2);
      };
      return c2;
    }
    function Si(a2, b2, c2) {
      c2 = zg(-1, c2);
      c2.tag = 3;
      var d2 = a2.type.getDerivedStateFromError;
      if ("function" === typeof d2) {
        var e2 = b2.value;
        c2.payload = function() {
          Ni(a2, b2);
          return d2(e2);
        };
      }
      var f2 = a2.stateNode;
      null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
        "function" !== typeof d2 && (null === Ti ? Ti = /* @__PURE__ */ new Set([this]) : Ti.add(this), Ni(a2, b2));
        var c3 = b2.stack;
        this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
      });
      return c2;
    }
    var Ui = "function" === typeof WeakSet ? WeakSet : Set;
    function Vi(a2) {
      var b2 = a2.ref;
      if (null !== b2)
        if ("function" === typeof b2)
          try {
            b2(null);
          } catch (c2) {
            Wi(a2, c2);
          }
        else
          b2.current = null;
    }
    function Xi(a2, b2) {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
        case 22:
          return;
        case 1:
          if (b2.flags & 256 && null !== a2) {
            var c2 = a2.memoizedProps, d2 = a2.memoizedState;
            a2 = b2.stateNode;
            b2 = a2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? c2 : lg(b2.type, c2), d2);
            a2.__reactInternalSnapshotBeforeUpdate = b2;
          }
          return;
        case 3:
          b2.flags & 256 && qf(b2.stateNode.containerInfo);
          return;
        case 5:
        case 6:
        case 4:
        case 17:
          return;
      }
      throw Error(y$2(163));
    }
    function Yi(a2, b2, c2) {
      switch (c2.tag) {
        case 0:
        case 11:
        case 15:
        case 22:
          b2 = c2.updateQueue;
          b2 = null !== b2 ? b2.lastEffect : null;
          if (null !== b2) {
            a2 = b2 = b2.next;
            do {
              if (3 === (a2.tag & 3)) {
                var d2 = a2.create;
                a2.destroy = d2();
              }
              a2 = a2.next;
            } while (a2 !== b2);
          }
          b2 = c2.updateQueue;
          b2 = null !== b2 ? b2.lastEffect : null;
          if (null !== b2) {
            a2 = b2 = b2.next;
            do {
              var e2 = a2;
              d2 = e2.next;
              e2 = e2.tag;
              0 !== (e2 & 4) && 0 !== (e2 & 1) && (Zi(c2, a2), $i(c2, a2));
              a2 = d2;
            } while (a2 !== b2);
          }
          return;
        case 1:
          a2 = c2.stateNode;
          c2.flags & 4 && (null === b2 ? a2.componentDidMount() : (d2 = c2.elementType === c2.type ? b2.memoizedProps : lg(c2.type, b2.memoizedProps), a2.componentDidUpdate(
            d2,
            b2.memoizedState,
            a2.__reactInternalSnapshotBeforeUpdate
          )));
          b2 = c2.updateQueue;
          null !== b2 && Eg(c2, b2, a2);
          return;
        case 3:
          b2 = c2.updateQueue;
          if (null !== b2) {
            a2 = null;
            if (null !== c2.child)
              switch (c2.child.tag) {
                case 5:
                  a2 = c2.child.stateNode;
                  break;
                case 1:
                  a2 = c2.child.stateNode;
              }
            Eg(c2, b2, a2);
          }
          return;
        case 5:
          a2 = c2.stateNode;
          null === b2 && c2.flags & 4 && mf(c2.type, c2.memoizedProps) && a2.focus();
          return;
        case 6:
          return;
        case 4:
          return;
        case 12:
          return;
        case 13:
          null === c2.memoizedState && (c2 = c2.alternate, null !== c2 && (c2 = c2.memoizedState, null !== c2 && (c2 = c2.dehydrated, null !== c2 && Cc(c2))));
          return;
        case 19:
        case 17:
        case 20:
        case 21:
        case 23:
        case 24:
          return;
      }
      throw Error(y$2(163));
    }
    function aj(a2, b2) {
      for (var c2 = a2; ; ) {
        if (5 === c2.tag) {
          var d2 = c2.stateNode;
          if (b2)
            d2 = d2.style, "function" === typeof d2.setProperty ? d2.setProperty("display", "none", "important") : d2.display = "none";
          else {
            d2 = c2.stateNode;
            var e2 = c2.memoizedProps.style;
            e2 = void 0 !== e2 && null !== e2 && e2.hasOwnProperty("display") ? e2.display : null;
            d2.style.display = sb("display", e2);
          }
        } else if (6 === c2.tag)
          c2.stateNode.nodeValue = b2 ? "" : c2.memoizedProps;
        else if ((23 !== c2.tag && 24 !== c2.tag || null === c2.memoizedState || c2 === a2) && null !== c2.child) {
          c2.child.return = c2;
          c2 = c2.child;
          continue;
        }
        if (c2 === a2)
          break;
        for (; null === c2.sibling; ) {
          if (null === c2.return || c2.return === a2)
            return;
          c2 = c2.return;
        }
        c2.sibling.return = c2.return;
        c2 = c2.sibling;
      }
    }
    function bj(a2, b2) {
      if (Mf && "function" === typeof Mf.onCommitFiberUnmount)
        try {
          Mf.onCommitFiberUnmount(Lf, b2);
        } catch (f2) {
        }
      switch (b2.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
        case 22:
          a2 = b2.updateQueue;
          if (null !== a2 && (a2 = a2.lastEffect, null !== a2)) {
            var c2 = a2 = a2.next;
            do {
              var d2 = c2, e2 = d2.destroy;
              d2 = d2.tag;
              if (void 0 !== e2)
                if (0 !== (d2 & 4))
                  Zi(b2, c2);
                else {
                  d2 = b2;
                  try {
                    e2();
                  } catch (f2) {
                    Wi(d2, f2);
                  }
                }
              c2 = c2.next;
            } while (c2 !== a2);
          }
          break;
        case 1:
          Vi(b2);
          a2 = b2.stateNode;
          if ("function" === typeof a2.componentWillUnmount)
            try {
              a2.props = b2.memoizedProps, a2.state = b2.memoizedState, a2.componentWillUnmount();
            } catch (f2) {
              Wi(
                b2,
                f2
              );
            }
          break;
        case 5:
          Vi(b2);
          break;
        case 4:
          cj(a2, b2);
      }
    }
    function dj(a2) {
      a2.alternate = null;
      a2.child = null;
      a2.dependencies = null;
      a2.firstEffect = null;
      a2.lastEffect = null;
      a2.memoizedProps = null;
      a2.memoizedState = null;
      a2.pendingProps = null;
      a2.return = null;
      a2.updateQueue = null;
    }
    function ej(a2) {
      return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
    }
    function fj(a2) {
      a: {
        for (var b2 = a2.return; null !== b2; ) {
          if (ej(b2))
            break a;
          b2 = b2.return;
        }
        throw Error(y$2(160));
      }
      var c2 = b2;
      b2 = c2.stateNode;
      switch (c2.tag) {
        case 5:
          var d2 = false;
          break;
        case 3:
          b2 = b2.containerInfo;
          d2 = true;
          break;
        case 4:
          b2 = b2.containerInfo;
          d2 = true;
          break;
        default:
          throw Error(y$2(161));
      }
      c2.flags & 16 && (pb(b2, ""), c2.flags &= -17);
      a:
        b:
          for (c2 = a2; ; ) {
            for (; null === c2.sibling; ) {
              if (null === c2.return || ej(c2.return)) {
                c2 = null;
                break a;
              }
              c2 = c2.return;
            }
            c2.sibling.return = c2.return;
            for (c2 = c2.sibling; 5 !== c2.tag && 6 !== c2.tag && 18 !== c2.tag; ) {
              if (c2.flags & 2)
                continue b;
              if (null === c2.child || 4 === c2.tag)
                continue b;
              else
                c2.child.return = c2, c2 = c2.child;
            }
            if (!(c2.flags & 2)) {
              c2 = c2.stateNode;
              break a;
            }
          }
      d2 ? gj(a2, c2, b2) : hj(a2, c2, b2);
    }
    function gj(a2, b2, c2) {
      var d2 = a2.tag, e2 = 5 === d2 || 6 === d2;
      if (e2)
        a2 = e2 ? a2.stateNode : a2.stateNode.instance, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = jf));
      else if (4 !== d2 && (a2 = a2.child, null !== a2))
        for (gj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
          gj(a2, b2, c2), a2 = a2.sibling;
    }
    function hj(a2, b2, c2) {
      var d2 = a2.tag, e2 = 5 === d2 || 6 === d2;
      if (e2)
        a2 = e2 ? a2.stateNode : a2.stateNode.instance, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
      else if (4 !== d2 && (a2 = a2.child, null !== a2))
        for (hj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
          hj(a2, b2, c2), a2 = a2.sibling;
    }
    function cj(a2, b2) {
      for (var c2 = b2, d2 = false, e2, f2; ; ) {
        if (!d2) {
          d2 = c2.return;
          a:
            for (; ; ) {
              if (null === d2)
                throw Error(y$2(160));
              e2 = d2.stateNode;
              switch (d2.tag) {
                case 5:
                  f2 = false;
                  break a;
                case 3:
                  e2 = e2.containerInfo;
                  f2 = true;
                  break a;
                case 4:
                  e2 = e2.containerInfo;
                  f2 = true;
                  break a;
              }
              d2 = d2.return;
            }
          d2 = true;
        }
        if (5 === c2.tag || 6 === c2.tag) {
          a:
            for (var g2 = a2, h2 = c2, k2 = h2; ; )
              if (bj(g2, k2), null !== k2.child && 4 !== k2.tag)
                k2.child.return = k2, k2 = k2.child;
              else {
                if (k2 === h2)
                  break a;
                for (; null === k2.sibling; ) {
                  if (null === k2.return || k2.return === h2)
                    break a;
                  k2 = k2.return;
                }
                k2.sibling.return = k2.return;
                k2 = k2.sibling;
              }
          f2 ? (g2 = e2, h2 = c2.stateNode, 8 === g2.nodeType ? g2.parentNode.removeChild(h2) : g2.removeChild(h2)) : e2.removeChild(c2.stateNode);
        } else if (4 === c2.tag) {
          if (null !== c2.child) {
            e2 = c2.stateNode.containerInfo;
            f2 = true;
            c2.child.return = c2;
            c2 = c2.child;
            continue;
          }
        } else if (bj(a2, c2), null !== c2.child) {
          c2.child.return = c2;
          c2 = c2.child;
          continue;
        }
        if (c2 === b2)
          break;
        for (; null === c2.sibling; ) {
          if (null === c2.return || c2.return === b2)
            return;
          c2 = c2.return;
          4 === c2.tag && (d2 = false);
        }
        c2.sibling.return = c2.return;
        c2 = c2.sibling;
      }
    }
    function ij(a2, b2) {
      switch (b2.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
        case 22:
          var c2 = b2.updateQueue;
          c2 = null !== c2 ? c2.lastEffect : null;
          if (null !== c2) {
            var d2 = c2 = c2.next;
            do
              3 === (d2.tag & 3) && (a2 = d2.destroy, d2.destroy = void 0, void 0 !== a2 && a2()), d2 = d2.next;
            while (d2 !== c2);
          }
          return;
        case 1:
          return;
        case 5:
          c2 = b2.stateNode;
          if (null != c2) {
            d2 = b2.memoizedProps;
            var e2 = null !== a2 ? a2.memoizedProps : d2;
            a2 = b2.type;
            var f2 = b2.updateQueue;
            b2.updateQueue = null;
            if (null !== f2) {
              c2[xf] = d2;
              "input" === a2 && "radio" === d2.type && null != d2.name && $a(c2, d2);
              wb(a2, e2);
              b2 = wb(a2, d2);
              for (e2 = 0; e2 < f2.length; e2 += 2) {
                var g2 = f2[e2], h2 = f2[e2 + 1];
                "style" === g2 ? tb(c2, h2) : "dangerouslySetInnerHTML" === g2 ? ob(c2, h2) : "children" === g2 ? pb(c2, h2) : qa(c2, g2, h2, b2);
              }
              switch (a2) {
                case "input":
                  ab(c2, d2);
                  break;
                case "textarea":
                  ib(c2, d2);
                  break;
                case "select":
                  a2 = c2._wrapperState.wasMultiple, c2._wrapperState.wasMultiple = !!d2.multiple, f2 = d2.value, null != f2 ? fb(c2, !!d2.multiple, f2, false) : a2 !== !!d2.multiple && (null != d2.defaultValue ? fb(c2, !!d2.multiple, d2.defaultValue, true) : fb(c2, !!d2.multiple, d2.multiple ? [] : "", false));
              }
            }
          }
          return;
        case 6:
          if (null === b2.stateNode)
            throw Error(y$2(162));
          b2.stateNode.nodeValue = b2.memoizedProps;
          return;
        case 3:
          c2 = b2.stateNode;
          c2.hydrate && (c2.hydrate = false, Cc(c2.containerInfo));
          return;
        case 12:
          return;
        case 13:
          null !== b2.memoizedState && (jj = O$2(), aj(b2.child, true));
          kj(b2);
          return;
        case 19:
          kj(b2);
          return;
        case 17:
          return;
        case 23:
        case 24:
          aj(b2, null !== b2.memoizedState);
          return;
      }
      throw Error(y$2(163));
    }
    function kj(a2) {
      var b2 = a2.updateQueue;
      if (null !== b2) {
        a2.updateQueue = null;
        var c2 = a2.stateNode;
        null === c2 && (c2 = a2.stateNode = new Ui());
        b2.forEach(function(b3) {
          var d2 = lj.bind(null, a2, b3);
          c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
        });
      }
    }
    function mj(a2, b2) {
      return null !== a2 && (a2 = a2.memoizedState, null === a2 || null !== a2.dehydrated) ? (b2 = b2.memoizedState, null !== b2 && null === b2.dehydrated) : false;
    }
    var nj = Math.ceil, oj = ra.ReactCurrentDispatcher, pj = ra.ReactCurrentOwner, X = 0, U = null, Y = null, W$1 = 0, qj = 0, rj = Bf(0), V$1 = 0, sj = null, tj = 0, Dg = 0, Hi = 0, uj = 0, vj = null, jj = 0, Ji = Infinity;
    function wj() {
      Ji = O$2() + 500;
    }
    var Z = null, Qi = false, Ri = null, Ti = null, xj = false, yj = null, zj = 90, Aj = [], Bj = [], Cj = null, Dj = 0, Ej = null, Fj = -1, Gj = 0, Hj = 0, Ij = null, Jj = false;
    function Hg() {
      return 0 !== (X & 48) ? O$2() : -1 !== Fj ? Fj : Fj = O$2();
    }
    function Ig(a2) {
      a2 = a2.mode;
      if (0 === (a2 & 2))
        return 1;
      if (0 === (a2 & 4))
        return 99 === eg() ? 1 : 2;
      0 === Gj && (Gj = tj);
      if (0 !== kg.transition) {
        0 !== Hj && (Hj = null !== vj ? vj.pendingLanes : 0);
        a2 = Gj;
        var b2 = 4186112 & ~Hj;
        b2 &= -b2;
        0 === b2 && (a2 = 4186112 & ~a2, b2 = a2 & -a2, 0 === b2 && (b2 = 8192));
        return b2;
      }
      a2 = eg();
      0 !== (X & 4) && 98 === a2 ? a2 = Xc(12, Gj) : (a2 = Sc(a2), a2 = Xc(a2, Gj));
      return a2;
    }
    function Jg(a2, b2, c2) {
      if (50 < Dj)
        throw Dj = 0, Ej = null, Error(y$2(185));
      a2 = Kj(a2, b2);
      if (null === a2)
        return null;
      $c(a2, b2, c2);
      a2 === U && (Hi |= b2, 4 === V$1 && Ii(a2, W$1));
      var d2 = eg();
      1 === b2 ? 0 !== (X & 8) && 0 === (X & 48) ? Lj(a2) : (Mj(a2, c2), 0 === X && (wj(), ig())) : (0 === (X & 4) || 98 !== d2 && 99 !== d2 || (null === Cj ? Cj = /* @__PURE__ */ new Set([a2]) : Cj.add(a2)), Mj(a2, c2));
      vj = a2;
    }
    function Kj(a2, b2) {
      a2.lanes |= b2;
      var c2 = a2.alternate;
      null !== c2 && (c2.lanes |= b2);
      c2 = a2;
      for (a2 = a2.return; null !== a2; )
        a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
      return 3 === c2.tag ? c2.stateNode : null;
    }
    function Mj(a2, b2) {
      for (var c2 = a2.callbackNode, d2 = a2.suspendedLanes, e2 = a2.pingedLanes, f2 = a2.expirationTimes, g2 = a2.pendingLanes; 0 < g2; ) {
        var h2 = 31 - Vc(g2), k2 = 1 << h2, l2 = f2[h2];
        if (-1 === l2) {
          if (0 === (k2 & d2) || 0 !== (k2 & e2)) {
            l2 = b2;
            Rc(k2);
            var n2 = F$1;
            f2[h2] = 10 <= n2 ? l2 + 250 : 6 <= n2 ? l2 + 5e3 : -1;
          }
        } else
          l2 <= b2 && (a2.expiredLanes |= k2);
        g2 &= ~k2;
      }
      d2 = Uc(a2, a2 === U ? W$1 : 0);
      b2 = F$1;
      if (0 === d2)
        null !== c2 && (c2 !== Zf && Pf(c2), a2.callbackNode = null, a2.callbackPriority = 0);
      else {
        if (null !== c2) {
          if (a2.callbackPriority === b2)
            return;
          c2 !== Zf && Pf(c2);
        }
        15 === b2 ? (c2 = Lj.bind(null, a2), null === ag ? (ag = [c2], bg = Of(Uf, jg)) : ag.push(c2), c2 = Zf) : 14 === b2 ? c2 = hg(99, Lj.bind(null, a2)) : (c2 = Tc(b2), c2 = hg(c2, Nj.bind(null, a2)));
        a2.callbackPriority = b2;
        a2.callbackNode = c2;
      }
    }
    function Nj(a2) {
      Fj = -1;
      Hj = Gj = 0;
      if (0 !== (X & 48))
        throw Error(y$2(327));
      var b2 = a2.callbackNode;
      if (Oj() && a2.callbackNode !== b2)
        return null;
      var c2 = Uc(a2, a2 === U ? W$1 : 0);
      if (0 === c2)
        return null;
      var d2 = c2;
      var e2 = X;
      X |= 16;
      var f2 = Pj();
      if (U !== a2 || W$1 !== d2)
        wj(), Qj(a2, d2);
      do
        try {
          Rj();
          break;
        } catch (h2) {
          Sj(a2, h2);
        }
      while (1);
      qg();
      oj.current = f2;
      X = e2;
      null !== Y ? d2 = 0 : (U = null, W$1 = 0, d2 = V$1);
      if (0 !== (tj & Hi))
        Qj(a2, 0);
      else if (0 !== d2) {
        2 === d2 && (X |= 64, a2.hydrate && (a2.hydrate = false, qf(a2.containerInfo)), c2 = Wc(a2), 0 !== c2 && (d2 = Tj(a2, c2)));
        if (1 === d2)
          throw b2 = sj, Qj(a2, 0), Ii(a2, c2), Mj(a2, O$2()), b2;
        a2.finishedWork = a2.current.alternate;
        a2.finishedLanes = c2;
        switch (d2) {
          case 0:
          case 1:
            throw Error(y$2(345));
          case 2:
            Uj(a2);
            break;
          case 3:
            Ii(a2, c2);
            if ((c2 & 62914560) === c2 && (d2 = jj + 500 - O$2(), 10 < d2)) {
              if (0 !== Uc(a2, 0))
                break;
              e2 = a2.suspendedLanes;
              if ((e2 & c2) !== c2) {
                Hg();
                a2.pingedLanes |= a2.suspendedLanes & e2;
                break;
              }
              a2.timeoutHandle = of(Uj.bind(null, a2), d2);
              break;
            }
            Uj(a2);
            break;
          case 4:
            Ii(a2, c2);
            if ((c2 & 4186112) === c2)
              break;
            d2 = a2.eventTimes;
            for (e2 = -1; 0 < c2; ) {
              var g2 = 31 - Vc(c2);
              f2 = 1 << g2;
              g2 = d2[g2];
              g2 > e2 && (e2 = g2);
              c2 &= ~f2;
            }
            c2 = e2;
            c2 = O$2() - c2;
            c2 = (120 > c2 ? 120 : 480 > c2 ? 480 : 1080 > c2 ? 1080 : 1920 > c2 ? 1920 : 3e3 > c2 ? 3e3 : 4320 > c2 ? 4320 : 1960 * nj(c2 / 1960)) - c2;
            if (10 < c2) {
              a2.timeoutHandle = of(Uj.bind(null, a2), c2);
              break;
            }
            Uj(a2);
            break;
          case 5:
            Uj(a2);
            break;
          default:
            throw Error(y$2(329));
        }
      }
      Mj(a2, O$2());
      return a2.callbackNode === b2 ? Nj.bind(null, a2) : null;
    }
    function Ii(a2, b2) {
      b2 &= ~uj;
      b2 &= ~Hi;
      a2.suspendedLanes |= b2;
      a2.pingedLanes &= ~b2;
      for (a2 = a2.expirationTimes; 0 < b2; ) {
        var c2 = 31 - Vc(b2), d2 = 1 << c2;
        a2[c2] = -1;
        b2 &= ~d2;
      }
    }
    function Lj(a2) {
      if (0 !== (X & 48))
        throw Error(y$2(327));
      Oj();
      if (a2 === U && 0 !== (a2.expiredLanes & W$1)) {
        var b2 = W$1;
        var c2 = Tj(a2, b2);
        0 !== (tj & Hi) && (b2 = Uc(a2, b2), c2 = Tj(a2, b2));
      } else
        b2 = Uc(a2, 0), c2 = Tj(a2, b2);
      0 !== a2.tag && 2 === c2 && (X |= 64, a2.hydrate && (a2.hydrate = false, qf(a2.containerInfo)), b2 = Wc(a2), 0 !== b2 && (c2 = Tj(a2, b2)));
      if (1 === c2)
        throw c2 = sj, Qj(a2, 0), Ii(a2, b2), Mj(a2, O$2()), c2;
      a2.finishedWork = a2.current.alternate;
      a2.finishedLanes = b2;
      Uj(a2);
      Mj(a2, O$2());
      return null;
    }
    function Vj() {
      if (null !== Cj) {
        var a2 = Cj;
        Cj = null;
        a2.forEach(function(a3) {
          a3.expiredLanes |= 24 & a3.pendingLanes;
          Mj(a3, O$2());
        });
      }
      ig();
    }
    function Wj(a2, b2) {
      var c2 = X;
      X |= 1;
      try {
        return a2(b2);
      } finally {
        X = c2, 0 === X && (wj(), ig());
      }
    }
    function Xj(a2, b2) {
      var c2 = X;
      X &= -2;
      X |= 8;
      try {
        return a2(b2);
      } finally {
        X = c2, 0 === X && (wj(), ig());
      }
    }
    function ni(a2, b2) {
      I(rj, qj);
      qj |= b2;
      tj |= b2;
    }
    function Ki() {
      qj = rj.current;
      H$1(rj);
    }
    function Qj(a2, b2) {
      a2.finishedWork = null;
      a2.finishedLanes = 0;
      var c2 = a2.timeoutHandle;
      -1 !== c2 && (a2.timeoutHandle = -1, pf(c2));
      if (null !== Y)
        for (c2 = Y.return; null !== c2; ) {
          var d2 = c2;
          switch (d2.tag) {
            case 1:
              d2 = d2.type.childContextTypes;
              null !== d2 && void 0 !== d2 && Gf();
              break;
            case 3:
              fh();
              H$1(N);
              H$1(M);
              uh();
              break;
            case 5:
              hh(d2);
              break;
            case 4:
              fh();
              break;
            case 13:
              H$1(P$1);
              break;
            case 19:
              H$1(P$1);
              break;
            case 10:
              rg(d2);
              break;
            case 23:
            case 24:
              Ki();
          }
          c2 = c2.return;
        }
      U = a2;
      Y = Tg(a2.current, null);
      W$1 = qj = tj = b2;
      V$1 = 0;
      sj = null;
      uj = Hi = Dg = 0;
    }
    function Sj(a2, b2) {
      do {
        var c2 = Y;
        try {
          qg();
          vh.current = Gh;
          if (yh) {
            for (var d2 = R$3.memoizedState; null !== d2; ) {
              var e2 = d2.queue;
              null !== e2 && (e2.pending = null);
              d2 = d2.next;
            }
            yh = false;
          }
          xh = 0;
          T$1 = S$1 = R$3 = null;
          zh = false;
          pj.current = null;
          if (null === c2 || null === c2.return) {
            V$1 = 1;
            sj = b2;
            Y = null;
            break;
          }
          a: {
            var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
            b2 = W$1;
            h2.flags |= 2048;
            h2.firstEffect = h2.lastEffect = null;
            if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
              var l2 = k2;
              if (0 === (h2.mode & 2)) {
                var n2 = h2.alternate;
                n2 ? (h2.updateQueue = n2.updateQueue, h2.memoizedState = n2.memoizedState, h2.lanes = n2.lanes) : (h2.updateQueue = null, h2.memoizedState = null);
              }
              var A2 = 0 !== (P$1.current & 1), p2 = g2;
              do {
                var C2;
                if (C2 = 13 === p2.tag) {
                  var x2 = p2.memoizedState;
                  if (null !== x2)
                    C2 = null !== x2.dehydrated ? true : false;
                  else {
                    var w2 = p2.memoizedProps;
                    C2 = void 0 === w2.fallback ? false : true !== w2.unstable_avoidThisFallback ? true : A2 ? false : true;
                  }
                }
                if (C2) {
                  var z2 = p2.updateQueue;
                  if (null === z2) {
                    var u2 = /* @__PURE__ */ new Set();
                    u2.add(l2);
                    p2.updateQueue = u2;
                  } else
                    z2.add(l2);
                  if (0 === (p2.mode & 2)) {
                    p2.flags |= 64;
                    h2.flags |= 16384;
                    h2.flags &= -2981;
                    if (1 === h2.tag)
                      if (null === h2.alternate)
                        h2.tag = 17;
                      else {
                        var t2 = zg(-1, 1);
                        t2.tag = 2;
                        Ag(h2, t2);
                      }
                    h2.lanes |= 1;
                    break a;
                  }
                  k2 = void 0;
                  h2 = b2;
                  var q2 = f2.pingCache;
                  null === q2 ? (q2 = f2.pingCache = new Oi(), k2 = /* @__PURE__ */ new Set(), q2.set(l2, k2)) : (k2 = q2.get(l2), void 0 === k2 && (k2 = /* @__PURE__ */ new Set(), q2.set(l2, k2)));
                  if (!k2.has(h2)) {
                    k2.add(h2);
                    var v2 = Yj.bind(null, f2, l2, h2);
                    l2.then(v2, v2);
                  }
                  p2.flags |= 4096;
                  p2.lanes = b2;
                  break a;
                }
                p2 = p2.return;
              } while (null !== p2);
              k2 = Error((Ra(h2.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
            }
            5 !== V$1 && (V$1 = 2);
            k2 = Mi(k2, h2);
            p2 = g2;
            do {
              switch (p2.tag) {
                case 3:
                  f2 = k2;
                  p2.flags |= 4096;
                  b2 &= -b2;
                  p2.lanes |= b2;
                  var J2 = Pi(p2, f2, b2);
                  Bg(p2, J2);
                  break a;
                case 1:
                  f2 = k2;
                  var K2 = p2.type, Q2 = p2.stateNode;
                  if (0 === (p2.flags & 64) && ("function" === typeof K2.getDerivedStateFromError || null !== Q2 && "function" === typeof Q2.componentDidCatch && (null === Ti || !Ti.has(Q2)))) {
                    p2.flags |= 4096;
                    b2 &= -b2;
                    p2.lanes |= b2;
                    var L2 = Si(p2, f2, b2);
                    Bg(p2, L2);
                    break a;
                  }
              }
              p2 = p2.return;
            } while (null !== p2);
          }
          Zj(c2);
        } catch (va) {
          b2 = va;
          Y === c2 && null !== c2 && (Y = c2 = c2.return);
          continue;
        }
        break;
      } while (1);
    }
    function Pj() {
      var a2 = oj.current;
      oj.current = Gh;
      return null === a2 ? Gh : a2;
    }
    function Tj(a2, b2) {
      var c2 = X;
      X |= 16;
      var d2 = Pj();
      U === a2 && W$1 === b2 || Qj(a2, b2);
      do
        try {
          ak();
          break;
        } catch (e2) {
          Sj(a2, e2);
        }
      while (1);
      qg();
      X = c2;
      oj.current = d2;
      if (null !== Y)
        throw Error(y$2(261));
      U = null;
      W$1 = 0;
      return V$1;
    }
    function ak() {
      for (; null !== Y; )
        bk(Y);
    }
    function Rj() {
      for (; null !== Y && !Qf(); )
        bk(Y);
    }
    function bk(a2) {
      var b2 = ck(a2.alternate, a2, qj);
      a2.memoizedProps = a2.pendingProps;
      null === b2 ? Zj(a2) : Y = b2;
      pj.current = null;
    }
    function Zj(a2) {
      var b2 = a2;
      do {
        var c2 = b2.alternate;
        a2 = b2.return;
        if (0 === (b2.flags & 2048)) {
          c2 = Gi(c2, b2, qj);
          if (null !== c2) {
            Y = c2;
            return;
          }
          c2 = b2;
          if (24 !== c2.tag && 23 !== c2.tag || null === c2.memoizedState || 0 !== (qj & 1073741824) || 0 === (c2.mode & 4)) {
            for (var d2 = 0, e2 = c2.child; null !== e2; )
              d2 |= e2.lanes | e2.childLanes, e2 = e2.sibling;
            c2.childLanes = d2;
          }
          null !== a2 && 0 === (a2.flags & 2048) && (null === a2.firstEffect && (a2.firstEffect = b2.firstEffect), null !== b2.lastEffect && (null !== a2.lastEffect && (a2.lastEffect.nextEffect = b2.firstEffect), a2.lastEffect = b2.lastEffect), 1 < b2.flags && (null !== a2.lastEffect ? a2.lastEffect.nextEffect = b2 : a2.firstEffect = b2, a2.lastEffect = b2));
        } else {
          c2 = Li(b2);
          if (null !== c2) {
            c2.flags &= 2047;
            Y = c2;
            return;
          }
          null !== a2 && (a2.firstEffect = a2.lastEffect = null, a2.flags |= 2048);
        }
        b2 = b2.sibling;
        if (null !== b2) {
          Y = b2;
          return;
        }
        Y = b2 = a2;
      } while (null !== b2);
      0 === V$1 && (V$1 = 5);
    }
    function Uj(a2) {
      var b2 = eg();
      gg(99, dk.bind(null, a2, b2));
      return null;
    }
    function dk(a2, b2) {
      do
        Oj();
      while (null !== yj);
      if (0 !== (X & 48))
        throw Error(y$2(327));
      var c2 = a2.finishedWork;
      if (null === c2)
        return null;
      a2.finishedWork = null;
      a2.finishedLanes = 0;
      if (c2 === a2.current)
        throw Error(y$2(177));
      a2.callbackNode = null;
      var d2 = c2.lanes | c2.childLanes, e2 = d2, f2 = a2.pendingLanes & ~e2;
      a2.pendingLanes = e2;
      a2.suspendedLanes = 0;
      a2.pingedLanes = 0;
      a2.expiredLanes &= e2;
      a2.mutableReadLanes &= e2;
      a2.entangledLanes &= e2;
      e2 = a2.entanglements;
      for (var g2 = a2.eventTimes, h2 = a2.expirationTimes; 0 < f2; ) {
        var k2 = 31 - Vc(f2), l2 = 1 << k2;
        e2[k2] = 0;
        g2[k2] = -1;
        h2[k2] = -1;
        f2 &= ~l2;
      }
      null !== Cj && 0 === (d2 & 24) && Cj.has(a2) && Cj.delete(a2);
      a2 === U && (Y = U = null, W$1 = 0);
      1 < c2.flags ? null !== c2.lastEffect ? (c2.lastEffect.nextEffect = c2, d2 = c2.firstEffect) : d2 = c2 : d2 = c2.firstEffect;
      if (null !== d2) {
        e2 = X;
        X |= 32;
        pj.current = null;
        kf = fd;
        g2 = Ne();
        if (Oe(g2)) {
          if ("selectionStart" in g2)
            h2 = { start: g2.selectionStart, end: g2.selectionEnd };
          else
            a:
              if (h2 = (h2 = g2.ownerDocument) && h2.defaultView || window, (l2 = h2.getSelection && h2.getSelection()) && 0 !== l2.rangeCount) {
                h2 = l2.anchorNode;
                f2 = l2.anchorOffset;
                k2 = l2.focusNode;
                l2 = l2.focusOffset;
                try {
                  h2.nodeType, k2.nodeType;
                } catch (va) {
                  h2 = null;
                  break a;
                }
                var n2 = 0, A2 = -1, p2 = -1, C2 = 0, x2 = 0, w2 = g2, z2 = null;
                b:
                  for (; ; ) {
                    for (var u2; ; ) {
                      w2 !== h2 || 0 !== f2 && 3 !== w2.nodeType || (A2 = n2 + f2);
                      w2 !== k2 || 0 !== l2 && 3 !== w2.nodeType || (p2 = n2 + l2);
                      3 === w2.nodeType && (n2 += w2.nodeValue.length);
                      if (null === (u2 = w2.firstChild))
                        break;
                      z2 = w2;
                      w2 = u2;
                    }
                    for (; ; ) {
                      if (w2 === g2)
                        break b;
                      z2 === h2 && ++C2 === f2 && (A2 = n2);
                      z2 === k2 && ++x2 === l2 && (p2 = n2);
                      if (null !== (u2 = w2.nextSibling))
                        break;
                      w2 = z2;
                      z2 = w2.parentNode;
                    }
                    w2 = u2;
                  }
                h2 = -1 === A2 || -1 === p2 ? null : { start: A2, end: p2 };
              } else
                h2 = null;
          h2 = h2 || { start: 0, end: 0 };
        } else
          h2 = null;
        lf = { focusedElem: g2, selectionRange: h2 };
        fd = false;
        Ij = null;
        Jj = false;
        Z = d2;
        do
          try {
            ek();
          } catch (va) {
            if (null === Z)
              throw Error(y$2(330));
            Wi(Z, va);
            Z = Z.nextEffect;
          }
        while (null !== Z);
        Ij = null;
        Z = d2;
        do
          try {
            for (g2 = a2; null !== Z; ) {
              var t2 = Z.flags;
              t2 & 16 && pb(Z.stateNode, "");
              if (t2 & 128) {
                var q2 = Z.alternate;
                if (null !== q2) {
                  var v2 = q2.ref;
                  null !== v2 && ("function" === typeof v2 ? v2(null) : v2.current = null);
                }
              }
              switch (t2 & 1038) {
                case 2:
                  fj(Z);
                  Z.flags &= -3;
                  break;
                case 6:
                  fj(Z);
                  Z.flags &= -3;
                  ij(Z.alternate, Z);
                  break;
                case 1024:
                  Z.flags &= -1025;
                  break;
                case 1028:
                  Z.flags &= -1025;
                  ij(Z.alternate, Z);
                  break;
                case 4:
                  ij(Z.alternate, Z);
                  break;
                case 8:
                  h2 = Z;
                  cj(g2, h2);
                  var J2 = h2.alternate;
                  dj(h2);
                  null !== J2 && dj(J2);
              }
              Z = Z.nextEffect;
            }
          } catch (va) {
            if (null === Z)
              throw Error(y$2(330));
            Wi(Z, va);
            Z = Z.nextEffect;
          }
        while (null !== Z);
        v2 = lf;
        q2 = Ne();
        t2 = v2.focusedElem;
        g2 = v2.selectionRange;
        if (q2 !== t2 && t2 && t2.ownerDocument && Me(t2.ownerDocument.documentElement, t2)) {
          null !== g2 && Oe(t2) && (q2 = g2.start, v2 = g2.end, void 0 === v2 && (v2 = q2), "selectionStart" in t2 ? (t2.selectionStart = q2, t2.selectionEnd = Math.min(v2, t2.value.length)) : (v2 = (q2 = t2.ownerDocument || document) && q2.defaultView || window, v2.getSelection && (v2 = v2.getSelection(), h2 = t2.textContent.length, J2 = Math.min(g2.start, h2), g2 = void 0 === g2.end ? J2 : Math.min(g2.end, h2), !v2.extend && J2 > g2 && (h2 = g2, g2 = J2, J2 = h2), h2 = Le(t2, J2), f2 = Le(t2, g2), h2 && f2 && (1 !== v2.rangeCount || v2.anchorNode !== h2.node || v2.anchorOffset !== h2.offset || v2.focusNode !== f2.node || v2.focusOffset !== f2.offset) && (q2 = q2.createRange(), q2.setStart(h2.node, h2.offset), v2.removeAllRanges(), J2 > g2 ? (v2.addRange(q2), v2.extend(f2.node, f2.offset)) : (q2.setEnd(f2.node, f2.offset), v2.addRange(q2))))));
          q2 = [];
          for (v2 = t2; v2 = v2.parentNode; )
            1 === v2.nodeType && q2.push({ element: v2, left: v2.scrollLeft, top: v2.scrollTop });
          "function" === typeof t2.focus && t2.focus();
          for (t2 = 0; t2 < q2.length; t2++)
            v2 = q2[t2], v2.element.scrollLeft = v2.left, v2.element.scrollTop = v2.top;
        }
        fd = !!kf;
        lf = kf = null;
        a2.current = c2;
        Z = d2;
        do
          try {
            for (t2 = a2; null !== Z; ) {
              var K2 = Z.flags;
              K2 & 36 && Yi(t2, Z.alternate, Z);
              if (K2 & 128) {
                q2 = void 0;
                var Q2 = Z.ref;
                if (null !== Q2) {
                  var L2 = Z.stateNode;
                  switch (Z.tag) {
                    case 5:
                      q2 = L2;
                      break;
                    default:
                      q2 = L2;
                  }
                  "function" === typeof Q2 ? Q2(q2) : Q2.current = q2;
                }
              }
              Z = Z.nextEffect;
            }
          } catch (va) {
            if (null === Z)
              throw Error(y$2(330));
            Wi(Z, va);
            Z = Z.nextEffect;
          }
        while (null !== Z);
        Z = null;
        $f();
        X = e2;
      } else
        a2.current = c2;
      if (xj)
        xj = false, yj = a2, zj = b2;
      else
        for (Z = d2; null !== Z; )
          b2 = Z.nextEffect, Z.nextEffect = null, Z.flags & 8 && (K2 = Z, K2.sibling = null, K2.stateNode = null), Z = b2;
      d2 = a2.pendingLanes;
      0 === d2 && (Ti = null);
      1 === d2 ? a2 === Ej ? Dj++ : (Dj = 0, Ej = a2) : Dj = 0;
      c2 = c2.stateNode;
      if (Mf && "function" === typeof Mf.onCommitFiberRoot)
        try {
          Mf.onCommitFiberRoot(Lf, c2, void 0, 64 === (c2.current.flags & 64));
        } catch (va) {
        }
      Mj(a2, O$2());
      if (Qi)
        throw Qi = false, a2 = Ri, Ri = null, a2;
      if (0 !== (X & 8))
        return null;
      ig();
      return null;
    }
    function ek() {
      for (; null !== Z; ) {
        var a2 = Z.alternate;
        Jj || null === Ij || (0 !== (Z.flags & 8) ? dc(Z, Ij) && (Jj = true) : 13 === Z.tag && mj(a2, Z) && dc(Z, Ij) && (Jj = true));
        var b2 = Z.flags;
        0 !== (b2 & 256) && Xi(a2, Z);
        0 === (b2 & 512) || xj || (xj = true, hg(97, function() {
          Oj();
          return null;
        }));
        Z = Z.nextEffect;
      }
    }
    function Oj() {
      if (90 !== zj) {
        var a2 = 97 < zj ? 97 : zj;
        zj = 90;
        return gg(a2, fk);
      }
      return false;
    }
    function $i(a2, b2) {
      Aj.push(b2, a2);
      xj || (xj = true, hg(97, function() {
        Oj();
        return null;
      }));
    }
    function Zi(a2, b2) {
      Bj.push(b2, a2);
      xj || (xj = true, hg(97, function() {
        Oj();
        return null;
      }));
    }
    function fk() {
      if (null === yj)
        return false;
      var a2 = yj;
      yj = null;
      if (0 !== (X & 48))
        throw Error(y$2(331));
      var b2 = X;
      X |= 32;
      var c2 = Bj;
      Bj = [];
      for (var d2 = 0; d2 < c2.length; d2 += 2) {
        var e2 = c2[d2], f2 = c2[d2 + 1], g2 = e2.destroy;
        e2.destroy = void 0;
        if ("function" === typeof g2)
          try {
            g2();
          } catch (k2) {
            if (null === f2)
              throw Error(y$2(330));
            Wi(f2, k2);
          }
      }
      c2 = Aj;
      Aj = [];
      for (d2 = 0; d2 < c2.length; d2 += 2) {
        e2 = c2[d2];
        f2 = c2[d2 + 1];
        try {
          var h2 = e2.create;
          e2.destroy = h2();
        } catch (k2) {
          if (null === f2)
            throw Error(y$2(330));
          Wi(f2, k2);
        }
      }
      for (h2 = a2.current.firstEffect; null !== h2; )
        a2 = h2.nextEffect, h2.nextEffect = null, h2.flags & 8 && (h2.sibling = null, h2.stateNode = null), h2 = a2;
      X = b2;
      ig();
      return true;
    }
    function gk(a2, b2, c2) {
      b2 = Mi(c2, b2);
      b2 = Pi(a2, b2, 1);
      Ag(a2, b2);
      b2 = Hg();
      a2 = Kj(a2, 1);
      null !== a2 && ($c(a2, 1, b2), Mj(a2, b2));
    }
    function Wi(a2, b2) {
      if (3 === a2.tag)
        gk(a2, a2, b2);
      else
        for (var c2 = a2.return; null !== c2; ) {
          if (3 === c2.tag) {
            gk(c2, a2, b2);
            break;
          } else if (1 === c2.tag) {
            var d2 = c2.stateNode;
            if ("function" === typeof c2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Ti || !Ti.has(d2))) {
              a2 = Mi(b2, a2);
              var e2 = Si(c2, a2, 1);
              Ag(c2, e2);
              e2 = Hg();
              c2 = Kj(c2, 1);
              if (null !== c2)
                $c(c2, 1, e2), Mj(c2, e2);
              else if ("function" === typeof d2.componentDidCatch && (null === Ti || !Ti.has(d2)))
                try {
                  d2.componentDidCatch(b2, a2);
                } catch (f2) {
                }
              break;
            }
          }
          c2 = c2.return;
        }
    }
    function Yj(a2, b2, c2) {
      var d2 = a2.pingCache;
      null !== d2 && d2.delete(b2);
      b2 = Hg();
      a2.pingedLanes |= a2.suspendedLanes & c2;
      U === a2 && (W$1 & c2) === c2 && (4 === V$1 || 3 === V$1 && (W$1 & 62914560) === W$1 && 500 > O$2() - jj ? Qj(a2, 0) : uj |= c2);
      Mj(a2, b2);
    }
    function lj(a2, b2) {
      var c2 = a2.stateNode;
      null !== c2 && c2.delete(b2);
      b2 = 0;
      0 === b2 && (b2 = a2.mode, 0 === (b2 & 2) ? b2 = 1 : 0 === (b2 & 4) ? b2 = 99 === eg() ? 1 : 2 : (0 === Gj && (Gj = tj), b2 = Yc(62914560 & ~Gj), 0 === b2 && (b2 = 4194304)));
      c2 = Hg();
      a2 = Kj(a2, b2);
      null !== a2 && ($c(a2, b2, c2), Mj(a2, c2));
    }
    var ck;
    ck = function(a2, b2, c2) {
      var d2 = b2.lanes;
      if (null !== a2)
        if (a2.memoizedProps !== b2.pendingProps || N.current)
          ug = true;
        else if (0 !== (c2 & d2))
          ug = 0 !== (a2.flags & 16384) ? true : false;
        else {
          ug = false;
          switch (b2.tag) {
            case 3:
              ri(b2);
              sh();
              break;
            case 5:
              gh(b2);
              break;
            case 1:
              Ff(b2.type) && Jf(b2);
              break;
            case 4:
              eh(b2, b2.stateNode.containerInfo);
              break;
            case 10:
              d2 = b2.memoizedProps.value;
              var e2 = b2.type._context;
              I(mg, e2._currentValue);
              e2._currentValue = d2;
              break;
            case 13:
              if (null !== b2.memoizedState) {
                if (0 !== (c2 & b2.child.childLanes))
                  return ti(a2, b2, c2);
                I(P$1, P$1.current & 1);
                b2 = hi(a2, b2, c2);
                return null !== b2 ? b2.sibling : null;
              }
              I(P$1, P$1.current & 1);
              break;
            case 19:
              d2 = 0 !== (c2 & b2.childLanes);
              if (0 !== (a2.flags & 64)) {
                if (d2)
                  return Ai(a2, b2, c2);
                b2.flags |= 64;
              }
              e2 = b2.memoizedState;
              null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
              I(P$1, P$1.current);
              if (d2)
                break;
              else
                return null;
            case 23:
            case 24:
              return b2.lanes = 0, mi(a2, b2, c2);
          }
          return hi(a2, b2, c2);
        }
      else
        ug = false;
      b2.lanes = 0;
      switch (b2.tag) {
        case 2:
          d2 = b2.type;
          null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
          a2 = b2.pendingProps;
          e2 = Ef(b2, M.current);
          tg(b2, c2);
          e2 = Ch(null, b2, d2, a2, e2, c2);
          b2.flags |= 1;
          if ("object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof) {
            b2.tag = 1;
            b2.memoizedState = null;
            b2.updateQueue = null;
            if (Ff(d2)) {
              var f2 = true;
              Jf(b2);
            } else
              f2 = false;
            b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null;
            xg(b2);
            var g2 = d2.getDerivedStateFromProps;
            "function" === typeof g2 && Gg(b2, d2, g2, a2);
            e2.updater = Kg;
            b2.stateNode = e2;
            e2._reactInternals = b2;
            Og(b2, d2, a2, c2);
            b2 = qi(null, b2, d2, true, f2, c2);
          } else
            b2.tag = 0, fi(null, b2, e2, c2), b2 = b2.child;
          return b2;
        case 16:
          e2 = b2.elementType;
          a: {
            null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
            a2 = b2.pendingProps;
            f2 = e2._init;
            e2 = f2(e2._payload);
            b2.type = e2;
            f2 = b2.tag = hk(e2);
            a2 = lg(e2, a2);
            switch (f2) {
              case 0:
                b2 = li(null, b2, e2, a2, c2);
                break a;
              case 1:
                b2 = pi(null, b2, e2, a2, c2);
                break a;
              case 11:
                b2 = gi(null, b2, e2, a2, c2);
                break a;
              case 14:
                b2 = ii(null, b2, e2, lg(e2.type, a2), d2, c2);
                break a;
            }
            throw Error(y$2(306, e2, ""));
          }
          return b2;
        case 0:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : lg(d2, e2), li(a2, b2, d2, e2, c2);
        case 1:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : lg(d2, e2), pi(a2, b2, d2, e2, c2);
        case 3:
          ri(b2);
          d2 = b2.updateQueue;
          if (null === a2 || null === d2)
            throw Error(y$2(282));
          d2 = b2.pendingProps;
          e2 = b2.memoizedState;
          e2 = null !== e2 ? e2.element : null;
          yg(a2, b2);
          Cg(b2, d2, null, c2);
          d2 = b2.memoizedState.element;
          if (d2 === e2)
            sh(), b2 = hi(a2, b2, c2);
          else {
            e2 = b2.stateNode;
            if (f2 = e2.hydrate)
              kh = rf(b2.stateNode.containerInfo.firstChild), jh = b2, f2 = lh = true;
            if (f2) {
              a2 = e2.mutableSourceEagerHydrationData;
              if (null != a2)
                for (e2 = 0; e2 < a2.length; e2 += 2)
                  f2 = a2[e2], f2._workInProgressVersionPrimary = a2[e2 + 1], th.push(f2);
              c2 = Zg(b2, null, d2, c2);
              for (b2.child = c2; c2; )
                c2.flags = c2.flags & -3 | 1024, c2 = c2.sibling;
            } else
              fi(a2, b2, d2, c2), sh();
            b2 = b2.child;
          }
          return b2;
        case 5:
          return gh(b2), null === a2 && ph(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e2.children, nf(d2, e2) ? g2 = null : null !== f2 && nf(d2, f2) && (b2.flags |= 16), oi(a2, b2), fi(a2, b2, g2, c2), b2.child;
        case 6:
          return null === a2 && ph(b2), null;
        case 13:
          return ti(a2, b2, c2);
        case 4:
          return eh(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a2 ? b2.child = Yg(b2, null, d2, c2) : fi(a2, b2, d2, c2), b2.child;
        case 11:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : lg(d2, e2), gi(a2, b2, d2, e2, c2);
        case 7:
          return fi(a2, b2, b2.pendingProps, c2), b2.child;
        case 8:
          return fi(
            a2,
            b2,
            b2.pendingProps.children,
            c2
          ), b2.child;
        case 12:
          return fi(a2, b2, b2.pendingProps.children, c2), b2.child;
        case 10:
          a: {
            d2 = b2.type._context;
            e2 = b2.pendingProps;
            g2 = b2.memoizedProps;
            f2 = e2.value;
            var h2 = b2.type._context;
            I(mg, h2._currentValue);
            h2._currentValue = f2;
            if (null !== g2)
              if (h2 = g2.value, f2 = He(h2, f2) ? 0 : ("function" === typeof d2._calculateChangedBits ? d2._calculateChangedBits(h2, f2) : 1073741823) | 0, 0 === f2) {
                if (g2.children === e2.children && !N.current) {
                  b2 = hi(a2, b2, c2);
                  break a;
                }
              } else
                for (h2 = b2.child, null !== h2 && (h2.return = b2); null !== h2; ) {
                  var k2 = h2.dependencies;
                  if (null !== k2) {
                    g2 = h2.child;
                    for (var l2 = k2.firstContext; null !== l2; ) {
                      if (l2.context === d2 && 0 !== (l2.observedBits & f2)) {
                        1 === h2.tag && (l2 = zg(-1, c2 & -c2), l2.tag = 2, Ag(h2, l2));
                        h2.lanes |= c2;
                        l2 = h2.alternate;
                        null !== l2 && (l2.lanes |= c2);
                        sg(h2.return, c2);
                        k2.lanes |= c2;
                        break;
                      }
                      l2 = l2.next;
                    }
                  } else
                    g2 = 10 === h2.tag ? h2.type === b2.type ? null : h2.child : h2.child;
                  if (null !== g2)
                    g2.return = h2;
                  else
                    for (g2 = h2; null !== g2; ) {
                      if (g2 === b2) {
                        g2 = null;
                        break;
                      }
                      h2 = g2.sibling;
                      if (null !== h2) {
                        h2.return = g2.return;
                        g2 = h2;
                        break;
                      }
                      g2 = g2.return;
                    }
                  h2 = g2;
                }
            fi(a2, b2, e2.children, c2);
            b2 = b2.child;
          }
          return b2;
        case 9:
          return e2 = b2.type, f2 = b2.pendingProps, d2 = f2.children, tg(b2, c2), e2 = vg(
            e2,
            f2.unstable_observedBits
          ), d2 = d2(e2), b2.flags |= 1, fi(a2, b2, d2, c2), b2.child;
        case 14:
          return e2 = b2.type, f2 = lg(e2, b2.pendingProps), f2 = lg(e2.type, f2), ii(a2, b2, e2, f2, d2, c2);
        case 15:
          return ki(a2, b2, b2.type, b2.pendingProps, d2, c2);
        case 17:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : lg(d2, e2), null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2), b2.tag = 1, Ff(d2) ? (a2 = true, Jf(b2)) : a2 = false, tg(b2, c2), Mg(b2, d2, e2), Og(b2, d2, e2, c2), qi(null, b2, d2, true, a2, c2);
        case 19:
          return Ai(a2, b2, c2);
        case 23:
          return mi(a2, b2, c2);
        case 24:
          return mi(a2, b2, c2);
      }
      throw Error(y$2(156, b2.tag));
    };
    function ik(a2, b2, c2, d2) {
      this.tag = a2;
      this.key = c2;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.ref = null;
      this.pendingProps = b2;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = d2;
      this.flags = 0;
      this.lastEffect = this.firstEffect = this.nextEffect = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
    }
    function nh(a2, b2, c2, d2) {
      return new ik(a2, b2, c2, d2);
    }
    function ji(a2) {
      a2 = a2.prototype;
      return !(!a2 || !a2.isReactComponent);
    }
    function hk(a2) {
      if ("function" === typeof a2)
        return ji(a2) ? 1 : 0;
      if (void 0 !== a2 && null !== a2) {
        a2 = a2.$$typeof;
        if (a2 === Aa)
          return 11;
        if (a2 === Da)
          return 14;
      }
      return 2;
    }
    function Tg(a2, b2) {
      var c2 = a2.alternate;
      null === c2 ? (c2 = nh(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.nextEffect = null, c2.firstEffect = null, c2.lastEffect = null);
      c2.childLanes = a2.childLanes;
      c2.lanes = a2.lanes;
      c2.child = a2.child;
      c2.memoizedProps = a2.memoizedProps;
      c2.memoizedState = a2.memoizedState;
      c2.updateQueue = a2.updateQueue;
      b2 = a2.dependencies;
      c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
      c2.sibling = a2.sibling;
      c2.index = a2.index;
      c2.ref = a2.ref;
      return c2;
    }
    function Vg(a2, b2, c2, d2, e2, f2) {
      var g2 = 2;
      d2 = a2;
      if ("function" === typeof a2)
        ji(a2) && (g2 = 1);
      else if ("string" === typeof a2)
        g2 = 5;
      else
        a:
          switch (a2) {
            case ua:
              return Xg(c2.children, e2, f2, b2);
            case Ha:
              g2 = 8;
              e2 |= 16;
              break;
            case wa:
              g2 = 8;
              e2 |= 1;
              break;
            case xa:
              return a2 = nh(12, c2, b2, e2 | 8), a2.elementType = xa, a2.type = xa, a2.lanes = f2, a2;
            case Ba:
              return a2 = nh(13, c2, b2, e2), a2.type = Ba, a2.elementType = Ba, a2.lanes = f2, a2;
            case Ca:
              return a2 = nh(19, c2, b2, e2), a2.elementType = Ca, a2.lanes = f2, a2;
            case Ia:
              return vi(c2, e2, f2, b2);
            case Ja:
              return a2 = nh(24, c2, b2, e2), a2.elementType = Ja, a2.lanes = f2, a2;
            default:
              if ("object" === typeof a2 && null !== a2)
                switch (a2.$$typeof) {
                  case ya:
                    g2 = 10;
                    break a;
                  case za:
                    g2 = 9;
                    break a;
                  case Aa:
                    g2 = 11;
                    break a;
                  case Da:
                    g2 = 14;
                    break a;
                  case Ea:
                    g2 = 16;
                    d2 = null;
                    break a;
                  case Fa:
                    g2 = 22;
                    break a;
                }
              throw Error(y$2(130, null == a2 ? a2 : typeof a2, ""));
          }
      b2 = nh(g2, c2, b2, e2);
      b2.elementType = a2;
      b2.type = d2;
      b2.lanes = f2;
      return b2;
    }
    function Xg(a2, b2, c2, d2) {
      a2 = nh(7, a2, d2, b2);
      a2.lanes = c2;
      return a2;
    }
    function vi(a2, b2, c2, d2) {
      a2 = nh(23, a2, d2, b2);
      a2.elementType = Ia;
      a2.lanes = c2;
      return a2;
    }
    function Ug(a2, b2, c2) {
      a2 = nh(6, a2, null, b2);
      a2.lanes = c2;
      return a2;
    }
    function Wg(a2, b2, c2) {
      b2 = nh(4, null !== a2.children ? a2.children : [], a2.key, b2);
      b2.lanes = c2;
      b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
      return b2;
    }
    function jk(a2, b2, c2) {
      this.tag = b2;
      this.containerInfo = a2;
      this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = -1;
      this.pendingContext = this.context = null;
      this.hydrate = c2;
      this.callbackNode = null;
      this.callbackPriority = 0;
      this.eventTimes = Zc(0);
      this.expirationTimes = Zc(-1);
      this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = Zc(0);
      this.mutableSourceEagerHydrationData = null;
    }
    function kk(a2, b2, c2) {
      var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      return { $$typeof: ta, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
    }
    function lk(a2, b2, c2, d2) {
      var e2 = b2.current, f2 = Hg(), g2 = Ig(e2);
      a:
        if (c2) {
          c2 = c2._reactInternals;
          b: {
            if (Zb(c2) !== c2 || 1 !== c2.tag)
              throw Error(y$2(170));
            var h2 = c2;
            do {
              switch (h2.tag) {
                case 3:
                  h2 = h2.stateNode.context;
                  break b;
                case 1:
                  if (Ff(h2.type)) {
                    h2 = h2.stateNode.__reactInternalMemoizedMergedChildContext;
                    break b;
                  }
              }
              h2 = h2.return;
            } while (null !== h2);
            throw Error(y$2(171));
          }
          if (1 === c2.tag) {
            var k2 = c2.type;
            if (Ff(k2)) {
              c2 = If(c2, k2, h2);
              break a;
            }
          }
          c2 = h2;
        } else
          c2 = Cf;
      null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
      b2 = zg(f2, g2);
      b2.payload = { element: a2 };
      d2 = void 0 === d2 ? null : d2;
      null !== d2 && (b2.callback = d2);
      Ag(e2, b2);
      Jg(e2, g2, f2);
      return g2;
    }
    function mk(a2) {
      a2 = a2.current;
      if (!a2.child)
        return null;
      switch (a2.child.tag) {
        case 5:
          return a2.child.stateNode;
        default:
          return a2.child.stateNode;
      }
    }
    function nk(a2, b2) {
      a2 = a2.memoizedState;
      if (null !== a2 && null !== a2.dehydrated) {
        var c2 = a2.retryLane;
        a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
      }
    }
    function ok$1(a2, b2) {
      nk(a2, b2);
      (a2 = a2.alternate) && nk(a2, b2);
    }
    function pk() {
      return null;
    }
    function qk(a2, b2, c2) {
      var d2 = null != c2 && null != c2.hydrationOptions && c2.hydrationOptions.mutableSources || null;
      c2 = new jk(a2, b2, null != c2 && true === c2.hydrate);
      b2 = nh(3, null, null, 2 === b2 ? 7 : 1 === b2 ? 3 : 0);
      c2.current = b2;
      b2.stateNode = c2;
      xg(b2);
      a2[ff] = c2.current;
      cf(8 === a2.nodeType ? a2.parentNode : a2);
      if (d2)
        for (a2 = 0; a2 < d2.length; a2++) {
          b2 = d2[a2];
          var e2 = b2._getVersion;
          e2 = e2(b2._source);
          null == c2.mutableSourceEagerHydrationData ? c2.mutableSourceEagerHydrationData = [b2, e2] : c2.mutableSourceEagerHydrationData.push(b2, e2);
        }
      this._internalRoot = c2;
    }
    qk.prototype.render = function(a2) {
      lk(a2, this._internalRoot, null, null);
    };
    qk.prototype.unmount = function() {
      var a2 = this._internalRoot, b2 = a2.containerInfo;
      lk(null, a2, null, function() {
        b2[ff] = null;
      });
    };
    function rk(a2) {
      return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
    }
    function sk(a2, b2) {
      b2 || (b2 = a2 ? 9 === a2.nodeType ? a2.documentElement : a2.firstChild : null, b2 = !(!b2 || 1 !== b2.nodeType || !b2.hasAttribute("data-reactroot")));
      if (!b2)
        for (var c2; c2 = a2.lastChild; )
          a2.removeChild(c2);
      return new qk(a2, 0, b2 ? { hydrate: true } : void 0);
    }
    function tk(a2, b2, c2, d2, e2) {
      var f2 = c2._reactRootContainer;
      if (f2) {
        var g2 = f2._internalRoot;
        if ("function" === typeof e2) {
          var h2 = e2;
          e2 = function() {
            var a3 = mk(g2);
            h2.call(a3);
          };
        }
        lk(b2, g2, a2, e2);
      } else {
        f2 = c2._reactRootContainer = sk(c2, d2);
        g2 = f2._internalRoot;
        if ("function" === typeof e2) {
          var k2 = e2;
          e2 = function() {
            var a3 = mk(g2);
            k2.call(a3);
          };
        }
        Xj(function() {
          lk(b2, g2, a2, e2);
        });
      }
      return mk(g2);
    }
    ec = function(a2) {
      if (13 === a2.tag) {
        var b2 = Hg();
        Jg(a2, 4, b2);
        ok$1(a2, 4);
      }
    };
    fc = function(a2) {
      if (13 === a2.tag) {
        var b2 = Hg();
        Jg(a2, 67108864, b2);
        ok$1(a2, 67108864);
      }
    };
    gc = function(a2) {
      if (13 === a2.tag) {
        var b2 = Hg(), c2 = Ig(a2);
        Jg(a2, c2, b2);
        ok$1(a2, c2);
      }
    };
    hc = function(a2, b2) {
      return b2();
    };
    yb = function(a2, b2, c2) {
      switch (b2) {
        case "input":
          ab(a2, c2);
          b2 = c2.name;
          if ("radio" === c2.type && null != b2) {
            for (c2 = a2; c2.parentNode; )
              c2 = c2.parentNode;
            c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
            for (b2 = 0; b2 < c2.length; b2++) {
              var d2 = c2[b2];
              if (d2 !== a2 && d2.form === a2.form) {
                var e2 = Db(d2);
                if (!e2)
                  throw Error(y$2(90));
                Wa(d2);
                ab(d2, e2);
              }
            }
          }
          break;
        case "textarea":
          ib(a2, c2);
          break;
        case "select":
          b2 = c2.value, null != b2 && fb(a2, !!c2.multiple, b2, false);
      }
    };
    Gb = Wj;
    Hb = function(a2, b2, c2, d2, e2) {
      var f2 = X;
      X |= 4;
      try {
        return gg(98, a2.bind(null, b2, c2, d2, e2));
      } finally {
        X = f2, 0 === X && (wj(), ig());
      }
    };
    Ib = function() {
      0 === (X & 49) && (Vj(), Oj());
    };
    Jb = function(a2, b2) {
      var c2 = X;
      X |= 2;
      try {
        return a2(b2);
      } finally {
        X = c2, 0 === X && (wj(), ig());
      }
    };
    function uk(a2, b2) {
      var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (!rk(b2))
        throw Error(y$2(200));
      return kk(a2, b2, null, c2);
    }
    var vk = { Events: [Cb, ue, Db, Eb, Fb, Oj, { current: false }] }, wk = { findFiberByHostInstance: wc, bundleType: 0, version: "17.0.2", rendererPackageName: "react-dom" };
    var xk = { bundleType: wk.bundleType, version: wk.version, rendererPackageName: wk.rendererPackageName, rendererConfig: wk.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ra.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
      a2 = cc(a2);
      return null === a2 ? null : a2.stateNode;
    }, findFiberByHostInstance: wk.findFiberByHostInstance || pk, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null };
    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
      var yk = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!yk.isDisabled && yk.supportsFiber)
        try {
          Lf = yk.inject(xk), Mf = yk;
        } catch (a2) {
        }
    }
    reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vk;
    reactDom_production_min.createPortal = uk;
    reactDom_production_min.findDOMNode = function(a2) {
      if (null == a2)
        return null;
      if (1 === a2.nodeType)
        return a2;
      var b2 = a2._reactInternals;
      if (void 0 === b2) {
        if ("function" === typeof a2.render)
          throw Error(y$2(188));
        throw Error(y$2(268, Object.keys(a2)));
      }
      a2 = cc(b2);
      a2 = null === a2 ? null : a2.stateNode;
      return a2;
    };
    reactDom_production_min.flushSync = function(a2, b2) {
      var c2 = X;
      if (0 !== (c2 & 48))
        return a2(b2);
      X |= 1;
      try {
        if (a2)
          return gg(99, a2.bind(null, b2));
      } finally {
        X = c2, ig();
      }
    };
    reactDom_production_min.hydrate = function(a2, b2, c2) {
      if (!rk(b2))
        throw Error(y$2(200));
      return tk(null, a2, b2, true, c2);
    };
    reactDom_production_min.render = function(a2, b2, c2) {
      if (!rk(b2))
        throw Error(y$2(200));
      return tk(null, a2, b2, false, c2);
    };
    reactDom_production_min.unmountComponentAtNode = function(a2) {
      if (!rk(a2))
        throw Error(y$2(40));
      return a2._reactRootContainer ? (Xj(function() {
        tk(null, null, a2, false, function() {
          a2._reactRootContainer = null;
          a2[ff] = null;
        });
      }), true) : false;
    };
    reactDom_production_min.unstable_batchedUpdates = Wj;
    reactDom_production_min.unstable_createPortal = function(a2, b2) {
      return uk(a2, b2, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null);
    };
    reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
      if (!rk(c2))
        throw Error(y$2(200));
      if (null == a2 || void 0 === a2._reactInternals)
        throw Error(y$2(38));
      return tk(a2, b2, c2, false, d2);
    };
    reactDom_production_min.version = "17.0.2";
    function checkDCE() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
        return;
      }
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
      } catch (err) {
        console.error(err);
      }
    }
    {
      checkDCE();
      reactDom.exports = reactDom_production_min;
    }
    var reactDomExports = reactDom.exports;
    const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
    var getClassNames$6 = classNamesFunction();
    var getFabricTheme = memoizeFunction(function(theme, isRTL) {
      return createTheme(__assign$1(__assign$1({}, theme), { rtl: isRTL }));
    });
    var getDir = function(_a2) {
      var theme = _a2.theme, dir = _a2.dir;
      var contextDir = getRTL(theme) ? "rtl" : "ltr";
      var pageDir = getRTL() ? "rtl" : "ltr";
      var componentDir = dir ? dir : contextDir;
      return {
        // If Fabric dir !== contextDir
        // Or If contextDir !== pageDir
        // Then we need to set dir of the Fabric root
        rootDir: componentDir !== contextDir || componentDir !== pageDir ? componentDir : dir,
        // If dir !== contextDir || pageDir
        // then set contextual theme around content
        needsTheme: componentDir !== contextDir
      };
    };
    var FabricBase = reactExports.forwardRef(function(props, ref) {
      var className = props.className, theme = props.theme, applyTheme = props.applyTheme, applyThemeToBody = props.applyThemeToBody, styles2 = props.styles;
      var classNames2 = getClassNames$6(styles2, {
        theme,
        applyTheme,
        className
      });
      var rootElement = reactExports.useRef(null);
      useApplyThemeToBody(applyThemeToBody, classNames2, rootElement);
      useFocusRects(rootElement);
      return reactExports.createElement(reactExports.Fragment, null, useRenderedContent(props, classNames2, rootElement, ref));
    });
    FabricBase.displayName = "FabricBase";
    function useRenderedContent(props, _a2, rootElement, ref) {
      var root2 = _a2.root;
      var _b = props.as, Root2 = _b === void 0 ? "div" : _b, dir = props.dir, theme = props.theme;
      var divProps = getNativeProps$1(props, divProperties, ["dir"]);
      var _c = getDir(props), rootDir = _c.rootDir, needsTheme = _c.needsTheme;
      var renderedContent = reactExports.createElement(Root2, __assign$1({ dir: rootDir }, divProps, { className: root2, ref: useMergedRefs$1(rootElement, ref) }));
      if (needsTheme) {
        renderedContent = // eslint-disable-next-line deprecation/deprecation
        reactExports.createElement(Customizer, { settings: { theme: getFabricTheme(theme, dir === "rtl") } }, renderedContent);
      }
      return renderedContent;
    }
    function useApplyThemeToBody(applyThemeToBody, _a2, rootElement) {
      var bodyThemed = _a2.bodyThemed;
      reactExports.useEffect(function() {
        if (applyThemeToBody) {
          var currentDoc_1 = getDocument(rootElement.current);
          if (currentDoc_1) {
            currentDoc_1.body.classList.add(bodyThemed);
            return function() {
              currentDoc_1.body.classList.remove(bodyThemed);
            };
          }
        }
      }, [bodyThemed, applyThemeToBody, rootElement]);
      return rootElement;
    }
    var inheritFont = { fontFamily: "inherit" };
    var GlobalClassNames$7 = {
      root: "ms-Fabric",
      bodyThemed: "ms-Fabric-bodyThemed"
    };
    var getStyles$8 = function(props) {
      var theme = props.theme, className = props.className, applyTheme = props.applyTheme;
      var classNames2 = getGlobalClassNames(GlobalClassNames$7, theme);
      return {
        root: [
          classNames2.root,
          theme.fonts.medium,
          {
            color: theme.palette.neutralPrimary,
            selectors: {
              "& button": inheritFont,
              "& input": inheritFont,
              "& textarea": inheritFont
            }
          },
          // apply theme to only if applyTheme is true
          applyTheme && {
            color: theme.semanticColors.bodyText,
            backgroundColor: theme.semanticColors.bodyBackground
          },
          className
        ],
        bodyThemed: [
          {
            backgroundColor: theme.semanticColors.bodyBackground
          }
        ]
      };
    };
    var Fabric = styled(FabricBase, getStyles$8, void 0, {
      scope: "Fabric"
    });
    var _layersByHostId = {};
    var _defaultHostSelector;
    function registerLayer(hostId, callback) {
      if (!_layersByHostId[hostId]) {
        _layersByHostId[hostId] = [];
      }
      _layersByHostId[hostId].push(callback);
    }
    function unregisterLayer(hostId, callback) {
      if (_layersByHostId[hostId]) {
        var idx = _layersByHostId[hostId].indexOf(callback);
        if (idx >= 0) {
          _layersByHostId[hostId].splice(idx, 1);
          if (_layersByHostId[hostId].length === 0) {
            delete _layersByHostId[hostId];
          }
        }
      }
    }
    function getDefaultTarget() {
      return _defaultHostSelector;
    }
    var getClassNames$5 = classNamesFunction();
    var LayerBase = reactExports.forwardRef(function(props, ref) {
      var rootRef = reactExports.useRef(null);
      var mergedRef = useMergedRefs$1(rootRef, ref);
      var layerRef = reactExports.useRef();
      var _a2 = reactExports.useState(false), needRaiseLayerMount = _a2[0], setNeedRaiseLayerMount = _a2[1];
      var doc = useDocument();
      var eventBubblingEnabled = props.eventBubblingEnabled, styles2 = props.styles, theme = props.theme, className = props.className, children = props.children, hostId = props.hostId, _b = props.onLayerDidMount, onLayerDidMount = _b === void 0 ? function() {
        return void 0;
      } : _b, _c = props.onLayerMounted, onLayerMounted = _c === void 0 ? function() {
        return void 0;
      } : _c, onLayerWillUnmount = props.onLayerWillUnmount, insertFirst = props.insertFirst;
      var classNames2 = getClassNames$5(styles2, {
        theme,
        className,
        isNotHost: !hostId
      });
      var getHost = function() {
        if (!doc) {
          return void 0;
        }
        if (hostId) {
          return doc.getElementById(hostId);
        } else {
          var defaultHostSelector = getDefaultTarget();
          return defaultHostSelector ? doc.querySelector(defaultHostSelector) : doc.body;
        }
      };
      var removeLayerElement = function() {
        onLayerWillUnmount === null || onLayerWillUnmount === void 0 ? void 0 : onLayerWillUnmount();
        var elem = layerRef.current;
        layerRef.current = void 0;
        if (elem && elem.parentNode) {
          elem.parentNode.removeChild(elem);
        }
      };
      var createLayerElement = function() {
        var host = getHost();
        if (!doc || !host) {
          return;
        }
        removeLayerElement();
        var el = doc.createElement("div");
        el.className = classNames2.root;
        setPortalAttribute(el);
        setVirtualParent$1(el, rootRef.current);
        insertFirst ? host.insertBefore(el, host.firstChild) : host.appendChild(el);
        layerRef.current = el;
        setNeedRaiseLayerMount(true);
      };
      useIsomorphicLayoutEffect$1(function() {
        createLayerElement();
        if (hostId) {
          registerLayer(hostId, createLayerElement);
        }
        return function() {
          removeLayerElement();
          if (hostId) {
            unregisterLayer(hostId, createLayerElement);
          }
        };
      }, [hostId]);
      reactExports.useEffect(function() {
        if (layerRef.current && needRaiseLayerMount) {
          onLayerMounted === null || onLayerMounted === void 0 ? void 0 : onLayerMounted();
          onLayerDidMount === null || onLayerDidMount === void 0 ? void 0 : onLayerDidMount();
          setNeedRaiseLayerMount(false);
        }
      }, [needRaiseLayerMount, onLayerMounted, onLayerDidMount]);
      return reactExports.createElement("span", { className: "ms-layer", ref: mergedRef }, layerRef.current && reactDomExports.createPortal(
        /* eslint-disable deprecation/deprecation */
        reactExports.createElement(Fabric, __assign$1({}, !eventBubblingEnabled && getFilteredEvents(), { className: classNames2.content }), children),
        /* eslint-enable deprecation/deprecation */
        layerRef.current
      ));
    });
    LayerBase.displayName = "LayerBase";
    var filteredEventProps;
    var onFilterEvent = function(ev) {
      if (ev.eventPhase === Event.BUBBLING_PHASE && ev.type !== "mouseenter" && ev.type !== "mouseleave" && ev.type !== "touchstart" && ev.type !== "touchend") {
        ev.stopPropagation();
      }
    };
    function getFilteredEvents() {
      if (!filteredEventProps) {
        filteredEventProps = {};
        [
          "onClick",
          "onContextMenu",
          "onDoubleClick",
          "onDrag",
          "onDragEnd",
          "onDragEnter",
          "onDragExit",
          "onDragLeave",
          "onDragOver",
          "onDragStart",
          "onDrop",
          "onMouseDown",
          "onMouseEnter",
          "onMouseLeave",
          "onMouseMove",
          "onMouseOver",
          "onMouseOut",
          "onMouseUp",
          "onTouchMove",
          "onTouchStart",
          "onTouchCancel",
          "onTouchEnd",
          "onKeyDown",
          "onKeyPress",
          "onKeyUp",
          "onFocus",
          "onBlur",
          "onChange",
          "onInput",
          "onInvalid",
          "onSubmit"
        ].forEach(function(name2) {
          return filteredEventProps[name2] = onFilterEvent;
        });
      }
      return filteredEventProps;
    }
    var GlobalClassNames$6 = {
      root: "ms-Layer",
      rootNoHost: "ms-Layer--fixed",
      content: "ms-Layer-content"
    };
    var getStyles$7 = function(props) {
      var className = props.className, isNotHost = props.isNotHost, theme = props.theme;
      var classNames2 = getGlobalClassNames(GlobalClassNames$6, theme);
      return {
        root: [
          classNames2.root,
          theme.fonts.medium,
          isNotHost && [
            classNames2.rootNoHost,
            {
              position: "fixed",
              zIndex: ZIndexes.Layer,
              top: 0,
              left: 0,
              bottom: 0,
              right: 0,
              visibility: "hidden"
            }
          ],
          className
        ],
        content: [
          classNames2.content,
          {
            visibility: "visible"
          }
        ]
      };
    };
    var Layer = styled(LayerBase, getStyles$7, void 0, {
      scope: "Layer",
      fields: ["hostId", "theme", "styles"]
    });
    var Callout = reactExports.forwardRef(function(_a2, forwardedRef) {
      var layerProps = _a2.layerProps, doNotLayer = _a2.doNotLayer, rest = __rest(_a2, ["layerProps", "doNotLayer"]);
      var content2 = reactExports.createElement(CalloutContent, __assign$1({}, rest, { doNotLayer, ref: forwardedRef }));
      return doNotLayer ? content2 : reactExports.createElement(Layer, __assign$1({}, layerProps), content2);
    });
    Callout.displayName = "Callout";
    var IconType;
    (function(IconType2) {
      IconType2[IconType2["default"] = 0] = "default";
      IconType2[IconType2["image"] = 1] = "image";
      IconType2[IconType2["Default"] = 1e5] = "Default";
      IconType2[IconType2["Image"] = 100001] = "Image";
    })(IconType || (IconType = {}));
    var ImageFit;
    (function(ImageFit2) {
      ImageFit2[ImageFit2["center"] = 0] = "center";
      ImageFit2[ImageFit2["contain"] = 1] = "contain";
      ImageFit2[ImageFit2["cover"] = 2] = "cover";
      ImageFit2[ImageFit2["none"] = 3] = "none";
      ImageFit2[ImageFit2["centerCover"] = 4] = "centerCover";
      ImageFit2[ImageFit2["centerContain"] = 5] = "centerContain";
    })(ImageFit || (ImageFit = {}));
    var ImageCoverStyle;
    (function(ImageCoverStyle2) {
      ImageCoverStyle2[ImageCoverStyle2["landscape"] = 0] = "landscape";
      ImageCoverStyle2[ImageCoverStyle2["portrait"] = 1] = "portrait";
    })(ImageCoverStyle || (ImageCoverStyle = {}));
    var ImageLoadState;
    (function(ImageLoadState2) {
      ImageLoadState2[ImageLoadState2["notLoaded"] = 0] = "notLoaded";
      ImageLoadState2[ImageLoadState2["loaded"] = 1] = "loaded";
      ImageLoadState2[ImageLoadState2["error"] = 2] = "error";
      ImageLoadState2[ImageLoadState2["errorLoaded"] = 3] = "errorLoaded";
    })(ImageLoadState || (ImageLoadState = {}));
    var getClassNames$4 = classNamesFunction();
    var SVG_REGEX = /\.svg$/i;
    var KEY_PREFIX = "fabricImage";
    function useLoadState(props, imageElement) {
      var onLoadingStateChange = props.onLoadingStateChange, onLoad = props.onLoad, onError = props.onError, src = props.src;
      var _a2 = reactExports.useState(ImageLoadState.notLoaded), loadState = _a2[0], setLoadState = _a2[1];
      useIsomorphicLayoutEffect$1(function() {
        setLoadState(ImageLoadState.notLoaded);
      }, [src]);
      reactExports.useEffect(function() {
        if (loadState === ImageLoadState.notLoaded) {
          var isLoaded = imageElement.current ? src && imageElement.current.naturalWidth > 0 && imageElement.current.naturalHeight > 0 || imageElement.current.complete && SVG_REGEX.test(src) : false;
          if (isLoaded) {
            setLoadState(ImageLoadState.loaded);
          }
        }
      });
      reactExports.useEffect(function() {
        onLoadingStateChange === null || onLoadingStateChange === void 0 ? void 0 : onLoadingStateChange(loadState);
      }, [loadState]);
      var onImageLoaded = reactExports.useCallback(function(ev) {
        onLoad === null || onLoad === void 0 ? void 0 : onLoad(ev);
        if (src) {
          setLoadState(ImageLoadState.loaded);
        }
      }, [src, onLoad]);
      var onImageError = reactExports.useCallback(function(ev) {
        onError === null || onError === void 0 ? void 0 : onError(ev);
        setLoadState(ImageLoadState.error);
      }, [onError]);
      return [loadState, onImageLoaded, onImageError];
    }
    var ImageBase = reactExports.forwardRef(function(props, forwardedRef) {
      var frameElement = reactExports.useRef();
      var imageElement = reactExports.useRef();
      var _a2 = useLoadState(props, imageElement), loadState = _a2[0], onImageLoaded = _a2[1], onImageError = _a2[2];
      var imageProps = getNativeProps$1(props, imgProperties$1, [
        "width",
        "height"
      ]);
      var src = props.src, alt = props.alt, width = props.width, height = props.height, _b = props.shouldFadeIn, shouldFadeIn = _b === void 0 ? true : _b, shouldStartVisible = props.shouldStartVisible, className = props.className, imageFit = props.imageFit, role = props.role, maximizeFrame = props.maximizeFrame, styles2 = props.styles, theme = props.theme, loading = props.loading;
      var coverStyle = useCoverStyle(props, loadState, imageElement, frameElement);
      var classNames2 = getClassNames$4(styles2, {
        theme,
        className,
        width,
        height,
        maximizeFrame,
        shouldFadeIn,
        shouldStartVisible,
        isLoaded: loadState === ImageLoadState.loaded || loadState === ImageLoadState.notLoaded && props.shouldStartVisible,
        isLandscape: coverStyle === ImageCoverStyle.landscape,
        isCenter: imageFit === ImageFit.center,
        isCenterContain: imageFit === ImageFit.centerContain,
        isCenterCover: imageFit === ImageFit.centerCover,
        isContain: imageFit === ImageFit.contain,
        isCover: imageFit === ImageFit.cover,
        isNone: imageFit === ImageFit.none,
        isError: loadState === ImageLoadState.error,
        isNotImageFit: imageFit === void 0
      });
      return reactExports.createElement(
        "div",
        { className: classNames2.root, style: { width, height }, ref: frameElement },
        reactExports.createElement("img", __assign$1({}, imageProps, { onLoad: onImageLoaded, onError: onImageError, key: KEY_PREFIX + props.src || "", className: classNames2.image, ref: useMergedRefs$1(imageElement, forwardedRef), src, alt, role, loading }))
      );
    });
    ImageBase.displayName = "ImageBase";
    function useCoverStyle(props, loadState, imageElement, frameElement) {
      var previousLoadState = reactExports.useRef(loadState);
      var coverStyle = reactExports.useRef();
      if (coverStyle === void 0 || previousLoadState.current === ImageLoadState.notLoaded && loadState === ImageLoadState.loaded) {
        coverStyle.current = computeCoverStyle(props, loadState, imageElement, frameElement);
      }
      previousLoadState.current = loadState;
      return coverStyle.current;
    }
    function computeCoverStyle(props, loadState, imageElement, frameElement) {
      var imageFit = props.imageFit, width = props.width, height = props.height;
      if (props.coverStyle !== void 0) {
        return props.coverStyle;
      } else if (loadState === ImageLoadState.loaded && (imageFit === ImageFit.cover || imageFit === ImageFit.contain || imageFit === ImageFit.centerContain || imageFit === ImageFit.centerCover) && imageElement.current && frameElement.current) {
        var desiredRatio = void 0;
        if (typeof width === "number" && typeof height === "number" && imageFit !== ImageFit.centerContain && imageFit !== ImageFit.centerCover) {
          desiredRatio = width / height;
        } else {
          desiredRatio = frameElement.current.clientWidth / frameElement.current.clientHeight;
        }
        var naturalRatio = imageElement.current.naturalWidth / imageElement.current.naturalHeight;
        if (naturalRatio > desiredRatio) {
          return ImageCoverStyle.landscape;
        }
      }
      return ImageCoverStyle.portrait;
    }
    var GlobalClassNames$5 = {
      root: "ms-Image",
      rootMaximizeFrame: "ms-Image--maximizeFrame",
      image: "ms-Image-image",
      imageCenter: "ms-Image-image--center",
      imageContain: "ms-Image-image--contain",
      imageCover: "ms-Image-image--cover",
      imageCenterContain: "ms-Image-image--centerContain",
      imageCenterCover: "ms-Image-image--centerCover",
      imageNone: "ms-Image-image--none",
      imageLandscape: "ms-Image-image--landscape",
      imagePortrait: "ms-Image-image--portrait"
    };
    var getStyles$6 = function(props) {
      var className = props.className, width = props.width, height = props.height, maximizeFrame = props.maximizeFrame, isLoaded = props.isLoaded, shouldFadeIn = props.shouldFadeIn, shouldStartVisible = props.shouldStartVisible, isLandscape = props.isLandscape, isCenter = props.isCenter, isContain = props.isContain, isCover = props.isCover, isCenterContain = props.isCenterContain, isCenterCover = props.isCenterCover, isNone2 = props.isNone, isError = props.isError, isNotImageFit = props.isNotImageFit, theme = props.theme;
      var classNames2 = getGlobalClassNames(GlobalClassNames$5, theme);
      var ImageFitStyles = {
        position: "absolute",
        left: "50% /* @noflip */",
        top: "50%",
        transform: "translate(-50%,-50%)"
        // @todo test RTL renders transform: translate(50%,-50%);
      };
      var window2 = getWindow();
      var supportsObjectFit = window2 !== void 0 && window2.navigator.msMaxTouchPoints === void 0;
      var fallbackObjectFitStyles = isContain && isLandscape || isCover && !isLandscape ? { width: "100%", height: "auto" } : { width: "auto", height: "100%" };
      return {
        root: [
          classNames2.root,
          theme.fonts.medium,
          {
            overflow: "hidden"
          },
          maximizeFrame && [
            classNames2.rootMaximizeFrame,
            {
              height: "100%",
              width: "100%"
            }
          ],
          isLoaded && shouldFadeIn && !shouldStartVisible && AnimationClassNames.fadeIn400,
          (isCenter || isContain || isCover || isCenterContain || isCenterCover) && {
            position: "relative"
          },
          className
        ],
        image: [
          classNames2.image,
          {
            display: "block",
            opacity: 0
          },
          isLoaded && [
            "is-loaded",
            {
              opacity: 1
            }
          ],
          isCenter && [classNames2.imageCenter, ImageFitStyles],
          isContain && [
            classNames2.imageContain,
            supportsObjectFit && {
              width: "100%",
              height: "100%",
              objectFit: "contain"
            },
            !supportsObjectFit && fallbackObjectFitStyles,
            !supportsObjectFit && ImageFitStyles
          ],
          isCover && [
            classNames2.imageCover,
            supportsObjectFit && {
              width: "100%",
              height: "100%",
              objectFit: "cover"
            },
            !supportsObjectFit && fallbackObjectFitStyles,
            !supportsObjectFit && ImageFitStyles
          ],
          isCenterContain && [
            classNames2.imageCenterContain,
            isLandscape && {
              maxWidth: "100%"
            },
            !isLandscape && {
              maxHeight: "100%"
            },
            ImageFitStyles
          ],
          isCenterCover && [
            classNames2.imageCenterCover,
            isLandscape && {
              maxHeight: "100%"
            },
            !isLandscape && {
              maxWidth: "100%"
            },
            ImageFitStyles
          ],
          isNone2 && [
            classNames2.imageNone,
            {
              width: "auto",
              height: "auto"
            }
          ],
          isNotImageFit && [
            !!width && !height && {
              height: "auto",
              width: "100%"
            },
            !width && !!height && {
              height: "100%",
              width: "auto"
            },
            !!width && !!height && {
              height: "100%",
              width: "100%"
            }
          ],
          isLandscape && classNames2.imageLandscape,
          !isLandscape && classNames2.imagePortrait,
          !isLoaded && "is-notLoaded",
          shouldFadeIn && "is-fadeIn",
          isError && "is-error"
        ]
      };
    };
    var Image$1 = styled(ImageBase, getStyles$6, void 0, {
      scope: "Image"
    }, true);
    Image$1.displayName = "Image";
    var classNames = mergeStyleSets({
      root: {
        display: "inline-block"
      },
      placeholder: [
        "ms-Icon-placeHolder",
        {
          width: "1em"
        }
      ],
      image: [
        "ms-Icon-imageContainer",
        {
          overflow: "hidden"
        }
      ]
    });
    var MS_ICON = "ms-Icon";
    var getStyles$5 = function(props) {
      var className = props.className, iconClassName = props.iconClassName, isPlaceholder = props.isPlaceholder, isImage = props.isImage, styles2 = props.styles;
      return {
        root: [
          isPlaceholder && classNames.placeholder,
          classNames.root,
          isImage && classNames.image,
          iconClassName,
          className,
          styles2 && styles2.root,
          // eslint-disable-next-line deprecation/deprecation
          styles2 && styles2.imageContainer
        ]
      };
    };
    var getIconContent = memoizeFunction(
      function(iconName) {
        var _a2 = getIcon(iconName) || {
          subset: {},
          code: void 0
        }, code2 = _a2.code, subset = _a2.subset;
        if (!code2) {
          return null;
        }
        return {
          children: code2,
          iconClassName: subset.className,
          fontFamily: subset.fontFace && subset.fontFace.fontFamily,
          mergeImageProps: subset.mergeImageProps
        };
      },
      void 0,
      true
      /*ignoreNullOrUndefinedResult */
    );
    var FontIcon = function(props) {
      var iconName = props.iconName, className = props.className, _a2 = props.style, style2 = _a2 === void 0 ? {} : _a2;
      var iconContent = getIconContent(iconName) || {};
      var iconClassName = iconContent.iconClassName, children = iconContent.children, fontFamily = iconContent.fontFamily, mergeImageProps = iconContent.mergeImageProps;
      var nativeProps = getNativeProps$1(props, htmlElementProperties$1);
      var accessibleName = props["aria-label"] || props.title;
      var containerProps = props["aria-label"] || props["aria-labelledby"] || props.title ? {
        role: mergeImageProps ? void 0 : "img"
      } : {
        "aria-hidden": true
      };
      var finalChildren = children;
      if (mergeImageProps) {
        if (typeof children === "object" && typeof children.props === "object" && accessibleName) {
          finalChildren = reactExports.cloneElement(children, { alt: accessibleName });
        }
      }
      return reactExports.createElement("i", __assign$1({ "data-icon-name": iconName }, containerProps, nativeProps, mergeImageProps ? {
        title: void 0,
        "aria-label": void 0
      } : {}, {
        className: css$1(MS_ICON, classNames.root, iconClassName, !iconName && classNames.placeholder, className),
        // Apply the font family this way to ensure it doesn't get overridden by Fabric Core ms-Icon styles
        // https://github.com/microsoft/fluentui/issues/10449
        style: __assign$1({ fontFamily }, style2)
      }), finalChildren);
    };
    memoizeFunction(function(iconName, className, ariaLabel) {
      return FontIcon({ iconName, className, "aria-label": ariaLabel });
    });
    var getClassNames$3 = classNamesFunction({
      // Icon is used a lot by other components.
      // It's likely to see expected cases which pass different className to the Icon.
      // Therefore setting a larger cache size.
      cacheSize: 100
    });
    var IconBase = (
      /** @class */
      function(_super) {
        __extends(IconBase2, _super);
        function IconBase2(props) {
          var _this = _super.call(this, props) || this;
          _this._onImageLoadingStateChange = function(state) {
            if (_this.props.imageProps && _this.props.imageProps.onLoadingStateChange) {
              _this.props.imageProps.onLoadingStateChange(state);
            }
            if (state === ImageLoadState.error) {
              _this.setState({ imageLoadError: true });
            }
          };
          _this.state = {
            imageLoadError: false
          };
          return _this;
        }
        IconBase2.prototype.render = function() {
          var _a2 = this.props, children = _a2.children, className = _a2.className, styles2 = _a2.styles, iconName = _a2.iconName, imageErrorAs = _a2.imageErrorAs, theme = _a2.theme;
          var isPlaceholder = typeof iconName === "string" && iconName.length === 0;
          var isImage = (
            // eslint-disable-next-line deprecation/deprecation
            !!this.props.imageProps || this.props.iconType === IconType.image || this.props.iconType === IconType.Image
          );
          var iconContent = getIconContent(iconName) || {};
          var iconClassName = iconContent.iconClassName, iconContentChildren = iconContent.children, mergeImageProps = iconContent.mergeImageProps;
          var classNames2 = getClassNames$3(styles2, {
            theme,
            className,
            iconClassName,
            isImage,
            isPlaceholder
          });
          var RootType = isImage ? "span" : "i";
          var nativeProps = getNativeProps$1(this.props, htmlElementProperties$1, [
            "aria-label"
          ]);
          var imageLoadError = this.state.imageLoadError;
          var imageProps = __assign$1(__assign$1({}, this.props.imageProps), { onLoadingStateChange: this._onImageLoadingStateChange });
          var ImageType = imageLoadError && imageErrorAs || Image$1;
          var ariaLabel = this.props["aria-label"] || this.props.ariaLabel;
          var accessibleName = imageProps.alt || ariaLabel || this.props.title;
          var hasName = !!(accessibleName || this.props["aria-labelledby"] || imageProps["aria-label"] || imageProps["aria-labelledby"]);
          var containerProps = hasName ? {
            role: isImage || mergeImageProps ? void 0 : "img",
            "aria-label": isImage || mergeImageProps ? void 0 : accessibleName
          } : {
            "aria-hidden": true
          };
          var finalIconContentChildren = iconContentChildren;
          if (mergeImageProps && iconContentChildren && typeof iconContentChildren === "object" && accessibleName) {
            finalIconContentChildren = reactExports.cloneElement(iconContentChildren, {
              alt: accessibleName
            });
          }
          return reactExports.createElement(RootType, __assign$1({ "data-icon-name": iconName }, containerProps, nativeProps, mergeImageProps ? {
            title: void 0,
            "aria-label": void 0
          } : {}, { className: classNames2.root }), isImage ? reactExports.createElement(ImageType, __assign$1({}, imageProps)) : children || finalIconContentChildren);
        };
        return IconBase2;
      }(reactExports.Component)
    );
    var Icon = styled(IconBase, getStyles$5, void 0, {
      scope: "Icon"
    }, true);
    Icon.displayName = "Icon";
    var ImageIcon = function(props) {
      var className = props.className, imageProps = props.imageProps;
      var nativeProps = getNativeProps$1(props, htmlElementProperties$1, [
        "aria-label",
        "aria-labelledby",
        "title",
        "aria-describedby"
      ]);
      var altText = imageProps.alt || props["aria-label"];
      var hasName = altText || props["aria-labelledby"] || props.title || imageProps["aria-label"] || imageProps["aria-labelledby"] || imageProps.title;
      var imageNameProps = {
        "aria-labelledby": props["aria-labelledby"],
        "aria-describedby": props["aria-describedby"],
        title: props.title
      };
      var containerProps = hasName ? {} : {
        "aria-hidden": true
      };
      return reactExports.createElement(
        "div",
        __assign$1({}, containerProps, nativeProps, { className: css$1(MS_ICON, classNames.root, classNames.image, className) }),
        reactExports.createElement(Image$1, __assign$1({}, imageNameProps, imageProps, { alt: hasName ? altText : "" }))
      );
    };
    var FocusZoneTabbableElements = {
      /** Tabbing is not allowed */
      none: 0,
      /** All tabbing action is allowed */
      all: 1,
      /** Tabbing is allowed only on input elements */
      inputOnly: 2
    };
    var FocusZoneDirection;
    (function(FocusZoneDirection2) {
      FocusZoneDirection2[FocusZoneDirection2["vertical"] = 0] = "vertical";
      FocusZoneDirection2[FocusZoneDirection2["horizontal"] = 1] = "horizontal";
      FocusZoneDirection2[FocusZoneDirection2["bidirectional"] = 2] = "bidirectional";
      FocusZoneDirection2[FocusZoneDirection2["domOrder"] = 3] = "domOrder";
    })(FocusZoneDirection || (FocusZoneDirection = {}));
    var IS_FOCUSABLE_ATTRIBUTE = "data-is-focusable";
    var IS_ENTER_DISABLED_ATTRIBUTE = "data-disable-click-on-enter";
    var FOCUSZONE_ID_ATTRIBUTE = "data-focuszone-id";
    var TABINDEX = "tabindex";
    var NO_VERTICAL_WRAP = "data-no-vertical-wrap";
    var NO_HORIZONTAL_WRAP = "data-no-horizontal-wrap";
    var LARGE_DISTANCE_FROM_CENTER = 999999999;
    var LARGE_NEGATIVE_DISTANCE_FROM_CENTER = -999999999;
    var focusZoneStyles;
    var focusZoneClass = "ms-FocusZone";
    function raiseClickFromKeyboardEvent(target, ev) {
      var event;
      if (typeof MouseEvent === "function") {
        event = new MouseEvent("click", {
          ctrlKey: ev === null || ev === void 0 ? void 0 : ev.ctrlKey,
          metaKey: ev === null || ev === void 0 ? void 0 : ev.metaKey,
          shiftKey: ev === null || ev === void 0 ? void 0 : ev.shiftKey,
          altKey: ev === null || ev === void 0 ? void 0 : ev.altKey,
          bubbles: ev === null || ev === void 0 ? void 0 : ev.bubbles,
          cancelable: ev === null || ev === void 0 ? void 0 : ev.cancelable
        });
      } else {
        event = document.createEvent("MouseEvents");
        event.initMouseEvent(
          "click",
          ev ? ev.bubbles : false,
          ev ? ev.cancelable : false,
          window,
          // not using getWindow() since this can only be run client side
          0,
          // detail
          0,
          // screen x
          0,
          // screen y
          0,
          // client x
          0,
          // client y
          ev ? ev.ctrlKey : false,
          ev ? ev.altKey : false,
          ev ? ev.shiftKey : false,
          ev ? ev.metaKey : false,
          0,
          // button
          null
        );
      }
      target.dispatchEvent(event);
    }
    function getRootClass() {
      if (!focusZoneStyles) {
        focusZoneStyles = mergeStyles({
          selectors: {
            ":focus": {
              outline: "none"
            }
          }
        }, focusZoneClass);
      }
      return focusZoneStyles;
    }
    var _allInstances = {};
    var _outerZones = /* @__PURE__ */ new Set();
    var ALLOWED_INPUT_TYPES = ["text", "number", "password", "email", "tel", "url", "search"];
    var ALLOW_VIRTUAL_ELEMENTS = false;
    var FocusZone = (
      /** @class */
      function(_super) {
        __extends(FocusZone2, _super);
        function FocusZone2(props) {
          var _a2, _b, _c, _d;
          var _this = _super.call(this, props) || this;
          _this._root = reactExports.createRef();
          _this._mergedRef = createMergedRef();
          _this._onFocus = function(ev) {
            if (_this._portalContainsElement(ev.target)) {
              return;
            }
            var _a3 = _this.props, onActiveElementChanged = _a3.onActiveElementChanged, doNotAllowFocusEventToPropagate = _a3.doNotAllowFocusEventToPropagate, stopFocusPropagation = _a3.stopFocusPropagation, onFocusNotification = _a3.onFocusNotification, onFocus = _a3.onFocus, shouldFocusInnerElementWhenReceivedFocus = _a3.shouldFocusInnerElementWhenReceivedFocus, defaultTabbableElement = _a3.defaultTabbableElement;
            var isImmediateDescendant = _this._isImmediateDescendantOfZone(ev.target);
            var newActiveElement;
            if (isImmediateDescendant) {
              newActiveElement = ev.target;
            } else {
              var parentElement = ev.target;
              while (parentElement && parentElement !== _this._root.current) {
                if (isElementTabbable(parentElement) && _this._isImmediateDescendantOfZone(parentElement)) {
                  newActiveElement = parentElement;
                  break;
                }
                parentElement = getParent$1(parentElement, ALLOW_VIRTUAL_ELEMENTS);
              }
            }
            if (shouldFocusInnerElementWhenReceivedFocus && ev.target === _this._root.current) {
              var maybeElementToFocus = defaultTabbableElement && typeof defaultTabbableElement === "function" && _this._root.current && defaultTabbableElement(_this._root.current);
              if (maybeElementToFocus && isElementTabbable(maybeElementToFocus)) {
                newActiveElement = maybeElementToFocus;
                maybeElementToFocus.focus();
              } else {
                _this.focus(true);
                if (_this._activeElement) {
                  newActiveElement = null;
                }
              }
            }
            var initialElementFocused = !_this._activeElement;
            if (newActiveElement && newActiveElement !== _this._activeElement) {
              if (isImmediateDescendant || initialElementFocused) {
                _this._setFocusAlignment(newActiveElement, true, true);
              }
              _this._activeElement = newActiveElement;
              if (initialElementFocused) {
                _this._updateTabIndexes();
              }
            }
            if (onActiveElementChanged) {
              onActiveElementChanged(_this._activeElement, ev);
            }
            if (stopFocusPropagation || doNotAllowFocusEventToPropagate) {
              ev.stopPropagation();
            }
            if (onFocus) {
              onFocus(ev);
            } else if (onFocusNotification) {
              onFocusNotification();
            }
          };
          _this._onBlur = function() {
            _this._setParkedFocus(false);
          };
          _this._onMouseDown = function(ev) {
            if (_this._portalContainsElement(ev.target)) {
              return;
            }
            var disabled = _this.props.disabled;
            if (disabled) {
              return;
            }
            var target = ev.target;
            var path2 = [];
            while (target && target !== _this._root.current) {
              path2.push(target);
              target = getParent$1(target, ALLOW_VIRTUAL_ELEMENTS);
            }
            while (path2.length) {
              target = path2.pop();
              if (target && isElementTabbable(target)) {
                _this._setActiveElement(target, true);
              }
              if (isElementFocusZone(target)) {
                break;
              }
            }
          };
          _this._onKeyDown = function(ev, theme) {
            if (_this._portalContainsElement(ev.target)) {
              return;
            }
            var _a3 = _this.props, direction = _a3.direction, disabled = _a3.disabled, isInnerZoneKeystroke = _a3.isInnerZoneKeystroke, pagingSupportDisabled = _a3.pagingSupportDisabled, shouldEnterInnerZone = _a3.shouldEnterInnerZone;
            if (disabled) {
              return;
            }
            if (_this.props.onKeyDown) {
              _this.props.onKeyDown(ev);
            }
            if (ev.isDefaultPrevented()) {
              return;
            }
            if (_this._getDocument().activeElement === _this._root.current && _this._isInnerZone) {
              return;
            }
            if ((shouldEnterInnerZone && shouldEnterInnerZone(ev) || isInnerZoneKeystroke && isInnerZoneKeystroke(ev)) && _this._isImmediateDescendantOfZone(ev.target)) {
              var innerZone = _this._getFirstInnerZone();
              if (innerZone) {
                if (!innerZone.focus(true)) {
                  return;
                }
              } else if (isElementFocusSubZone(ev.target)) {
                if (!_this.focusElement(getNextElement(ev.target, ev.target.firstChild, true))) {
                  return;
                }
              } else {
                return;
              }
            } else if (ev.altKey) {
              return;
            } else {
              switch (ev.which) {
                case KeyCodes.space:
                  if (_this._shouldRaiseClicksOnSpace && _this._tryInvokeClickForFocusable(ev.target, ev)) {
                    break;
                  }
                  return;
                case KeyCodes.left:
                  if (direction !== FocusZoneDirection.vertical) {
                    _this._preventDefaultWhenHandled(ev);
                    if (_this._moveFocusLeft(theme)) {
                      break;
                    }
                  }
                  return;
                case KeyCodes.right:
                  if (direction !== FocusZoneDirection.vertical) {
                    _this._preventDefaultWhenHandled(ev);
                    if (_this._moveFocusRight(theme)) {
                      break;
                    }
                  }
                  return;
                case KeyCodes.up:
                  if (direction !== FocusZoneDirection.horizontal) {
                    _this._preventDefaultWhenHandled(ev);
                    if (_this._moveFocusUp()) {
                      break;
                    }
                  }
                  return;
                case KeyCodes.down:
                  if (direction !== FocusZoneDirection.horizontal) {
                    _this._preventDefaultWhenHandled(ev);
                    if (_this._moveFocusDown()) {
                      break;
                    }
                  }
                  return;
                case KeyCodes.pageDown:
                  if (!pagingSupportDisabled && _this._moveFocusPaging(true)) {
                    break;
                  }
                  return;
                case KeyCodes.pageUp:
                  if (!pagingSupportDisabled && _this._moveFocusPaging(false)) {
                    break;
                  }
                  return;
                case KeyCodes.tab:
                  if (
                    // eslint-disable-next-line deprecation/deprecation
                    _this.props.allowTabKey || _this.props.handleTabKey === FocusZoneTabbableElements.all || _this.props.handleTabKey === FocusZoneTabbableElements.inputOnly && _this._isElementInput(ev.target)
                  ) {
                    var focusChanged = false;
                    _this._processingTabKey = true;
                    if (direction === FocusZoneDirection.vertical || !_this._shouldWrapFocus(_this._activeElement, NO_HORIZONTAL_WRAP)) {
                      focusChanged = ev.shiftKey ? _this._moveFocusUp() : _this._moveFocusDown();
                    } else {
                      var tabWithDirection = getRTL(theme) ? !ev.shiftKey : ev.shiftKey;
                      focusChanged = tabWithDirection ? _this._moveFocusLeft(theme) : _this._moveFocusRight(theme);
                    }
                    _this._processingTabKey = false;
                    if (focusChanged) {
                      break;
                    } else if (_this.props.shouldResetActiveElementWhenTabFromZone) {
                      _this._activeElement = null;
                    }
                  }
                  return;
                case KeyCodes.home:
                  if (_this._isContentEditableElement(ev.target) || _this._isElementInput(ev.target) && !_this._shouldInputLoseFocus(ev.target, false)) {
                    return false;
                  }
                  var firstChild = _this._root.current && _this._root.current.firstChild;
                  if (_this._root.current && firstChild && _this.focusElement(getNextElement(_this._root.current, firstChild, true))) {
                    break;
                  }
                  return;
                case KeyCodes.end:
                  if (_this._isContentEditableElement(ev.target) || _this._isElementInput(ev.target) && !_this._shouldInputLoseFocus(ev.target, true)) {
                    return false;
                  }
                  var lastChild = _this._root.current && _this._root.current.lastChild;
                  if (_this._root.current && _this.focusElement(getPreviousElement(_this._root.current, lastChild, true, true, true))) {
                    break;
                  }
                  return;
                case KeyCodes.enter:
                  if (_this._shouldRaiseClicksOnEnter && _this._tryInvokeClickForFocusable(ev.target, ev)) {
                    break;
                  }
                  return;
                default:
                  return;
              }
            }
            ev.preventDefault();
            ev.stopPropagation();
          };
          _this._getHorizontalDistanceFromCenter = function(isForward, activeRect, targetRect) {
            var leftAlignment = _this._focusAlignment.left || _this._focusAlignment.x || 0;
            var targetRectTop = Math.floor(targetRect.top);
            var activeRectBottom = Math.floor(activeRect.bottom);
            var targetRectBottom = Math.floor(targetRect.bottom);
            var activeRectTop = Math.floor(activeRect.top);
            var isValidCandidateOnpagingDown = isForward && targetRectTop > activeRectBottom;
            var isValidCandidateOnpagingUp = !isForward && targetRectBottom < activeRectTop;
            if (isValidCandidateOnpagingDown || isValidCandidateOnpagingUp) {
              if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {
                return 0;
              }
              return Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);
            }
            if (!_this._shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {
              return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
            }
            return LARGE_DISTANCE_FROM_CENTER;
          };
          initializeComponentRef(_this);
          _this._id = getId("FocusZone");
          _this._focusAlignment = {
            left: 0,
            top: 0
          };
          _this._processingTabKey = false;
          var shouldRaiseClicksFallback = (_b = (_a2 = props.shouldRaiseClicks) !== null && _a2 !== void 0 ? _a2 : FocusZone2.defaultProps.shouldRaiseClicks) !== null && _b !== void 0 ? _b : true;
          _this._shouldRaiseClicksOnEnter = (_c = props.shouldRaiseClicksOnEnter) !== null && _c !== void 0 ? _c : shouldRaiseClicksFallback;
          _this._shouldRaiseClicksOnSpace = (_d = props.shouldRaiseClicksOnSpace) !== null && _d !== void 0 ? _d : shouldRaiseClicksFallback;
          return _this;
        }
        FocusZone2.getOuterZones = function() {
          return _outerZones.size;
        };
        FocusZone2._onKeyDownCapture = function(ev) {
          if (ev.which === KeyCodes.tab) {
            _outerZones.forEach(function(zone) {
              return zone._updateTabIndexes();
            });
          }
        };
        FocusZone2.prototype.componentDidMount = function() {
          var root2 = this._root.current;
          _allInstances[this._id] = this;
          if (root2) {
            this._windowElement = getWindow(root2);
            var parentElement = getParent$1(root2, ALLOW_VIRTUAL_ELEMENTS);
            while (parentElement && parentElement !== this._getDocument().body && parentElement.nodeType === 1) {
              if (isElementFocusZone(parentElement)) {
                this._isInnerZone = true;
                break;
              }
              parentElement = getParent$1(parentElement, ALLOW_VIRTUAL_ELEMENTS);
            }
            if (!this._isInnerZone) {
              _outerZones.add(this);
              if (this._windowElement && _outerZones.size === 1) {
                this._windowElement.addEventListener("keydown", FocusZone2._onKeyDownCapture, true);
              }
            }
            this._root.current && this._root.current.addEventListener("blur", this._onBlur, true);
            this._updateTabIndexes();
            if (this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement === "string") {
              this._activeElement = this._getDocument().querySelector(this.props.defaultTabbableElement);
            } else if (this.props.defaultActiveElement) {
              this._activeElement = this._getDocument().querySelector(this.props.defaultActiveElement);
            }
            if (this.props.shouldFocusOnMount) {
              this.focus();
            }
          }
        };
        FocusZone2.prototype.componentDidUpdate = function() {
          var root2 = this._root.current;
          var doc = this._getDocument();
          if (!this.props.preventFocusRestoration && doc && this._lastIndexPath && (doc.activeElement === doc.body || doc.activeElement === null || doc.activeElement === root2)) {
            var elementToFocus = getFocusableByIndexPath(root2, this._lastIndexPath);
            if (elementToFocus) {
              this._setActiveElement(elementToFocus, true);
              elementToFocus.focus();
              this._setParkedFocus(false);
            } else {
              this._setParkedFocus(true);
            }
          }
        };
        FocusZone2.prototype.componentWillUnmount = function() {
          delete _allInstances[this._id];
          if (!this._isInnerZone) {
            _outerZones.delete(this);
            if (this._windowElement && _outerZones.size === 0) {
              this._windowElement.removeEventListener("keydown", FocusZone2._onKeyDownCapture, true);
            }
          }
          if (this._root.current) {
            this._root.current.removeEventListener("blur", this._onBlur, true);
          }
          this._activeElement = null;
          this._defaultFocusElement = null;
        };
        FocusZone2.prototype.render = function() {
          var _this = this;
          var _a2 = this.props, tag = _a2.as, elementType = _a2.elementType, rootProps = _a2.rootProps, ariaDescribedBy = _a2.ariaDescribedBy, ariaLabelledBy = _a2.ariaLabelledBy, className = _a2.className;
          var divProps = getNativeProps$1(this.props, htmlElementProperties$1);
          var Tag = tag || elementType || "div";
          this._evaluateFocusBeforeRender();
          var theme = getTheme();
          return reactExports.createElement(Tag, __assign$1({ "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy }, divProps, rootProps, {
            // Once the getClassName correctly memoizes inputs this should
            // be replaced so that className is passed to getRootClass and is included there so
            // the class names will always be in the same order.
            className: css$1(getRootClass(), className),
            // eslint-disable-next-line deprecation/deprecation
            ref: this._mergedRef(this.props.elementRef, this._root),
            "data-focuszone-id": this._id,
            // eslint-disable-next-line react/jsx-no-bind
            onKeyDown: function(ev) {
              return _this._onKeyDown(ev, theme);
            },
            onFocus: this._onFocus,
            onMouseDownCapture: this._onMouseDown
          }), this.props.children);
        };
        FocusZone2.prototype.focus = function(forceIntoFirstElement) {
          if (forceIntoFirstElement === void 0) {
            forceIntoFirstElement = false;
          }
          if (this._root.current) {
            if (!forceIntoFirstElement && this._root.current.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === "true" && this._isInnerZone) {
              var ownerZoneElement = this._getOwnerZone(this._root.current);
              if (ownerZoneElement !== this._root.current) {
                var ownerZone = _allInstances[ownerZoneElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];
                return !!ownerZone && ownerZone.focusElement(this._root.current);
              }
              return false;
            } else if (!forceIntoFirstElement && this._activeElement && elementContains$1(this._root.current, this._activeElement) && isElementTabbable(this._activeElement)) {
              this._activeElement.focus();
              return true;
            } else {
              var firstChild = this._root.current.firstChild;
              return this.focusElement(getNextElement(this._root.current, firstChild, true));
            }
          }
          return false;
        };
        FocusZone2.prototype.focusLast = function() {
          if (this._root.current) {
            var lastChild = this._root.current && this._root.current.lastChild;
            return this.focusElement(getPreviousElement(this._root.current, lastChild, true, true, true));
          }
          return false;
        };
        FocusZone2.prototype.focusElement = function(element2, forceAlignment) {
          var _a2 = this.props, onBeforeFocus = _a2.onBeforeFocus, shouldReceiveFocus = _a2.shouldReceiveFocus;
          if (shouldReceiveFocus && !shouldReceiveFocus(element2) || onBeforeFocus && !onBeforeFocus(element2)) {
            return false;
          }
          if (element2) {
            this._setActiveElement(element2, forceAlignment);
            if (this._activeElement) {
              this._activeElement.focus();
            }
            return true;
          }
          return false;
        };
        FocusZone2.prototype.setFocusAlignment = function(point2) {
          this._focusAlignment = point2;
        };
        FocusZone2.prototype._evaluateFocusBeforeRender = function() {
          var root2 = this._root.current;
          var doc = this._getDocument();
          if (doc) {
            var focusedElement = doc.activeElement;
            if (focusedElement !== root2) {
              var shouldRestoreFocus = elementContains$1(root2, focusedElement, false);
              this._lastIndexPath = shouldRestoreFocus ? getElementIndexPath(root2, focusedElement) : void 0;
            }
          }
        };
        FocusZone2.prototype._setParkedFocus = function(isParked) {
          var root2 = this._root.current;
          if (root2 && this._isParked !== isParked) {
            this._isParked = isParked;
            if (isParked) {
              if (!this.props.allowFocusRoot) {
                this._parkedTabIndex = root2.getAttribute("tabindex");
                root2.setAttribute("tabindex", "-1");
              }
              root2.focus();
            } else if (!this.props.allowFocusRoot) {
              if (this._parkedTabIndex) {
                root2.setAttribute("tabindex", this._parkedTabIndex);
                this._parkedTabIndex = void 0;
              } else {
                root2.removeAttribute("tabindex");
              }
            }
          }
        };
        FocusZone2.prototype._setActiveElement = function(element2, forceAlignment) {
          var previousActiveElement = this._activeElement;
          this._activeElement = element2;
          if (previousActiveElement) {
            if (isElementFocusZone(previousActiveElement)) {
              this._updateTabIndexes(previousActiveElement);
            }
            previousActiveElement.tabIndex = -1;
          }
          if (this._activeElement) {
            if (!this._focusAlignment || forceAlignment) {
              this._setFocusAlignment(element2, true, true);
            }
            this._activeElement.tabIndex = 0;
          }
        };
        FocusZone2.prototype._preventDefaultWhenHandled = function(ev) {
          this.props.preventDefaultWhenHandled && ev.preventDefault();
        };
        FocusZone2.prototype._tryInvokeClickForFocusable = function(targetElement, ev) {
          var target = targetElement;
          if (target === this._root.current) {
            return false;
          }
          do {
            if (target.tagName === "BUTTON" || target.tagName === "A" || target.tagName === "INPUT" || target.tagName === "TEXTAREA") {
              return false;
            }
            if (this._isImmediateDescendantOfZone(target) && target.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === "true" && target.getAttribute(IS_ENTER_DISABLED_ATTRIBUTE) !== "true") {
              raiseClickFromKeyboardEvent(target, ev);
              return true;
            }
            target = getParent$1(target, ALLOW_VIRTUAL_ELEMENTS);
          } while (target !== this._root.current);
          return false;
        };
        FocusZone2.prototype._getFirstInnerZone = function(rootElement) {
          rootElement = rootElement || this._activeElement || this._root.current;
          if (!rootElement) {
            return null;
          }
          if (isElementFocusZone(rootElement)) {
            return _allInstances[rootElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];
          }
          var child = rootElement.firstElementChild;
          while (child) {
            if (isElementFocusZone(child)) {
              return _allInstances[child.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];
            }
            var match5 = this._getFirstInnerZone(child);
            if (match5) {
              return match5;
            }
            child = child.nextElementSibling;
          }
          return null;
        };
        FocusZone2.prototype._moveFocus = function(isForward, getDistanceFromCenter, ev, useDefaultWrap) {
          if (useDefaultWrap === void 0) {
            useDefaultWrap = true;
          }
          var element2 = this._activeElement;
          var candidateDistance = -1;
          var candidateElement = void 0;
          var changedFocus = false;
          var isBidirectional = this.props.direction === FocusZoneDirection.bidirectional;
          if (!element2 || !this._root.current) {
            return false;
          }
          if (this._isElementInput(element2)) {
            if (!this._shouldInputLoseFocus(element2, isForward)) {
              return false;
            }
          }
          var activeRect = isBidirectional ? element2.getBoundingClientRect() : null;
          do {
            element2 = isForward ? getNextElement(this._root.current, element2) : getPreviousElement(this._root.current, element2);
            if (isBidirectional) {
              if (element2) {
                var targetRect = element2.getBoundingClientRect();
                var elementDistance = getDistanceFromCenter(activeRect, targetRect);
                if (elementDistance === -1 && candidateDistance === -1) {
                  candidateElement = element2;
                  break;
                }
                if (elementDistance > -1 && (candidateDistance === -1 || elementDistance < candidateDistance)) {
                  candidateDistance = elementDistance;
                  candidateElement = element2;
                }
                if (candidateDistance >= 0 && elementDistance < 0) {
                  break;
                }
              }
            } else {
              candidateElement = element2;
              break;
            }
          } while (element2);
          if (candidateElement && candidateElement !== this._activeElement) {
            changedFocus = true;
            this.focusElement(candidateElement);
          } else if (this.props.isCircularNavigation && useDefaultWrap) {
            if (isForward) {
              return this.focusElement(getNextElement(this._root.current, this._root.current.firstElementChild, true));
            } else {
              return this.focusElement(getPreviousElement(this._root.current, this._root.current.lastElementChild, true, true, true));
            }
          }
          return changedFocus;
        };
        FocusZone2.prototype._moveFocusDown = function() {
          var _this = this;
          var targetTop = -1;
          var leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;
          if (this._moveFocus(true, function(activeRect, targetRect) {
            var distance = -1;
            var targetRectTop = Math.floor(targetRect.top);
            var activeRectBottom = Math.floor(activeRect.bottom);
            if (targetRectTop < activeRectBottom) {
              if (!_this._shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {
                return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
              }
              return LARGE_DISTANCE_FROM_CENTER;
            }
            if (targetTop === -1 && targetRectTop >= activeRectBottom || targetRectTop === targetTop) {
              targetTop = targetRectTop;
              if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {
                distance = 0;
              } else {
                distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);
              }
            }
            return distance;
          })) {
            this._setFocusAlignment(this._activeElement, false, true);
            return true;
          }
          return false;
        };
        FocusZone2.prototype._moveFocusUp = function() {
          var _this = this;
          var targetTop = -1;
          var leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;
          if (this._moveFocus(false, function(activeRect, targetRect) {
            var distance = -1;
            var targetRectBottom = Math.floor(targetRect.bottom);
            var targetRectTop = Math.floor(targetRect.top);
            var activeRectTop = Math.floor(activeRect.top);
            if (targetRectBottom > activeRectTop) {
              if (!_this._shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {
                return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
              }
              return LARGE_DISTANCE_FROM_CENTER;
            }
            if (targetTop === -1 && targetRectBottom <= activeRectTop || targetRectTop === targetTop) {
              targetTop = targetRectTop;
              if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {
                distance = 0;
              } else {
                distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);
              }
            }
            return distance;
          })) {
            this._setFocusAlignment(this._activeElement, false, true);
            return true;
          }
          return false;
        };
        FocusZone2.prototype._moveFocusLeft = function(theme) {
          var _this = this;
          var shouldWrap = this._shouldWrapFocus(this._activeElement, NO_HORIZONTAL_WRAP);
          if (this._moveFocus(getRTL(theme), function(activeRect, targetRect) {
            var distance = -1;
            var topBottomComparison;
            if (getRTL(theme)) {
              topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));
            } else {
              topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));
            }
            if (topBottomComparison && targetRect.right <= activeRect.right && _this.props.direction !== FocusZoneDirection.vertical) {
              distance = activeRect.right - targetRect.right;
            } else if (!shouldWrap) {
              distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
            }
            return distance;
          }, void 0, shouldWrap)) {
            this._setFocusAlignment(this._activeElement, true, false);
            return true;
          }
          return false;
        };
        FocusZone2.prototype._moveFocusRight = function(theme) {
          var _this = this;
          var shouldWrap = this._shouldWrapFocus(this._activeElement, NO_HORIZONTAL_WRAP);
          if (this._moveFocus(!getRTL(theme), function(activeRect, targetRect) {
            var distance = -1;
            var topBottomComparison;
            if (getRTL(theme)) {
              topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));
            } else {
              topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));
            }
            if (topBottomComparison && targetRect.left >= activeRect.left && _this.props.direction !== FocusZoneDirection.vertical) {
              distance = targetRect.left - activeRect.left;
            } else if (!shouldWrap) {
              distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;
            }
            return distance;
          }, void 0, shouldWrap)) {
            this._setFocusAlignment(this._activeElement, true, false);
            return true;
          }
          return false;
        };
        FocusZone2.prototype._moveFocusPaging = function(isForward, useDefaultWrap) {
          if (useDefaultWrap === void 0) {
            useDefaultWrap = true;
          }
          var element2 = this._activeElement;
          if (!element2 || !this._root.current) {
            return false;
          }
          if (this._isElementInput(element2)) {
            if (!this._shouldInputLoseFocus(element2, isForward)) {
              return false;
            }
          }
          var scrollableParent = findScrollableParent(element2);
          if (!scrollableParent) {
            return false;
          }
          var candidateDistance = -1;
          var candidateElement = void 0;
          var targetTop = -1;
          var targetBottom = -1;
          var pagesize = scrollableParent.clientHeight;
          var activeRect = element2.getBoundingClientRect();
          do {
            element2 = isForward ? getNextElement(this._root.current, element2) : getPreviousElement(this._root.current, element2);
            if (element2) {
              var targetRect = element2.getBoundingClientRect();
              var targetRectTop = Math.floor(targetRect.top);
              var activeRectBottom = Math.floor(activeRect.bottom);
              var targetRectBottom = Math.floor(targetRect.bottom);
              var activeRectTop = Math.floor(activeRect.top);
              var elementDistance = this._getHorizontalDistanceFromCenter(isForward, activeRect, targetRect);
              var isElementPassedPageSizeOnPagingDown = isForward && targetRectTop > activeRectBottom + pagesize;
              var isElementPassedPageSizeOnPagingUp = !isForward && targetRectBottom < activeRectTop - pagesize;
              if (isElementPassedPageSizeOnPagingDown || isElementPassedPageSizeOnPagingUp) {
                break;
              }
              if (elementDistance > -1) {
                if (isForward && targetRectTop > targetTop) {
                  targetTop = targetRectTop;
                  candidateDistance = elementDistance;
                  candidateElement = element2;
                } else if (!isForward && targetRectBottom < targetBottom) {
                  targetBottom = targetRectBottom;
                  candidateDistance = elementDistance;
                  candidateElement = element2;
                } else if (candidateDistance === -1 || elementDistance <= candidateDistance) {
                  candidateDistance = elementDistance;
                  candidateElement = element2;
                }
              }
            }
          } while (element2);
          var changedFocus = false;
          if (candidateElement && candidateElement !== this._activeElement) {
            changedFocus = true;
            this.focusElement(candidateElement);
            this._setFocusAlignment(candidateElement, false, true);
          } else if (this.props.isCircularNavigation && useDefaultWrap) {
            if (isForward) {
              return this.focusElement(getNextElement(this._root.current, this._root.current.firstElementChild, true));
            }
            return this.focusElement(getPreviousElement(this._root.current, this._root.current.lastElementChild, true, true, true));
          }
          return changedFocus;
        };
        FocusZone2.prototype._setFocusAlignment = function(element2, isHorizontal, isVertical) {
          if (this.props.direction === FocusZoneDirection.bidirectional && (!this._focusAlignment || isHorizontal || isVertical)) {
            var rect = element2.getBoundingClientRect();
            var left = rect.left + rect.width / 2;
            var top_1 = rect.top + rect.height / 2;
            if (!this._focusAlignment) {
              this._focusAlignment = { left, top: top_1 };
            }
            if (isHorizontal) {
              this._focusAlignment.left = left;
            }
            if (isVertical) {
              this._focusAlignment.top = top_1;
            }
          }
        };
        FocusZone2.prototype._isImmediateDescendantOfZone = function(element2) {
          return this._getOwnerZone(element2) === this._root.current;
        };
        FocusZone2.prototype._getOwnerZone = function(element2) {
          var parentElement = getParent$1(element2, ALLOW_VIRTUAL_ELEMENTS);
          while (parentElement && parentElement !== this._root.current && parentElement !== this._getDocument().body) {
            if (isElementFocusZone(parentElement)) {
              return parentElement;
            }
            parentElement = getParent$1(parentElement, ALLOW_VIRTUAL_ELEMENTS);
          }
          return parentElement;
        };
        FocusZone2.prototype._updateTabIndexes = function(element2) {
          if (!this._activeElement && this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement === "function") {
            this._activeElement = this.props.defaultTabbableElement(this._root.current);
          }
          if (!element2 && this._root.current) {
            this._defaultFocusElement = null;
            element2 = this._root.current;
            if (this._activeElement && !elementContains$1(element2, this._activeElement)) {
              this._activeElement = null;
            }
          }
          if (this._activeElement && !isElementTabbable(this._activeElement)) {
            this._activeElement = null;
          }
          var childNodes = element2 && element2.children;
          for (var childIndex = 0; childNodes && childIndex < childNodes.length; childIndex++) {
            var child = childNodes[childIndex];
            if (!isElementFocusZone(child)) {
              if (child.getAttribute && child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === "false") {
                child.setAttribute(TABINDEX, "-1");
              }
              if (isElementTabbable(child)) {
                if (this.props.disabled) {
                  child.setAttribute(TABINDEX, "-1");
                } else if (!this._isInnerZone && (!this._activeElement && !this._defaultFocusElement || this._activeElement === child)) {
                  this._defaultFocusElement = child;
                  if (child.getAttribute(TABINDEX) !== "0") {
                    child.setAttribute(TABINDEX, "0");
                  }
                } else if (child.getAttribute(TABINDEX) !== "-1") {
                  child.setAttribute(TABINDEX, "-1");
                }
              } else if (child.tagName === "svg" && child.getAttribute("focusable") !== "false") {
                child.setAttribute("focusable", "false");
              }
            } else if (child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === "true") {
              if (!this._isInnerZone && (!this._activeElement && !this._defaultFocusElement || this._activeElement === child)) {
                this._defaultFocusElement = child;
                if (child.getAttribute(TABINDEX) !== "0") {
                  child.setAttribute(TABINDEX, "0");
                }
              } else if (child.getAttribute(TABINDEX) !== "-1") {
                child.setAttribute(TABINDEX, "-1");
              }
            }
            this._updateTabIndexes(child);
          }
        };
        FocusZone2.prototype._isContentEditableElement = function(element2) {
          return element2 && element2.getAttribute("contenteditable") === "true";
        };
        FocusZone2.prototype._isElementInput = function(element2) {
          if (element2 && element2.tagName && (element2.tagName.toLowerCase() === "input" || element2.tagName.toLowerCase() === "textarea")) {
            return true;
          }
          return false;
        };
        FocusZone2.prototype._shouldInputLoseFocus = function(element2, isForward) {
          if (!this._processingTabKey && element2 && element2.type && ALLOWED_INPUT_TYPES.indexOf(element2.type.toLowerCase()) > -1) {
            var selectionStart = element2.selectionStart;
            var selectionEnd = element2.selectionEnd;
            var isRangeSelected = selectionStart !== selectionEnd;
            var inputValue = element2.value;
            var isReadonly = element2.readOnly;
            if (isRangeSelected || selectionStart > 0 && !isForward && !isReadonly || selectionStart !== inputValue.length && isForward && !isReadonly || !!this.props.handleTabKey && !(this.props.shouldInputLoseFocusOnArrowKey && this.props.shouldInputLoseFocusOnArrowKey(element2))) {
              return false;
            }
          }
          return true;
        };
        FocusZone2.prototype._shouldWrapFocus = function(element2, noWrapDataAttribute) {
          return this.props.checkForNoWrap ? shouldWrapFocus(element2, noWrapDataAttribute) : true;
        };
        FocusZone2.prototype._portalContainsElement = function(element2) {
          return element2 && !!this._root.current && portalContainsElement(element2, this._root.current);
        };
        FocusZone2.prototype._getDocument = function() {
          return getDocument(this._root.current);
        };
        FocusZone2.defaultProps = {
          isCircularNavigation: false,
          direction: FocusZoneDirection.bidirectional,
          shouldRaiseClicks: true
        };
        return FocusZone2;
      }(reactExports.Component)
    );
    var ContextualMenuItemType;
    (function(ContextualMenuItemType2) {
      ContextualMenuItemType2[ContextualMenuItemType2["Normal"] = 0] = "Normal";
      ContextualMenuItemType2[ContextualMenuItemType2["Divider"] = 1] = "Divider";
      ContextualMenuItemType2[ContextualMenuItemType2["Header"] = 2] = "Header";
      ContextualMenuItemType2[ContextualMenuItemType2["Section"] = 3] = "Section";
    })(ContextualMenuItemType || (ContextualMenuItemType = {}));
    function getIsChecked(item) {
      if (item.canCheck) {
        return !!(item.isChecked || item.checked);
      }
      if (typeof item.isChecked === "boolean") {
        return item.isChecked;
      }
      if (typeof item.checked === "boolean") {
        return item.checked;
      }
      return null;
    }
    function hasSubmenu(item) {
      return !!(item.subMenuProps || item.items);
    }
    function isItemDisabled(item) {
      return !!(item.isDisabled || item.disabled);
    }
    function getMenuItemAriaRole(item) {
      var isChecked = getIsChecked(item);
      var canCheck = isChecked !== null;
      return canCheck ? "menuitemcheckbox" : "menuitem";
    }
    var defaultIconRenderer = function(props) {
      var item = props.item, classNames2 = props.classNames;
      var iconProps = item.iconProps;
      return reactExports.createElement(Icon, __assign$1({}, iconProps, { className: classNames2.icon }));
    };
    var renderItemIcon = function(props) {
      var item = props.item, hasIcons = props.hasIcons;
      if (!hasIcons) {
        return null;
      }
      if (item.onRenderIcon) {
        return item.onRenderIcon(props, defaultIconRenderer);
      }
      return defaultIconRenderer(props);
    };
    var renderCheckMarkIcon = function(_a2) {
      var onCheckmarkClick = _a2.onCheckmarkClick, item = _a2.item, classNames2 = _a2.classNames;
      var isItemChecked = getIsChecked(item);
      if (onCheckmarkClick) {
        var onClick = function(e2) {
          return onCheckmarkClick(item, e2);
        };
        return reactExports.createElement(Icon, {
          iconName: item.canCheck !== false && isItemChecked ? "CheckMark" : "",
          className: classNames2.checkmarkIcon,
          // eslint-disable-next-line react/jsx-no-bind
          onClick
        });
      }
      return null;
    };
    var renderItemName = function(_a2) {
      var item = _a2.item, classNames2 = _a2.classNames;
      if (item.text || item.name) {
        return reactExports.createElement("span", { className: classNames2.label }, item.text || item.name);
      }
      return null;
    };
    var renderSecondaryText = function(_a2) {
      var item = _a2.item, classNames2 = _a2.classNames;
      if (item.secondaryText) {
        return reactExports.createElement("span", { className: classNames2.secondaryText }, item.secondaryText);
      }
      return null;
    };
    var renderSubMenuIcon = function(_a2) {
      var item = _a2.item, classNames2 = _a2.classNames, theme = _a2.theme;
      if (hasSubmenu(item)) {
        return reactExports.createElement(Icon, __assign$1({ iconName: getRTL(theme) ? "ChevronLeft" : "ChevronRight" }, item.submenuIconProps, { className: classNames2.subMenuIcon }));
      }
      return null;
    };
    var ContextualMenuItemBase = (
      /** @class */
      function(_super) {
        __extends(ContextualMenuItemBase2, _super);
        function ContextualMenuItemBase2(props) {
          var _this = _super.call(this, props) || this;
          _this.openSubMenu = function() {
            var _a2 = _this.props, item = _a2.item, openSubMenu = _a2.openSubMenu, getSubmenuTarget = _a2.getSubmenuTarget;
            if (getSubmenuTarget) {
              var submenuTarget = getSubmenuTarget();
              if (hasSubmenu(item) && openSubMenu && submenuTarget) {
                openSubMenu(item, submenuTarget);
              }
            }
          };
          _this.dismissSubMenu = function() {
            var _a2 = _this.props, item = _a2.item, dismissSubMenu = _a2.dismissSubMenu;
            if (hasSubmenu(item) && dismissSubMenu) {
              dismissSubMenu();
            }
          };
          _this.dismissMenu = function(dismissAll) {
            var dismissMenu = _this.props.dismissMenu;
            if (dismissMenu) {
              dismissMenu(void 0, dismissAll);
            }
          };
          initializeComponentRef(_this);
          return _this;
        }
        ContextualMenuItemBase2.prototype.render = function() {
          var _a2 = this.props, item = _a2.item, classNames2 = _a2.classNames;
          var renderContent = item.onRenderContent || this._renderLayout;
          return reactExports.createElement("div", { className: item.split ? classNames2.linkContentMenu : classNames2.linkContent }, renderContent(this.props, {
            renderCheckMarkIcon,
            renderItemIcon,
            renderItemName,
            renderSecondaryText,
            renderSubMenuIcon
          }));
        };
        ContextualMenuItemBase2.prototype._renderLayout = function(props, defaultRenders) {
          return reactExports.createElement(
            reactExports.Fragment,
            null,
            defaultRenders.renderCheckMarkIcon(props),
            defaultRenders.renderItemIcon(props),
            defaultRenders.renderItemName(props),
            defaultRenders.renderSecondaryText(props),
            defaultRenders.renderSubMenuIcon(props)
          );
        };
        return ContextualMenuItemBase2;
      }(reactExports.Component)
    );
    var getDividerClassNames = memoizeFunction(
      // eslint-disable-next-line deprecation/deprecation
      function(theme) {
        return mergeStyleSets({
          wrapper: {
            display: "inline-flex",
            height: "100%",
            alignItems: "center"
          },
          divider: {
            width: 1,
            height: "100%",
            backgroundColor: theme.palette.neutralTertiaryAlt
          }
        });
      }
    );
    var CONTEXTUAL_MENU_ITEM_HEIGHT = 36;
    var MediumScreenSelector$1 = getScreenSelector(0, ScreenWidthMaxMedium);
    var getItemHighContrastStyles = memoizeFunction(function() {
      var _a2;
      return {
        selectors: (_a2 = {}, _a2[HighContrastSelector] = __assign$1({ backgroundColor: "Highlight", borderColor: "Highlight", color: "HighlightText" }, getHighContrastNoAdjustStyle()), _a2)
      };
    });
    var getMenuItemStyles = memoizeFunction(function(theme) {
      var _a2, _b, _c, _d, _e, _f, _g;
      var semanticColors = theme.semanticColors, fonts = theme.fonts, palette = theme.palette;
      var ContextualMenuItemBackgroundHoverColor = semanticColors.menuItemBackgroundHovered;
      var ContextualMenuItemTextHoverColor = semanticColors.menuItemTextHovered;
      var ContextualMenuItemBackgroundSelectedColor = semanticColors.menuItemBackgroundPressed;
      var ContextualMenuItemDividerColor = semanticColors.bodyDivider;
      var menuItemStyles = {
        item: [
          fonts.medium,
          {
            color: semanticColors.bodyText,
            position: "relative",
            boxSizing: "border-box"
          }
        ],
        divider: {
          display: "block",
          height: "1px",
          backgroundColor: ContextualMenuItemDividerColor,
          position: "relative"
        },
        root: [
          getFocusStyle(theme),
          fonts.medium,
          {
            color: semanticColors.bodyText,
            backgroundColor: "transparent",
            border: "none",
            width: "100%",
            height: CONTEXTUAL_MENU_ITEM_HEIGHT,
            lineHeight: CONTEXTUAL_MENU_ITEM_HEIGHT,
            display: "block",
            cursor: "pointer",
            padding: "0px 8px 0 4px",
            textAlign: "left"
          }
        ],
        rootDisabled: {
          color: semanticColors.disabledBodyText,
          cursor: "default",
          pointerEvents: "none",
          selectors: (_a2 = {}, _a2[HighContrastSelector] = __assign$1({ color: "GrayText", opacity: 1 }, getHighContrastNoAdjustStyle()), _a2)
        },
        rootHovered: __assign$1({ backgroundColor: ContextualMenuItemBackgroundHoverColor, color: ContextualMenuItemTextHoverColor, selectors: {
          ".ms-ContextualMenu-icon": {
            color: palette.themeDarkAlt
          },
          ".ms-ContextualMenu-submenuIcon": {
            color: palette.neutralPrimary
          }
        } }, getItemHighContrastStyles()),
        rootFocused: __assign$1({ backgroundColor: palette.white }, getItemHighContrastStyles()),
        rootChecked: __assign$1({ selectors: {
          ".ms-ContextualMenu-checkmarkIcon": {
            color: palette.neutralPrimary
          }
        } }, getItemHighContrastStyles()),
        rootPressed: __assign$1({ backgroundColor: ContextualMenuItemBackgroundSelectedColor, selectors: {
          ".ms-ContextualMenu-icon": {
            color: palette.themeDark
          },
          ".ms-ContextualMenu-submenuIcon": {
            color: palette.neutralPrimary
          }
        } }, getItemHighContrastStyles()),
        rootExpanded: __assign$1({ backgroundColor: ContextualMenuItemBackgroundSelectedColor, color: semanticColors.bodyTextChecked }, getItemHighContrastStyles()),
        linkContent: {
          whiteSpace: "nowrap",
          height: "inherit",
          display: "flex",
          alignItems: "center",
          maxWidth: "100%"
        },
        anchorLink: {
          padding: "0px 8px 0 4px",
          textRendering: "auto",
          color: "inherit",
          letterSpacing: "normal",
          wordSpacing: "normal",
          textTransform: "none",
          textIndent: "0px",
          textShadow: "none",
          textDecoration: "none",
          boxSizing: "border-box"
        },
        label: {
          margin: "0 4px",
          verticalAlign: "middle",
          display: "inline-block",
          flexGrow: "1",
          textOverflow: "ellipsis",
          overflow: "hidden",
          whiteSpace: "nowrap"
        },
        secondaryText: {
          color: theme.palette.neutralSecondary,
          paddingLeft: "20px",
          textAlign: "right"
        },
        icon: {
          display: "inline-block",
          minHeight: "1px",
          maxHeight: CONTEXTUAL_MENU_ITEM_HEIGHT,
          fontSize: IconFontSizes$1.medium,
          width: IconFontSizes$1.medium,
          margin: "0 4px",
          verticalAlign: "middle",
          flexShrink: "0",
          selectors: (_b = {}, _b[MediumScreenSelector$1] = {
            fontSize: IconFontSizes$1.large,
            width: IconFontSizes$1.large
          }, _b)
        },
        iconColor: {
          color: semanticColors.menuIcon,
          selectors: (_c = {}, _c[HighContrastSelector] = {
            color: "inherit"
          }, _c["$root:hover &"] = {
            selectors: (_d = {}, _d[HighContrastSelector] = {
              color: "HighlightText"
            }, _d)
          }, _c["$root:focus &"] = {
            selectors: (_e = {}, _e[HighContrastSelector] = {
              color: "HighlightText"
            }, _e)
          }, _c)
        },
        iconDisabled: {
          color: semanticColors.disabledBodyText
        },
        checkmarkIcon: {
          color: semanticColors.bodySubtext,
          selectors: (_f = {}, _f[HighContrastSelector] = {
            color: "HighlightText"
          }, _f)
        },
        subMenuIcon: {
          height: CONTEXTUAL_MENU_ITEM_HEIGHT,
          lineHeight: CONTEXTUAL_MENU_ITEM_HEIGHT,
          color: palette.neutralSecondary,
          textAlign: "center",
          display: "inline-block",
          verticalAlign: "middle",
          flexShrink: "0",
          fontSize: IconFontSizes$1.small,
          selectors: (_g = {
            ":hover": {
              color: palette.neutralPrimary
            },
            ":active": {
              color: palette.neutralPrimary
            }
          }, _g[MediumScreenSelector$1] = {
            fontSize: IconFontSizes$1.medium
            // 16px
          }, _g[HighContrastSelector] = {
            color: "HighlightText"
          }, _g)
        },
        splitButtonFlexContainer: [
          getFocusStyle(theme),
          {
            display: "flex",
            height: CONTEXTUAL_MENU_ITEM_HEIGHT,
            flexWrap: "nowrap",
            justifyContent: "center",
            alignItems: "flex-start"
          }
        ]
      };
      return concatStyleSets(menuItemStyles);
    });
    var CONTEXTUAL_SPLIT_MENU_MINWIDTH = "28px";
    var MediumScreenSelector = getScreenSelector(0, ScreenWidthMaxMedium);
    var getSplitButtonVerticalDividerClassNames = memoizeFunction(
      /* eslint-disable deprecation/deprecation */
      function(theme) {
        var _a2;
        return mergeStyleSets(getDividerClassNames(theme), {
          /* eslint-enable deprecation/deprecation */
          wrapper: {
            position: "absolute",
            right: 28,
            selectors: (_a2 = {}, _a2[MediumScreenSelector] = {
              right: 32
              // fontSize of the icon increased from 12px to 16px
            }, _a2)
          },
          divider: {
            height: 16,
            width: 1
          }
        });
      }
    );
    var GlobalClassNames$4 = {
      item: "ms-ContextualMenu-item",
      divider: "ms-ContextualMenu-divider",
      root: "ms-ContextualMenu-link",
      isChecked: "is-checked",
      isExpanded: "is-expanded",
      isDisabled: "is-disabled",
      linkContent: "ms-ContextualMenu-linkContent",
      linkContentMenu: "ms-ContextualMenu-linkContent",
      icon: "ms-ContextualMenu-icon",
      iconColor: "ms-ContextualMenu-iconColor",
      checkmarkIcon: "ms-ContextualMenu-checkmarkIcon",
      subMenuIcon: "ms-ContextualMenu-submenuIcon",
      label: "ms-ContextualMenu-itemText",
      secondaryText: "ms-ContextualMenu-secondaryText",
      splitMenu: "ms-ContextualMenu-splitMenu",
      screenReaderText: "ms-ContextualMenu-screenReaderText"
    };
    var getItemClassNames = memoizeFunction(function(theme, disabled, expanded, checked, isAnchorLink, knownIcon, itemClassName, dividerClassName, iconClassName, subMenuClassName, primaryDisabled, className) {
      var _a2, _b, _c, _d;
      var styles2 = getMenuItemStyles(theme);
      var classNames2 = getGlobalClassNames(GlobalClassNames$4, theme);
      return mergeStyleSets({
        item: [classNames2.item, styles2.item, itemClassName],
        divider: [classNames2.divider, styles2.divider, dividerClassName],
        root: [
          classNames2.root,
          styles2.root,
          checked && [classNames2.isChecked, styles2.rootChecked],
          isAnchorLink && styles2.anchorLink,
          expanded && [classNames2.isExpanded, styles2.rootExpanded],
          disabled && [classNames2.isDisabled, styles2.rootDisabled],
          !disabled && !expanded && [
            {
              selectors: (_a2 = {
                ":hover": styles2.rootHovered,
                ":active": styles2.rootPressed
              }, _a2["." + IsFocusVisibleClassName + " &:focus, ." + IsFocusVisibleClassName + " &:focus:hover"] = styles2.rootFocused, _a2["." + IsFocusVisibleClassName + " &:hover"] = { background: "inherit;" }, _a2)
            }
          ],
          className
        ],
        splitPrimary: [
          styles2.root,
          {
            width: "calc(100% - " + CONTEXTUAL_SPLIT_MENU_MINWIDTH + ")"
          },
          checked && ["is-checked", styles2.rootChecked],
          (disabled || primaryDisabled) && ["is-disabled", styles2.rootDisabled],
          !(disabled || primaryDisabled) && !checked && [
            {
              selectors: (_b = {
                ":hover": styles2.rootHovered
              }, // when hovering over the splitPrimary also affect the splitMenu
              _b[":hover ~ ." + classNames2.splitMenu] = styles2.rootHovered, _b[":active"] = styles2.rootPressed, _b["." + IsFocusVisibleClassName + " &:focus, ." + IsFocusVisibleClassName + " &:focus:hover"] = styles2.rootFocused, _b["." + IsFocusVisibleClassName + " &:hover"] = { background: "inherit;" }, _b)
            }
          ]
        ],
        splitMenu: [
          classNames2.splitMenu,
          styles2.root,
          {
            flexBasis: "0",
            padding: "0 8px",
            minWidth: CONTEXTUAL_SPLIT_MENU_MINWIDTH
          },
          expanded && ["is-expanded", styles2.rootExpanded],
          disabled && ["is-disabled", styles2.rootDisabled],
          !disabled && !expanded && [
            {
              selectors: (_c = {
                ":hover": styles2.rootHovered,
                ":active": styles2.rootPressed
              }, _c["." + IsFocusVisibleClassName + " &:focus, ." + IsFocusVisibleClassName + " &:focus:hover"] = styles2.rootFocused, _c["." + IsFocusVisibleClassName + " &:hover"] = { background: "inherit;" }, _c)
            }
          ]
        ],
        anchorLink: styles2.anchorLink,
        linkContent: [classNames2.linkContent, styles2.linkContent],
        linkContentMenu: [
          classNames2.linkContentMenu,
          styles2.linkContent,
          {
            justifyContent: "center"
          }
        ],
        icon: [
          classNames2.icon,
          knownIcon && styles2.iconColor,
          styles2.icon,
          iconClassName,
          disabled && [classNames2.isDisabled, styles2.iconDisabled]
        ],
        iconColor: styles2.iconColor,
        checkmarkIcon: [classNames2.checkmarkIcon, knownIcon && styles2.checkmarkIcon, styles2.icon, iconClassName],
        subMenuIcon: [
          classNames2.subMenuIcon,
          styles2.subMenuIcon,
          subMenuClassName,
          expanded && { color: theme.palette.neutralPrimary },
          disabled && [styles2.iconDisabled]
        ],
        label: [classNames2.label, styles2.label],
        secondaryText: [classNames2.secondaryText, styles2.secondaryText],
        splitContainer: [
          styles2.splitButtonFlexContainer,
          !disabled && !checked && [
            {
              selectors: (_d = {}, _d["." + IsFocusVisibleClassName + " &:focus, ." + IsFocusVisibleClassName + " &:focus:hover"] = styles2.rootFocused, _d)
            }
          ]
        ],
        screenReaderText: [
          classNames2.screenReaderText,
          styles2.screenReaderText,
          hiddenContentStyle,
          { visibility: "hidden" }
        ]
      });
    });
    var getItemStyles = function(props) {
      var theme = props.theme, disabled = props.disabled, expanded = props.expanded, checked = props.checked, isAnchorLink = props.isAnchorLink, knownIcon = props.knownIcon, itemClassName = props.itemClassName, dividerClassName = props.dividerClassName, iconClassName = props.iconClassName, subMenuClassName = props.subMenuClassName, primaryDisabled = props.primaryDisabled, className = props.className;
      return getItemClassNames(theme, disabled, expanded, checked, isAnchorLink, knownIcon, itemClassName, dividerClassName, iconClassName, subMenuClassName, primaryDisabled, className);
    };
    var ContextualMenuItem = styled(ContextualMenuItemBase, getItemStyles, void 0, { scope: "ContextualMenuItem" });
    var ContextualMenuItemWrapper = (
      /** @class */
      function(_super) {
        __extends(ContextualMenuItemWrapper2, _super);
        function ContextualMenuItemWrapper2(props) {
          var _this = _super.call(this, props) || this;
          _this._onItemMouseEnter = function(ev) {
            var _a2 = _this.props, item = _a2.item, onItemMouseEnter = _a2.onItemMouseEnter;
            if (onItemMouseEnter) {
              onItemMouseEnter(item, ev, ev.currentTarget);
            }
          };
          _this._onItemClick = function(ev) {
            var _a2 = _this.props, item = _a2.item, onItemClickBase = _a2.onItemClickBase;
            if (onItemClickBase) {
              onItemClickBase(item, ev, ev.currentTarget);
            }
          };
          _this._onItemMouseLeave = function(ev) {
            var _a2 = _this.props, item = _a2.item, onItemMouseLeave = _a2.onItemMouseLeave;
            if (onItemMouseLeave) {
              onItemMouseLeave(item, ev);
            }
          };
          _this._onItemKeyDown = function(ev) {
            var _a2 = _this.props, item = _a2.item, onItemKeyDown = _a2.onItemKeyDown;
            if (onItemKeyDown) {
              onItemKeyDown(item, ev);
            }
          };
          _this._onItemMouseMove = function(ev) {
            var _a2 = _this.props, item = _a2.item, onItemMouseMove = _a2.onItemMouseMove;
            if (onItemMouseMove) {
              onItemMouseMove(item, ev, ev.currentTarget);
            }
          };
          _this._getSubmenuTarget = function() {
            return void 0;
          };
          initializeComponentRef(_this);
          return _this;
        }
        ContextualMenuItemWrapper2.prototype.shouldComponentUpdate = function(newProps) {
          return !shallowCompare(newProps, this.props);
        };
        return ContextualMenuItemWrapper2;
      }(reactExports.Component)
    );
    var KTP_PREFIX = "ktp";
    var KTP_SEPARATOR = "-";
    var DATAKTP_TARGET = "data-ktp-target";
    var DATAKTP_EXECUTE_TARGET = "data-ktp-execute-target";
    var KTP_LAYER_ID = "ktp-layer-id";
    var KeytipEvents;
    (function(KeytipEvents2) {
      KeytipEvents2.KEYTIP_ADDED = "keytipAdded";
      KeytipEvents2.KEYTIP_REMOVED = "keytipRemoved";
      KeytipEvents2.KEYTIP_UPDATED = "keytipUpdated";
      KeytipEvents2.PERSISTED_KEYTIP_ADDED = "persistedKeytipAdded";
      KeytipEvents2.PERSISTED_KEYTIP_REMOVED = "persistedKeytipRemoved";
      KeytipEvents2.PERSISTED_KEYTIP_EXECUTE = "persistedKeytipExecute";
      KeytipEvents2.ENTER_KEYTIP_MODE = "enterKeytipMode";
      KeytipEvents2.EXIT_KEYTIP_MODE = "exitKeytipMode";
    })(KeytipEvents || (KeytipEvents = {}));
    var KeytipManager = (
      /** @class */
      function() {
        function KeytipManager2() {
          this.keytips = {};
          this.persistedKeytips = {};
          this.sequenceMapping = {};
          this.inKeytipMode = false;
          this.shouldEnterKeytipMode = true;
          this.delayUpdatingKeytipChange = false;
        }
        KeytipManager2.getInstance = function() {
          return this._instance;
        };
        KeytipManager2.prototype.init = function(delayUpdatingKeytipChange) {
          this.delayUpdatingKeytipChange = delayUpdatingKeytipChange;
        };
        KeytipManager2.prototype.register = function(keytipProps, persisted) {
          if (persisted === void 0) {
            persisted = false;
          }
          var props = keytipProps;
          if (!persisted) {
            props = this.addParentOverflow(keytipProps);
            this.sequenceMapping[props.keySequences.toString()] = props;
          }
          var uniqueKeytip = this._getUniqueKtp(props);
          persisted ? this.persistedKeytips[uniqueKeytip.uniqueID] = uniqueKeytip : this.keytips[uniqueKeytip.uniqueID] = uniqueKeytip;
          if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {
            var event_1 = persisted ? KeytipEvents.PERSISTED_KEYTIP_ADDED : KeytipEvents.KEYTIP_ADDED;
            EventGroup.raise(this, event_1, {
              keytip: props,
              uniqueID: uniqueKeytip.uniqueID
            });
          }
          return uniqueKeytip.uniqueID;
        };
        KeytipManager2.prototype.update = function(keytipProps, uniqueID) {
          var newKeytipProps = this.addParentOverflow(keytipProps);
          var uniqueKeytip = this._getUniqueKtp(newKeytipProps, uniqueID);
          var oldKeyTip = this.keytips[uniqueID];
          if (oldKeyTip) {
            uniqueKeytip.keytip.visible = oldKeyTip.keytip.visible;
            this.keytips[uniqueID] = uniqueKeytip;
            delete this.sequenceMapping[oldKeyTip.keytip.keySequences.toString()];
            this.sequenceMapping[uniqueKeytip.keytip.keySequences.toString()] = uniqueKeytip.keytip;
            if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {
              EventGroup.raise(this, KeytipEvents.KEYTIP_UPDATED, {
                keytip: uniqueKeytip.keytip,
                uniqueID: uniqueKeytip.uniqueID
              });
            }
          }
        };
        KeytipManager2.prototype.unregister = function(keytipToRemove, uniqueID, persisted) {
          if (persisted === void 0) {
            persisted = false;
          }
          persisted ? delete this.persistedKeytips[uniqueID] : delete this.keytips[uniqueID];
          !persisted && delete this.sequenceMapping[keytipToRemove.keySequences.toString()];
          var event = persisted ? KeytipEvents.PERSISTED_KEYTIP_REMOVED : KeytipEvents.KEYTIP_REMOVED;
          if (this.inKeytipMode || !this.delayUpdatingKeytipChange) {
            EventGroup.raise(this, event, {
              keytip: keytipToRemove,
              uniqueID
            });
          }
        };
        KeytipManager2.prototype.enterKeytipMode = function() {
          EventGroup.raise(this, KeytipEvents.ENTER_KEYTIP_MODE);
        };
        KeytipManager2.prototype.exitKeytipMode = function() {
          EventGroup.raise(this, KeytipEvents.EXIT_KEYTIP_MODE);
        };
        KeytipManager2.prototype.getKeytips = function() {
          var _this = this;
          return Object.keys(this.keytips).map(function(key) {
            return _this.keytips[key].keytip;
          });
        };
        KeytipManager2.prototype.addParentOverflow = function(keytipProps) {
          var fullSequence = __spreadArray([], keytipProps.keySequences);
          fullSequence.pop();
          if (fullSequence.length !== 0) {
            var parentKeytip = this.sequenceMapping[fullSequence.toString()];
            if (parentKeytip && parentKeytip.overflowSetSequence) {
              return __assign$1(__assign$1({}, keytipProps), { overflowSetSequence: parentKeytip.overflowSetSequence });
            }
          }
          return keytipProps;
        };
        KeytipManager2.prototype.menuExecute = function(overflowButtonSequences, keytipSequences) {
          EventGroup.raise(this, KeytipEvents.PERSISTED_KEYTIP_EXECUTE, {
            overflowButtonSequences,
            keytipSequences
          });
        };
        KeytipManager2.prototype._getUniqueKtp = function(keytipProps, uniqueID) {
          if (uniqueID === void 0) {
            uniqueID = getId();
          }
          return { keytip: __assign$1({}, keytipProps), uniqueID };
        };
        KeytipManager2._instance = new KeytipManager2();
        return KeytipManager2;
      }()
    );
    function sequencesToID(keySequences) {
      return keySequences.reduce(function(prevValue, keySequence) {
        return prevValue + KTP_SEPARATOR + keySequence.split("").join(KTP_SEPARATOR);
      }, KTP_PREFIX);
    }
    function mergeOverflows(keySequences, overflowKeySequences) {
      var overflowSequenceLen = overflowKeySequences.length;
      var overflowSequence = __spreadArray([], overflowKeySequences).pop();
      var newKeySequences = __spreadArray([], keySequences);
      return addElementAtIndex(newKeySequences, overflowSequenceLen - 1, overflowSequence);
    }
    function getAriaDescribedBy(keySequences) {
      var describedby = " " + KTP_LAYER_ID;
      if (!keySequences.length) {
        return describedby;
      }
      return describedby + " " + sequencesToID(keySequences);
    }
    function useKeytipData(options) {
      var uniqueId2 = reactExports.useRef();
      var keytipProps = options.keytipProps ? __assign$1({ disabled: options.disabled }, options.keytipProps) : void 0;
      var keytipManager = useConst(KeytipManager.getInstance());
      var prevOptions = usePrevious(options);
      useIsomorphicLayoutEffect$1(function() {
        if (uniqueId2.current && keytipProps && ((prevOptions === null || prevOptions === void 0 ? void 0 : prevOptions.keytipProps) !== options.keytipProps || (prevOptions === null || prevOptions === void 0 ? void 0 : prevOptions.disabled) !== options.disabled)) {
          keytipManager.update(keytipProps, uniqueId2.current);
        }
      });
      useIsomorphicLayoutEffect$1(function() {
        if (keytipProps) {
          uniqueId2.current = keytipManager.register(keytipProps);
        }
        return function() {
          keytipProps && keytipManager.unregister(keytipProps, uniqueId2.current);
        };
      }, []);
      var nativeKeytipProps = {
        ariaDescribedBy: void 0,
        keytipId: void 0
      };
      if (keytipProps) {
        nativeKeytipProps = getKeytipData(keytipManager, keytipProps, options.ariaDescribedBy);
      }
      return nativeKeytipProps;
    }
    function getKeytipData(keytipManager, keytipProps, describedByPrepend) {
      var newKeytipProps = keytipManager.addParentOverflow(keytipProps);
      var ariaDescribedBy = mergeAriaAttributeValues(describedByPrepend, getAriaDescribedBy(newKeytipProps.keySequences));
      var keySequences = __spreadArray([], newKeytipProps.keySequences);
      if (newKeytipProps.overflowSetSequence) {
        keySequences = mergeOverflows(keySequences, newKeytipProps.overflowSetSequence);
      }
      var keytipId = sequencesToID(keySequences);
      return {
        ariaDescribedBy,
        keytipId
      };
    }
    var KeytipData = function(props) {
      var _a2;
      var children = props.children, keytipDataProps = __rest(props, ["children"]);
      var _b = useKeytipData(keytipDataProps), keytipId = _b.keytipId, ariaDescribedBy = _b.ariaDescribedBy;
      return children((_a2 = {}, _a2[DATAKTP_TARGET] = keytipId, _a2[DATAKTP_EXECUTE_TARGET] = keytipId, _a2["aria-describedby"] = ariaDescribedBy, _a2));
    };
    var ContextualMenuAnchor = (
      /** @class */
      function(_super) {
        __extends(ContextualMenuAnchor2, _super);
        function ContextualMenuAnchor2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this._anchor = reactExports.createRef();
          _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function(keytipProps) {
            return __assign$1(__assign$1({}, keytipProps), { hasMenu: true });
          });
          _this._getSubmenuTarget = function() {
            return _this._anchor.current ? _this._anchor.current : void 0;
          };
          _this._onItemClick = function(ev) {
            var _a2 = _this.props, item = _a2.item, onItemClick = _a2.onItemClick;
            if (onItemClick) {
              onItemClick(item, ev);
            }
          };
          _this._renderAriaDescription = function(ariaDescription, className) {
            return ariaDescription ? reactExports.createElement("span", { id: _this._ariaDescriptionId, className }, ariaDescription) : null;
          };
          return _this;
        }
        ContextualMenuAnchor2.prototype.render = function() {
          var _this = this;
          var _a2 = this.props, item = _a2.item, classNames2 = _a2.classNames, index2 = _a2.index, focusableElementIndex = _a2.focusableElementIndex, totalItemCount = _a2.totalItemCount, hasCheckmarks = _a2.hasCheckmarks, hasIcons = _a2.hasIcons, _b = _a2.contextualMenuItemAs, ChildrenRenderer = _b === void 0 ? ContextualMenuItem : _b, expandedMenuItemKey = _a2.expandedMenuItemKey, onItemClick = _a2.onItemClick, openSubMenu = _a2.openSubMenu, dismissSubMenu = _a2.dismissSubMenu, dismissMenu = _a2.dismissMenu;
          var anchorRel = item.rel;
          if (item.target && item.target.toLowerCase() === "_blank") {
            anchorRel = anchorRel ? anchorRel : "nofollow noopener noreferrer";
          }
          var itemHasSubmenu = hasSubmenu(item);
          var nativeProps = getNativeProps$1(item, anchorProperties$1);
          var disabled = isItemDisabled(item);
          var itemProps = item.itemProps, ariaDescription = item.ariaDescription;
          var keytipProps = item.keytipProps;
          if (keytipProps && itemHasSubmenu) {
            keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
          }
          if (ariaDescription) {
            this._ariaDescriptionId = getId();
          }
          var ariaDescribedByIds = mergeAriaAttributeValues(item.ariaDescribedBy, ariaDescription ? this._ariaDescriptionId : void 0, nativeProps["aria-describedby"]);
          var additionalItemProperties = {
            "aria-describedby": ariaDescribedByIds
          };
          return reactExports.createElement(
            "div",
            null,
            reactExports.createElement(KeytipData, { keytipProps: item.keytipProps, ariaDescribedBy: ariaDescribedByIds, disabled }, function(keytipAttributes) {
              return reactExports.createElement(
                "a",
                __assign$1({}, additionalItemProperties, nativeProps, keytipAttributes, {
                  ref: _this._anchor,
                  href: item.href,
                  target: item.target,
                  rel: anchorRel,
                  className: classNames2.root,
                  role: "menuitem",
                  "aria-haspopup": itemHasSubmenu || void 0,
                  "aria-expanded": itemHasSubmenu ? item.key === expandedMenuItemKey : void 0,
                  "aria-posinset": focusableElementIndex + 1,
                  "aria-setsize": totalItemCount,
                  "aria-disabled": isItemDisabled(item),
                  // eslint-disable-next-line deprecation/deprecation
                  style: item.style,
                  onClick: _this._onItemClick,
                  onMouseEnter: _this._onItemMouseEnter,
                  onMouseLeave: _this._onItemMouseLeave,
                  onMouseMove: _this._onItemMouseMove,
                  onKeyDown: itemHasSubmenu ? _this._onItemKeyDown : void 0
                }),
                reactExports.createElement(ChildrenRenderer, __assign$1({ componentRef: item.componentRef, item, classNames: classNames2, index: index2, onCheckmarkClick: hasCheckmarks && onItemClick ? onItemClick : void 0, hasIcons, openSubMenu, dismissSubMenu, dismissMenu, getSubmenuTarget: _this._getSubmenuTarget }, itemProps)),
                _this._renderAriaDescription(ariaDescription, classNames2.screenReaderText)
              );
            })
          );
        };
        return ContextualMenuAnchor2;
      }(ContextualMenuItemWrapper)
    );
    var ContextualMenuButton = (
      /** @class */
      function(_super) {
        __extends(ContextualMenuButton2, _super);
        function ContextualMenuButton2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this._btn = reactExports.createRef();
          _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function(keytipProps) {
            return __assign$1(__assign$1({}, keytipProps), { hasMenu: true });
          });
          _this._renderAriaDescription = function(ariaDescription, className) {
            return ariaDescription ? reactExports.createElement("span", { id: _this._ariaDescriptionId, className }, ariaDescription) : null;
          };
          _this._getSubmenuTarget = function() {
            return _this._btn.current ? _this._btn.current : void 0;
          };
          return _this;
        }
        ContextualMenuButton2.prototype.render = function() {
          var _this = this;
          var _a2 = this.props, item = _a2.item, classNames2 = _a2.classNames, index2 = _a2.index, focusableElementIndex = _a2.focusableElementIndex, totalItemCount = _a2.totalItemCount, hasCheckmarks = _a2.hasCheckmarks, hasIcons = _a2.hasIcons, _b = _a2.contextualMenuItemAs, ChildrenRenderer = _b === void 0 ? ContextualMenuItem : _b, expandedMenuItemKey = _a2.expandedMenuItemKey, onItemMouseDown2 = _a2.onItemMouseDown, onItemClick = _a2.onItemClick, openSubMenu = _a2.openSubMenu, dismissSubMenu = _a2.dismissSubMenu, dismissMenu = _a2.dismissMenu;
          var isChecked = getIsChecked(item);
          var canCheck = isChecked !== null;
          var defaultRole = getMenuItemAriaRole(item);
          var itemHasSubmenu = hasSubmenu(item);
          var itemProps = item.itemProps, ariaLabel = item.ariaLabel, ariaDescription = item.ariaDescription;
          var buttonNativeProperties = getNativeProps$1(item, buttonProperties$1);
          delete buttonNativeProperties.disabled;
          var itemRole = item.role || defaultRole;
          if (ariaDescription) {
            this._ariaDescriptionId = getId();
          }
          var ariaDescribedByIds = mergeAriaAttributeValues(item.ariaDescribedBy, ariaDescription ? this._ariaDescriptionId : void 0, buttonNativeProperties["aria-describedby"]);
          var itemButtonProperties = {
            className: classNames2.root,
            onClick: this._onItemClick,
            onKeyDown: itemHasSubmenu ? this._onItemKeyDown : void 0,
            onMouseEnter: this._onItemMouseEnter,
            onMouseLeave: this._onItemMouseLeave,
            onMouseDown: function(ev) {
              return onItemMouseDown2 ? onItemMouseDown2(item, ev) : void 0;
            },
            onMouseMove: this._onItemMouseMove,
            href: item.href,
            title: item.title,
            "aria-label": ariaLabel,
            "aria-describedby": ariaDescribedByIds,
            "aria-haspopup": itemHasSubmenu || void 0,
            "aria-expanded": itemHasSubmenu ? item.key === expandedMenuItemKey : void 0,
            "aria-posinset": focusableElementIndex + 1,
            "aria-setsize": totalItemCount,
            "aria-disabled": isItemDisabled(item),
            "aria-checked": (itemRole === "menuitemcheckbox" || itemRole === "menuitemradio") && canCheck ? !!isChecked : void 0,
            "aria-selected": itemRole === "menuitem" && canCheck ? !!isChecked : void 0,
            role: itemRole,
            // eslint-disable-next-line deprecation/deprecation
            style: item.style
          };
          var keytipProps = item.keytipProps;
          if (keytipProps && itemHasSubmenu) {
            keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
          }
          return reactExports.createElement(KeytipData, { keytipProps, ariaDescribedBy: ariaDescribedByIds, disabled: isItemDisabled(item) }, function(keytipAttributes) {
            return reactExports.createElement(
              "button",
              __assign$1({ ref: _this._btn }, buttonNativeProperties, itemButtonProperties, keytipAttributes),
              reactExports.createElement(ChildrenRenderer, __assign$1({ componentRef: item.componentRef, item, classNames: classNames2, index: index2, onCheckmarkClick: hasCheckmarks && onItemClick ? onItemClick : void 0, hasIcons, openSubMenu, dismissSubMenu, dismissMenu, getSubmenuTarget: _this._getSubmenuTarget }, itemProps)),
              _this._renderAriaDescription(ariaDescription, classNames2.screenReaderText)
            );
          });
        };
        return ContextualMenuButton2;
      }(ContextualMenuItemWrapper)
    );
    var getStyles$4 = function(props) {
      var theme = props.theme, getClassNames2 = props.getClassNames, className = props.className;
      if (!theme) {
        throw new Error("Theme is undefined or null.");
      }
      if (getClassNames2) {
        var names = getClassNames2(theme);
        return {
          wrapper: [names.wrapper],
          divider: [names.divider]
        };
      }
      return {
        wrapper: [
          {
            display: "inline-flex",
            height: "100%",
            alignItems: "center"
          },
          className
        ],
        divider: [
          {
            width: 1,
            height: "100%",
            backgroundColor: theme.palette.neutralTertiaryAlt
          }
        ]
      };
    };
    var getClassNames$2 = classNamesFunction();
    var VerticalDividerBase = reactExports.forwardRef(function(props, ref) {
      var styles2 = props.styles, theme = props.theme, deprecatedGetClassNames = props.getClassNames, className = props.className;
      var classNames2 = getClassNames$2(styles2, { theme, getClassNames: deprecatedGetClassNames, className });
      return reactExports.createElement(
        "span",
        { className: classNames2.wrapper, ref },
        reactExports.createElement("span", { className: classNames2.divider })
      );
    });
    VerticalDividerBase.displayName = "VerticalDividerBase";
    var VerticalDivider = styled(VerticalDividerBase, getStyles$4, void 0, {
      scope: "VerticalDivider"
    });
    var TouchIdleDelay$1 = 500;
    var ContextualMenuSplitButton = (
      /** @class */
      function(_super) {
        __extends(ContextualMenuSplitButton2, _super);
        function ContextualMenuSplitButton2(props) {
          var _this = _super.call(this, props) || this;
          _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function(keytipProps) {
            return __assign$1(__assign$1({}, keytipProps), { hasMenu: true });
          });
          _this._onItemKeyDown = function(ev) {
            var _a2 = _this.props, item = _a2.item, onItemKeyDown = _a2.onItemKeyDown;
            if (ev.which === KeyCodes.enter) {
              _this._executeItemClick(ev);
              ev.preventDefault();
              ev.stopPropagation();
            } else if (onItemKeyDown) {
              onItemKeyDown(item, ev);
            }
          };
          _this._getSubmenuTarget = function() {
            return _this._splitButton;
          };
          _this._renderAriaDescription = function(ariaDescription, className) {
            return ariaDescription ? reactExports.createElement("span", { id: _this._ariaDescriptionId, className }, ariaDescription) : null;
          };
          _this._onItemMouseEnterPrimary = function(ev) {
            var _a2 = _this.props, item = _a2.item, onItemMouseEnter = _a2.onItemMouseEnter;
            if (onItemMouseEnter) {
              onItemMouseEnter(__assign$1(__assign$1({}, item), { subMenuProps: void 0, items: void 0 }), ev, _this._splitButton);
            }
          };
          _this._onItemMouseEnterIcon = function(ev) {
            var _a2 = _this.props, item = _a2.item, onItemMouseEnter = _a2.onItemMouseEnter;
            if (onItemMouseEnter) {
              onItemMouseEnter(item, ev, _this._splitButton);
            }
          };
          _this._onItemMouseMovePrimary = function(ev) {
            var _a2 = _this.props, item = _a2.item, onItemMouseMove = _a2.onItemMouseMove;
            if (onItemMouseMove) {
              onItemMouseMove(__assign$1(__assign$1({}, item), { subMenuProps: void 0, items: void 0 }), ev, _this._splitButton);
            }
          };
          _this._onItemMouseMoveIcon = function(ev) {
            var _a2 = _this.props, item = _a2.item, onItemMouseMove = _a2.onItemMouseMove;
            if (onItemMouseMove) {
              onItemMouseMove(item, ev, _this._splitButton);
            }
          };
          _this._onIconItemClick = function(ev) {
            var _a2 = _this.props, item = _a2.item, onItemClickBase = _a2.onItemClickBase;
            if (onItemClickBase) {
              onItemClickBase(item, ev, _this._splitButton ? _this._splitButton : ev.currentTarget);
            }
          };
          _this._executeItemClick = function(ev) {
            var _a2 = _this.props, item = _a2.item, executeItemClick = _a2.executeItemClick, onItemClick = _a2.onItemClick;
            if (item.disabled || item.isDisabled) {
              return;
            }
            if (_this._processingTouch && onItemClick) {
              return onItemClick(item, ev);
            }
            if (executeItemClick) {
              executeItemClick(item, ev);
            }
          };
          _this._onTouchStart = function(ev) {
            if (_this._splitButton && !("onpointerdown" in _this._splitButton)) {
              _this._handleTouchAndPointerEvent(ev);
            }
          };
          _this._onPointerDown = function(ev) {
            if (ev.pointerType === "touch") {
              _this._handleTouchAndPointerEvent(ev);
              ev.preventDefault();
              ev.stopImmediatePropagation();
            }
          };
          _this._async = new Async(_this);
          _this._events = new EventGroup(_this);
          return _this;
        }
        ContextualMenuSplitButton2.prototype.componentDidMount = function() {
          if (this._splitButton && "onpointerdown" in this._splitButton) {
            this._events.on(this._splitButton, "pointerdown", this._onPointerDown, true);
          }
        };
        ContextualMenuSplitButton2.prototype.componentWillUnmount = function() {
          this._async.dispose();
          this._events.dispose();
        };
        ContextualMenuSplitButton2.prototype.render = function() {
          var _this = this;
          var _a2 = this.props, item = _a2.item, classNames2 = _a2.classNames, index2 = _a2.index, focusableElementIndex = _a2.focusableElementIndex, totalItemCount = _a2.totalItemCount, hasCheckmarks = _a2.hasCheckmarks, hasIcons = _a2.hasIcons, onItemMouseLeave = _a2.onItemMouseLeave, expandedMenuItemKey = _a2.expandedMenuItemKey;
          var itemHasSubmenu = hasSubmenu(item);
          var keytipProps = item.keytipProps;
          if (keytipProps) {
            keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
          }
          var ariaDescription = item.ariaDescription;
          if (ariaDescription) {
            this._ariaDescriptionId = getId();
          }
          return reactExports.createElement(KeytipData, { keytipProps, disabled: isItemDisabled(item) }, function(keytipAttributes) {
            return reactExports.createElement(
              "div",
              { "data-ktp-target": keytipAttributes["data-ktp-target"], ref: function(splitButton) {
                return _this._splitButton = splitButton;
              }, role: getMenuItemAriaRole(item), "aria-label": item.ariaLabel, className: classNames2.splitContainer, "aria-disabled": isItemDisabled(item), "aria-expanded": itemHasSubmenu ? item.key === expandedMenuItemKey : void 0, "aria-haspopup": true, "aria-describedby": mergeAriaAttributeValues(item.ariaDescribedBy, ariaDescription ? _this._ariaDescriptionId : void 0, keytipAttributes["aria-describedby"]), "aria-checked": item.isChecked || item.checked, "aria-posinset": focusableElementIndex + 1, "aria-setsize": totalItemCount, onMouseEnter: _this._onItemMouseEnterPrimary, onMouseLeave: onItemMouseLeave ? onItemMouseLeave.bind(_this, __assign$1(__assign$1({}, item), { subMenuProps: null, items: null })) : void 0, onMouseMove: _this._onItemMouseMovePrimary, onKeyDown: _this._onItemKeyDown, onClick: _this._executeItemClick, onTouchStart: _this._onTouchStart, tabIndex: 0, "data-is-focusable": true, "aria-roledescription": item["aria-roledescription"] },
              _this._renderSplitPrimaryButton(item, classNames2, index2, hasCheckmarks, hasIcons),
              _this._renderSplitDivider(item),
              _this._renderSplitIconButton(item, classNames2, index2, keytipAttributes),
              _this._renderAriaDescription(ariaDescription, classNames2.screenReaderText)
            );
          });
        };
        ContextualMenuSplitButton2.prototype._renderSplitPrimaryButton = function(item, classNames2, index2, hasCheckmarks, hasIcons) {
          var _a2 = this.props, _b = _a2.contextualMenuItemAs, ChildrenRenderer = _b === void 0 ? ContextualMenuItem : _b, onItemClick = _a2.onItemClick;
          var itemProps = {
            key: item.key,
            disabled: isItemDisabled(item) || item.primaryDisabled,
            /* eslint-disable deprecation/deprecation */
            name: item.name,
            text: item.text || item.name,
            secondaryText: item.secondaryText,
            /* eslint-enable deprecation/deprecation */
            className: classNames2.splitPrimary,
            canCheck: item.canCheck,
            isChecked: item.isChecked,
            checked: item.checked,
            iconProps: item.iconProps,
            onRenderIcon: item.onRenderIcon,
            data: item.data,
            "data-is-focusable": false
          };
          var itemComponentProps = item.itemProps;
          return reactExports.createElement(
            "button",
            __assign$1({}, getNativeProps$1(itemProps, buttonProperties$1)),
            reactExports.createElement(ChildrenRenderer, __assign$1({ "data-is-focusable": false, item: itemProps, classNames: classNames2, index: index2, onCheckmarkClick: hasCheckmarks && onItemClick ? onItemClick : void 0, hasIcons }, itemComponentProps))
          );
        };
        ContextualMenuSplitButton2.prototype._renderSplitDivider = function(item) {
          var getDividerClassNames2 = item.getSplitButtonVerticalDividerClassNames || getSplitButtonVerticalDividerClassNames;
          return reactExports.createElement(VerticalDivider, { getClassNames: getDividerClassNames2 });
        };
        ContextualMenuSplitButton2.prototype._renderSplitIconButton = function(item, classNames2, index2, keytipAttributes) {
          var _a2 = this.props, _b = _a2.contextualMenuItemAs, ChildrenRenderer = _b === void 0 ? ContextualMenuItem : _b, onItemMouseLeave = _a2.onItemMouseLeave, onItemMouseDown2 = _a2.onItemMouseDown, openSubMenu = _a2.openSubMenu, dismissSubMenu = _a2.dismissSubMenu, dismissMenu = _a2.dismissMenu;
          var itemProps = {
            onClick: this._onIconItemClick,
            disabled: isItemDisabled(item),
            className: classNames2.splitMenu,
            subMenuProps: item.subMenuProps,
            submenuIconProps: item.submenuIconProps,
            split: true,
            key: item.key
          };
          var buttonProps = __assign$1(__assign$1({}, getNativeProps$1(itemProps, buttonProperties$1)), {
            onMouseEnter: this._onItemMouseEnterIcon,
            onMouseLeave: onItemMouseLeave ? onItemMouseLeave.bind(this, item) : void 0,
            onMouseDown: function(ev) {
              return onItemMouseDown2 ? onItemMouseDown2(item, ev) : void 0;
            },
            onMouseMove: this._onItemMouseMoveIcon,
            "data-is-focusable": false,
            "data-ktp-execute-target": keytipAttributes["data-ktp-execute-target"],
            "aria-hidden": true
          });
          var itemComponentProps = item.itemProps;
          return reactExports.createElement(
            "button",
            __assign$1({}, buttonProps),
            reactExports.createElement(ChildrenRenderer, __assign$1({ componentRef: item.componentRef, item: itemProps, classNames: classNames2, index: index2, hasIcons: false, openSubMenu, dismissSubMenu, dismissMenu, getSubmenuTarget: this._getSubmenuTarget }, itemComponentProps))
          );
        };
        ContextualMenuSplitButton2.prototype._handleTouchAndPointerEvent = function(ev) {
          var _this = this;
          var onTap = this.props.onTap;
          if (onTap) {
            onTap(ev);
          }
          if (this._lastTouchTimeoutId) {
            this._async.clearTimeout(this._lastTouchTimeoutId);
            this._lastTouchTimeoutId = void 0;
          }
          this._processingTouch = true;
          this._lastTouchTimeoutId = this._async.setTimeout(function() {
            _this._processingTouch = false;
            _this._lastTouchTimeoutId = void 0;
          }, TouchIdleDelay$1);
        };
        return ContextualMenuSplitButton2;
      }(ContextualMenuItemWrapper)
    );
    var ResponsiveMode;
    (function(ResponsiveMode2) {
      ResponsiveMode2[ResponsiveMode2["small"] = 0] = "small";
      ResponsiveMode2[ResponsiveMode2["medium"] = 1] = "medium";
      ResponsiveMode2[ResponsiveMode2["large"] = 2] = "large";
      ResponsiveMode2[ResponsiveMode2["xLarge"] = 3] = "xLarge";
      ResponsiveMode2[ResponsiveMode2["xxLarge"] = 4] = "xxLarge";
      ResponsiveMode2[ResponsiveMode2["xxxLarge"] = 5] = "xxxLarge";
      ResponsiveMode2[ResponsiveMode2["unknown"] = 999] = "unknown";
    })(ResponsiveMode || (ResponsiveMode = {}));
    var RESPONSIVE_MAX_CONSTRAINT = [479, 639, 1023, 1365, 1919, 99999999];
    var _lastMode;
    function getInitialResponsiveMode() {
      var _a2;
      return (_a2 = _lastMode) !== null && _a2 !== void 0 ? _a2 : ResponsiveMode.large;
    }
    function getResponsiveMode(currentWindow) {
      var responsiveMode = ResponsiveMode.small;
      if (currentWindow) {
        try {
          while (currentWindow.innerWidth > RESPONSIVE_MAX_CONSTRAINT[responsiveMode]) {
            responsiveMode++;
          }
        } catch (e2) {
          responsiveMode = getInitialResponsiveMode();
        }
        _lastMode = responsiveMode;
      } else {
        {
          throw new Error("Content was rendered in a server environment without providing a default responsive mode. Call setResponsiveMode to define what the responsive mode is.");
        }
      }
      return responsiveMode;
    }
    var useResponsiveMode = function(elementRef, overrideResponsiveMode) {
      var _a2 = reactExports.useState(getInitialResponsiveMode()), lastResponsiveMode = _a2[0], setLastResponsiveMode = _a2[1];
      var onResize = reactExports.useCallback(function() {
        var newResponsiveMode = getResponsiveMode(getWindow(elementRef.current));
        if (lastResponsiveMode !== newResponsiveMode) {
          setLastResponsiveMode(newResponsiveMode);
        }
      }, [elementRef, lastResponsiveMode]);
      var win = useWindow();
      useOnEvent(win, "resize", onResize);
      reactExports.useEffect(function() {
        if (overrideResponsiveMode === void 0) {
          onResize();
        }
      }, [overrideResponsiveMode]);
      return overrideResponsiveMode !== null && overrideResponsiveMode !== void 0 ? overrideResponsiveMode : lastResponsiveMode;
    };
    var MenuContext$1 = reactExports.createContext({});
    var getClassNames$1 = classNamesFunction();
    var getContextualMenuItemClassNames = classNamesFunction();
    var DEFAULT_PROPS = {
      items: [],
      shouldFocusOnMount: true,
      gapSpace: 0,
      directionalHint: DirectionalHint.bottomAutoEdge,
      beakWidth: 16
    };
    function getSubmenuItems(item, options) {
      var target = options === null || options === void 0 ? void 0 : options.target;
      var items = item.subMenuProps ? item.subMenuProps.items : item.items;
      if (items) {
        var overrideItems = [];
        for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
          var subItem = items_1[_i];
          if (subItem.preferMenuTargetAsEventTarget) {
            var onClick = subItem.onClick, contextItem = __rest(subItem, ["onClick"]);
            overrideItems.push(__assign$1(__assign$1({}, contextItem), { onClick: getOnClickWithOverrideTarget(onClick, target) }));
          } else {
            overrideItems.push(subItem);
          }
        }
        return overrideItems;
      }
    }
    function canAnyMenuItemsCheck(items) {
      return items.some(function(item) {
        if (item.canCheck) {
          return true;
        }
        if (item.sectionProps && item.sectionProps.items.some(function(submenuItem) {
          return submenuItem.canCheck === true;
        })) {
          return true;
        }
        return false;
      });
    }
    var NavigationIdleDelay = 250;
    var COMPONENT_NAME$1 = "ContextualMenu";
    var _getMenuItemStylesFunction = memoizeFunction(function() {
      var styles2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        styles2[_i] = arguments[_i];
      }
      return function(styleProps) {
        return concatStyleSetsWithProps.apply(void 0, __spreadArray([styleProps, getItemStyles], styles2));
      };
    });
    function useVisibility(props, targetWindow) {
      var _a2 = props.hidden, hidden = _a2 === void 0 ? false : _a2, onMenuDismissed = props.onMenuDismissed, onMenuOpened = props.onMenuOpened;
      var previousHidden = usePrevious(hidden);
      var onMenuOpenedRef = reactExports.useRef(onMenuOpened);
      var onMenuClosedRef = reactExports.useRef(onMenuDismissed);
      var propsRef = reactExports.useRef(props);
      onMenuOpenedRef.current = onMenuOpened;
      onMenuClosedRef.current = onMenuDismissed;
      propsRef.current = props;
      reactExports.useEffect(function() {
        var _a3, _b;
        if (hidden && previousHidden === false) {
          (_a3 = onMenuClosedRef.current) === null || _a3 === void 0 ? void 0 : _a3.call(onMenuClosedRef, propsRef.current);
        } else if (!hidden && previousHidden !== false) {
          (_b = onMenuOpenedRef.current) === null || _b === void 0 ? void 0 : _b.call(onMenuOpenedRef, propsRef.current);
        }
      }, [hidden, previousHidden]);
      reactExports.useEffect(function() {
        return function() {
          var _a3;
          return (_a3 = onMenuClosedRef.current) === null || _a3 === void 0 ? void 0 : _a3.call(onMenuClosedRef, propsRef.current);
        };
      }, []);
    }
    function useSubMenuState(_a2, dismiss) {
      var hidden = _a2.hidden, items = _a2.items, theme = _a2.theme, className = _a2.className, id2 = _a2.id, menuTarget = _a2.target;
      var _b = reactExports.useState(), expandedMenuItemKey = _b[0], setExpandedMenuItemKey = _b[1];
      var _c = reactExports.useState(), submenuTarget = _c[0], setSubmenuTarget = _c[1];
      var subMenuId = useId$1(COMPONENT_NAME$1, id2);
      var closeSubMenu = reactExports.useCallback(function() {
        setExpandedMenuItemKey(void 0);
        setSubmenuTarget(void 0);
      }, []);
      var openSubMenu = reactExports.useCallback(function(_a3, target) {
        var submenuItemKey = _a3.key;
        if (expandedMenuItemKey === submenuItemKey) {
          return;
        }
        target.focus();
        setExpandedMenuItemKey(submenuItemKey);
        setSubmenuTarget(target);
      }, [expandedMenuItemKey]);
      reactExports.useEffect(function() {
        if (hidden) {
          closeSubMenu();
        }
      }, [hidden, closeSubMenu]);
      var onSubMenuDismiss = useOnSubmenuDismiss(dismiss, closeSubMenu);
      var getSubmenuProps = function() {
        var item = findItemByKeyFromItems(expandedMenuItemKey, items);
        var submenuProps = null;
        if (item) {
          submenuProps = {
            items: getSubmenuItems(item, { target: menuTarget }),
            target: submenuTarget,
            onDismiss: onSubMenuDismiss,
            isSubMenu: true,
            id: subMenuId,
            shouldFocusOnMount: true,
            directionalHint: getRTL(theme) ? DirectionalHint.leftTopEdge : DirectionalHint.rightTopEdge,
            className,
            gapSpace: 0,
            isBeakVisible: false
          };
          if (item.subMenuProps) {
            assign$4(submenuProps, item.subMenuProps);
          }
          if (item.preferMenuTargetAsEventTarget) {
            var onItemClick = item.onItemClick;
            submenuProps.onItemClick = getOnClickWithOverrideTarget(onItemClick, menuTarget);
          }
        }
        return submenuProps;
      };
      return [expandedMenuItemKey, openSubMenu, getSubmenuProps, onSubMenuDismiss];
    }
    function useShouldUpdateFocusOnMouseMove(_a2) {
      var delayUpdateFocusOnHover = _a2.delayUpdateFocusOnHover, hidden = _a2.hidden;
      var shouldUpdateFocusOnMouseEvent = reactExports.useRef(!delayUpdateFocusOnHover);
      var gotMouseMove = reactExports.useRef(false);
      reactExports.useEffect(function() {
        shouldUpdateFocusOnMouseEvent.current = !delayUpdateFocusOnHover;
        gotMouseMove.current = hidden ? false : !delayUpdateFocusOnHover && gotMouseMove.current;
      }, [delayUpdateFocusOnHover, hidden]);
      var onMenuFocusCapture = reactExports.useCallback(function() {
        if (delayUpdateFocusOnHover) {
          shouldUpdateFocusOnMouseEvent.current = false;
        }
      }, [delayUpdateFocusOnHover]);
      return [shouldUpdateFocusOnMouseEvent, gotMouseMove, onMenuFocusCapture];
    }
    function usePreviousActiveElement(_a2, targetWindow) {
      var hidden = _a2.hidden, onRestoreFocus = _a2.onRestoreFocus;
      var previousActiveElement = reactExports.useRef();
      var tryFocusPreviousActiveElement = reactExports.useCallback(function(options) {
        var _a3, _b;
        if (onRestoreFocus) {
          onRestoreFocus(options);
        } else if (options === null || options === void 0 ? void 0 : options.documentContainsFocus) {
          (_b = (_a3 = previousActiveElement.current) === null || _a3 === void 0 ? void 0 : _a3.focus) === null || _b === void 0 ? void 0 : _b.call(_a3);
        }
      }, [onRestoreFocus]);
      useIsomorphicLayoutEffect$1(function() {
        var _a3;
        if (!hidden) {
          previousActiveElement.current = targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.activeElement;
        } else if (previousActiveElement.current) {
          tryFocusPreviousActiveElement({
            originalElement: previousActiveElement.current,
            containsFocus: true,
            documentContainsFocus: ((_a3 = getDocument()) === null || _a3 === void 0 ? void 0 : _a3.hasFocus()) || false
          });
          previousActiveElement.current = void 0;
        }
      }, [hidden, targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.activeElement, tryFocusPreviousActiveElement]);
      return [tryFocusPreviousActiveElement];
    }
    function useKeyHandlers(_a2, dismiss, hostElement, openSubMenu) {
      var theme = _a2.theme, isSubMenu = _a2.isSubMenu, _b = _a2.focusZoneProps, _c = _b === void 0 ? {} : _b, checkForNoWrap = _c.checkForNoWrap, _d = _c.direction, focusZoneDirection = _d === void 0 ? FocusZoneDirection.vertical : _d;
      var lastKeyDownWasAltOrMeta = reactExports.useRef();
      var keyHandler = function(ev, shouldHandleKey, dismissAllMenus) {
        var handled = false;
        if (shouldHandleKey(ev)) {
          dismiss(ev, dismissAllMenus);
          ev.preventDefault();
          ev.stopPropagation();
          handled = true;
        }
        return handled;
      };
      var shouldCloseSubMenu = function(ev) {
        var submenuCloseKey = getRTL(theme) ? KeyCodes.right : KeyCodes.left;
        if (ev.which !== submenuCloseKey || !isSubMenu) {
          return false;
        }
        return !!(focusZoneDirection === FocusZoneDirection.vertical || checkForNoWrap && !shouldWrapFocus(ev.target, "data-no-horizontal-wrap"));
      };
      var shouldHandleKeyDown = function(ev) {
        return (
          // eslint-disable-next-line deprecation/deprecation
          ev.which === KeyCodes.escape || shouldCloseSubMenu(ev) || // eslint-disable-next-line deprecation/deprecation
          ev.which === KeyCodes.up && (ev.altKey || ev.metaKey)
        );
      };
      var onKeyDown = function(ev) {
        lastKeyDownWasAltOrMeta.current = isAltOrMeta(ev);
        var dismissAllMenus = ev.which === KeyCodes.escape && (isMac() || isIOS());
        return keyHandler(ev, shouldHandleKeyDown, dismissAllMenus);
      };
      var shouldHandleKeyUp = function(ev) {
        var keyPressIsAltOrMetaAlone = lastKeyDownWasAltOrMeta.current && isAltOrMeta(ev);
        lastKeyDownWasAltOrMeta.current = false;
        return !!keyPressIsAltOrMetaAlone && !(isIOS() || isMac());
      };
      var onKeyUp = function(ev) {
        return keyHandler(
          ev,
          shouldHandleKeyUp,
          true
          /* dismissAllMenus */
        );
      };
      var onMenuKeyDown = function(ev) {
        var handled = onKeyDown(ev);
        if (handled || !hostElement.current) {
          return;
        }
        var hasModifier = !!(ev.altKey || ev.metaKey);
        var isUp = ev.which === KeyCodes.up;
        var isDown = ev.which === KeyCodes.down;
        if (!hasModifier && (isUp || isDown)) {
          var elementToFocus = isUp ? getLastFocusable(hostElement.current, hostElement.current.lastChild, true) : getFirstFocusable(hostElement.current, hostElement.current.firstChild, true);
          if (elementToFocus) {
            elementToFocus.focus();
            ev.preventDefault();
            ev.stopPropagation();
          }
        }
      };
      var onItemKeyDown = function(item, ev) {
        var openKey = getRTL(theme) ? KeyCodes.left : KeyCodes.right;
        if (!item.disabled && // eslint-disable-next-line deprecation/deprecation
        (ev.which === openKey || ev.which === KeyCodes.enter || ev.which === KeyCodes.down && (ev.altKey || ev.metaKey))) {
          openSubMenu(item, ev.currentTarget, false);
          ev.preventDefault();
        }
      };
      return [onKeyDown, onKeyUp, onMenuKeyDown, onItemKeyDown];
    }
    function useScrollHandler(asyncTracker) {
      var isScrollIdle = reactExports.useRef(true);
      var scrollIdleTimeoutId = reactExports.useRef();
      var onScroll = function() {
        if (!isScrollIdle.current && scrollIdleTimeoutId.current !== void 0) {
          asyncTracker.clearTimeout(scrollIdleTimeoutId.current);
          scrollIdleTimeoutId.current = void 0;
        } else {
          isScrollIdle.current = false;
        }
        scrollIdleTimeoutId.current = asyncTracker.setTimeout(function() {
          isScrollIdle.current = true;
        }, NavigationIdleDelay);
      };
      return [onScroll, isScrollIdle];
    }
    function useOnSubmenuDismiss(dismiss, closeSubMenu) {
      var isMountedRef = reactExports.useRef(false);
      reactExports.useEffect(function() {
        isMountedRef.current = true;
        return function() {
          isMountedRef.current = false;
        };
      }, []);
      var onSubMenuDismiss = function(ev, dismissAll) {
        if (dismissAll) {
          dismiss(ev, dismissAll);
        } else if (isMountedRef.current) {
          closeSubMenu();
        }
      };
      return onSubMenuDismiss;
    }
    function useSubmenuEnterTimer(_a2, asyncTracker) {
      var _b = _a2.subMenuHoverDelay, subMenuHoverDelay = _b === void 0 ? NavigationIdleDelay : _b;
      var enterTimerRef = reactExports.useRef(void 0);
      var cancelSubMenuTimer = function() {
        if (enterTimerRef.current !== void 0) {
          asyncTracker.clearTimeout(enterTimerRef.current);
          enterTimerRef.current = void 0;
        }
      };
      var startSubmenuTimer = function(onTimerExpired) {
        enterTimerRef.current = asyncTracker.setTimeout(function() {
          onTimerExpired();
          cancelSubMenuTimer();
        }, subMenuHoverDelay);
      };
      return [cancelSubMenuTimer, startSubmenuTimer, enterTimerRef];
    }
    function useMouseHandlers(props, isScrollIdle, subMenuEntryTimer, targetWindow, shouldUpdateFocusOnMouseEvent, gotMouseMove, expandedMenuItemKey, hostElement, startSubmenuTimer, cancelSubMenuTimer, openSubMenu, onSubMenuDismiss, dismiss) {
      var menuTarget = props.target;
      var onItemMouseEnterBase = function(item, ev, target) {
        if (shouldUpdateFocusOnMouseEvent.current) {
          gotMouseMove.current = true;
        }
        if (shouldIgnoreMouseEvent()) {
          return;
        }
        updateFocusOnMouseEvent(item, ev, target);
      };
      var onItemMouseMoveBase = function(item, ev, target) {
        var targetElement = ev.currentTarget;
        if (shouldUpdateFocusOnMouseEvent.current) {
          gotMouseMove.current = true;
        } else {
          return;
        }
        if (!isScrollIdle.current || subMenuEntryTimer.current !== void 0 || targetElement === (targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.document.activeElement)) {
          return;
        }
        updateFocusOnMouseEvent(item, ev, target);
      };
      var shouldIgnoreMouseEvent = function() {
        return !isScrollIdle.current || !gotMouseMove.current;
      };
      var onMouseItemLeave = function(item, ev) {
        var _a2;
        if (shouldIgnoreMouseEvent()) {
          return;
        }
        cancelSubMenuTimer();
        if (expandedMenuItemKey !== void 0) {
          return;
        }
        if (hostElement.current.setActive) {
          try {
            hostElement.current.setActive();
          } catch (e2) {
          }
        } else {
          (_a2 = hostElement.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
        }
      };
      var updateFocusOnMouseEvent = function(item, ev, target) {
        var targetElement = target ? target : ev.currentTarget;
        if (item.key === expandedMenuItemKey) {
          return;
        }
        cancelSubMenuTimer();
        if (expandedMenuItemKey === void 0) {
          targetElement.focus();
        }
        if (hasSubmenu(item)) {
          ev.stopPropagation();
          startSubmenuTimer(function() {
            targetElement.focus();
            openSubMenu(item, targetElement, true);
          });
        } else {
          startSubmenuTimer(function() {
            onSubMenuDismiss(ev);
            targetElement.focus();
          });
        }
      };
      var onItemClick = function(item, ev) {
        onItemClickBase(item, ev, ev.currentTarget);
      };
      var onItemClickBase = function(item, ev, target) {
        var items = getSubmenuItems(item, { target: menuTarget });
        cancelSubMenuTimer();
        if (!hasSubmenu(item) && (!items || !items.length)) {
          executeItemClick(item, ev);
        } else {
          if (item.key !== expandedMenuItemKey) {
            openSubMenu(
              item,
              target,
              // When Edge + Narrator are used together (regardless of if the button is in a form or not), pressing
              // "Enter" fires this method and not _onMenuKeyDown. Checking ev.nativeEvent.detail differentiates
              // between a real click event and a keypress event (detail should be the number of mouse clicks).
              // ...Plot twist! For a real click event in IE 11, detail is always 0 (Edge sets it properly to 1).
              // So we also check the pointerType property, which both Edge and IE set to "mouse" for real clicks
              // and "" for pressing "Enter" with Narrator on.
              ev.nativeEvent.detail !== 0 || ev.nativeEvent.pointerType === "mouse"
            );
          }
        }
        ev.stopPropagation();
        ev.preventDefault();
      };
      var onAnchorClick = function(item, ev) {
        executeItemClick(item, ev);
        ev.stopPropagation();
      };
      var executeItemClick = function(item, ev) {
        if (item.disabled || item.isDisabled) {
          return;
        }
        if (item.preferMenuTargetAsEventTarget) {
          overrideTarget(ev, menuTarget);
        }
        var shouldDismiss = false;
        if (item.onClick) {
          shouldDismiss = !!item.onClick(ev, item);
        } else if (props.onItemClick) {
          shouldDismiss = !!props.onItemClick(ev, item);
        }
        if (shouldDismiss || !ev.defaultPrevented) {
          dismiss(ev, true);
        }
      };
      return [
        onItemMouseEnterBase,
        onItemMouseMoveBase,
        onMouseItemLeave,
        onItemClick,
        onAnchorClick,
        executeItemClick,
        onItemClickBase
      ];
    }
    var ContextualMenuBase = reactExports.memo(reactExports.forwardRef(function(propsWithoutDefaults, forwardedRef) {
      var _a2;
      var _b = getPropsWithDefaults(DEFAULT_PROPS, propsWithoutDefaults);
      _b.ref;
      var props = __rest(_b, ["ref"]);
      var hostElement = reactExports.useRef(null);
      var asyncTracker = useAsync();
      var menuId = useId$1(COMPONENT_NAME$1, props.id);
      var dismiss = function(ev, dismissAll) {
        var _a3;
        return (_a3 = props.onDismiss) === null || _a3 === void 0 ? void 0 : _a3.call(props, ev, dismissAll);
      };
      var _c = useTarget(props.target, hostElement), targetRef = _c[0], targetWindow = _c[1];
      var tryFocusPreviousActiveElement = usePreviousActiveElement(props, targetWindow)[0];
      var _d = useSubMenuState(props, dismiss), expandedMenuItemKey = _d[0], openSubMenu = _d[1], getSubmenuProps = _d[2], onSubMenuDismiss = _d[3];
      var _e = useShouldUpdateFocusOnMouseMove(props), shouldUpdateFocusOnMouseEvent = _e[0], gotMouseMove = _e[1], onMenuFocusCapture = _e[2];
      var _f = useScrollHandler(asyncTracker), onScroll = _f[0], isScrollIdle = _f[1];
      var _g = useSubmenuEnterTimer(props, asyncTracker), cancelSubMenuTimer = _g[0], startSubmenuTimer = _g[1], subMenuEntryTimer = _g[2];
      var responsiveMode = useResponsiveMode(hostElement, props.responsiveMode);
      useVisibility(props);
      var _h = useKeyHandlers(props, dismiss, hostElement, openSubMenu), onKeyDown = _h[0], onKeyUp = _h[1], onMenuKeyDown = _h[2], onItemKeyDown = _h[3];
      var _j = useMouseHandlers(props, isScrollIdle, subMenuEntryTimer, targetWindow, shouldUpdateFocusOnMouseEvent, gotMouseMove, expandedMenuItemKey, hostElement, startSubmenuTimer, cancelSubMenuTimer, openSubMenu, onSubMenuDismiss, dismiss), onItemMouseEnterBase = _j[0], onItemMouseMoveBase = _j[1], onMouseItemLeave = _j[2], onItemClick = _j[3], onAnchorClick = _j[4], executeItemClick = _j[5], onItemClickBase = _j[6];
      var onDefaultRenderMenuList = function(menuListProps, menuClassNames, defaultRender) {
        var indexCorrection = 0;
        var items2 = menuListProps.items, totalItemCount = menuListProps.totalItemCount, hasCheckmarks2 = menuListProps.hasCheckmarks, hasIcons2 = menuListProps.hasIcons;
        return reactExports.createElement("ul", { className: menuClassNames.list, onKeyDown, onKeyUp, role: "presentation" }, items2.map(function(item2, index2) {
          var menuItem = renderMenuItem(item2, index2, indexCorrection, totalItemCount, hasCheckmarks2, hasIcons2, menuClassNames);
          if (item2.itemType !== ContextualMenuItemType.Divider && item2.itemType !== ContextualMenuItemType.Header) {
            var indexIncrease = item2.customOnRenderListLength ? item2.customOnRenderListLength : 1;
            indexCorrection += indexIncrease;
          }
          return menuItem;
        }));
      };
      var renderFocusZone = function(children, adjustedFocusZoneProps2) {
        var _a3 = props.focusZoneAs, ChildrenRenderer = _a3 === void 0 ? FocusZone : _a3;
        return reactExports.createElement(ChildrenRenderer, __assign$1({}, adjustedFocusZoneProps2), children);
      };
      var renderMenuItem = function(item2, index2, focusableElementIndex, totalItemCount, hasCheckmarks2, hasIcons2, menuClassNames) {
        var _a3;
        var renderedItems = [];
        var iconProps = item2.iconProps || { iconName: "None" };
        var getItemClassNames2 = item2.getItemClassNames, itemProps = item2.itemProps;
        var styles3 = itemProps ? itemProps.styles : void 0;
        var dividerClassName = item2.itemType === ContextualMenuItemType.Divider ? item2.className : void 0;
        var subMenuIconClassName = item2.submenuIconProps ? item2.submenuIconProps.className : "";
        var itemClassNames;
        if (getItemClassNames2) {
          itemClassNames = getItemClassNames2(props.theme, isItemDisabled(item2), expandedMenuItemKey === item2.key, !!getIsChecked(item2), !!item2.href, iconProps.iconName !== "None", item2.className, dividerClassName, iconProps.className, subMenuIconClassName, item2.primaryDisabled);
        } else {
          var itemStyleProps = {
            theme: props.theme,
            disabled: isItemDisabled(item2),
            expanded: expandedMenuItemKey === item2.key,
            checked: !!getIsChecked(item2),
            isAnchorLink: !!item2.href,
            knownIcon: iconProps.iconName !== "None",
            itemClassName: item2.className,
            dividerClassName,
            iconClassName: iconProps.className,
            subMenuClassName: subMenuIconClassName,
            primaryDisabled: item2.primaryDisabled
          };
          itemClassNames = getContextualMenuItemClassNames(_getMenuItemStylesFunction((_a3 = menuClassNames.subComponentStyles) === null || _a3 === void 0 ? void 0 : _a3.menuItem, styles3), itemStyleProps);
        }
        if (item2.text === "-" || item2.name === "-") {
          item2.itemType = ContextualMenuItemType.Divider;
        }
        switch (item2.itemType) {
          case ContextualMenuItemType.Divider:
            renderedItems.push(renderSeparator(index2, itemClassNames));
            break;
          case ContextualMenuItemType.Header:
            renderedItems.push(renderSeparator(index2, itemClassNames));
            var headerItem = renderHeaderMenuItem(item2, itemClassNames, menuClassNames, index2, hasCheckmarks2, hasIcons2);
            renderedItems.push(renderListItem(headerItem, item2.key || index2, itemClassNames, item2.title));
            break;
          case ContextualMenuItemType.Section:
            renderedItems.push(renderSectionItem(item2, itemClassNames, menuClassNames, index2, hasCheckmarks2, hasIcons2));
            break;
          default:
            var defaultRenderNormalItem = function() {
              return renderNormalItem(item2, itemClassNames, index2, focusableElementIndex, totalItemCount, hasCheckmarks2, hasIcons2);
            };
            var menuItem = props.onRenderContextualMenuItem ? props.onRenderContextualMenuItem(item2, defaultRenderNormalItem) : defaultRenderNormalItem();
            renderedItems.push(renderListItem(menuItem, item2.key || index2, itemClassNames, item2.title));
            break;
        }
        return reactExports.createElement(reactExports.Fragment, { key: item2.key }, renderedItems);
      };
      var defaultMenuItemRenderer = function(item2, menuClassNames) {
        var index2 = item2.index, focusableElementIndex = item2.focusableElementIndex, totalItemCount = item2.totalItemCount, hasCheckmarks2 = item2.hasCheckmarks, hasIcons2 = item2.hasIcons;
        return renderMenuItem(item2, index2, focusableElementIndex, totalItemCount, hasCheckmarks2, hasIcons2, menuClassNames);
      };
      var renderSectionItem = function(sectionItem, itemClassNames, menuClassNames, index2, hasCheckmarks2, hasIcons2) {
        var sectionProps = sectionItem.sectionProps;
        if (!sectionProps) {
          return;
        }
        var headerItem;
        var groupProps;
        if (sectionProps.title) {
          var headerContextualMenuItem = void 0;
          var ariaLabelledby = "";
          if (typeof sectionProps.title === "string") {
            var id_1 = menuId + sectionProps.title.replace(/\s/g, "");
            headerContextualMenuItem = {
              key: "section-" + sectionProps.title + "-title",
              itemType: ContextualMenuItemType.Header,
              text: sectionProps.title,
              id: id_1
            };
            ariaLabelledby = id_1;
          } else {
            var id_2 = sectionProps.title.id || menuId + sectionProps.title.key.replace(/\s/g, "");
            headerContextualMenuItem = __assign$1(__assign$1({}, sectionProps.title), { id: id_2 });
            ariaLabelledby = id_2;
          }
          if (headerContextualMenuItem) {
            groupProps = {
              role: "group",
              "aria-labelledby": ariaLabelledby
            };
            headerItem = renderHeaderMenuItem(headerContextualMenuItem, itemClassNames, menuClassNames, index2, hasCheckmarks2, hasIcons2);
          }
        }
        if (sectionProps.items && sectionProps.items.length > 0) {
          return reactExports.createElement(
            "li",
            { role: "presentation", key: sectionProps.key || sectionItem.key || "section-" + index2 },
            reactExports.createElement(
              "div",
              __assign$1({}, groupProps),
              reactExports.createElement(
                "ul",
                { className: menuClassNames.list, role: "presentation" },
                sectionProps.topDivider && renderSeparator(index2, itemClassNames, true, true),
                headerItem && renderListItem(headerItem, sectionItem.key || index2, itemClassNames, sectionItem.title),
                sectionProps.items.map(function(contextualMenuItem, itemsIndex) {
                  return renderMenuItem(contextualMenuItem, itemsIndex, itemsIndex, sectionProps.items.length, hasCheckmarks2, hasIcons2, menuClassNames);
                }),
                sectionProps.bottomDivider && renderSeparator(index2, itemClassNames, false, true)
              )
            )
          );
        }
      };
      var renderListItem = function(content2, key, classNames3, title2) {
        return reactExports.createElement("li", { role: "presentation", title: title2, key, className: classNames3.item }, content2);
      };
      var renderSeparator = function(index2, classNames3, top, fromSection) {
        if (fromSection || index2 > 0) {
          return reactExports.createElement("li", { role: "separator", key: "separator-" + index2 + (top === void 0 ? "" : top ? "-top" : "-bottom"), className: classNames3.divider, "aria-hidden": "true" });
        }
        return null;
      };
      var renderNormalItem = function(item2, classNames3, index2, focusableElementIndex, totalItemCount, hasCheckmarks2, hasIcons2) {
        if (item2.onRender) {
          return item2.onRender(__assign$1({ "aria-posinset": focusableElementIndex + 1, "aria-setsize": totalItemCount }, item2), dismiss);
        }
        var contextualMenuItemAs = props.contextualMenuItemAs;
        var commonProps = {
          item: item2,
          classNames: classNames3,
          index: index2,
          focusableElementIndex,
          totalItemCount,
          hasCheckmarks: hasCheckmarks2,
          hasIcons: hasIcons2,
          contextualMenuItemAs,
          onItemMouseEnter: onItemMouseEnterBase,
          onItemMouseLeave: onMouseItemLeave,
          onItemMouseMove: onItemMouseMoveBase,
          onItemMouseDown,
          executeItemClick,
          onItemKeyDown,
          expandedMenuItemKey,
          openSubMenu,
          dismissSubMenu: onSubMenuDismiss,
          dismissMenu: dismiss
        };
        if (item2.href) {
          return reactExports.createElement(ContextualMenuAnchor, __assign$1({}, commonProps, { onItemClick: onAnchorClick }));
        }
        if (item2.split && hasSubmenu(item2)) {
          return reactExports.createElement(ContextualMenuSplitButton, __assign$1({}, commonProps, { onItemClick, onItemClickBase, onTap: cancelSubMenuTimer }));
        }
        return reactExports.createElement(ContextualMenuButton, __assign$1({}, commonProps, { onItemClick, onItemClickBase }));
      };
      var renderHeaderMenuItem = function(item2, itemClassNames, menuClassNames, index2, hasCheckmarks2, hasIcons2) {
        var _a3 = props.contextualMenuItemAs, ChildrenRenderer = _a3 === void 0 ? ContextualMenuItem : _a3;
        var itemProps = item2.itemProps, id3 = item2.id;
        var divHtmlProperties = itemProps && getNativeProps$1(itemProps, divProperties);
        return (
          // eslint-disable-next-line deprecation/deprecation
          reactExports.createElement(
            "div",
            __assign$1({ id: id3, className: menuClassNames.header }, divHtmlProperties, { style: item2.style }),
            reactExports.createElement(ChildrenRenderer, __assign$1({ item: item2, classNames: itemClassNames, index: index2, onCheckmarkClick: hasCheckmarks2 ? onItemClick : void 0, hasIcons: hasIcons2 }, itemProps))
          )
        );
      };
      var isBeakVisible = props.isBeakVisible;
      var items = props.items, labelElementId = props.labelElementId, id2 = props.id, className = props.className, beakWidth = props.beakWidth, directionalHint = props.directionalHint, directionalHintForRTL = props.directionalHintForRTL, alignTargetEdge = props.alignTargetEdge, gapSpace = props.gapSpace, coverTarget2 = props.coverTarget, ariaLabel = props.ariaLabel, doNotLayer = props.doNotLayer, target = props.target, bounds = props.bounds, useTargetWidth = props.useTargetWidth, useTargetAsMinWidth = props.useTargetAsMinWidth, directionalHintFixed = props.directionalHintFixed, shouldFocusOnMount = props.shouldFocusOnMount, shouldFocusOnContainer = props.shouldFocusOnContainer, title = props.title, styles2 = props.styles, theme = props.theme, calloutProps = props.calloutProps, _k = props.onRenderSubMenu, onRenderSubMenu2 = _k === void 0 ? onDefaultRenderSubMenu : _k, _l = props.onRenderMenuList, onRenderMenuList = _l === void 0 ? function(menuListProps, defaultRender) {
        return onDefaultRenderMenuList(menuListProps, classNames2);
      } : _l, focusZoneProps = props.focusZoneProps, getMenuClassNames = props.getMenuClassNames;
      var classNames2 = getMenuClassNames ? getMenuClassNames(theme, className) : getClassNames$1(styles2, {
        theme,
        className
      });
      var hasIcons = itemsHaveIcons(items);
      function itemsHaveIcons(contextualMenuItems) {
        for (var _i2 = 0, contextualMenuItems_1 = contextualMenuItems; _i2 < contextualMenuItems_1.length; _i2++) {
          var item2 = contextualMenuItems_1[_i2];
          if (item2.iconProps) {
            return true;
          }
          if (item2.itemType === ContextualMenuItemType.Section && item2.sectionProps && itemsHaveIcons(item2.sectionProps.items)) {
            return true;
          }
        }
        return false;
      }
      var adjustedFocusZoneProps = __assign$1(__assign$1({ direction: FocusZoneDirection.vertical, handleTabKey: FocusZoneTabbableElements.all, isCircularNavigation: true }, focusZoneProps), { className: css$1(classNames2.root, (_a2 = props.focusZoneProps) === null || _a2 === void 0 ? void 0 : _a2.className) });
      var hasCheckmarks = canAnyMenuItemsCheck(items);
      var submenuProps = expandedMenuItemKey && props.hidden !== true ? getSubmenuProps() : null;
      isBeakVisible = isBeakVisible === void 0 ? responsiveMode <= ResponsiveMode.medium : isBeakVisible;
      var contextMenuStyle;
      var targetAsHtmlElement = targetRef.current;
      if ((useTargetWidth || useTargetAsMinWidth) && targetAsHtmlElement && targetAsHtmlElement.offsetWidth) {
        var targetBoundingRect = targetAsHtmlElement.getBoundingClientRect();
        var targetWidth = targetBoundingRect.width - 2;
        if (useTargetWidth) {
          contextMenuStyle = {
            width: targetWidth
          };
        } else if (useTargetAsMinWidth) {
          contextMenuStyle = {
            minWidth: targetWidth
          };
        }
      }
      if (items && items.length > 0) {
        var totalItemCount_1 = 0;
        for (var _i = 0, items_2 = items; _i < items_2.length; _i++) {
          var item = items_2[_i];
          if (item.itemType !== ContextualMenuItemType.Divider && item.itemType !== ContextualMenuItemType.Header) {
            var itemCount = item.customOnRenderListLength ? item.customOnRenderListLength : 1;
            totalItemCount_1 += itemCount;
          }
        }
        var calloutStyles_1 = classNames2.subComponentStyles ? classNames2.subComponentStyles.callout : void 0;
        return reactExports.createElement(MenuContext$1.Consumer, null, function(menuContext) {
          return reactExports.createElement(
            Callout,
            __assign$1({ styles: calloutStyles_1, onRestoreFocus: tryFocusPreviousActiveElement }, calloutProps, { target: target || menuContext.target, isBeakVisible, beakWidth, directionalHint, directionalHintForRTL, gapSpace, coverTarget: coverTarget2, doNotLayer, className: css$1("ms-ContextualMenu-Callout", calloutProps && calloutProps.className), setInitialFocus: shouldFocusOnMount, onDismiss: props.onDismiss || menuContext.onDismiss, onScroll, bounds, directionalHintFixed, alignTargetEdge, hidden: props.hidden || menuContext.hidden, ref: forwardedRef }),
            reactExports.createElement(
              "div",
              { style: contextMenuStyle, ref: hostElement, id: id2, className: classNames2.container, tabIndex: shouldFocusOnContainer ? 0 : -1, onKeyDown: onMenuKeyDown, onKeyUp, onFocusCapture: onMenuFocusCapture, "aria-label": ariaLabel, "aria-labelledby": labelElementId, role: "menu" },
              title && reactExports.createElement(
                "div",
                { className: classNames2.title },
                " ",
                title,
                " "
              ),
              items && items.length ? renderFocusZone(onRenderMenuList({
                ariaLabel,
                items,
                totalItemCount: totalItemCount_1,
                hasCheckmarks,
                hasIcons,
                defaultMenuItemRenderer: function(item2) {
                  return defaultMenuItemRenderer(item2, classNames2);
                },
                labelElementId
              }, function(menuListProps, defaultRender) {
                return onDefaultRenderMenuList(menuListProps, classNames2);
              }), adjustedFocusZoneProps) : null,
              submenuProps && onRenderSubMenu2(submenuProps, onDefaultRenderSubMenu)
            )
          );
        });
      } else {
        return null;
      }
    }), function(prevProps, newProps) {
      if (!newProps.shouldUpdateWhenHidden && prevProps.hidden && newProps.hidden) {
        return true;
      }
      return shallowCompare(prevProps, newProps);
    });
    ContextualMenuBase.displayName = "ContextualMenuBase";
    function isAltOrMeta(ev) {
      return ev.which === KeyCodes.alt || ev.key === "Meta";
    }
    function onItemMouseDown(item, ev) {
      var _a2;
      (_a2 = item.onMouseDown) === null || _a2 === void 0 ? void 0 : _a2.call(item, item, ev);
    }
    function onDefaultRenderSubMenu(subMenuProps, defaultRender) {
      throw Error("ContextualMenuBase: onRenderSubMenu callback is null or undefined. Please ensure to set `onRenderSubMenu` property either manually or with `styled` helper.");
    }
    function findItemByKeyFromItems(key, items) {
      for (var _i = 0, items_3 = items; _i < items_3.length; _i++) {
        var item = items_3[_i];
        if (item.itemType === ContextualMenuItemType.Section && item.sectionProps) {
          var match5 = findItemByKeyFromItems(key, item.sectionProps.items);
          if (match5) {
            return match5;
          }
        } else if (item.key && item.key === key) {
          return item;
        }
      }
    }
    function getOnClickWithOverrideTarget(onClick, target) {
      return onClick ? function(ev, item) {
        overrideTarget(ev, target);
        return onClick(ev, item);
      } : onClick;
    }
    function overrideTarget(ev, target) {
      if (ev && target) {
        ev.persist();
        if (target instanceof Event) {
          ev.target = target.target;
        } else if (target instanceof Element) {
          ev.target = target;
        }
      }
    }
    var GlobalClassNames$3 = {
      root: "ms-ContextualMenu",
      container: "ms-ContextualMenu-container",
      list: "ms-ContextualMenu-list",
      header: "ms-ContextualMenu-header",
      title: "ms-ContextualMenu-title",
      isopen: "is-open"
    };
    var getStyles$3 = function(props) {
      var className = props.className, theme = props.theme;
      var classNames2 = getGlobalClassNames(GlobalClassNames$3, theme);
      var fonts = theme.fonts, semanticColors = theme.semanticColors, effects = theme.effects;
      return {
        root: [
          theme.fonts.medium,
          classNames2.root,
          classNames2.isopen,
          {
            backgroundColor: semanticColors.menuBackground,
            minWidth: "180px"
          },
          className
        ],
        container: [
          classNames2.container,
          {
            selectors: {
              ":focus": { outline: 0 }
            }
          }
        ],
        list: [
          classNames2.list,
          classNames2.isopen,
          {
            listStyleType: "none",
            margin: "0",
            padding: "0"
          }
        ],
        header: [
          classNames2.header,
          fonts.small,
          {
            fontWeight: FontWeights$1.semibold,
            color: semanticColors.menuHeader,
            background: "none",
            backgroundColor: "transparent",
            border: "none",
            height: CONTEXTUAL_MENU_ITEM_HEIGHT,
            lineHeight: CONTEXTUAL_MENU_ITEM_HEIGHT,
            cursor: "default",
            padding: "0px 6px",
            userSelect: "none",
            textAlign: "left"
          }
        ],
        title: [
          classNames2.title,
          {
            fontSize: fonts.mediumPlus.fontSize,
            paddingRight: "14px",
            paddingLeft: "14px",
            paddingBottom: "5px",
            paddingTop: "5px",
            backgroundColor: semanticColors.menuItemBackgroundPressed
          }
        ],
        subComponentStyles: {
          callout: {
            root: {
              boxShadow: effects.elevation8
            }
          },
          menuItem: {}
        }
      };
    };
    function onRenderSubMenu(subMenuProps) {
      return reactExports.createElement(LocalContextualMenu, __assign$1({}, subMenuProps));
    }
    var LocalContextualMenu = styled(ContextualMenuBase, getStyles$3, function(props) {
      return {
        onRenderSubMenu: props.onRenderSubMenu ? composeRenderFunction(props.onRenderSubMenu, onRenderSubMenu) : onRenderSubMenu
      };
    }, { scope: "ContextualMenu" });
    var ContextualMenu = LocalContextualMenu;
    ContextualMenu.displayName = "ContextualMenu";
    var ButtonGlobalClassNames = {
      msButton: "ms-Button",
      msButtonHasMenu: "ms-Button--hasMenu",
      msButtonIcon: "ms-Button-icon",
      msButtonMenuIcon: "ms-Button-menuIcon",
      msButtonLabel: "ms-Button-label",
      msButtonDescription: "ms-Button-description",
      msButtonScreenReaderText: "ms-Button-screenReaderText",
      msButtonFlexContainer: "ms-Button-flexContainer",
      msButtonTextContainer: "ms-Button-textContainer"
    };
    var getBaseButtonClassNames = memoizeFunction(function(theme, styles2, className, variantClassName, iconClassName, menuIconClassName, disabled, hasMenu, checked, expanded, isSplit) {
      var _a2, _b;
      var classNames2 = getGlobalClassNames(ButtonGlobalClassNames, theme || {});
      var isExpanded = expanded && !isSplit;
      return mergeStyleSets({
        root: [
          classNames2.msButton,
          styles2.root,
          variantClassName,
          checked && ["is-checked", styles2.rootChecked],
          isExpanded && [
            "is-expanded",
            styles2.rootExpanded,
            {
              selectors: (_a2 = {}, _a2[":hover ." + classNames2.msButtonIcon] = styles2.iconExpandedHovered, // menuIcon falls back to rootExpandedHovered to support original behavior
              _a2[":hover ." + classNames2.msButtonMenuIcon] = styles2.menuIconExpandedHovered || styles2.rootExpandedHovered, _a2[":hover"] = styles2.rootExpandedHovered, _a2)
            }
          ],
          hasMenu && [ButtonGlobalClassNames.msButtonHasMenu, styles2.rootHasMenu],
          disabled && ["is-disabled", styles2.rootDisabled],
          !disabled && !isExpanded && !checked && {
            selectors: (_b = {
              ":hover": styles2.rootHovered
            }, _b[":hover ." + classNames2.msButtonLabel] = styles2.labelHovered, _b[":hover ." + classNames2.msButtonIcon] = styles2.iconHovered, _b[":hover ." + classNames2.msButtonDescription] = styles2.descriptionHovered, _b[":hover ." + classNames2.msButtonMenuIcon] = styles2.menuIconHovered, _b[":focus"] = styles2.rootFocused, _b[":active"] = styles2.rootPressed, _b[":active ." + classNames2.msButtonIcon] = styles2.iconPressed, _b[":active ." + classNames2.msButtonDescription] = styles2.descriptionPressed, _b[":active ." + classNames2.msButtonMenuIcon] = styles2.menuIconPressed, _b)
          },
          disabled && checked && [styles2.rootCheckedDisabled],
          !disabled && checked && {
            selectors: {
              ":hover": styles2.rootCheckedHovered,
              ":active": styles2.rootCheckedPressed
            }
          },
          className
        ],
        flexContainer: [classNames2.msButtonFlexContainer, styles2.flexContainer],
        textContainer: [classNames2.msButtonTextContainer, styles2.textContainer],
        icon: [
          classNames2.msButtonIcon,
          iconClassName,
          styles2.icon,
          isExpanded && styles2.iconExpanded,
          checked && styles2.iconChecked,
          disabled && styles2.iconDisabled
        ],
        label: [classNames2.msButtonLabel, styles2.label, checked && styles2.labelChecked, disabled && styles2.labelDisabled],
        menuIcon: [
          classNames2.msButtonMenuIcon,
          menuIconClassName,
          styles2.menuIcon,
          checked && styles2.menuIconChecked,
          disabled && !isSplit && styles2.menuIconDisabled,
          !disabled && !isExpanded && !checked && {
            selectors: {
              ":hover": styles2.menuIconHovered,
              ":active": styles2.menuIconPressed
            }
          },
          isExpanded && ["is-expanded", styles2.menuIconExpanded]
        ],
        description: [
          classNames2.msButtonDescription,
          styles2.description,
          checked && styles2.descriptionChecked,
          disabled && styles2.descriptionDisabled
        ],
        screenReaderText: [classNames2.msButtonScreenReaderText, styles2.screenReaderText]
      });
    });
    var getSplitButtonClassNames = memoizeFunction(function(styles2, disabled, expanded, checked, primaryDisabled) {
      return {
        root: mergeStyles(styles2.splitButtonMenuButton, expanded && [styles2.splitButtonMenuButtonExpanded], disabled && [styles2.splitButtonMenuButtonDisabled], checked && !disabled && [styles2.splitButtonMenuButtonChecked], primaryDisabled && !disabled && [
          {
            selectors: {
              ":focus": styles2.splitButtonMenuFocused
            }
          }
        ]),
        splitButtonContainer: mergeStyles(styles2.splitButtonContainer, !disabled && checked && [
          styles2.splitButtonContainerChecked,
          {
            selectors: {
              ":hover": styles2.splitButtonContainerCheckedHovered
            }
          }
        ], !disabled && !checked && [
          {
            selectors: {
              ":hover": styles2.splitButtonContainerHovered,
              ":focus": styles2.splitButtonContainerFocused
            }
          }
        ], disabled && styles2.splitButtonContainerDisabled),
        icon: mergeStyles(styles2.splitButtonMenuIcon, disabled && styles2.splitButtonMenuIconDisabled, !disabled && primaryDisabled && styles2.splitButtonMenuIcon),
        flexContainer: mergeStyles(styles2.splitButtonFlexContainer),
        divider: mergeStyles(styles2.splitButtonDivider, (primaryDisabled || disabled) && styles2.splitButtonDividerDisabled)
      };
    });
    var TouchIdleDelay = 500;
    var COMPONENT_NAME = "BaseButton";
    var BaseButton = (
      /** @class */
      function(_super) {
        __extends(BaseButton2, _super);
        function BaseButton2(props) {
          var _this = _super.call(this, props) || this;
          _this._buttonElement = reactExports.createRef();
          _this._splitButtonContainer = reactExports.createRef();
          _this._mergedRef = createMergedRef();
          _this._renderedVisibleMenu = false;
          _this._getMemoizedMenuButtonKeytipProps = memoizeFunction(function(keytipProps) {
            return __assign$1(__assign$1({}, keytipProps), { hasMenu: true });
          });
          _this._onRenderIcon = function(buttonProps, defaultRender) {
            var iconProps = _this.props.iconProps;
            if (iconProps && (iconProps.iconName !== void 0 || iconProps.imageProps)) {
              var className = iconProps.className, imageProps = iconProps.imageProps, rest = __rest(iconProps, ["className", "imageProps"]);
              if (iconProps.styles) {
                return reactExports.createElement(Icon, __assign$1({ className: css$1(_this._classNames.icon, className), imageProps }, rest));
              }
              if (iconProps.iconName) {
                return reactExports.createElement(FontIcon, __assign$1({ className: css$1(_this._classNames.icon, className) }, rest));
              }
              if (imageProps) {
                return reactExports.createElement(ImageIcon, __assign$1({ className: css$1(_this._classNames.icon, className), imageProps }, rest));
              }
            }
            return null;
          };
          _this._onRenderTextContents = function() {
            var _a2 = _this.props, text2 = _a2.text, children = _a2.children, _b = _a2.secondaryText, secondaryText = _b === void 0 ? _this.props.description : _b, _c = _a2.onRenderText, onRenderText = _c === void 0 ? _this._onRenderText : _c, _d = _a2.onRenderDescription, onRenderDescription = _d === void 0 ? _this._onRenderDescription : _d;
            if (text2 || typeof children === "string" || secondaryText) {
              return reactExports.createElement(
                "span",
                { className: _this._classNames.textContainer },
                onRenderText(_this.props, _this._onRenderText),
                onRenderDescription(_this.props, _this._onRenderDescription)
              );
            }
            return [onRenderText(_this.props, _this._onRenderText), onRenderDescription(_this.props, _this._onRenderDescription)];
          };
          _this._onRenderText = function() {
            var text2 = _this.props.text;
            var children = _this.props.children;
            if (text2 === void 0 && typeof children === "string") {
              text2 = children;
            }
            if (_this._hasText()) {
              return reactExports.createElement("span", { key: _this._labelId, className: _this._classNames.label, id: _this._labelId }, text2);
            }
            return null;
          };
          _this._onRenderChildren = function() {
            var children = _this.props.children;
            if (typeof children === "string") {
              return null;
            }
            return children;
          };
          _this._onRenderDescription = function(props2) {
            var _a2 = props2.secondaryText, secondaryText = _a2 === void 0 ? _this.props.description : _a2;
            return secondaryText ? reactExports.createElement("span", { key: _this._descriptionId, className: _this._classNames.description, id: _this._descriptionId }, secondaryText) : null;
          };
          _this._onRenderAriaDescription = function() {
            var ariaDescription = _this.props.ariaDescription;
            return ariaDescription ? reactExports.createElement("span", { className: _this._classNames.screenReaderText, id: _this._ariaDescriptionId }, ariaDescription) : null;
          };
          _this._onRenderMenuIcon = function(props2) {
            var menuIconProps = _this.props.menuIconProps;
            return reactExports.createElement(FontIcon, __assign$1({ iconName: "ChevronDown" }, menuIconProps, { className: _this._classNames.menuIcon }));
          };
          _this._onRenderMenu = function(menuProps) {
            var MenuType = _this.props.menuAs ? composeComponentAs(_this.props.menuAs, ContextualMenu) : ContextualMenu;
            return reactExports.createElement(MenuType, __assign$1({}, menuProps));
          };
          _this._onDismissMenu = function(ev) {
            var menuProps = _this.props.menuProps;
            if (menuProps && menuProps.onDismiss) {
              menuProps.onDismiss(ev);
            }
            if (!ev || !ev.defaultPrevented) {
              _this._dismissMenu();
            }
          };
          _this._dismissMenu = function() {
            _this._menuShouldFocusOnMount = void 0;
            _this._menuShouldFocusOnContainer = void 0;
            _this.setState({ menuHidden: true });
          };
          _this._openMenu = function(shouldFocusOnContainer, shouldFocusOnMount) {
            if (shouldFocusOnMount === void 0) {
              shouldFocusOnMount = true;
            }
            if (_this.props.menuProps) {
              _this._menuShouldFocusOnContainer = shouldFocusOnContainer;
              _this._menuShouldFocusOnMount = shouldFocusOnMount;
              _this._renderedVisibleMenu = true;
              _this.setState({ menuHidden: false });
            }
          };
          _this._onToggleMenu = function(shouldFocusOnContainer) {
            var shouldFocusOnMount = true;
            if (_this.props.menuProps && _this.props.menuProps.shouldFocusOnMount === false) {
              shouldFocusOnMount = false;
            }
            _this.state.menuHidden ? _this._openMenu(shouldFocusOnContainer, shouldFocusOnMount) : _this._dismissMenu();
          };
          _this._onSplitContainerFocusCapture = function(ev) {
            var container = _this._splitButtonContainer.current;
            if (!container || ev.target && portalContainsElement(ev.target, container)) {
              return;
            }
            container.focus();
          };
          _this._onSplitButtonPrimaryClick = function(ev) {
            if (!_this.state.menuHidden) {
              _this._dismissMenu();
            }
            if (!_this._processingTouch && _this.props.onClick) {
              _this.props.onClick(ev);
            } else if (_this._processingTouch) {
              _this._onMenuClick(ev);
            }
          };
          _this._onKeyDown = function(ev) {
            if (_this.props.disabled && (ev.which === KeyCodes.enter || ev.which === KeyCodes.space)) {
              ev.preventDefault();
              ev.stopPropagation();
            } else if (!_this.props.disabled) {
              if (_this.props.menuProps) {
                _this._onMenuKeyDown(ev);
              } else if (_this.props.onKeyDown !== void 0) {
                _this.props.onKeyDown(ev);
              }
            }
          };
          _this._onKeyUp = function(ev) {
            if (!_this.props.disabled && _this.props.onKeyUp !== void 0) {
              _this.props.onKeyUp(ev);
            }
          };
          _this._onKeyPress = function(ev) {
            if (!_this.props.disabled && _this.props.onKeyPress !== void 0) {
              _this.props.onKeyPress(ev);
            }
          };
          _this._onMouseUp = function(ev) {
            if (!_this.props.disabled && _this.props.onMouseUp !== void 0) {
              _this.props.onMouseUp(ev);
            }
          };
          _this._onMouseDown = function(ev) {
            if (!_this.props.disabled && _this.props.onMouseDown !== void 0) {
              _this.props.onMouseDown(ev);
            }
          };
          _this._onClick = function(ev) {
            if (!_this.props.disabled) {
              if (_this.props.menuProps) {
                _this._onMenuClick(ev);
              } else if (_this.props.onClick !== void 0) {
                _this.props.onClick(ev);
              }
            }
          };
          _this._onSplitButtonContainerKeyDown = function(ev) {
            if (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) {
              if (_this._buttonElement.current) {
                _this._buttonElement.current.click();
                ev.preventDefault();
                ev.stopPropagation();
              }
            } else {
              _this._onMenuKeyDown(ev);
            }
          };
          _this._onMenuKeyDown = function(ev) {
            if (_this.props.disabled) {
              return;
            }
            if (_this.props.onKeyDown) {
              _this.props.onKeyDown(ev);
            }
            var isUp = ev.which === KeyCodes.up;
            var isDown = ev.which === KeyCodes.down;
            if (!ev.defaultPrevented && _this._isValidMenuOpenKey(ev)) {
              var onMenuClick = _this.props.onMenuClick;
              if (onMenuClick) {
                onMenuClick(ev, _this.props);
              }
              _this._onToggleMenu(false);
              ev.preventDefault();
              ev.stopPropagation();
            }
            if (ev.which === KeyCodes.enter || ev.which === KeyCodes.space) {
              setFocusVisibility(true, ev.target);
            }
            if (!(ev.altKey || ev.metaKey) && (isUp || isDown)) {
              if (!_this.state.menuHidden && _this.props.menuProps) {
                var currentShouldFocusOnMount = _this._menuShouldFocusOnMount !== void 0 ? _this._menuShouldFocusOnMount : _this.props.menuProps.shouldFocusOnMount;
                if (!currentShouldFocusOnMount) {
                  ev.preventDefault();
                  ev.stopPropagation();
                  _this._menuShouldFocusOnMount = true;
                  _this.forceUpdate();
                }
              }
            }
          };
          _this._onTouchStart = function() {
            if (_this._isSplitButton && _this._splitButtonContainer.current && !("onpointerdown" in _this._splitButtonContainer.current)) {
              _this._handleTouchAndPointerEvent();
            }
          };
          _this._onMenuClick = function(ev) {
            var _a2 = _this.props, onMenuClick = _a2.onMenuClick, menuProps = _a2.menuProps;
            if (onMenuClick) {
              onMenuClick(ev, _this.props);
            }
            if (!ev.defaultPrevented) {
              _this._onToggleMenu((menuProps === null || menuProps === void 0 ? void 0 : menuProps.shouldFocusOnContainer) || false);
              ev.preventDefault();
              ev.stopPropagation();
            }
          };
          initializeComponentRef(_this);
          _this._async = new Async(_this);
          _this._events = new EventGroup(_this);
          warnConditionallyRequiredProps(COMPONENT_NAME, props, ["menuProps", "onClick"], "split", _this.props.split);
          _this._labelId = getId();
          _this._descriptionId = getId();
          _this._ariaDescriptionId = getId();
          _this.state = {
            menuHidden: true
          };
          return _this;
        }
        Object.defineProperty(BaseButton2.prototype, "_isSplitButton", {
          get: function() {
            return !!this.props.menuProps && !!this.props.onClick && this.props.split === true;
          },
          enumerable: false,
          configurable: true
        });
        BaseButton2.prototype.render = function() {
          var _a2;
          var _b = this.props, ariaDescription = _b.ariaDescription, ariaLabel = _b.ariaLabel, ariaHidden = _b.ariaHidden, className = _b.className, disabled = _b.disabled, allowDisabledFocus = _b.allowDisabledFocus, primaryDisabled = _b.primaryDisabled, _c = _b.secondaryText, secondaryText = _c === void 0 ? this.props.description : _c, href = _b.href, iconProps = _b.iconProps, menuIconProps = _b.menuIconProps, styles2 = _b.styles, checked = _b.checked, variantClassName = _b.variantClassName, theme = _b.theme, toggle = _b.toggle, getClassNames2 = _b.getClassNames, role = _b.role;
          var menuHidden = this.state.menuHidden;
          var isPrimaryButtonDisabled = disabled || primaryDisabled;
          this._classNames = getClassNames2 ? getClassNames2(theme, className, variantClassName, iconProps && iconProps.className, menuIconProps && menuIconProps.className, isPrimaryButtonDisabled, checked, !menuHidden, !!this.props.menuProps, this.props.split, !!allowDisabledFocus) : getBaseButtonClassNames(theme, styles2, className, variantClassName, iconProps && iconProps.className, menuIconProps && menuIconProps.className, isPrimaryButtonDisabled, !!this.props.menuProps, checked, !menuHidden, this.props.split);
          var _d = this, _ariaDescriptionId = _d._ariaDescriptionId, _labelId = _d._labelId, _descriptionId = _d._descriptionId;
          var renderAsAnchor = !isPrimaryButtonDisabled && !!href;
          var tag = renderAsAnchor ? "a" : "button";
          var nativeProps = getNativeProps$1(
            // eslint-disable-next-line deprecation/deprecation
            assign$4(renderAsAnchor ? {} : { type: "button" }, this.props.rootProps, this.props),
            renderAsAnchor ? anchorProperties$1 : buttonProperties$1,
            [
              "disabled"
              // let disabled buttons be focused and styled as disabled.
            ]
          );
          var resolvedAriaLabel = ariaLabel || nativeProps["aria-label"];
          var ariaDescribedBy = void 0;
          if (ariaDescription) {
            ariaDescribedBy = _ariaDescriptionId;
          } else if (secondaryText && this.props.onRenderDescription !== nullRender) {
            ariaDescribedBy = _descriptionId;
          } else if (nativeProps["aria-describedby"]) {
            ariaDescribedBy = nativeProps["aria-describedby"];
          }
          var ariaLabelledBy = void 0;
          if (nativeProps["aria-labelledby"]) {
            ariaLabelledBy = nativeProps["aria-labelledby"];
          } else if (ariaDescribedBy && !resolvedAriaLabel) {
            ariaLabelledBy = this._hasText() ? _labelId : void 0;
          }
          var dataIsFocusable = this.props["data-is-focusable"] === false || disabled && !allowDisabledFocus || this._isSplitButton ? false : true;
          var isCheckboxTypeRole = role === "menuitemcheckbox" || role === "checkbox";
          var checkedOrPressedValue = isCheckboxTypeRole ? !!checked : toggle === true ? !!checked : void 0;
          var buttonProps = assign$4(nativeProps, (_a2 = {
            className: this._classNames.root,
            // eslint-disable-next-line deprecation/deprecation
            ref: this._mergedRef(this.props.elementRef, this._buttonElement),
            disabled: isPrimaryButtonDisabled && !allowDisabledFocus,
            onKeyDown: this._onKeyDown,
            onKeyPress: this._onKeyPress,
            onKeyUp: this._onKeyUp,
            onMouseDown: this._onMouseDown,
            onMouseUp: this._onMouseUp,
            onClick: this._onClick,
            "aria-label": resolvedAriaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-describedby": ariaDescribedBy,
            "aria-disabled": isPrimaryButtonDisabled,
            "data-is-focusable": dataIsFocusable
          }, // aria-pressed attribute should only be present for toggle buttons
          // aria-checked attribute should only be present for toggle buttons with checkbox type role
          _a2[isCheckboxTypeRole ? "aria-checked" : "aria-pressed"] = checkedOrPressedValue, _a2));
          if (ariaHidden) {
            buttonProps["aria-hidden"] = true;
          }
          if (this._isSplitButton) {
            return this._onRenderSplitButtonContent(tag, buttonProps);
          } else if (this.props.menuProps) {
            var _e = this.props.menuProps.id, id2 = _e === void 0 ? this._labelId + "-menu" : _e;
            assign$4(buttonProps, {
              "aria-expanded": !menuHidden,
              "aria-controls": !menuHidden ? id2 : null,
              "aria-haspopup": true
            });
          }
          return this._onRenderContent(tag, buttonProps);
        };
        BaseButton2.prototype.componentDidMount = function() {
          if (this._isSplitButton && this._splitButtonContainer.current) {
            if ("onpointerdown" in this._splitButtonContainer.current) {
              this._events.on(this._splitButtonContainer.current, "pointerdown", this._onPointerDown, true);
            }
            if ("onpointerup" in this._splitButtonContainer.current && this.props.onPointerUp) {
              this._events.on(this._splitButtonContainer.current, "pointerup", this.props.onPointerUp, true);
            }
          }
        };
        BaseButton2.prototype.componentDidUpdate = function(prevProps, prevState) {
          if (this.props.onAfterMenuDismiss && !prevState.menuHidden && this.state.menuHidden) {
            this.props.onAfterMenuDismiss();
          }
        };
        BaseButton2.prototype.componentWillUnmount = function() {
          this._async.dispose();
          this._events.dispose();
        };
        BaseButton2.prototype.focus = function() {
          if (this._isSplitButton && this._splitButtonContainer.current) {
            setFocusVisibility(true);
            this._splitButtonContainer.current.focus();
          } else if (this._buttonElement.current) {
            setFocusVisibility(true);
            this._buttonElement.current.focus();
          }
        };
        BaseButton2.prototype.dismissMenu = function() {
          this._dismissMenu();
        };
        BaseButton2.prototype.openMenu = function(shouldFocusOnContainer, shouldFocusOnMount) {
          this._openMenu(shouldFocusOnContainer, shouldFocusOnMount);
        };
        BaseButton2.prototype._onRenderContent = function(tag, buttonProps) {
          var _this = this;
          var props = this.props;
          var Tag = tag;
          var menuIconProps = props.menuIconProps, menuProps = props.menuProps, _a2 = props.onRenderIcon, onRenderIcon = _a2 === void 0 ? this._onRenderIcon : _a2, _b = props.onRenderAriaDescription, onRenderAriaDescription = _b === void 0 ? this._onRenderAriaDescription : _b, _c = props.onRenderChildren, onRenderChildren = _c === void 0 ? this._onRenderChildren : _c, _d = props.onRenderMenu, onRenderMenu = _d === void 0 ? this._onRenderMenu : _d, _e = props.onRenderMenuIcon, onRenderMenuIcon = _e === void 0 ? this._onRenderMenuIcon : _e, disabled = props.disabled;
          var keytipProps = props.keytipProps;
          if (keytipProps && menuProps) {
            keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
          }
          var Button2 = function(keytipAttributes) {
            return reactExports.createElement(
              Tag,
              __assign$1({}, buttonProps, keytipAttributes),
              reactExports.createElement(
                "span",
                { className: _this._classNames.flexContainer, "data-automationid": "splitbuttonprimary" },
                onRenderIcon(props, _this._onRenderIcon),
                _this._onRenderTextContents(),
                onRenderAriaDescription(props, _this._onRenderAriaDescription),
                onRenderChildren(props, _this._onRenderChildren),
                !_this._isSplitButton && (menuProps || menuIconProps || _this.props.onRenderMenuIcon) && onRenderMenuIcon(_this.props, _this._onRenderMenuIcon),
                menuProps && !menuProps.doNotLayer && _this._shouldRenderMenu() && onRenderMenu(_this._getMenuProps(menuProps), _this._onRenderMenu)
              )
            );
          };
          var Content = keytipProps ? (
            // If we're making a split button, we won't put the keytip here
            reactExports.createElement(KeytipData, { keytipProps: !this._isSplitButton ? keytipProps : void 0, ariaDescribedBy: buttonProps["aria-describedby"], disabled }, function(keytipAttributes) {
              return Button2(keytipAttributes);
            })
          ) : Button2();
          if (menuProps && menuProps.doNotLayer) {
            return reactExports.createElement(
              reactExports.Fragment,
              null,
              Content,
              this._shouldRenderMenu() && onRenderMenu(this._getMenuProps(menuProps), this._onRenderMenu)
            );
          }
          return reactExports.createElement(
            reactExports.Fragment,
            null,
            Content,
            reactExports.createElement(FocusRects, null)
          );
        };
        BaseButton2.prototype._shouldRenderMenu = function() {
          var menuHidden = this.state.menuHidden;
          var _a2 = this.props, persistMenu = _a2.persistMenu, renderPersistedMenuHiddenOnMount = _a2.renderPersistedMenuHiddenOnMount;
          if (!menuHidden) {
            return true;
          } else if (persistMenu && (this._renderedVisibleMenu || renderPersistedMenuHiddenOnMount)) {
            return true;
          }
          return false;
        };
        BaseButton2.prototype._hasText = function() {
          return this.props.text !== null && (this.props.text !== void 0 || typeof this.props.children === "string");
        };
        BaseButton2.prototype._getMenuProps = function(menuProps) {
          var persistMenu = this.props.persistMenu;
          var menuHidden = this.state.menuHidden;
          if (!menuProps.ariaLabel && !menuProps.labelElementId && this._hasText()) {
            menuProps = __assign$1(__assign$1({}, menuProps), { labelElementId: this._labelId });
          }
          return __assign$1(__assign$1({ id: this._labelId + "-menu", directionalHint: DirectionalHint.bottomLeftEdge }, menuProps), { shouldFocusOnContainer: this._menuShouldFocusOnContainer, shouldFocusOnMount: this._menuShouldFocusOnMount, hidden: persistMenu ? menuHidden : void 0, className: css$1("ms-BaseButton-menuhost", menuProps.className), target: this._isSplitButton ? this._splitButtonContainer.current : this._buttonElement.current, onDismiss: this._onDismissMenu });
        };
        BaseButton2.prototype._onRenderSplitButtonContent = function(tag, buttonProps) {
          var _this = this;
          var _a2 = this.props, _b = _a2.styles, styles2 = _b === void 0 ? {} : _b, disabled = _a2.disabled, allowDisabledFocus = _a2.allowDisabledFocus, checked = _a2.checked, getSplitButtonClassNames$1 = _a2.getSplitButtonClassNames, primaryDisabled = _a2.primaryDisabled, menuProps = _a2.menuProps, toggle = _a2.toggle, role = _a2.role, primaryActionButtonProps = _a2.primaryActionButtonProps;
          var keytipProps = this.props.keytipProps;
          var menuHidden = this.state.menuHidden;
          var classNames2 = getSplitButtonClassNames$1 ? getSplitButtonClassNames$1(!!disabled, !menuHidden, !!checked, !!allowDisabledFocus) : styles2 && getSplitButtonClassNames(styles2, !!disabled, !menuHidden, !!checked, !!primaryDisabled);
          assign$4(buttonProps, {
            onClick: void 0,
            onPointerDown: void 0,
            onPointerUp: void 0,
            tabIndex: -1,
            "data-is-focusable": false
          });
          if (keytipProps && menuProps) {
            keytipProps = this._getMemoizedMenuButtonKeytipProps(keytipProps);
          }
          var containerProps = getNativeProps$1(buttonProps, [], ["disabled"]);
          if (primaryActionButtonProps) {
            assign$4(buttonProps, primaryActionButtonProps);
          }
          var SplitButton = function(keytipAttributes) {
            return reactExports.createElement(
              "div",
              __assign$1({}, containerProps, { "data-ktp-target": keytipAttributes ? keytipAttributes["data-ktp-target"] : void 0, role: role ? role : "button", "aria-disabled": disabled, "aria-haspopup": true, "aria-expanded": !menuHidden, "aria-pressed": toggle ? !!checked : void 0, "aria-describedby": mergeAriaAttributeValues(buttonProps["aria-describedby"], keytipAttributes ? keytipAttributes["aria-describedby"] : void 0), className: classNames2 && classNames2.splitButtonContainer, onKeyDown: _this._onSplitButtonContainerKeyDown, onTouchStart: _this._onTouchStart, ref: _this._splitButtonContainer, "data-is-focusable": true, onClick: !disabled && !primaryDisabled ? _this._onSplitButtonPrimaryClick : void 0, tabIndex: !disabled && !primaryDisabled || allowDisabledFocus ? 0 : void 0, "aria-roledescription": buttonProps["aria-roledescription"], onFocusCapture: _this._onSplitContainerFocusCapture }),
              reactExports.createElement(
                "span",
                { style: { display: "flex" } },
                _this._onRenderContent(tag, buttonProps),
                _this._onRenderSplitButtonMenuButton(classNames2, keytipAttributes),
                _this._onRenderSplitButtonDivider(classNames2)
              )
            );
          };
          return keytipProps ? reactExports.createElement(KeytipData, { keytipProps, disabled }, function(keytipAttributes) {
            return SplitButton(keytipAttributes);
          }) : SplitButton();
        };
        BaseButton2.prototype._onRenderSplitButtonDivider = function(classNames2) {
          if (classNames2 && classNames2.divider) {
            var onClick = function(ev) {
              ev.stopPropagation();
            };
            return reactExports.createElement("span", { className: classNames2.divider, "aria-hidden": true, onClick });
          }
          return null;
        };
        BaseButton2.prototype._onRenderSplitButtonMenuButton = function(classNames2, keytipAttributes) {
          var _a2 = this.props, allowDisabledFocus = _a2.allowDisabledFocus, checked = _a2.checked, disabled = _a2.disabled, splitButtonMenuProps = _a2.splitButtonMenuProps, splitButtonAriaLabel = _a2.splitButtonAriaLabel, primaryDisabled = _a2.primaryDisabled;
          var menuHidden = this.state.menuHidden;
          var menuIconProps = this.props.menuIconProps;
          if (menuIconProps === void 0) {
            menuIconProps = {
              iconName: "ChevronDown"
            };
          }
          var splitButtonProps = __assign$1(__assign$1({}, splitButtonMenuProps), { styles: classNames2, checked, disabled, allowDisabledFocus, onClick: this._onMenuClick, menuProps: void 0, iconProps: __assign$1(__assign$1({}, menuIconProps), { className: this._classNames.menuIcon }), ariaLabel: splitButtonAriaLabel, "aria-haspopup": true, "aria-expanded": !menuHidden, "data-is-focusable": false });
          return reactExports.createElement(BaseButton2, __assign$1({}, splitButtonProps, { "data-ktp-execute-target": keytipAttributes ? keytipAttributes["data-ktp-execute-target"] : keytipAttributes, onMouseDown: this._onMouseDown, tabIndex: primaryDisabled && !allowDisabledFocus ? 0 : -1 }));
        };
        BaseButton2.prototype._onPointerDown = function(ev) {
          var onPointerDown = this.props.onPointerDown;
          if (onPointerDown) {
            onPointerDown(ev);
          }
          if (ev.pointerType === "touch") {
            this._handleTouchAndPointerEvent();
            ev.preventDefault();
            ev.stopImmediatePropagation();
          }
        };
        BaseButton2.prototype._handleTouchAndPointerEvent = function() {
          var _this = this;
          if (this._lastTouchTimeoutId !== void 0) {
            this._async.clearTimeout(this._lastTouchTimeoutId);
            this._lastTouchTimeoutId = void 0;
          }
          this._processingTouch = true;
          this._lastTouchTimeoutId = this._async.setTimeout(function() {
            _this._processingTouch = false;
            _this._lastTouchTimeoutId = void 0;
            _this.focus();
          }, TouchIdleDelay);
        };
        BaseButton2.prototype._isValidMenuOpenKey = function(ev) {
          if (this.props.menuTriggerKeyCode) {
            return ev.which === this.props.menuTriggerKeyCode;
          } else if (this.props.menuProps) {
            return ev.which === KeyCodes.down && (ev.altKey || ev.metaKey);
          }
          return false;
        };
        BaseButton2.defaultProps = {
          baseClassName: "ms-Button",
          styles: {},
          split: false
        };
        return BaseButton2;
      }(reactExports.Component)
    );
    var noOutline = {
      outline: 0
    };
    var iconStyle = function(fontSize) {
      return {
        fontSize,
        margin: "0 4px",
        height: "16px",
        lineHeight: "16px",
        textAlign: "center",
        flexShrink: 0
      };
    };
    var getStyles$2 = memoizeFunction(function(theme) {
      var _a2, _b;
      var semanticColors = theme.semanticColors, effects = theme.effects, fonts = theme.fonts;
      var border2 = semanticColors.buttonBorder;
      var disabledBackground = semanticColors.disabledBackground;
      var disabledText = semanticColors.disabledText;
      var buttonHighContrastFocus = {
        left: -2,
        top: -2,
        bottom: -2,
        right: -2,
        outlineColor: "ButtonText"
      };
      return {
        root: [
          getFocusStyle(theme, { inset: 1, highContrastStyle: buttonHighContrastFocus, borderColor: "transparent" }),
          theme.fonts.medium,
          {
            boxSizing: "border-box",
            border: "1px solid " + border2,
            userSelect: "none",
            display: "inline-block",
            textDecoration: "none",
            textAlign: "center",
            cursor: "pointer",
            padding: "0 16px",
            borderRadius: effects.roundedCorner2,
            selectors: {
              // IE11 workaround for preventing shift of child elements of a button when active.
              ":active > *": {
                position: "relative",
                left: 0,
                top: 0
              }
            }
          }
        ],
        rootDisabled: [
          getFocusStyle(theme, { inset: 1, highContrastStyle: buttonHighContrastFocus, borderColor: "transparent" }),
          {
            backgroundColor: disabledBackground,
            borderColor: disabledBackground,
            color: disabledText,
            cursor: "default",
            selectors: {
              ":hover": noOutline,
              ":focus": noOutline
            }
          }
        ],
        iconDisabled: {
          color: disabledText,
          selectors: (_a2 = {}, _a2[HighContrastSelector] = {
            color: "GrayText"
          }, _a2)
        },
        menuIconDisabled: {
          color: disabledText,
          selectors: (_b = {}, _b[HighContrastSelector] = {
            color: "GrayText"
          }, _b)
        },
        flexContainer: {
          display: "flex",
          height: "100%",
          flexWrap: "nowrap",
          justifyContent: "center",
          alignItems: "center"
        },
        description: {
          display: "block"
        },
        textContainer: {
          flexGrow: 1,
          display: "block"
        },
        icon: iconStyle(fonts.mediumPlus.fontSize),
        menuIcon: iconStyle(fonts.small.fontSize),
        label: {
          margin: "0 4px",
          lineHeight: "100%",
          display: "block"
        },
        screenReaderText: hiddenContentStyle
      };
    });
    var DEFAULT_BUTTON_HEIGHT = "40px";
    var DEFAULT_PADDING = "0 4px";
    var getStyles$1 = memoizeFunction(function(theme, customStyles) {
      var _a2, _b, _c;
      var baseButtonStyles = getStyles$2(theme);
      var actionButtonStyles = {
        root: {
          padding: DEFAULT_PADDING,
          height: DEFAULT_BUTTON_HEIGHT,
          color: theme.palette.neutralPrimary,
          backgroundColor: "transparent",
          border: "1px solid transparent",
          selectors: (_a2 = {}, _a2[HighContrastSelector] = {
            borderColor: "Window"
          }, _a2)
        },
        rootHovered: {
          color: theme.palette.themePrimary,
          selectors: (_b = {}, _b[HighContrastSelector] = {
            color: "Highlight"
          }, _b)
        },
        iconHovered: {
          color: theme.palette.themePrimary
        },
        rootPressed: {
          color: theme.palette.black
        },
        rootExpanded: {
          color: theme.palette.themePrimary
        },
        iconPressed: {
          color: theme.palette.themeDarker
        },
        rootDisabled: {
          color: theme.palette.neutralTertiary,
          backgroundColor: "transparent",
          borderColor: "transparent",
          selectors: (_c = {}, _c[HighContrastSelector] = {
            color: "GrayText"
          }, _c)
        },
        rootChecked: {
          color: theme.palette.black
        },
        iconChecked: {
          color: theme.palette.themeDarker
        },
        flexContainer: {
          justifyContent: "flex-start"
        },
        icon: {
          color: theme.palette.themeDarkAlt
        },
        iconDisabled: {
          color: "inherit"
        },
        menuIcon: {
          color: theme.palette.neutralSecondary
        },
        textContainer: {
          flexGrow: 0
        }
      };
      return concatStyleSets(baseButtonStyles, actionButtonStyles, customStyles);
    });
    var ActionButton = (
      /** @class */
      function(_super) {
        __extends(ActionButton2, _super);
        function ActionButton2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        ActionButton2.prototype.render = function() {
          var _a2 = this.props, styles2 = _a2.styles, theme = _a2.theme;
          return reactExports.createElement(BaseButton, __assign$1({}, this.props, { variantClassName: "ms-Button--action ms-Button--command", styles: getStyles$1(theme, styles2), onRenderDescription: nullRender }));
        };
        ActionButton2 = __decorate([
          customizable("ActionButton", ["theme", "styles"], true)
        ], ActionButton2);
        return ActionButton2;
      }(reactExports.Component)
    );
    function initializeIcons$j(baseUrl, options) {
      if (baseUrl === void 0) {
        baseUrl = "";
      }
      var subset = {
        style: {
          MozOsxFontSmoothing: "grayscale",
          WebkitFontSmoothing: "antialiased",
          fontStyle: "normal",
          fontWeight: "normal",
          speak: "none"
        },
        fontFace: {
          fontFamily: '"FabricMDL2Icons"',
          src: "url('" + baseUrl + "fabric-icons-a13498cf.woff') format('woff')"
        },
        icons: {
          GlobalNavButton: "",
          ChevronDown: "",
          ChevronUp: "",
          Edit: "",
          Add: "",
          Cancel: "",
          More: "",
          Settings: "",
          Mail: "",
          Filter: "",
          Search: "",
          Share: "",
          BlockedSite: "",
          FavoriteStar: "",
          FavoriteStarFill: "",
          CheckMark: "",
          Delete: "",
          ChevronLeft: "",
          ChevronRight: "",
          Calendar: "",
          Megaphone: "",
          Undo: "",
          Flag: "",
          Page: "",
          Pinned: "",
          View: "",
          Clear: "",
          Download: "",
          Upload: "",
          Folder: "",
          Sort: "",
          AlignRight: "",
          AlignLeft: "",
          Tag: "",
          AddFriend: "",
          Info: "",
          SortLines: "",
          List: "",
          CircleRing: "",
          Heart: "",
          HeartFill: "",
          Tiles: "",
          Embed: "",
          Glimmer: "",
          Ascending: "",
          Descending: "",
          SortUp: "",
          SortDown: "",
          SyncToPC: "",
          LargeGrid: "",
          SkypeCheck: "",
          SkypeClock: "",
          SkypeMinus: "",
          ClearFilter: "",
          Flow: "",
          StatusCircleCheckmark: "",
          MoreVertical: ""
        }
      };
      registerIcons(subset, options);
    }
    function initializeIcons$i(baseUrl, options) {
      if (baseUrl === void 0) {
        baseUrl = "";
      }
      var subset = {
        style: {
          MozOsxFontSmoothing: "grayscale",
          WebkitFontSmoothing: "antialiased",
          fontStyle: "normal",
          fontWeight: "normal",
          speak: "none"
        },
        fontFace: {
          fontFamily: '"FabricMDL2Icons-0"',
          src: "url('" + baseUrl + "fabric-icons-0-467ee27f.woff') format('woff')"
        },
        icons: {
          "PageLink": "",
          "CommentSolid": "",
          "ChangeEntitlements": "",
          "Installation": "",
          "WebAppBuilderModule": "",
          "WebAppBuilderFragment": "",
          "WebAppBuilderSlot": "",
          "BullseyeTargetEdit": "",
          "WebAppBuilderFragmentCreate": "",
          "PageData": "",
          "PageHeaderEdit": "",
          "ProductList": "",
          "UnpublishContent": "",
          "DependencyAdd": "",
          "DependencyRemove": "",
          "EntitlementPolicy": "",
          "EntitlementRedemption": "",
          "SchoolDataSyncLogo": "",
          "PinSolid12": "",
          "PinSolidOff12": "",
          "AddLink": "",
          "SharepointAppIcon16": "",
          "DataflowsLink": "",
          "TimePicker": "",
          "UserWarning": "",
          "ComplianceAudit": "",
          "InternetSharing": "",
          "Brightness": "",
          "MapPin": "",
          "Airplane": "",
          "Tablet": "",
          "QuickNote": "",
          "Video": "",
          "People": "",
          "Phone": "",
          "Pin": "",
          "Shop": "",
          "Stop": "",
          "Link": "",
          "AllApps": "",
          "Zoom": "",
          "ZoomOut": "",
          "Microphone": "",
          "Camera": "",
          "Attach": "",
          "Send": "",
          "FavoriteList": "",
          "PageSolid": "",
          "Forward": "",
          "Back": "",
          "Refresh": "",
          "Lock": "",
          "ReportHacked": "",
          "EMI": "",
          "MiniLink": "",
          "Blocked": "",
          "ReadingMode": "",
          "Favicon": "",
          "Remove": "",
          "Checkbox": "",
          "CheckboxComposite": "",
          "CheckboxFill": "",
          "CheckboxIndeterminate": "",
          "CheckboxCompositeReversed": "",
          "BackToWindow": "",
          "FullScreen": "",
          "Print": "",
          "Up": "",
          "Down": "",
          "OEM": "",
          "Save": "",
          "ReturnKey": "",
          "Cloud": "",
          "Flashlight": "",
          "CommandPrompt": "",
          "Sad": "",
          "RealEstate": "",
          "SIPMove": "",
          "EraseTool": "",
          "GripperTool": "",
          "Dialpad": "",
          "PageLeft": "",
          "PageRight": "",
          "MultiSelect": "",
          "KeyboardClassic": "",
          "Play": "",
          "Pause": "",
          "InkingTool": "",
          "Emoji2": "",
          "GripperBarHorizontal": "",
          "System": "",
          "Personalize": "",
          "SearchAndApps": "",
          "Globe": "",
          "EaseOfAccess": "",
          "ContactInfo": "",
          "Unpin": "",
          "Contact": "",
          "Memo": "",
          "IncomingCall": ""
        }
      };
      registerIcons(subset, options);
    }
    function initializeIcons$h(baseUrl, options) {
      if (baseUrl === void 0) {
        baseUrl = "";
      }
      var subset = {
        style: {
          MozOsxFontSmoothing: "grayscale",
          WebkitFontSmoothing: "antialiased",
          fontStyle: "normal",
          fontWeight: "normal",
          speak: "none"
        },
        fontFace: {
          fontFamily: '"FabricMDL2Icons-1"',
          src: "url('" + baseUrl + "fabric-icons-1-4d521695.woff') format('woff')"
        },
        icons: {
          "Paste": "",
          "WindowsLogo": "",
          "Error": "",
          "GripperBarVertical": "",
          "Unlock": "",
          "Slideshow": "",
          "Trim": "",
          "AutoEnhanceOn": "",
          "AutoEnhanceOff": "",
          "Color": "",
          "SaveAs": "",
          "Light": "",
          "Filters": "",
          "AspectRatio": "",
          "Contrast": "",
          "Redo": "",
          "Crop": "",
          "PhotoCollection": "",
          "Album": "",
          "Rotate": "",
          "PanoIndicator": "",
          "Translate": "",
          "RedEye": "",
          "ViewOriginal": "",
          "ThumbnailView": "",
          "Package": "",
          "Telemarketer": "",
          "Warning": "",
          "Financial": "",
          "Education": "",
          "ShoppingCart": "",
          "Train": "",
          "Move": "",
          "TouchPointer": "",
          "Merge": "",
          "TurnRight": "",
          "Ferry": "",
          "Highlight": "",
          "PowerButton": "",
          "Tab": "",
          "Admin": "",
          "TVMonitor": "",
          "Speakers": "",
          "Game": "",
          "HorizontalTabKey": "",
          "UnstackSelected": "",
          "StackIndicator": "",
          "Nav2DMapView": "",
          "StreetsideSplitMinimize": "",
          "Car": "",
          "Bus": "",
          "EatDrink": "",
          "SeeDo": "",
          "LocationCircle": "",
          "Home": "",
          "SwitcherStartEnd": "",
          "ParkingLocation": "",
          "IncidentTriangle": "",
          "Touch": "",
          "MapDirections": "",
          "CaretHollow": "",
          "CaretSolid": "",
          "History": "",
          "Location": "",
          "MapLayers": "",
          "SearchNearby": "",
          "Work": "",
          "Recent": "",
          "Hotel": "",
          "Bank": "",
          "LocationDot": "",
          "Dictionary": "",
          "ChromeBack": "",
          "FolderOpen": "",
          "PinnedFill": "",
          "RevToggleKey": "",
          "USB": "",
          "Previous": "",
          "Next": "",
          "Sync": "",
          "Help": "",
          "Emoji": "",
          "MailForward": "",
          "ClosePane": "",
          "OpenPane": "",
          "PreviewLink": "",
          "ZoomIn": "",
          "Bookmarks": "",
          "Document": "",
          "ProtectedDocument": "",
          "OpenInNewWindow": "",
          "MailFill": "",
          "ViewAll": "",
          "Switch": "",
          "Rename": "",
          "Go": "",
          "Remote": "",
          "SelectAll": "",
          "Orientation": "",
          "Import": ""
        }
      };
      registerIcons(subset, options);
    }
    function initializeIcons$g(baseUrl, options) {
      if (baseUrl === void 0) {
        baseUrl = "";
      }
      var subset = {
        style: {
          MozOsxFontSmoothing: "grayscale",
          WebkitFontSmoothing: "antialiased",
          fontStyle: "normal",
          fontWeight: "normal",
          speak: "none"
        },
        fontFace: {
          fontFamily: '"FabricMDL2Icons-2"',
          src: "url('" + baseUrl + "fabric-icons-2-63c99abf.woff') format('woff')"
        },
        icons: {
          "Picture": "",
          "ChromeClose": "",
          "ShowResults": "",
          "Message": "",
          "CalendarDay": "",
          "CalendarWeek": "",
          "MailReplyAll": "",
          "Read": "",
          "Cut": "",
          "PaymentCard": "",
          "Copy": "",
          "Important": "",
          "MailReply": "",
          "GotoToday": "",
          "Font": "",
          "FontColor": "",
          "FolderFill": "",
          "Permissions": "",
          "DisableUpdates": "",
          "Unfavorite": "",
          "Italic": "",
          "Underline": "",
          "Bold": "",
          "MoveToFolder": "",
          "Dislike": "",
          "Like": "",
          "AlignCenter": "",
          "OpenFile": "",
          "ClearSelection": "",
          "FontDecrease": "",
          "FontIncrease": "",
          "FontSize": "",
          "CellPhone": "",
          "RepeatOne": "",
          "RepeatAll": "",
          "Calculator": "",
          "Library": "",
          "PostUpdate": "",
          "NewFolder": "",
          "CalendarReply": "",
          "UnsyncFolder": "",
          "SyncFolder": "",
          "BlockContact": "",
          "Accept": "",
          "BulletedList": "",
          "Preview": "",
          "News": "",
          "Chat": "",
          "Group": "",
          "World": "",
          "Comment": "",
          "DockLeft": "",
          "DockRight": "",
          "Repair": "",
          "Accounts": "",
          "Street": "",
          "RadioBullet": "",
          "Stopwatch": "",
          "Clock": "",
          "WorldClock": "",
          "AlarmClock": "",
          "Photo": "",
          "ActionCenter": "",
          "Hospital": "",
          "Timer": "",
          "FullCircleMask": "",
          "LocationFill": "",
          "ChromeMinimize": "",
          "ChromeRestore": "",
          "Annotation": "",
          "Fingerprint": "",
          "Handwriting": "",
          "ChromeFullScreen": "",
          "Completed": "",
          "Label": "",
          "FlickDown": "",
          "FlickUp": "",
          "FlickLeft": "",
          "FlickRight": "",
          "MiniExpand": "",
          "MiniContract": "",
          "Streaming": "",
          "MusicInCollection": "",
          "OneDriveLogo": "",
          "CompassNW": "",
          "Code": "",
          "LightningBolt": "",
          "CalculatorMultiply": "",
          "CalculatorAddition": "",
          "CalculatorSubtract": "",
          "CalculatorPercentage": "",
          "CalculatorEqualTo": "",
          "PrintfaxPrinterFile": "",
          "StorageOptical": "",
          "Communications": "",
          "Headset": "",
          "Health": "",
          "Webcam2": "",
          "FrontCamera": "",
          "ChevronUpSmall": ""
        }
      };
      registerIcons(subset, options);
    }
    function initializeIcons$f(baseUrl, options) {
      if (baseUrl === void 0) {
        baseUrl = "";
      }
      var subset = {
        style: {
          MozOsxFontSmoothing: "grayscale",
          WebkitFontSmoothing: "antialiased",
          fontStyle: "normal",
          fontWeight: "normal",
          speak: "none"
        },
        fontFace: {
          fontFamily: '"FabricMDL2Icons-3"',
          src: "url('" + baseUrl + "fabric-icons-3-089e217a.woff') format('woff')"
        },
        icons: {
          "ChevronDownSmall": "",
          "ChevronLeftSmall": "",
          "ChevronRightSmall": "",
          "ChevronUpMed": "",
          "ChevronDownMed": "",
          "ChevronLeftMed": "",
          "ChevronRightMed": "",
          "Devices2": "",
          "PC1": "",
          "PresenceChickletVideo": "",
          "Reply": "",
          "HalfAlpha": "",
          "ConstructionCone": "",
          "DoubleChevronLeftMed": "",
          "Volume0": "",
          "Volume1": "",
          "Volume2": "",
          "Volume3": "",
          "Chart": "",
          "Robot": "",
          "Manufacturing": "",
          "LockSolid": "",
          "FitPage": "",
          "FitWidth": "",
          "BidiLtr": "",
          "BidiRtl": "",
          "RightDoubleQuote": "",
          "Sunny": "",
          "CloudWeather": "",
          "Cloudy": "",
          "PartlyCloudyDay": "",
          "PartlyCloudyNight": "",
          "ClearNight": "",
          "RainShowersDay": "",
          "Rain": "",
          "Thunderstorms": "",
          "RainSnow": "",
          "Snow": "",
          "BlowingSnow": "",
          "Frigid": "",
          "Fog": "",
          "Squalls": "",
          "Duststorm": "",
          "Unknown": "",
          "Precipitation": "",
          "Ribbon": "",
          "AreaChart": "",
          "Assign": "",
          "FlowChart": "",
          "CheckList": "",
          "Diagnostic": "",
          "Generate": "",
          "LineChart": "",
          "Equalizer": "",
          "BarChartHorizontal": "",
          "BarChartVertical": "",
          "Freezing": "",
          "FunnelChart": "",
          "Processing": "",
          "Quantity": "",
          "ReportDocument": "",
          "StackColumnChart": "",
          "SnowShowerDay": "",
          "HailDay": "",
          "WorkFlow": "",
          "HourGlass": "",
          "StoreLogoMed20": "",
          "TimeSheet": "",
          "TriangleSolid": "",
          "UpgradeAnalysis": "",
          "VideoSolid": "",
          "RainShowersNight": "",
          "SnowShowerNight": "",
          "Teamwork": "",
          "HailNight": "",
          "PeopleAdd": "",
          "Glasses": "",
          "DateTime2": "",
          "Shield": "",
          "Header1": "",
          "PageAdd": "",
          "NumberedList": "",
          "PowerBILogo": "",
          "Info2": "",
          "MusicInCollectionFill": "",
          "Asterisk": "",
          "ErrorBadge": "",
          "CircleFill": "",
          "Record2": "",
          "AllAppsMirrored": "",
          "BookmarksMirrored": "",
          "BulletedListMirrored": "",
          "CaretHollowMirrored": "",
          "CaretSolidMirrored": "",
          "ChromeBackMirrored": "",
          "ClearSelectionMirrored": "",
          "ClosePaneMirrored": "",
          "DockLeftMirrored": "",
          "DoubleChevronLeftMedMirrored": "",
          "GoMirrored": ""
        }
      };
      registerIcons(subset, options);
    }
    function initializeIcons$e(baseUrl, options) {
      if (baseUrl === void 0) {
        baseUrl = "";
      }
      var subset = {
        style: {
          MozOsxFontSmoothing: "grayscale",
          WebkitFontSmoothing: "antialiased",
          fontStyle: "normal",
          fontWeight: "normal",
          speak: "none"
        },
        fontFace: {
          fontFamily: '"FabricMDL2Icons-4"',
          src: "url('" + baseUrl + "fabric-icons-4-a656cc0a.woff') format('woff')"
        },
        icons: {
          "HelpMirrored": "",
          "ImportMirrored": "",
          "ImportAllMirrored": "",
          "ListMirrored": "",
          "MailForwardMirrored": "",
          "MailReplyMirrored": "",
          "MailReplyAllMirrored": "",
          "MiniContractMirrored": "",
          "MiniExpandMirrored": "",
          "OpenPaneMirrored": "",
          "ParkingLocationMirrored": "",
          "SendMirrored": "",
          "ShowResultsMirrored": "",
          "ThumbnailViewMirrored": "",
          "Media": "",
          "Devices3": "",
          "Focus": "",
          "VideoLightOff": "",
          "Lightbulb": "",
          "StatusTriangle": "",
          "VolumeDisabled": "",
          "Puzzle": "",
          "EmojiNeutral": "",
          "EmojiDisappointed": "",
          "HomeSolid": "",
          "Ringer": "",
          "PDF": "",
          "HeartBroken": "",
          "StoreLogo16": "",
          "MultiSelectMirrored": "",
          "Broom": "",
          "AddToShoppingList": "",
          "Cocktails": "",
          "Wines": "",
          "Articles": "",
          "Cycling": "",
          "DietPlanNotebook": "",
          "Pill": "",
          "ExerciseTracker": "",
          "HandsFree": "",
          "Medical": "",
          "Running": "",
          "Weights": "",
          "Trackers": "",
          "AddNotes": "",
          "AllCurrency": "",
          "BarChart4": "",
          "CirclePlus": "",
          "Coffee": "",
          "Cotton": "",
          "Market": "",
          "Money": "",
          "PieDouble": "",
          "PieSingle": "",
          "RemoveFilter": "",
          "Savings": "",
          "Sell": "",
          "StockDown": "",
          "StockUp": "",
          "Lamp": "",
          "Source": "",
          "MSNVideos": "",
          "Cricket": "",
          "Golf": "",
          "Baseball": "",
          "Soccer": "",
          "MoreSports": "",
          "AutoRacing": "",
          "CollegeHoops": "",
          "CollegeFootball": "",
          "ProFootball": "",
          "ProHockey": "",
          "Rugby": "",
          "SubstitutionsIn": "",
          "Tennis": "",
          "Arrivals": "",
          "Design": "",
          "Website": "",
          "Drop": "",
          "HistoricalWeather": "",
          "SkiResorts": "",
          "Snowflake": "",
          "BusSolid": "",
          "FerrySolid": "",
          "AirplaneSolid": "",
          "TrainSolid": "",
          "Ticket": "",
          "WifiWarning4": "",
          "Devices4": "",
          "AzureLogo": "",
          "BingLogo": "",
          "MSNLogo": "",
          "OutlookLogoInverse": "",
          "OfficeLogo": "",
          "SkypeLogo": "",
          "Door": "",
          "EditMirrored": "",
          "GiftCard": "",
          "DoubleBookmark": "",
          "StatusErrorFull": ""
        }
      };
      registerIcons(subset, options);
    }
    function initializeIcons$d(baseUrl, options) {
      if (baseUrl === void 0) {
        baseUrl = "";
      }
      var subset = {
        style: {
          MozOsxFontSmoothing: "grayscale",
          WebkitFontSmoothing: "antialiased",
          fontStyle: "normal",
          fontWeight: "normal",
          speak: "none"
        },
        fontFace: {
          fontFamily: '"FabricMDL2Icons-5"',
          src: "url('" + baseUrl + "fabric-icons-5-f95ba260.woff') format('woff')"
        },
        icons: {
          "Certificate": "",
          "FastForward": "",
          "Rewind": "",
          "Photo2": "",
          "OpenSource": "",
          "Movers": "",
          "CloudDownload": "",
          "Family": "",
          "WindDirection": "",
          "Bug": "",
          "SiteScan": "",
          "BrowserScreenShot": "",
          "F12DevTools": "",
          "CSS": "",
          "JS": "",
          "DeliveryTruck": "",
          "ReminderPerson": "",
          "ReminderGroup": "",
          "ReminderTime": "",
          "TabletMode": "",
          "Umbrella": "",
          "NetworkTower": "",
          "CityNext": "",
          "CityNext2": "",
          "Section": "",
          "OneNoteLogoInverse": "",
          "ToggleFilled": "",
          "ToggleBorder": "",
          "SliderThumb": "",
          "ToggleThumb": "",
          "Documentation": "",
          "Badge": "",
          "Giftbox": "",
          "VisualStudioLogo": "",
          "HomeGroup": "",
          "ExcelLogoInverse": "",
          "WordLogoInverse": "",
          "PowerPointLogoInverse": "",
          "Cafe": "",
          "SpeedHigh": "",
          "Commitments": "",
          "ThisPC": "",
          "MusicNote": "",
          "MicOff": "",
          "PlaybackRate1x": "",
          "EdgeLogo": "",
          "CompletedSolid": "",
          "AlbumRemove": "",
          "MessageFill": "",
          "TabletSelected": "",
          "MobileSelected": "",
          "LaptopSelected": "",
          "TVMonitorSelected": "",
          "DeveloperTools": "",
          "Shapes": "",
          "InsertTextBox": "",
          "LowerBrightness": "",
          "WebComponents": "",
          "OfflineStorage": "",
          "DOM": "",
          "CloudUpload": "",
          "ScrollUpDown": "",
          "DateTime": "",
          "Event": "",
          "Cake": "",
          "Org": "",
          "PartyLeader": "",
          "DRM": "",
          "CloudAdd": "",
          "AppIconDefault": "",
          "Photo2Add": "",
          "Photo2Remove": "",
          "Calories": "",
          "POI": "",
          "AddTo": "",
          "RadioBtnOff": "",
          "RadioBtnOn": "",
          "ExploreContent": "",
          "Product": "",
          "ProgressLoopInner": "",
          "ProgressLoopOuter": "",
          "Blocked2": "",
          "FangBody": "",
          "Toolbox": "",
          "PageHeader": "",
          "ChatInviteFriend": "",
          "Brush": "",
          "Shirt": "",
          "Crown": "",
          "Diamond": "",
          "ScaleUp": "",
          "QRCode": "",
          "Feedback": "",
          "SharepointLogoInverse": "",
          "YammerLogo": "",
          "Hide": "",
          "Uneditable": "",
          "ReturnToSession": "",
          "OpenFolderHorizontal": "",
          "CalendarMirrored": ""
        }
      };
      registerIcons(subset, options);
    }
    function initializeIcons$c(baseUrl, options) {
      if (baseUrl === void 0) {
        baseUrl = "";
      }
      var subset = {
        style: {
          MozOsxFontSmoothing: "grayscale",
          WebkitFontSmoothing: "antialiased",
          fontStyle: "normal",
          fontWeight: "normal",
          speak: "none"
        },
        fontFace: {
          fontFamily: '"FabricMDL2Icons-6"',
          src: "url('" + baseUrl + "fabric-icons-6-ef6fd590.woff') format('woff')"
        },
        icons: {
          "SwayLogoInverse": "",
          "OutOfOffice": "",
          "Trophy": "",
          "ReopenPages": "",
          "EmojiTabSymbols": "",
          "AADLogo": "",
          "AccessLogo": "",
          "AdminALogoInverse32": "",
          "AdminCLogoInverse32": "",
          "AdminDLogoInverse32": "",
          "AdminELogoInverse32": "",
          "AdminLLogoInverse32": "",
          "AdminMLogoInverse32": "",
          "AdminOLogoInverse32": "",
          "AdminPLogoInverse32": "",
          "AdminSLogoInverse32": "",
          "AdminYLogoInverse32": "",
          "DelveLogoInverse": "",
          "ExchangeLogoInverse": "",
          "LyncLogo": "",
          "OfficeVideoLogoInverse": "",
          "SocialListeningLogo": "",
          "VisioLogoInverse": "",
          "Balloons": "",
          "Cat": "",
          "MailAlert": "",
          "MailCheck": "",
          "MailLowImportance": "",
          "MailPause": "",
          "MailRepeat": "",
          "SecurityGroup": "",
          "Table": "",
          "VoicemailForward": "",
          "VoicemailReply": "",
          "Waffle": "",
          "RemoveEvent": "",
          "EventInfo": "",
          "ForwardEvent": "",
          "WipePhone": "",
          "AddOnlineMeeting": "",
          "JoinOnlineMeeting": "",
          "RemoveLink": "",
          "PeopleBlock": "",
          "PeopleRepeat": "",
          "PeopleAlert": "",
          "PeoplePause": "",
          "TransferCall": "",
          "AddPhone": "",
          "UnknownCall": "",
          "NoteReply": "",
          "NoteForward": "",
          "NotePinned": "",
          "RemoveOccurrence": "",
          "Timeline": "",
          "EditNote": "",
          "CircleHalfFull": "",
          "Room": "",
          "Unsubscribe": "",
          "Subscribe": "",
          "HardDrive": "",
          "RecurringTask": "",
          "TaskManager": "",
          "TaskManagerMirrored": "",
          "Combine": "",
          "Split": "",
          "DoubleChevronUp": "",
          "DoubleChevronLeft": "",
          "DoubleChevronRight": "",
          "TextBox": "",
          "TextField": "",
          "NumberField": "",
          "Dropdown": "",
          "PenWorkspace": "",
          "BookingsLogo": "",
          "ClassNotebookLogoInverse": "",
          "DelveAnalyticsLogo": "",
          "DocsLogoInverse": "",
          "Dynamics365Logo": "",
          "DynamicSMBLogo": "",
          "OfficeAssistantLogo": "",
          "OfficeStoreLogo": "",
          "OneNoteEduLogoInverse": "",
          "PlannerLogo": "",
          "PowerApps": "",
          "Suitcase": "",
          "ProjectLogoInverse": "",
          "CaretLeft8": "",
          "CaretRight8": "",
          "CaretUp8": "",
          "CaretDown8": "",
          "CaretLeftSolid8": "",
          "CaretRightSolid8": "",
          "CaretUpSolid8": "",
          "CaretDownSolid8": "",
          "ClearFormatting": "",
          "Superscript": "",
          "Subscript": "",
          "Strikethrough": "",
          "Export": "",
          "ExportMirrored": ""
        }
      };
      registerIcons(subset, options);
    }
    function initializeIcons$b(baseUrl, options) {
      if (baseUrl === void 0) {
        baseUrl = "";
      }
      var subset = {
        style: {
          MozOsxFontSmoothing: "grayscale",
          WebkitFontSmoothing: "antialiased",
          fontStyle: "normal",
          fontWeight: "normal",
          speak: "none"
        },
        fontFace: {
          fontFamily: '"FabricMDL2Icons-7"',
          src: "url('" + baseUrl + "fabric-icons-7-2b97bb99.woff') format('woff')"
        },
        icons: {
          "SingleBookmark": "",
          "SingleBookmarkSolid": "",
          "DoubleChevronDown": "",
          "FollowUser": "",
          "ReplyAll": "",
          "WorkforceManagement": "",
          "RecruitmentManagement": "",
          "Questionnaire": "",
          "ManagerSelfService": "",
          "ProductionFloorManagement": "",
          "ProductRelease": "",
          "ProductVariant": "",
          "ReplyMirrored": "",
          "ReplyAllMirrored": "",
          "Medal": "",
          "AddGroup": "",
          "QuestionnaireMirrored": "",
          "CloudImportExport": "",
          "TemporaryUser": "",
          "CaretSolid16": "",
          "GroupedDescending": "",
          "GroupedAscending": "",
          "AwayStatus": "",
          "MyMoviesTV": "",
          "GenericScan": "",
          "AustralianRules": "",
          "WifiEthernet": "",
          "TrackersMirrored": "",
          "DateTimeMirrored": "",
          "StopSolid": "",
          "DoubleChevronUp12": "",
          "DoubleChevronDown12": "",
          "DoubleChevronLeft12": "",
          "DoubleChevronRight12": "",
          "CalendarAgenda": "",
          "ConnectVirtualMachine": "",
          "AddEvent": "",
          "AssetLibrary": "",
          "DataConnectionLibrary": "",
          "DocLibrary": "",
          "FormLibrary": "",
          "FormLibraryMirrored": "",
          "ReportLibrary": "",
          "ReportLibraryMirrored": "",
          "ContactCard": "",
          "CustomList": "",
          "CustomListMirrored": "",
          "IssueTracking": "",
          "IssueTrackingMirrored": "",
          "PictureLibrary": "",
          "OfficeAddinsLogo": "",
          "OfflineOneDriveParachute": "",
          "OfflineOneDriveParachuteDisabled": "",
          "TriangleSolidUp12": "",
          "TriangleSolidDown12": "",
          "TriangleSolidLeft12": "",
          "TriangleSolidRight12": "",
          "TriangleUp12": "",
          "TriangleDown12": "",
          "TriangleLeft12": "",
          "TriangleRight12": "",
          "ArrowUpRight8": "",
          "ArrowDownRight8": "",
          "DocumentSet": "",
          "GoToDashboard": "",
          "DelveAnalytics": "",
          "ArrowUpRightMirrored8": "",
          "ArrowDownRightMirrored8": "",
          "CompanyDirectory": "",
          "OpenEnrollment": "",
          "CompanyDirectoryMirrored": "",
          "OneDriveAdd": "",
          "ProfileSearch": "",
          "Header2": "",
          "Header3": "",
          "Header4": "",
          "RingerSolid": "",
          "Eyedropper": "",
          "MarketDown": "",
          "CalendarWorkWeek": "",
          "SidePanel": "",
          "GlobeFavorite": "",
          "CaretTopLeftSolid8": "",
          "CaretTopRightSolid8": "",
          "ViewAll2": "",
          "DocumentReply": "",
          "PlayerSettings": "",
          "ReceiptForward": "",
          "ReceiptReply": "",
          "ReceiptCheck": "",
          "Fax": "",
          "RecurringEvent": "",
          "ReplyAlt": "",
          "ReplyAllAlt": "",
          "EditStyle": "",
          "EditMail": "",
          "Lifesaver": "",
          "LifesaverLock": "",
          "InboxCheck": "",
          "FolderSearch": ""
        }
      };
      registerIcons(subset, options);
    }
    function initializeIcons$a(baseUrl, options) {
      if (baseUrl === void 0) {
        baseUrl = "";
      }
      var subset = {
        style: {
          MozOsxFontSmoothing: "grayscale",
          WebkitFontSmoothing: "antialiased",
          fontStyle: "normal",
          fontWeight: "normal",
          speak: "none"
        },
        fontFace: {
          fontFamily: '"FabricMDL2Icons-8"',
          src: "url('" + baseUrl + "fabric-icons-8-6fdf1528.woff') format('woff')"
        },
        icons: {
          "CollapseMenu": "",
          "ExpandMenu": "",
          "Boards": "",
          "SunAdd": "",
          "SunQuestionMark": "",
          "LandscapeOrientation": "",
          "DocumentSearch": "",
          "PublicCalendar": "",
          "PublicContactCard": "",
          "PublicEmail": "",
          "PublicFolder": "",
          "WordDocument": "",
          "PowerPointDocument": "",
          "ExcelDocument": "",
          "GroupedList": "",
          "ClassroomLogo": "",
          "Sections": "",
          "EditPhoto": "",
          "Starburst": "",
          "ShareiOS": "",
          "AirTickets": "",
          "PencilReply": "",
          "Tiles2": "",
          "SkypeCircleCheck": "",
          "SkypeCircleClock": "",
          "SkypeCircleMinus": "",
          "SkypeMessage": "",
          "ClosedCaption": "",
          "ATPLogo": "",
          "OfficeFormsLogoInverse": "",
          "RecycleBin": "",
          "EmptyRecycleBin": "",
          "Hide2": "",
          "Breadcrumb": "",
          "BirthdayCake": "",
          "TimeEntry": "",
          "CRMProcesses": "",
          "PageEdit": "",
          "PageArrowRight": "",
          "PageRemove": "",
          "Database": "",
          "DataManagementSettings": "",
          "CRMServices": "",
          "EditContact": "",
          "ConnectContacts": "",
          "AppIconDefaultAdd": "",
          "AppIconDefaultList": "",
          "ActivateOrders": "",
          "DeactivateOrders": "",
          "ProductCatalog": "",
          "ScatterChart": "",
          "AccountActivity": "",
          "DocumentManagement": "",
          "CRMReport": "",
          "KnowledgeArticle": "",
          "Relationship": "",
          "HomeVerify": "",
          "ZipFolder": "",
          "SurveyQuestions": "",
          "TextDocument": "",
          "TextDocumentShared": "",
          "PageCheckedOut": "",
          "PageShared": "",
          "SaveAndClose": "",
          "Script": "",
          "Archive": "",
          "ActivityFeed": "",
          "Compare": "",
          "EventDate": "",
          "ArrowUpRight": "",
          "CaretRight": "",
          "SetAction": "",
          "ChatBot": "",
          "CaretSolidLeft": "",
          "CaretSolidDown": "",
          "CaretSolidRight": "",
          "CaretSolidUp": "",
          "PowerAppsLogo": "",
          "PowerApps2Logo": "",
          "SearchIssue": "",
          "SearchIssueMirrored": "",
          "FabricAssetLibrary": "",
          "FabricDataConnectionLibrary": "",
          "FabricDocLibrary": "",
          "FabricFormLibrary": "",
          "FabricFormLibraryMirrored": "",
          "FabricReportLibrary": "",
          "FabricReportLibraryMirrored": "",
          "FabricPublicFolder": "",
          "FabricFolderSearch": "",
          "FabricMovetoFolder": "",
          "FabricUnsyncFolder": "",
          "FabricSyncFolder": "",
          "FabricOpenFolderHorizontal": "",
          "FabricFolder": "",
          "FabricFolderFill": "",
          "FabricNewFolder": "",
          "FabricPictureLibrary": "",
          "PhotoVideoMedia": "",
          "AddFavorite": ""
        }
      };
      registerIcons(subset, options);
    }
    function initializeIcons$9(baseUrl, options) {
      if (baseUrl === void 0) {
        baseUrl = "";
      }
      var subset = {
        style: {
          MozOsxFontSmoothing: "grayscale",
          WebkitFontSmoothing: "antialiased",
          fontStyle: "normal",
          fontWeight: "normal",
          speak: "none"
        },
        fontFace: {
          fontFamily: '"FabricMDL2Icons-9"',
          src: "url('" + baseUrl + "fabric-icons-9-c6162b42.woff') format('woff')"
        },
        icons: {
          "AddFavoriteFill": "",
          "BufferTimeBefore": "",
          "BufferTimeAfter": "",
          "BufferTimeBoth": "",
          "PublishContent": "",
          "ClipboardList": "",
          "ClipboardListMirrored": "",
          "CannedChat": "",
          "SkypeForBusinessLogo": "",
          "TabCenter": "",
          "PageCheckedin": "",
          "PageList": "",
          "ReadOutLoud": "",
          "CaretBottomLeftSolid8": "",
          "CaretBottomRightSolid8": "",
          "FolderHorizontal": "",
          "MicrosoftStaffhubLogo": "",
          "GiftboxOpen": "",
          "StatusCircleOuter": "",
          "StatusCircleInner": "",
          "StatusCircleRing": "",
          "StatusTriangleOuter": "",
          "StatusTriangleInner": "",
          "StatusTriangleExclamation": "",
          "StatusCircleExclamation": "",
          "StatusCircleErrorX": "",
          "StatusCircleInfo": "",
          "StatusCircleBlock": "",
          "StatusCircleBlock2": "",
          "StatusCircleQuestionMark": "",
          "StatusCircleSync": "",
          "Toll": "",
          "ExploreContentSingle": "",
          "CollapseContent": "",
          "CollapseContentSingle": "",
          "InfoSolid": "",
          "GroupList": "",
          "ProgressRingDots": "",
          "CaloriesAdd": "",
          "BranchFork": "",
          "MuteChat": "",
          "AddHome": "",
          "AddWork": "",
          "MobileReport": "",
          "ScaleVolume": "",
          "HardDriveGroup": "",
          "FastMode": "",
          "ToggleLeft": "",
          "ToggleRight": "",
          "TriangleShape": "",
          "RectangleShape": "",
          "CubeShape": "",
          "Trophy2": "",
          "BucketColor": "",
          "BucketColorFill": "",
          "Taskboard": "",
          "SingleColumn": "",
          "DoubleColumn": "",
          "TripleColumn": "",
          "ColumnLeftTwoThirds": "",
          "ColumnRightTwoThirds": "",
          "AccessLogoFill": "",
          "AnalyticsLogo": "",
          "AnalyticsQuery": "",
          "NewAnalyticsQuery": "",
          "AnalyticsReport": "",
          "WordLogo": "",
          "WordLogoFill": "",
          "ExcelLogo": "",
          "ExcelLogoFill": "",
          "OneNoteLogo": "",
          "OneNoteLogoFill": "",
          "OutlookLogo": "",
          "OutlookLogoFill": "",
          "PowerPointLogo": "",
          "PowerPointLogoFill": "",
          "PublisherLogo": "",
          "PublisherLogoFill": "",
          "ScheduleEventAction": "",
          "FlameSolid": "",
          "ServerProcesses": "",
          "Server": "",
          "SaveAll": "",
          "LinkedInLogo": "",
          "Decimals": "",
          "SidePanelMirrored": "",
          "ProtectRestrict": "",
          "Blog": "",
          "UnknownMirrored": "",
          "PublicContactCardMirrored": "",
          "GridViewSmall": "",
          "GridViewMedium": "",
          "GridViewLarge": "",
          "Step": "",
          "StepInsert": "",
          "StepShared": "",
          "StepSharedAdd": "",
          "StepSharedInsert": "",
          "ViewDashboard": "",
          "ViewList": ""
        }
      };
      registerIcons(subset, options);
    }
    function initializeIcons$8(baseUrl, options) {
      if (baseUrl === void 0) {
        baseUrl = "";
      }
      var subset = {
        style: {
          MozOsxFontSmoothing: "grayscale",
          WebkitFontSmoothing: "antialiased",
          fontStyle: "normal",
          fontWeight: "normal",
          speak: "none"
        },
        fontFace: {
          fontFamily: '"FabricMDL2Icons-10"',
          src: "url('" + baseUrl + "fabric-icons-10-c4ded8e4.woff') format('woff')"
        },
        icons: {
          "ViewListGroup": "",
          "ViewListTree": "",
          "TriggerAuto": "",
          "TriggerUser": "",
          "PivotChart": "",
          "StackedBarChart": "",
          "StackedLineChart": "",
          "BuildQueue": "",
          "BuildQueueNew": "",
          "UserFollowed": "",
          "ContactLink": "",
          "Stack": "",
          "Bullseye": "",
          "VennDiagram": "",
          "FiveTileGrid": "",
          "FocalPoint": "",
          "Insert": "",
          "RingerRemove": "",
          "TeamsLogoInverse": "",
          "TeamsLogo": "",
          "TeamsLogoFill": "",
          "SkypeForBusinessLogoFill": "",
          "SharepointLogo": "",
          "SharepointLogoFill": "",
          "DelveLogo": "",
          "DelveLogoFill": "",
          "OfficeVideoLogo": "",
          "OfficeVideoLogoFill": "",
          "ExchangeLogo": "",
          "ExchangeLogoFill": "",
          "Signin": "",
          "DocumentApproval": "",
          "CloneToDesktop": "",
          "InstallToDrive": "",
          "Blur": "",
          "Build": "",
          "ProcessMetaTask": "",
          "BranchFork2": "",
          "BranchLocked": "",
          "BranchCommit": "",
          "BranchCompare": "",
          "BranchMerge": "",
          "BranchPullRequest": "",
          "BranchSearch": "",
          "BranchShelveset": "",
          "RawSource": "",
          "MergeDuplicate": "",
          "RowsGroup": "",
          "RowsChild": "",
          "Deploy": "",
          "Redeploy": "",
          "ServerEnviroment": "",
          "VisioDiagram": "",
          "HighlightMappedShapes": "",
          "TextCallout": "",
          "IconSetsFlag": "",
          "VisioLogo": "",
          "VisioLogoFill": "",
          "VisioDocument": "",
          "TimelineProgress": "",
          "TimelineDelivery": "",
          "Backlog": "",
          "TeamFavorite": "",
          "TaskGroup": "",
          "TaskGroupMirrored": "",
          "ScopeTemplate": "",
          "AssessmentGroupTemplate": "",
          "NewTeamProject": "",
          "CommentAdd": "",
          "CommentNext": "",
          "CommentPrevious": "",
          "ShopServer": "",
          "LocaleLanguage": "",
          "QueryList": "",
          "UserSync": "",
          "UserPause": "",
          "StreamingOff": "",
          "ArrowTallUpLeft": "",
          "ArrowTallUpRight": "",
          "ArrowTallDownLeft": "",
          "ArrowTallDownRight": "",
          "FieldEmpty": "",
          "FieldFilled": "",
          "FieldChanged": "",
          "FieldNotChanged": "",
          "RingerOff": "",
          "PlayResume": "",
          "BulletedList2": "",
          "BulletedList2Mirrored": "",
          "ImageCrosshair": "",
          "GitGraph": "",
          "Repo": "",
          "RepoSolid": "",
          "FolderQuery": "",
          "FolderList": "",
          "FolderListMirrored": "",
          "LocationOutline": "",
          "POISolid": "",
          "CalculatorNotEqualTo": "",
          "BoxSubtractSolid": ""
        }
      };
      registerIcons(subset, options);
    }
    function initializeIcons$7(baseUrl, options) {
      if (baseUrl === void 0) {
        baseUrl = "";
      }
      var subset = {
        style: {
          MozOsxFontSmoothing: "grayscale",
          WebkitFontSmoothing: "antialiased",
          fontStyle: "normal",
          fontWeight: "normal",
          speak: "none"
        },
        fontFace: {
          fontFamily: '"FabricMDL2Icons-11"',
          src: "url('" + baseUrl + "fabric-icons-11-2a8393d6.woff') format('woff')"
        },
        icons: {
          "BoxAdditionSolid": "",
          "BoxMultiplySolid": "",
          "BoxPlaySolid": "",
          "BoxCheckmarkSolid": "",
          "CirclePauseSolid": "",
          "CirclePause": "",
          "MSNVideosSolid": "",
          "CircleStopSolid": "",
          "CircleStop": "",
          "NavigateBack": "",
          "NavigateBackMirrored": "",
          "NavigateForward": "",
          "NavigateForwardMirrored": "",
          "UnknownSolid": "",
          "UnknownMirroredSolid": "",
          "CircleAddition": "",
          "CircleAdditionSolid": "",
          "FilePDB": "",
          "FileTemplate": "",
          "FileSQL": "",
          "FileJAVA": "",
          "FileASPX": "",
          "FileCSS": "",
          "FileSass": "",
          "FileLess": "",
          "FileHTML": "",
          "JavaScriptLanguage": "",
          "CSharpLanguage": "",
          "CSharp": "",
          "VisualBasicLanguage": "",
          "VB": "",
          "CPlusPlusLanguage": "",
          "CPlusPlus": "",
          "FSharpLanguage": "",
          "FSharp": "",
          "TypeScriptLanguage": "",
          "PythonLanguage": "",
          "PY": "",
          "CoffeeScript": "",
          "MarkDownLanguage": "",
          "FullWidth": "",
          "FullWidthEdit": "",
          "Plug": "",
          "PlugSolid": "",
          "PlugConnected": "",
          "PlugDisconnected": "",
          "UnlockSolid": "",
          "Variable": "",
          "Parameter": "",
          "CommentUrgent": "",
          "Storyboard": "",
          "DiffInline": "",
          "DiffSideBySide": "",
          "ImageDiff": "",
          "ImagePixel": "",
          "FileBug": "",
          "FileCode": "",
          "FileComment": "",
          "BusinessHoursSign": "",
          "FileImage": "",
          "FileSymlink": "",
          "AutoFillTemplate": "",
          "WorkItem": "",
          "WorkItemBug": "",
          "LogRemove": "",
          "ColumnOptions": "",
          "Packages": "",
          "BuildIssue": "",
          "AssessmentGroup": "",
          "VariableGroup": "",
          "FullHistory": "",
          "Wheelchair": "",
          "SingleColumnEdit": "",
          "DoubleColumnEdit": "",
          "TripleColumnEdit": "",
          "ColumnLeftTwoThirdsEdit": "",
          "ColumnRightTwoThirdsEdit": "",
          "StreamLogo": "",
          "PassiveAuthentication": "",
          "AlertSolid": "",
          "MegaphoneSolid": "",
          "TaskSolid": "",
          "ConfigurationSolid": "",
          "BugSolid": "",
          "CrownSolid": "",
          "Trophy2Solid": "",
          "QuickNoteSolid": "",
          "ConstructionConeSolid": "",
          "PageListSolid": "",
          "PageListMirroredSolid": "",
          "StarburstSolid": "",
          "ReadingModeSolid": "",
          "SadSolid": "",
          "HealthSolid": "",
          "ShieldSolid": "",
          "GiftBoxSolid": "",
          "ShoppingCartSolid": "",
          "MailSolid": "",
          "ChatSolid": "",
          "RibbonSolid": ""
        }
      };
      registerIcons(subset, options);
    }
    function initializeIcons$6(baseUrl, options) {
      if (baseUrl === void 0) {
        baseUrl = "";
      }
      var subset = {
        style: {
          MozOsxFontSmoothing: "grayscale",
          WebkitFontSmoothing: "antialiased",
          fontStyle: "normal",
          fontWeight: "normal",
          speak: "none"
        },
        fontFace: {
          fontFamily: '"FabricMDL2Icons-12"',
          src: "url('" + baseUrl + "fabric-icons-12-7e945a1e.woff') format('woff')"
        },
        icons: {
          "FinancialSolid": "",
          "FinancialMirroredSolid": "",
          "HeadsetSolid": "",
          "PermissionsSolid": "",
          "ParkingSolid": "",
          "ParkingMirroredSolid": "",
          "DiamondSolid": "",
          "AsteriskSolid": "",
          "OfflineStorageSolid": "",
          "BankSolid": "",
          "DecisionSolid": "",
          "Parachute": "",
          "ParachuteSolid": "",
          "FiltersSolid": "",
          "ColorSolid": "",
          "ReviewSolid": "",
          "ReviewRequestSolid": "",
          "ReviewRequestMirroredSolid": "",
          "ReviewResponseSolid": "",
          "FeedbackRequestSolid": "",
          "FeedbackRequestMirroredSolid": "",
          "FeedbackResponseSolid": "",
          "WorkItemBar": "",
          "WorkItemBarSolid": "",
          "Separator": "",
          "NavigateExternalInline": "",
          "PlanView": "",
          "TimelineMatrixView": "",
          "EngineeringGroup": "",
          "ProjectCollection": "",
          "CaretBottomRightCenter8": "",
          "CaretBottomLeftCenter8": "",
          "CaretTopRightCenter8": "",
          "CaretTopLeftCenter8": "",
          "DonutChart": "",
          "ChevronUnfold10": "",
          "ChevronFold10": "",
          "DoubleChevronDown8": "",
          "DoubleChevronUp8": "",
          "DoubleChevronLeft8": "",
          "DoubleChevronRight8": "",
          "ChevronDownEnd6": "",
          "ChevronUpEnd6": "",
          "ChevronLeftEnd6": "",
          "ChevronRightEnd6": "",
          "ContextMenu": "",
          "AzureAPIManagement": "",
          "AzureServiceEndpoint": "",
          "VSTSLogo": "",
          "VSTSAltLogo1": "",
          "VSTSAltLogo2": "",
          "FileTypeSolution": "",
          "WordLogoInverse16": "",
          "WordLogo16": "",
          "WordLogoFill16": "",
          "PowerPointLogoInverse16": "",
          "PowerPointLogo16": "",
          "PowerPointLogoFill16": "",
          "ExcelLogoInverse16": "",
          "ExcelLogo16": "",
          "ExcelLogoFill16": "",
          "OneNoteLogoInverse16": "",
          "OneNoteLogo16": "",
          "OneNoteLogoFill16": "",
          "OutlookLogoInverse16": "",
          "OutlookLogo16": "",
          "OutlookLogoFill16": "",
          "PublisherLogoInverse16": "",
          "PublisherLogo16": "",
          "PublisherLogoFill16": "",
          "VisioLogoInverse16": "",
          "VisioLogo16": "",
          "VisioLogoFill16": "",
          "TestBeaker": "",
          "TestBeakerSolid": "",
          "TestExploreSolid": "",
          "TestAutoSolid": "",
          "TestUserSolid": "",
          "TestImpactSolid": "",
          "TestPlan": "",
          "TestStep": "",
          "TestParameter": "",
          "TestSuite": "",
          "TestCase": "",
          "Sprint": "",
          "SignOut": "",
          "TriggerApproval": "",
          "Rocket": "",
          "AzureKeyVault": "",
          "Onboarding": "",
          "Transition": "",
          "LikeSolid": "",
          "DislikeSolid": "",
          "CRMCustomerInsightsApp": "",
          "EditCreate": "",
          "PlayReverseResume": "",
          "PlayReverse": "",
          "SearchData": "",
          "UnSetColor": "",
          "DeclineCall": ""
        }
      };
      registerIcons(subset, options);
    }
    function initializeIcons$5(baseUrl, options) {
      if (baseUrl === void 0) {
        baseUrl = "";
      }
      var subset = {
        style: {
          MozOsxFontSmoothing: "grayscale",
          WebkitFontSmoothing: "antialiased",
          fontStyle: "normal",
          fontWeight: "normal",
          speak: "none"
        },
        fontFace: {
          fontFamily: '"FabricMDL2Icons-13"',
          src: "url('" + baseUrl + "fabric-icons-13-c3989a02.woff') format('woff')"
        },
        icons: {
          "RectangularClipping": "",
          "TeamsLogo16": "",
          "TeamsLogoFill16": "",
          "Spacer": "",
          "SkypeLogo16": "",
          "SkypeForBusinessLogo16": "",
          "SkypeForBusinessLogoFill16": "",
          "FilterSolid": "",
          "MailUndelivered": "",
          "MailTentative": "",
          "MailTentativeMirrored": "",
          "MailReminder": "",
          "ReceiptUndelivered": "",
          "ReceiptTentative": "",
          "ReceiptTentativeMirrored": "",
          "Inbox": "",
          "IRMReply": "",
          "IRMReplyMirrored": "",
          "IRMForward": "",
          "IRMForwardMirrored": "",
          "VoicemailIRM": "",
          "EventAccepted": "",
          "EventTentative": "",
          "EventTentativeMirrored": "",
          "EventDeclined": "",
          "IDBadge": "",
          "BackgroundColor": "",
          "OfficeFormsLogoInverse16": "",
          "OfficeFormsLogo": "",
          "OfficeFormsLogoFill": "",
          "OfficeFormsLogo16": "",
          "OfficeFormsLogoFill16": "",
          "OfficeFormsLogoInverse24": "",
          "OfficeFormsLogo24": "",
          "OfficeFormsLogoFill24": "",
          "PageLock": "",
          "NotExecuted": "",
          "NotImpactedSolid": "",
          "FieldReadOnly": "",
          "FieldRequired": "",
          "BacklogBoard": "",
          "ExternalBuild": "",
          "ExternalTFVC": "",
          "ExternalXAML": "",
          "IssueSolid": "",
          "DefectSolid": "",
          "LadybugSolid": "",
          "NugetLogo": "",
          "TFVCLogo": "",
          "ProjectLogo32": "",
          "ProjectLogoFill32": "",
          "ProjectLogo16": "",
          "ProjectLogoFill16": "",
          "SwayLogo32": "",
          "SwayLogoFill32": "",
          "SwayLogo16": "",
          "SwayLogoFill16": "",
          "ClassNotebookLogo32": "",
          "ClassNotebookLogoFill32": "",
          "ClassNotebookLogo16": "",
          "ClassNotebookLogoFill16": "",
          "ClassNotebookLogoInverse32": "",
          "ClassNotebookLogoInverse16": "",
          "StaffNotebookLogo32": "",
          "StaffNotebookLogoFill32": "",
          "StaffNotebookLogo16": "",
          "StaffNotebookLogoFill16": "",
          "StaffNotebookLogoInverted32": "",
          "StaffNotebookLogoInverted16": "",
          "KaizalaLogo": "",
          "TaskLogo": "",
          "ProtectionCenterLogo32": "",
          "GallatinLogo": "",
          "Globe2": "",
          "Guitar": "",
          "Breakfast": "",
          "Brunch": "",
          "BeerMug": "",
          "Vacation": "",
          "Teeth": "",
          "Taxi": "",
          "Chopsticks": "",
          "SyncOccurence": "",
          "UnsyncOccurence": "",
          "GIF": "",
          "PrimaryCalendar": "",
          "SearchCalendar": "",
          "VideoOff": "",
          "MicrosoftFlowLogo": "",
          "BusinessCenterLogo": "",
          "ToDoLogoBottom": "",
          "ToDoLogoTop": "",
          "EditSolid12": "",
          "EditSolidMirrored12": "",
          "UneditableSolid12": "",
          "UneditableSolidMirrored12": "",
          "UneditableMirrored": "",
          "AdminALogo32": "",
          "AdminALogoFill32": "",
          "ToDoLogoInverse": ""
        }
      };
      registerIcons(subset, options);
    }
    function initializeIcons$4(baseUrl, options) {
      if (baseUrl === void 0) {
        baseUrl = "";
      }
      var subset = {
        style: {
          MozOsxFontSmoothing: "grayscale",
          WebkitFontSmoothing: "antialiased",
          fontStyle: "normal",
          fontWeight: "normal",
          speak: "none"
        },
        fontFace: {
          fontFamily: '"FabricMDL2Icons-14"',
          src: "url('" + baseUrl + "fabric-icons-14-5cf58db8.woff') format('woff')"
        },
        icons: {
          "Snooze": "",
          "WaffleOffice365": "",
          "ImageSearch": "",
          "NewsSearch": "",
          "VideoSearch": "",
          "R": "",
          "FontColorA": "",
          "FontColorSwatch": "",
          "LightWeight": "",
          "NormalWeight": "",
          "SemiboldWeight": "",
          "GroupObject": "",
          "UngroupObject": "",
          "AlignHorizontalLeft": "",
          "AlignHorizontalCenter": "",
          "AlignHorizontalRight": "",
          "AlignVerticalTop": "",
          "AlignVerticalCenter": "",
          "AlignVerticalBottom": "",
          "HorizontalDistributeCenter": "",
          "VerticalDistributeCenter": "",
          "Ellipse": "",
          "Line": "",
          "Octagon": "",
          "Hexagon": "",
          "Pentagon": "",
          "RightTriangle": "",
          "HalfCircle": "",
          "QuarterCircle": "",
          "ThreeQuarterCircle": "",
          "6PointStar": "",
          "12PointStar": "",
          "ArrangeBringToFront": "",
          "ArrangeSendToBack": "",
          "ArrangeSendBackward": "",
          "ArrangeBringForward": "",
          "BorderDash": "",
          "BorderDot": "",
          "LineStyle": "",
          "LineThickness": "",
          "WindowEdit": "",
          "HintText": "",
          "MediaAdd": "",
          "AnchorLock": "",
          "AutoHeight": "",
          "ChartSeries": "",
          "ChartXAngle": "",
          "ChartYAngle": "",
          "Combobox": "",
          "LineSpacing": "",
          "Padding": "",
          "PaddingTop": "",
          "PaddingBottom": "",
          "PaddingLeft": "",
          "PaddingRight": "",
          "NavigationFlipper": "",
          "AlignJustify": "",
          "TextOverflow": "",
          "VisualsFolder": "",
          "VisualsStore": "",
          "PictureCenter": "",
          "PictureFill": "",
          "PicturePosition": "",
          "PictureStretch": "",
          "PictureTile": "",
          "Slider": "",
          "SliderHandleSize": "",
          "DefaultRatio": "",
          "NumberSequence": "",
          "GUID": "",
          "ReportAdd": "",
          "DashboardAdd": "",
          "MapPinSolid": "",
          "WebPublish": "",
          "PieSingleSolid": "",
          "BlockedSolid": "",
          "DrillDown": "",
          "DrillDownSolid": "",
          "DrillExpand": "",
          "DrillShow": "",
          "SpecialEvent": "",
          "OneDriveFolder16": "",
          "FunctionalManagerDashboard": "",
          "BIDashboard": "",
          "CodeEdit": "",
          "RenewalCurrent": "",
          "RenewalFuture": "",
          "SplitObject": "",
          "BulkUpload": "",
          "DownloadDocument": "",
          "GreetingCard": "",
          "Flower": "",
          "WaitlistConfirm": "",
          "WaitlistConfirmMirrored": "",
          "LaptopSecure": "",
          "DragObject": "",
          "EntryView": "",
          "EntryDecline": "",
          "ContactCardSettings": "",
          "ContactCardSettingsMirrored": ""
        }
      };
      registerIcons(subset, options);
    }
    function initializeIcons$3(baseUrl, options) {
      if (baseUrl === void 0) {
        baseUrl = "";
      }
      var subset = {
        style: {
          MozOsxFontSmoothing: "grayscale",
          WebkitFontSmoothing: "antialiased",
          fontStyle: "normal",
          fontWeight: "normal",
          speak: "none"
        },
        fontFace: {
          fontFamily: '"FabricMDL2Icons-15"',
          src: "url('" + baseUrl + "fabric-icons-15-3807251b.woff') format('woff')"
        },
        icons: {
          "CalendarSettings": "",
          "CalendarSettingsMirrored": "",
          "HardDriveLock": "",
          "HardDriveUnlock": "",
          "AccountManagement": "",
          "ReportWarning": "",
          "TransitionPop": "",
          "TransitionPush": "",
          "TransitionEffect": "",
          "LookupEntities": "",
          "ExploreData": "",
          "AddBookmark": "",
          "SearchBookmark": "",
          "DrillThrough": "",
          "MasterDatabase": "",
          "CertifiedDatabase": "",
          "MaximumValue": "",
          "MinimumValue": "",
          "VisualStudioIDELogo32": "",
          "PasteAsText": "",
          "PasteAsCode": "",
          "BrowserTab": "",
          "BrowserTabScreenshot": "",
          "DesktopScreenshot": "",
          "FileYML": "",
          "ClipboardSolid": "",
          "FabricUserFolder": "",
          "FabricNetworkFolder": "",
          "BullseyeTarget": "",
          "AnalyticsView": "",
          "Video360Generic": "",
          "Untag": "",
          "Leave": "",
          "Trending12": "",
          "Blocked12": "",
          "Warning12": "",
          "CheckedOutByOther12": "",
          "CheckedOutByYou12": "",
          "CircleShapeSolid": "",
          "SquareShapeSolid": "",
          "TriangleShapeSolid": "",
          "DropShapeSolid": "",
          "RectangleShapeSolid": "",
          "ZoomToFit": "",
          "InsertColumnsLeft": "",
          "InsertColumnsRight": "",
          "InsertRowsAbove": "",
          "InsertRowsBelow": "",
          "DeleteColumns": "",
          "DeleteRows": "",
          "DeleteRowsMirrored": "",
          "DeleteTable": "",
          "AccountBrowser": "",
          "VersionControlPush": "",
          "StackedColumnChart2": "",
          "TripleColumnWide": "",
          "QuadColumn": "",
          "WhiteBoardApp16": "",
          "WhiteBoardApp32": "",
          "PinnedSolid": "",
          "InsertSignatureLine": "",
          "ArrangeByFrom": "",
          "Phishing": "",
          "CreateMailRule": "",
          "PublishCourse": "",
          "DictionaryRemove": "",
          "UserRemove": "",
          "UserEvent": "",
          "Encryption": "",
          "PasswordField": "",
          "OpenInNewTab": "",
          "Hide3": "",
          "VerifiedBrandSolid": "",
          "MarkAsProtected": "",
          "AuthenticatorApp": "",
          "WebTemplate": "",
          "DefenderTVM": "",
          "MedalSolid": "",
          "D365TalentLearn": "",
          "D365TalentInsight": "",
          "D365TalentHRCore": "",
          "BacklogList": "",
          "ButtonControl": "",
          "TableGroup": "",
          "MountainClimbing": "",
          "TagUnknown": "",
          "TagUnknownMirror": "",
          "TagUnknown12": "",
          "TagUnknown12Mirror": "",
          "Link12": "",
          "Presentation": "",
          "Presentation12": "",
          "Lock12": "",
          "BuildDefinition": "",
          "ReleaseDefinition": "",
          "SaveTemplate": "",
          "UserGauge": "",
          "BlockedSiteSolid12": "",
          "TagSolid": "",
          "OfficeChat": ""
        }
      };
      registerIcons(subset, options);
    }
    function initializeIcons$2(baseUrl, options) {
      if (baseUrl === void 0) {
        baseUrl = "";
      }
      var subset = {
        style: {
          MozOsxFontSmoothing: "grayscale",
          WebkitFontSmoothing: "antialiased",
          fontStyle: "normal",
          fontWeight: "normal",
          speak: "none"
        },
        fontFace: {
          fontFamily: '"FabricMDL2Icons-16"',
          src: "url('" + baseUrl + "fabric-icons-16-9cf93f3b.woff') format('woff')"
        },
        icons: {
          "OfficeChatSolid": "",
          "MailSchedule": "",
          "WarningSolid": "",
          "Blocked2Solid": "",
          "SkypeCircleArrow": "",
          "SkypeArrow": "",
          "SyncStatus": "",
          "SyncStatusSolid": "",
          "ProjectDocument": "",
          "ToDoLogoOutline": "",
          "VisioOnlineLogoFill32": "",
          "VisioOnlineLogo32": "",
          "VisioOnlineLogoCloud32": "",
          "VisioDiagramSync": "",
          "Event12": "",
          "EventDateMissed12": "",
          "UserOptional": "",
          "ResponsesMenu": "",
          "DoubleDownArrow": "",
          "DistributeDown": "",
          "BookmarkReport": "",
          "FilterSettings": "",
          "GripperDotsVertical": "",
          "MailAttached": "",
          "AddIn": "",
          "LinkedDatabase": "",
          "TableLink": "",
          "PromotedDatabase": "",
          "BarChartVerticalFilter": "",
          "BarChartVerticalFilterSolid": "",
          "MicOff2": "",
          "MicrosoftTranslatorLogo": "",
          "ShowTimeAs": "",
          "FileRequest": "",
          "WorkItemAlert": "",
          "PowerBILogo16": "",
          "PowerBILogoBackplate16": "",
          "BulletedListText": "",
          "BulletedListBullet": "",
          "BulletedListTextMirrored": "",
          "BulletedListBulletMirrored": "",
          "NumberedListText": "",
          "NumberedListNumber": "",
          "NumberedListTextMirrored": "",
          "NumberedListNumberMirrored": "",
          "RemoveLinkChain": "",
          "RemoveLinkX": "",
          "FabricTextHighlight": "",
          "ClearFormattingA": "",
          "ClearFormattingEraser": "",
          "Photo2Fill": "",
          "IncreaseIndentText": "",
          "IncreaseIndentArrow": "",
          "DecreaseIndentText": "",
          "DecreaseIndentArrow": "",
          "IncreaseIndentTextMirrored": "",
          "IncreaseIndentArrowMirrored": "",
          "DecreaseIndentTextMirrored": "",
          "DecreaseIndentArrowMirrored": "",
          "CheckListText": "",
          "CheckListCheck": "",
          "CheckListTextMirrored": "",
          "CheckListCheckMirrored": "",
          "NumberSymbol": "",
          "Coupon": "",
          "VerifiedBrand": "",
          "ReleaseGate": "",
          "ReleaseGateCheck": "",
          "ReleaseGateError": "",
          "M365InvoicingLogo": "",
          "RemoveFromShoppingList": "",
          "ShieldAlert": "",
          "FabricTextHighlightComposite": "",
          "Dataflows": "",
          "GenericScanFilled": "",
          "DiagnosticDataBarTooltip": "",
          "SaveToMobile": "",
          "Orientation2": "",
          "ScreenCast": "",
          "ShowGrid": "",
          "SnapToGrid": "",
          "ContactList": "",
          "NewMail": "",
          "EyeShadow": "",
          "FabricFolderConfirm": "",
          "InformationBarriers": "",
          "CommentActive": "",
          "ColumnVerticalSectionEdit": "",
          "WavingHand": "",
          "ShakeDevice": "",
          "SmartGlassRemote": "",
          "Rotate90Clockwise": "",
          "Rotate90CounterClockwise": "",
          "CampaignTemplate": "",
          "ChartTemplate": "",
          "PageListFilter": "",
          "SecondaryNav": "",
          "ColumnVerticalSection": "",
          "SkypeCircleSlash": "",
          "SkypeSlash": ""
        }
      };
      registerIcons(subset, options);
    }
    function initializeIcons$1(baseUrl, options) {
      if (baseUrl === void 0) {
        baseUrl = "";
      }
      var subset = {
        style: {
          MozOsxFontSmoothing: "grayscale",
          WebkitFontSmoothing: "antialiased",
          fontStyle: "normal",
          fontWeight: "normal",
          speak: "none"
        },
        fontFace: {
          fontFamily: '"FabricMDL2Icons-17"',
          src: "url('" + baseUrl + "fabric-icons-17-0c4ed701.woff') format('woff')"
        },
        icons: {
          "CustomizeToolbar": "",
          "DuplicateRow": "",
          "RemoveFromTrash": "",
          "MailOptions": "",
          "Childof": "",
          "Footer": "",
          "Header": "",
          "BarChartVerticalFill": "",
          "StackedColumnChart2Fill": "",
          "PlainText": "",
          "AccessibiltyChecker": "",
          "DatabaseSync": "",
          "ReservationOrders": "",
          "TabOneColumn": "",
          "TabTwoColumn": "",
          "TabThreeColumn": "",
          "BulletedTreeList": "",
          "MicrosoftTranslatorLogoGreen": "",
          "MicrosoftTranslatorLogoBlue": "",
          "InternalInvestigation": "",
          "AddReaction": "",
          "ContactHeart": "",
          "VisuallyImpaired": "",
          "EventToDoLogo": "",
          "Variable2": "",
          "ModelingView": "",
          "DisconnectVirtualMachine": "",
          "ReportLock": "",
          "Uneditable2": "",
          "Uneditable2Mirrored": "",
          "BarChartVerticalEdit": "",
          "GlobalNavButtonActive": "",
          "PollResults": "",
          "Rerun": "",
          "QandA": "",
          "QandAMirror": "",
          "BookAnswers": "",
          "AlertSettings": "",
          "TrimStart": "",
          "TrimEnd": "",
          "TableComputed": "",
          "DecreaseIndentLegacy": "",
          "IncreaseIndentLegacy": "",
          "SizeLegacy": ""
        }
      };
      registerIcons(subset, options);
    }
    var registerIconAliases = function() {
      registerIconAlias("trash", "delete");
      registerIconAlias("onedrive", "onedrivelogo");
      registerIconAlias("alertsolid12", "eventdatemissed12");
      registerIconAlias("sixpointstar", "6pointstar");
      registerIconAlias("twelvepointstar", "12pointstar");
      registerIconAlias("toggleon", "toggleleft");
      registerIconAlias("toggleoff", "toggleright");
    };
    setVersion("@fluentui/font-icons-mdl2", "8.2.0");
    var DEFAULT_BASE_URL = "https://spoppe-b.azureedge.net/files/fabric-cdn-prod_20210407.001/assets/icons/";
    function initializeIcons(baseUrl, options) {
      if (baseUrl === void 0) {
        baseUrl = DEFAULT_BASE_URL;
      }
      [
        initializeIcons$j,
        initializeIcons$i,
        initializeIcons$h,
        initializeIcons$g,
        initializeIcons$f,
        initializeIcons$e,
        initializeIcons$d,
        initializeIcons$c,
        initializeIcons$b,
        initializeIcons$a,
        initializeIcons$9,
        initializeIcons$8,
        initializeIcons$7,
        initializeIcons$6,
        initializeIcons$5,
        initializeIcons$4,
        initializeIcons$3,
        initializeIcons$2,
        initializeIcons$1
      ].forEach(function(initialize) {
        return initialize(baseUrl, options);
      });
      registerIconAliases();
    }
    var GlobalClassNames$2 = {
      root: "ms-Nav",
      linkText: "ms-Nav-linkText",
      compositeLink: "ms-Nav-compositeLink",
      link: "ms-Nav-link",
      chevronButton: "ms-Nav-chevronButton",
      chevronIcon: "ms-Nav-chevron",
      navItem: "ms-Nav-navItem",
      navItems: "ms-Nav-navItems",
      group: "ms-Nav-group",
      groupContent: "ms-Nav-groupContent"
    };
    var buttonStyles = {
      textContainer: {
        overflow: "hidden"
      },
      label: {
        whiteSpace: "nowrap",
        textOverflow: "ellipsis",
        overflow: "hidden"
      }
    };
    var getStyles = function(props) {
      var _a2;
      var className = props.className, theme = props.theme, isOnTop = props.isOnTop, isExpanded = props.isExpanded, isGroup = props.isGroup, isLink = props.isLink, isSelected = props.isSelected, isDisabled = props.isDisabled, isButtonEntry = props.isButtonEntry, _b = props.navHeight, navHeight = _b === void 0 ? 44 : _b, position2 = props.position, _c = props.leftPadding, leftPadding = _c === void 0 ? 20 : _c, _d = props.leftPaddingExpanded, leftPaddingExpanded = _d === void 0 ? 28 : _d, _e = props.rightPadding, rightPadding = _e === void 0 ? 20 : _e;
      var palette = theme.palette, semanticColors = theme.semanticColors, fonts = theme.fonts;
      var classNames2 = getGlobalClassNames(GlobalClassNames$2, theme);
      return {
        root: [
          classNames2.root,
          className,
          fonts.medium,
          {
            overflowY: "auto",
            userSelect: "none",
            WebkitOverflowScrolling: "touch"
          },
          isOnTop && [
            {
              position: "absolute"
            },
            AnimationClassNames.slideRightIn40
          ]
        ],
        linkText: [
          classNames2.linkText,
          {
            margin: "0 4px",
            overflow: "hidden",
            verticalAlign: "middle",
            textAlign: "left",
            textOverflow: "ellipsis"
          }
        ],
        compositeLink: [
          classNames2.compositeLink,
          {
            display: "block",
            position: "relative",
            color: semanticColors.bodyText
          },
          isExpanded && "is-expanded",
          isSelected && "is-selected",
          isDisabled && "is-disabled",
          isDisabled && {
            color: semanticColors.disabledText
          }
        ],
        link: [
          classNames2.link,
          getFocusStyle(theme),
          {
            display: "block",
            position: "relative",
            height: navHeight,
            width: "100%",
            lineHeight: navHeight + "px",
            textDecoration: "none",
            cursor: "pointer",
            textOverflow: "ellipsis",
            whiteSpace: "nowrap",
            overflow: "hidden",
            paddingLeft: leftPadding,
            paddingRight: rightPadding,
            color: semanticColors.bodyText,
            selectors: (_a2 = {}, _a2[HighContrastSelector] = {
              border: 0,
              selectors: {
                ":focus": {
                  border: "1px solid WindowText"
                }
              }
            }, _a2)
          },
          !isDisabled && {
            selectors: {
              ".ms-Nav-compositeLink:hover &": {
                backgroundColor: semanticColors.bodyBackgroundHovered
              }
            }
          },
          isSelected && {
            color: semanticColors.bodyTextChecked,
            fontWeight: FontWeights$1.semibold,
            backgroundColor: semanticColors.bodyBackgroundChecked,
            selectors: {
              "&:after": {
                borderLeft: "2px solid " + palette.themePrimary,
                content: '""',
                position: "absolute",
                top: 0,
                right: 0,
                bottom: 0,
                left: 0,
                pointerEvents: "none"
              }
            }
          },
          isDisabled && {
            color: semanticColors.disabledText
          },
          isButtonEntry && {
            color: palette.themePrimary
          }
        ],
        chevronButton: [
          classNames2.chevronButton,
          getFocusStyle(theme),
          fonts.small,
          {
            display: "block",
            textAlign: "left",
            lineHeight: navHeight + "px",
            margin: "5px 0",
            padding: "0px, " + rightPadding + "px, 0px, " + leftPaddingExpanded + "px",
            border: "none",
            textOverflow: "ellipsis",
            whiteSpace: "nowrap",
            overflow: "hidden",
            cursor: "pointer",
            color: semanticColors.bodyText,
            backgroundColor: "transparent",
            selectors: {
              "&:visited": {
                color: semanticColors.bodyText
              }
            }
          },
          isGroup && {
            fontSize: fonts.large.fontSize,
            width: "100%",
            height: navHeight,
            borderBottom: "1px solid " + semanticColors.bodyDivider
          },
          isLink && {
            display: "block",
            width: leftPaddingExpanded - 2,
            height: navHeight - 2,
            position: "absolute",
            top: "1px",
            left: position2 + "px",
            zIndex: ZIndexes.Nav,
            padding: 0,
            margin: 0
          },
          isSelected && {
            color: palette.themePrimary,
            backgroundColor: palette.neutralLighterAlt,
            selectors: {
              "&:after": {
                borderLeft: "2px solid " + palette.themePrimary,
                content: '""',
                position: "absolute",
                top: 0,
                right: 0,
                bottom: 0,
                left: 0,
                pointerEvents: "none"
              }
            }
          }
        ],
        chevronIcon: [
          classNames2.chevronIcon,
          {
            position: "absolute",
            left: "8px",
            height: navHeight,
            // inline-flex prevents the chevron from shifting with custom line height styles
            display: "inline-flex",
            alignItems: "center",
            lineHeight: navHeight + "px",
            fontSize: fonts.small.fontSize,
            transition: "transform .1s linear"
          },
          isExpanded && {
            transform: "rotate(-180deg)"
          },
          isLink && {
            top: 0
          }
        ],
        navItem: [
          classNames2.navItem,
          {
            padding: 0
          }
        ],
        navItems: [
          classNames2.navItems,
          {
            listStyleType: "none",
            padding: 0,
            margin: 0
            // remove default <UL> styles
          }
        ],
        group: [classNames2.group, isExpanded && "is-expanded"],
        groupContent: [
          classNames2.groupContent,
          {
            display: "none",
            marginBottom: "40px"
          },
          AnimationClassNames.slideDownIn20,
          isExpanded && {
            display: "block"
          }
        ]
      };
    };
    var _indentationSize = 14;
    var _baseIndent = 3;
    var _urlResolver;
    function isRelativeUrl(url) {
      return !!url && !/^[a-z0-9+-.]+:\/\//i.test(url);
    }
    var getClassNames = classNamesFunction();
    var NavBase = (
      /** @class */
      function(_super) {
        __extends(NavBase2, _super);
        function NavBase2(props) {
          var _this = _super.call(this, props) || this;
          _this._focusZone = reactExports.createRef();
          _this._onRenderLink = function(link2) {
            var _a2 = _this.props, styles2 = _a2.styles, groups = _a2.groups, theme = _a2.theme;
            var classNames2 = getClassNames(styles2, { theme, groups });
            return reactExports.createElement("div", { className: classNames2.linkText }, link2.name);
          };
          _this._renderGroup = function(group, groupIndex) {
            var _a2 = _this.props, styles2 = _a2.styles, groups = _a2.groups, theme = _a2.theme, _b = _a2.onRenderGroupHeader, onRenderGroupHeader = _b === void 0 ? _this._renderGroupHeader : _b;
            var isExpanded = _this._isGroupExpanded(group);
            var classNames2 = getClassNames(styles2, {
              theme,
              isGroup: true,
              isExpanded,
              groups
            });
            var finalOnHeaderClick = function(ev, isCollapsing) {
              _this._onGroupHeaderClicked(group, ev);
            };
            var groupProps = __assign$1(__assign$1({}, group), { isExpanded, onHeaderClick: finalOnHeaderClick });
            return reactExports.createElement(
              "div",
              { key: groupIndex, className: classNames2.group },
              groupProps.name ? onRenderGroupHeader(groupProps, _this._renderGroupHeader) : null,
              reactExports.createElement("div", { className: classNames2.groupContent }, _this._renderLinks(
                groupProps.links,
                0
                /* nestingLevel */
              ))
            );
          };
          _this._renderGroupHeader = function(group) {
            var _a2 = _this.props, styles2 = _a2.styles, groups = _a2.groups, theme = _a2.theme, expandButtonAriaLabel = _a2.expandButtonAriaLabel;
            var isExpanded = group.isExpanded;
            var classNames2 = getClassNames(styles2, {
              theme,
              isGroup: true,
              isExpanded,
              groups
            });
            var label = (isExpanded ? group.collapseAriaLabel : group.expandAriaLabel) || expandButtonAriaLabel;
            var onHeaderClick = group.onHeaderClick;
            var onClick = onHeaderClick ? function(ev) {
              onHeaderClick(ev, isExpanded);
            } : void 0;
            return reactExports.createElement(
              "button",
              { className: classNames2.chevronButton, onClick, "aria-label": label, "aria-expanded": isExpanded },
              reactExports.createElement(Icon, { className: classNames2.chevronIcon, iconName: "ChevronDown" }),
              group.name
            );
          };
          initializeComponentRef(_this);
          _this.state = {
            isGroupCollapsed: {},
            // TODO: consider removing
            // eslint-disable-next-line react/no-unused-state
            isLinkExpandStateChanged: false,
            selectedKey: props.initialSelectedKey || props.selectedKey
          };
          return _this;
        }
        NavBase2.prototype.render = function() {
          var _a2 = this.props, styles2 = _a2.styles, groups = _a2.groups, className = _a2.className, isOnTop = _a2.isOnTop, theme = _a2.theme;
          if (!groups) {
            return null;
          }
          var groupElements = groups.map(this._renderGroup);
          var classNames2 = getClassNames(styles2, { theme, className, isOnTop, groups });
          return reactExports.createElement(
            FocusZone,
            { direction: FocusZoneDirection.vertical, componentRef: this._focusZone },
            reactExports.createElement("nav", { role: "navigation", className: classNames2.root, "aria-label": this.props.ariaLabel }, groupElements)
          );
        };
        Object.defineProperty(NavBase2.prototype, "selectedKey", {
          get: function() {
            return this.state.selectedKey;
          },
          enumerable: false,
          configurable: true
        });
        NavBase2.prototype.focus = function(forceIntoFirstElement) {
          if (forceIntoFirstElement === void 0) {
            forceIntoFirstElement = false;
          }
          if (this._focusZone && this._focusZone.current) {
            return this._focusZone.current.focus(forceIntoFirstElement);
          }
          return false;
        };
        NavBase2.prototype._renderNavLink = function(link2, linkIndex, nestingLevel) {
          var _a2 = this.props, styles2 = _a2.styles, groups = _a2.groups, theme = _a2.theme;
          var isLinkWithIcon = link2.icon || link2.iconProps;
          var isSelectedLink = this._isLinkSelected(link2);
          var _b = link2.ariaCurrent, ariaCurrent = _b === void 0 ? "page" : _b;
          var classNames2 = getClassNames(styles2, {
            theme,
            isSelected: isSelectedLink,
            isDisabled: link2.disabled,
            isButtonEntry: link2.onClick && !link2.forceAnchor,
            leftPadding: _indentationSize * nestingLevel + _baseIndent + (isLinkWithIcon ? 0 : 24),
            groups
          });
          var rel = link2.url && link2.target && !isRelativeUrl(link2.url) ? "noopener noreferrer" : void 0;
          var LinkAs = this.props.linkAs ? composeComponentAs(this.props.linkAs, ActionButton) : ActionButton;
          var onRenderLink = this.props.onRenderLink ? composeRenderFunction(this.props.onRenderLink, this._onRenderLink) : this._onRenderLink;
          return reactExports.createElement(LinkAs, {
            className: classNames2.link,
            styles: buttonStyles,
            href: link2.url || (link2.forceAnchor ? "#" : void 0),
            iconProps: link2.iconProps || { iconName: link2.icon },
            // eslint-disable-next-line react/jsx-no-bind
            onClick: link2.onClick ? this._onNavButtonLinkClicked.bind(this, link2) : this._onNavAnchorLinkClicked.bind(this, link2),
            title: link2.title !== void 0 ? link2.title : link2.name,
            target: link2.target,
            rel,
            disabled: link2.disabled,
            "aria-current": isSelectedLink ? ariaCurrent : void 0,
            "aria-label": link2.ariaLabel ? link2.ariaLabel : void 0,
            link: link2
          }, onRenderLink(link2));
        };
        NavBase2.prototype._renderCompositeLink = function(link2, linkIndex, nestingLevel) {
          var divProps = __assign$1({}, getNativeProps$1(link2, divProperties, ["onClick"]));
          var _a2 = this.props, expandButtonAriaLabel = _a2.expandButtonAriaLabel, styles2 = _a2.styles, groups = _a2.groups, theme = _a2.theme;
          var classNames2 = getClassNames(styles2, {
            theme,
            isExpanded: !!link2.isExpanded,
            isSelected: this._isLinkSelected(link2),
            isLink: true,
            isDisabled: link2.disabled,
            position: _indentationSize * nestingLevel + 1,
            groups
          });
          var finalExpandBtnAriaLabel = "";
          if (link2.links && link2.links.length > 0) {
            if (link2.collapseAriaLabel || link2.expandAriaLabel) {
              finalExpandBtnAriaLabel = link2.isExpanded ? link2.collapseAriaLabel : link2.expandAriaLabel;
            } else {
              finalExpandBtnAriaLabel = expandButtonAriaLabel ? link2.name + " " + expandButtonAriaLabel : link2.name;
            }
          }
          return reactExports.createElement(
            "div",
            __assign$1({}, divProps, { key: link2.key || linkIndex, className: classNames2.compositeLink }),
            link2.links && link2.links.length > 0 ? reactExports.createElement(
              "button",
              { className: classNames2.chevronButton, onClick: this._onLinkExpandClicked.bind(this, link2), "aria-label": finalExpandBtnAriaLabel, "aria-expanded": link2.isExpanded ? "true" : "false" },
              reactExports.createElement(Icon, { className: classNames2.chevronIcon, iconName: "ChevronDown" })
            ) : null,
            this._renderNavLink(link2, linkIndex, nestingLevel)
          );
        };
        NavBase2.prototype._renderLink = function(link2, linkIndex, nestingLevel) {
          var _a2 = this.props, styles2 = _a2.styles, groups = _a2.groups, theme = _a2.theme;
          var classNames2 = getClassNames(styles2, { theme, groups });
          return reactExports.createElement(
            "li",
            { key: link2.key || linkIndex, role: "listitem", className: classNames2.navItem },
            this._renderCompositeLink(link2, linkIndex, nestingLevel),
            link2.isExpanded ? this._renderLinks(link2.links, ++nestingLevel) : null
          );
        };
        NavBase2.prototype._renderLinks = function(links, nestingLevel) {
          var _this = this;
          if (!links || !links.length) {
            return null;
          }
          var linkElements = links.map(function(link2, linkIndex) {
            return _this._renderLink(link2, linkIndex, nestingLevel);
          });
          var _a2 = this.props, styles2 = _a2.styles, groups = _a2.groups, theme = _a2.theme;
          var classNames2 = getClassNames(styles2, { theme, groups });
          return reactExports.createElement("ul", { role: "list", className: classNames2.navItems }, linkElements);
        };
        NavBase2.prototype._onGroupHeaderClicked = function(group, ev) {
          if (group.onHeaderClick) {
            group.onHeaderClick(ev, this._isGroupExpanded(group));
          }
          if (group.isExpanded === void 0) {
            this._toggleCollapsed(group);
          }
          if (ev) {
            ev.preventDefault();
            ev.stopPropagation();
          }
        };
        NavBase2.prototype._onLinkExpandClicked = function(link2, ev) {
          var onLinkExpandClick = this.props.onLinkExpandClick;
          if (onLinkExpandClick) {
            onLinkExpandClick(ev, link2);
          }
          if (!ev.defaultPrevented) {
            link2.isExpanded = !link2.isExpanded;
            this.setState({ isLinkExpandStateChanged: true });
          }
          ev.preventDefault();
          ev.stopPropagation();
        };
        NavBase2.prototype._preventBounce = function(link2, ev) {
          if (!link2.url && link2.forceAnchor) {
            ev.preventDefault();
          }
        };
        NavBase2.prototype._onNavAnchorLinkClicked = function(link2, ev) {
          this._preventBounce(link2, ev);
          if (this.props.onLinkClick) {
            this.props.onLinkClick(ev, link2);
          }
          if (!link2.url && link2.links && link2.links.length > 0) {
            this._onLinkExpandClicked(link2, ev);
          }
          this.setState({ selectedKey: link2.key });
        };
        NavBase2.prototype._onNavButtonLinkClicked = function(link2, ev) {
          this._preventBounce(link2, ev);
          if (link2.onClick) {
            link2.onClick(ev, link2);
          }
          if (!link2.url && link2.links && link2.links.length > 0) {
            this._onLinkExpandClicked(link2, ev);
          }
          this.setState({ selectedKey: link2.key });
        };
        NavBase2.prototype._isLinkSelected = function(link2) {
          if (this.props.selectedKey !== void 0) {
            return link2.key === this.props.selectedKey;
          } else if (this.state.selectedKey !== void 0) {
            return link2.key === this.state.selectedKey;
          } else if (typeof getWindow() === "undefined" || !link2.url) {
            return false;
          } else {
            _urlResolver = _urlResolver || document.createElement("a");
            _urlResolver.href = link2.url || "";
            var target = _urlResolver.href;
            if (location.href === target) {
              return true;
            }
            if (location.protocol + "//" + location.host + location.pathname === target) {
              return true;
            }
            if (location.hash) {
              if (location.hash === link2.url) {
                return true;
              }
              _urlResolver.href = location.hash.substring(1);
              return _urlResolver.href === target;
            }
          }
          return false;
        };
        NavBase2.prototype._isGroupExpanded = function(group) {
          if (group.isExpanded !== void 0) {
            return group.isExpanded;
          }
          if (group.name && this.state.isGroupCollapsed.hasOwnProperty(group.name)) {
            return !this.state.isGroupCollapsed[group.name];
          }
          if (group.collapseByDefault !== void 0) {
            return !group.collapseByDefault;
          }
          return true;
        };
        NavBase2.prototype._toggleCollapsed = function(group) {
          var _a2;
          if (group.name) {
            var newGroupCollapsed = __assign$1(__assign$1({}, this.state.isGroupCollapsed), (_a2 = {}, _a2[group.name] = this._isGroupExpanded(group), _a2));
            this.setState({ isGroupCollapsed: newGroupCollapsed });
          }
        };
        NavBase2.defaultProps = {
          groups: null
        };
        return NavBase2;
      }(reactExports.Component)
    );
    var Nav = styled(NavBase, getStyles, void 0, {
      scope: "Nav"
    });
    var assign$3 = __assign$1;
    function withSlots(type, props) {
      var children = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        children[_i - 2] = arguments[_i];
      }
      var slotType = type;
      if (slotType.isSlot) {
        children = reactExports.Children.toArray(children);
        if (children.length === 0) {
          return slotType(props);
        }
        return slotType(__assign$1(__assign$1({}, props), { children }));
      } else {
        return reactExports.createElement.apply(React$1, __spreadArray([type, props], children));
      }
    }
    function createFactory(DefaultComponent, options) {
      if (options === void 0) {
        options = {};
      }
      var _a2 = options.defaultProp, defaultProp = _a2 === void 0 ? "children" : _a2;
      var result = function(componentProps, userProps, userSlotOptions, defaultStyles, theme) {
        if (reactExports.isValidElement(userProps)) {
          return userProps;
        }
        var flattenedUserProps = _translateShorthand(defaultProp, userProps);
        var finalProps = _constructFinalProps(defaultStyles, theme, componentProps, flattenedUserProps);
        if (userSlotOptions) {
          if (userSlotOptions.component) {
            var UserComponent = userSlotOptions.component;
            return reactExports.createElement(UserComponent, __assign$1({}, finalProps));
          }
          if (userSlotOptions.render) {
            return userSlotOptions.render(finalProps, DefaultComponent);
          }
        }
        return reactExports.createElement(DefaultComponent, __assign$1({}, finalProps));
      };
      return result;
    }
    var defaultFactory = memoizeFunction(function(type) {
      return createFactory(type);
    });
    function getSlots(userProps, slots) {
      var result = {};
      var mixedProps = userProps;
      var _loop_1 = function(name_12) {
        if (slots.hasOwnProperty(name_12)) {
          var slot = function(componentProps) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
              args[_i - 1] = arguments[_i];
            }
            if (args.length > 0) {
              throw new Error("Any module using getSlots must use withSlots. Please see withSlots javadoc for more info.");
            }
            return _renderSlot(
              slots[name_12],
              // TODO: this cast to any is hiding a relationship issue between the first two args
              componentProps,
              mixedProps[name_12],
              mixedProps.slots && mixedProps.slots[name_12],
              // _defaultStyles should always be present, but a check for existence is added to make view tests
              // easier to use.
              mixedProps._defaultStyles && mixedProps._defaultStyles[name_12],
              mixedProps.theme
            );
          };
          slot.isSlot = true;
          result[name_12] = slot;
        }
      };
      for (var name_1 in slots) {
        _loop_1(name_1);
      }
      return result;
    }
    function _translateShorthand(defaultProp, slotProps) {
      var _a2;
      var transformedProps;
      if (typeof slotProps === "string" || typeof slotProps === "number" || typeof slotProps === "boolean") {
        transformedProps = (_a2 = {}, _a2[defaultProp] = slotProps, _a2);
      } else {
        transformedProps = slotProps;
      }
      return transformedProps;
    }
    function _constructFinalProps(defaultStyles, theme) {
      var allProps = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        allProps[_i - 2] = arguments[_i];
      }
      var finalProps = {};
      var classNames2 = [];
      for (var _a2 = 0, allProps_1 = allProps; _a2 < allProps_1.length; _a2++) {
        var props = allProps_1[_a2];
        classNames2.push(props && props.className);
        assign$3(finalProps, props);
      }
      finalProps.className = mergeCss([defaultStyles, classNames2], { rtl: getRTL(theme) });
      return finalProps;
    }
    function _renderSlot(ComponentType, componentProps, userProps, slotOptions, defaultStyles, theme) {
      if (ComponentType.create !== void 0) {
        return ComponentType.create(componentProps, userProps, slotOptions, defaultStyles);
      } else {
        return defaultFactory(ComponentType)(componentProps, userProps, slotOptions, defaultStyles, theme);
      }
    }
    function createComponent(view, options) {
      if (options === void 0) {
        options = {};
      }
      var _a2 = options.factoryOptions, factoryOptions = _a2 === void 0 ? {} : _a2;
      var defaultProp = factoryOptions.defaultProp;
      var ResultComponent = function(componentProps) {
        var settings = _getCustomizations(options.displayName, reactExports.useContext(CustomizerContext), options.fields);
        var stateReducer = options.state;
        if (stateReducer) {
          componentProps = __assign$1(__assign$1({}, componentProps), stateReducer(componentProps));
        }
        var theme = componentProps.theme || settings.theme;
        var tokens2 = _resolveTokens(componentProps, theme, options.tokens, settings.tokens, componentProps.tokens);
        var styles2 = _resolveStyles(componentProps, theme, tokens2, options.styles, settings.styles, componentProps.styles);
        var viewProps = __assign$1(__assign$1({}, componentProps), { styles: styles2, tokens: tokens2, _defaultStyles: styles2, theme });
        return view(viewProps);
      };
      ResultComponent.displayName = options.displayName || view.name;
      if (defaultProp) {
        ResultComponent.create = createFactory(ResultComponent, { defaultProp });
      }
      assign$3(ResultComponent, options.statics);
      return ResultComponent;
    }
    function _resolveStyles(props, theme, tokens2) {
      var allStyles = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        allStyles[_i - 3] = arguments[_i];
      }
      return concatStyleSets.apply(void 0, allStyles.map(function(styles2) {
        return typeof styles2 === "function" ? styles2(props, theme, tokens2) : styles2;
      }));
    }
    function _resolveTokens(props, theme) {
      var allTokens = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        allTokens[_i - 2] = arguments[_i];
      }
      var tokens2 = {};
      for (var _a2 = 0, allTokens_1 = allTokens; _a2 < allTokens_1.length; _a2++) {
        var currentTokens = allTokens_1[_a2];
        if (currentTokens) {
          currentTokens = typeof currentTokens === "function" ? currentTokens(props, theme) : currentTokens;
          if (Array.isArray(currentTokens)) {
            currentTokens = _resolveTokens.apply(void 0, __spreadArray([props, theme], currentTokens));
          }
          assign$3(tokens2, currentTokens);
        }
      }
      return tokens2;
    }
    function _getCustomizations(displayName, context, fields) {
      var DefaultFields2 = ["theme", "styles", "tokens"];
      return Customizations.getSettings(fields || DefaultFields2, displayName, context.customizations);
    }
    var GlobalClassNames$1 = {
      root: "ms-StackItem"
    };
    var alignMap = {
      start: "flex-start",
      end: "flex-end"
    };
    var StackItemStyles = function(props, theme, tokens2) {
      var grow = props.grow, shrink = props.shrink, disableShrink = props.disableShrink, align = props.align, verticalFill = props.verticalFill, order2 = props.order, className = props.className;
      var classNames2 = getGlobalClassNames(GlobalClassNames$1, theme);
      return {
        root: [
          theme.fonts.medium,
          classNames2.root,
          {
            margin: tokens2.margin,
            padding: tokens2.padding,
            height: verticalFill ? "100%" : "auto",
            width: "auto"
          },
          grow && { flexGrow: grow === true ? 1 : grow },
          (disableShrink || !grow && !shrink) && {
            flexShrink: 0
          },
          shrink && !disableShrink && {
            flexShrink: 1
          },
          align && {
            alignSelf: alignMap[align] || align
          },
          order2 && {
            order: order2
          },
          className
        ]
        // TODO: this cast may be hiding some potential issues with styling and name
        //        lookups and should be removed
      };
    };
    var StackItemView = function(props) {
      var children = props.children;
      var nativeProps = getNativeProps$1(props, htmlElementProperties$1);
      if (children == null) {
        return null;
      }
      var Slots = getSlots(props, {
        root: "div"
      });
      return withSlots(Slots.root, __assign$1({}, nativeProps), children);
    };
    var StackItem = createComponent(StackItemView, {
      displayName: "StackItem",
      styles: StackItemStyles
    });
    var _getThemedSpacing = function(space2, theme) {
      if (theme.spacing.hasOwnProperty(space2)) {
        return theme.spacing[space2];
      }
      return space2;
    };
    var _getValueUnitGap = function(gap2) {
      var numericalPart = parseFloat(gap2);
      var numericalValue = isNaN(numericalPart) ? 0 : numericalPart;
      var numericalString = isNaN(numericalPart) ? "" : numericalPart.toString();
      var unitPart = gap2.substring(numericalString.toString().length);
      return {
        value: numericalValue,
        unit: unitPart || "px"
      };
    };
    var parseGap = function(gap2, theme) {
      if (gap2 === void 0 || gap2 === "") {
        return {
          rowGap: {
            value: 0,
            unit: "px"
          },
          columnGap: {
            value: 0,
            unit: "px"
          }
        };
      }
      if (typeof gap2 === "number") {
        return {
          rowGap: {
            value: gap2,
            unit: "px"
          },
          columnGap: {
            value: gap2,
            unit: "px"
          }
        };
      }
      var splitGap = gap2.split(" ");
      if (splitGap.length > 2) {
        return {
          rowGap: {
            value: 0,
            unit: "px"
          },
          columnGap: {
            value: 0,
            unit: "px"
          }
        };
      }
      if (splitGap.length === 2) {
        return {
          rowGap: _getValueUnitGap(_getThemedSpacing(splitGap[0], theme)),
          columnGap: _getValueUnitGap(_getThemedSpacing(splitGap[1], theme))
        };
      }
      var calculatedGap = _getValueUnitGap(_getThemedSpacing(gap2, theme));
      return {
        rowGap: calculatedGap,
        columnGap: calculatedGap
      };
    };
    var parsePadding = function(padding2, theme) {
      if (padding2 === void 0 || typeof padding2 === "number" || padding2 === "") {
        return padding2;
      }
      var paddingValues = padding2.split(" ");
      if (paddingValues.length < 2) {
        return _getThemedSpacing(padding2, theme);
      }
      return paddingValues.reduce(function(padding1, padding22) {
        return _getThemedSpacing(padding1, theme) + " " + _getThemedSpacing(padding22, theme);
      });
    };
    var nameMap = {
      start: "flex-start",
      end: "flex-end"
    };
    var GlobalClassNames = {
      root: "ms-Stack",
      inner: "ms-Stack-inner"
    };
    var styles = function(props, theme, tokens2) {
      var _a2, _b, _c, _d, _e, _f, _g;
      var verticalFill = props.verticalFill, horizontal = props.horizontal, reversed = props.reversed, grow = props.grow, wrap2 = props.wrap, horizontalAlign = props.horizontalAlign, verticalAlign = props.verticalAlign, disableShrink = props.disableShrink, className = props.className;
      var classNames2 = getGlobalClassNames(GlobalClassNames, theme);
      var childrenGap = tokens2 && tokens2.childrenGap ? tokens2.childrenGap : props.gap;
      var maxHeight = tokens2 && tokens2.maxHeight ? tokens2.maxHeight : props.maxHeight;
      var maxWidth = tokens2 && tokens2.maxWidth ? tokens2.maxWidth : props.maxWidth;
      var padding2 = tokens2 && tokens2.padding ? tokens2.padding : props.padding;
      var _h = parseGap(childrenGap, theme), rowGap = _h.rowGap, columnGap = _h.columnGap;
      var horizontalMargin = "" + -0.5 * columnGap.value + columnGap.unit;
      var verticalMargin = "" + -0.5 * rowGap.value + rowGap.unit;
      var childStyles = {
        textOverflow: "ellipsis"
      };
      var commonSelectors = {
        // flexShrink styles are applied by the StackItem
        "> *:not(.ms-StackItem)": {
          flexShrink: disableShrink ? 0 : 1
        }
      };
      if (wrap2) {
        return {
          root: [
            classNames2.root,
            {
              flexWrap: "wrap",
              maxWidth,
              maxHeight,
              width: "auto",
              overflow: "visible",
              height: "100%"
            },
            horizontalAlign && (_a2 = {}, _a2[horizontal ? "justifyContent" : "alignItems"] = nameMap[horizontalAlign] || horizontalAlign, _a2),
            verticalAlign && (_b = {}, _b[horizontal ? "alignItems" : "justifyContent"] = nameMap[verticalAlign] || verticalAlign, _b),
            className,
            {
              // not allowed to be overridden by className
              // since this is necessary in order to prevent collapsing margins
              display: "flex"
            },
            horizontal && {
              height: verticalFill ? "100%" : "auto"
            }
          ],
          inner: [
            classNames2.inner,
            {
              display: "flex",
              flexWrap: "wrap",
              marginLeft: horizontalMargin,
              marginRight: horizontalMargin,
              marginTop: verticalMargin,
              marginBottom: verticalMargin,
              overflow: "visible",
              boxSizing: "border-box",
              padding: parsePadding(padding2, theme),
              // avoid unnecessary calc() calls if horizontal gap is 0
              width: columnGap.value === 0 ? "100%" : "calc(100% + " + columnGap.value + columnGap.unit + ")",
              maxWidth: "100vw",
              selectors: __assign$1({ "> *": __assign$1({ margin: "" + 0.5 * rowGap.value + rowGap.unit + " " + 0.5 * columnGap.value + columnGap.unit }, childStyles) }, commonSelectors)
            },
            horizontalAlign && (_c = {}, _c[horizontal ? "justifyContent" : "alignItems"] = nameMap[horizontalAlign] || horizontalAlign, _c),
            verticalAlign && (_d = {}, _d[horizontal ? "alignItems" : "justifyContent"] = nameMap[verticalAlign] || verticalAlign, _d),
            horizontal && {
              flexDirection: reversed ? "row-reverse" : "row",
              // avoid unnecessary calc() calls if vertical gap is 0
              height: rowGap.value === 0 ? "100%" : "calc(100% + " + rowGap.value + rowGap.unit + ")",
              selectors: {
                "> *": {
                  maxWidth: columnGap.value === 0 ? "100%" : "calc(100% - " + columnGap.value + columnGap.unit + ")"
                }
              }
            },
            !horizontal && {
              flexDirection: reversed ? "column-reverse" : "column",
              height: "calc(100% + " + rowGap.value + rowGap.unit + ")",
              selectors: {
                "> *": {
                  maxHeight: rowGap.value === 0 ? "100%" : "calc(100% - " + rowGap.value + rowGap.unit + ")"
                }
              }
            }
          ]
        };
      }
      return {
        root: [
          classNames2.root,
          {
            display: "flex",
            flexDirection: horizontal ? reversed ? "row-reverse" : "row" : reversed ? "column-reverse" : "column",
            flexWrap: "nowrap",
            width: "auto",
            height: verticalFill ? "100%" : "auto",
            maxWidth,
            maxHeight,
            padding: parsePadding(padding2, theme),
            boxSizing: "border-box",
            selectors: __assign$1((_e = { "> *": childStyles }, _e[reversed ? "> *:not(:last-child)" : "> *:not(:first-child)"] = [
              horizontal && {
                marginLeft: "" + columnGap.value + columnGap.unit
              },
              !horizontal && {
                marginTop: "" + rowGap.value + rowGap.unit
              }
            ], _e), commonSelectors)
          },
          grow && {
            flexGrow: grow === true ? 1 : grow
          },
          horizontalAlign && (_f = {}, _f[horizontal ? "justifyContent" : "alignItems"] = nameMap[horizontalAlign] || horizontalAlign, _f),
          verticalAlign && (_g = {}, _g[horizontal ? "alignItems" : "justifyContent"] = nameMap[verticalAlign] || verticalAlign, _g),
          className
        ]
        // TODO: this cast may be hiding some potential issues with styling and name
        //        lookups and should be removed
      };
    };
    var StackView = function(props) {
      var _a2 = props.as, RootType = _a2 === void 0 ? "div" : _a2, disableShrink = props.disableShrink, wrap2 = props.wrap, rest = __rest(props, ["as", "disableShrink", "wrap"]);
      var stackChildren = reactExports.Children.toArray(props.children);
      if (stackChildren.length === 1 && reactExports.isValidElement(stackChildren[0]) && stackChildren[0].type === reactExports.Fragment) {
        stackChildren = stackChildren[0].props.children;
      }
      stackChildren = reactExports.Children.map(stackChildren, function(child, index2) {
        if (!child) {
          return null;
        }
        if (_isStackItem(child)) {
          var defaultItemProps = {
            shrink: !disableShrink
          };
          return reactExports.cloneElement(child, __assign$1(__assign$1({}, defaultItemProps), child.props));
        }
        return child;
      });
      var nativeProps = getNativeProps$1(rest, htmlElementProperties$1);
      var Slots = getSlots(props, {
        root: RootType,
        inner: "div"
      });
      if (wrap2) {
        return withSlots(
          Slots.root,
          __assign$1({}, nativeProps),
          withSlots(Slots.inner, null, stackChildren)
        );
      }
      return withSlots(Slots.root, __assign$1({}, nativeProps), stackChildren);
    };
    function _isStackItem(item) {
      return !!item && typeof item === "object" && !!item.type && // StackItem is generated by createComponent, so we need to check its displayName instead of name
      item.type.displayName === StackItem.displayName;
    }
    var StackStatics = {
      Item: StackItem
    };
    var Stack = createComponent(StackView, {
      displayName: "Stack",
      styles,
      statics: StackStatics
    });
    const positionMap = ["Top", "Right", "Bottom", "Left"];
    function generateStyles(property, suffix, ...values) {
      const [firstValue, secondValue = firstValue, thirdValue = firstValue, fourthValue = secondValue] = values;
      const valuesWithDefaults = [firstValue, secondValue, thirdValue, fourthValue];
      const styles2 = {};
      for (let i2 = 0; i2 < valuesWithDefaults.length; i2 += 1) {
        if (valuesWithDefaults[i2] || valuesWithDefaults[i2] === 0) {
          const newKey = property + positionMap[i2] + suffix;
          styles2[newKey] = valuesWithDefaults[i2];
        }
      }
      return styles2;
    }
    function borderWidth(...values) {
      return generateStyles("border", "Width", ...values);
    }
    function borderStyle(...values) {
      return generateStyles("border", "Style", ...values);
    }
    function borderColor(...values) {
      return generateStyles("border", "Color", ...values);
    }
    const LINE_STYLES = ["none", "hidden", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset"];
    function isBorderStyle(value) {
      return LINE_STYLES.includes(value);
    }
    function border(...values) {
      if (isBorderStyle(values[0])) {
        return {
          ...borderStyle(values[0]),
          ...values[1] && borderWidth(values[1]),
          ...values[2] && borderColor(values[2])
        };
      }
      return {
        ...borderWidth(values[0]),
        ...values[1] && borderStyle(values[1]),
        ...values[2] && borderColor(values[2])
      };
    }
    function borderLeft(...values) {
      if (isBorderStyle(values[0])) {
        return {
          borderLeftStyle: values[0],
          ...values[1] && {
            borderLeftWidth: values[1]
          },
          ...values[2] && {
            borderLeftColor: values[2]
          }
        };
      }
      return {
        borderLeftWidth: values[0],
        ...values[1] && {
          borderLeftStyle: values[1]
        },
        ...values[2] && {
          borderLeftColor: values[2]
        }
      };
    }
    function borderBottom(...values) {
      if (isBorderStyle(values[0])) {
        return {
          borderBottomStyle: values[0],
          ...values[1] && {
            borderBottomWidth: values[1]
          },
          ...values[2] && {
            borderBottomColor: values[2]
          }
        };
      }
      return {
        borderBottomWidth: values[0],
        ...values[1] && {
          borderBottomStyle: values[1]
        },
        ...values[2] && {
          borderBottomColor: values[2]
        }
      };
    }
    function borderRight(...values) {
      if (isBorderStyle(values[0])) {
        return {
          borderRightStyle: values[0],
          ...values[1] && {
            borderRightWidth: values[1]
          },
          ...values[2] && {
            borderRightColor: values[2]
          }
        };
      }
      return {
        borderRightWidth: values[0],
        ...values[1] && {
          borderRightStyle: values[1]
        },
        ...values[2] && {
          borderRightColor: values[2]
        }
      };
    }
    function borderTop(...values) {
      if (isBorderStyle(values[0])) {
        return {
          borderTopStyle: values[0],
          ...values[1] && {
            borderTopWidth: values[1]
          },
          ...values[2] && {
            borderTopColor: values[2]
          }
        };
      }
      return {
        borderTopWidth: values[0],
        ...values[1] && {
          borderTopStyle: values[1]
        },
        ...values[2] && {
          borderTopColor: values[2]
        }
      };
    }
    function borderRadius$1(value1, value2 = value1, value3 = value1, value4 = value2) {
      return {
        borderBottomRightRadius: value3,
        borderBottomLeftRadius: value4,
        borderTopRightRadius: value2,
        borderTopLeftRadius: value1
      };
    }
    const isUnit = (value) => typeof value === "string" && /(\d+(\w+|%))/.test(value);
    const isUnitless = (value) => typeof value === "number" && !Number.isNaN(value);
    const isInitial = (value) => value === "initial";
    const isAuto = (value) => value === "auto";
    const isNone = (value) => value === "none";
    const widthReservedKeys = ["content", "fit-content", "max-content", "min-content"];
    const isWidth = (value) => widthReservedKeys.some((key) => value === key) || isUnit(value);
    function flex(...values) {
      const isOneValueSyntax = values.length === 1;
      const isTwoValueSyntax = values.length === 2;
      const isThreeValueSyntax = values.length === 3;
      if (isOneValueSyntax) {
        const [firstValue] = values;
        if (isInitial(firstValue)) {
          return {
            flexGrow: 0,
            flexShrink: 1,
            flexBasis: "auto"
          };
        }
        if (isAuto(firstValue)) {
          return {
            flexGrow: 1,
            flexShrink: 1,
            flexBasis: "auto"
          };
        }
        if (isNone(firstValue)) {
          return {
            flexGrow: 0,
            flexShrink: 0,
            flexBasis: "auto"
          };
        }
        if (isUnitless(firstValue)) {
          return {
            flexGrow: firstValue,
            flexShrink: 1,
            flexBasis: 0
          };
        }
        if (isWidth(firstValue)) {
          return {
            flexGrow: 1,
            flexShrink: 1,
            flexBasis: firstValue
          };
        }
      }
      if (isTwoValueSyntax) {
        const [firstValue, secondValue] = values;
        if (isUnitless(secondValue)) {
          return {
            flexGrow: firstValue,
            flexShrink: secondValue,
            flexBasis: 0
          };
        }
        if (isWidth(secondValue)) {
          return {
            flexGrow: firstValue,
            flexShrink: 1,
            flexBasis: secondValue
          };
        }
      }
      if (isThreeValueSyntax) {
        const [firstValue, secondValue, thirdValue] = values;
        if (isUnitless(firstValue) && isUnitless(secondValue) && (isAuto(thirdValue) || isWidth(thirdValue))) {
          return {
            flexGrow: firstValue,
            flexShrink: secondValue,
            flexBasis: thirdValue
          };
        }
      }
      return {};
    }
    function gap(columnGap, rowGap = columnGap) {
      return {
        columnGap,
        rowGap
      };
    }
    const cssVarRegEx = /var\(.*\)/gi;
    function isValidGridAreaInput(value) {
      return value === void 0 || typeof value === "number" || typeof value === "string" && !cssVarRegEx.test(value);
    }
    const customIdentRegEx = /^[a-zA-Z0-9\-_\\#;]+$/;
    const nonCustomIdentRegEx = /^-moz-initial$|^auto$|^initial$|^inherit$|^revert$|^unset$|^span \d+$|\d.*/;
    function isCustomIdent(value) {
      return value !== void 0 && typeof value === "string" && customIdentRegEx.test(value) && !nonCustomIdentRegEx.test(value);
    }
    function gridArea(...values) {
      if (values.some((value) => !isValidGridAreaInput(value))) {
        return {};
      }
      const gridRowStart = values[0] !== void 0 ? values[0] : "auto";
      const gridColumnStart = values[1] !== void 0 ? values[1] : isCustomIdent(gridRowStart) ? gridRowStart : "auto";
      const gridRowEnd = values[2] !== void 0 ? values[2] : isCustomIdent(gridRowStart) ? gridRowStart : "auto";
      const gridColumnEnd = values[3] !== void 0 ? values[3] : isCustomIdent(gridColumnStart) ? gridColumnStart : "auto";
      return {
        gridRowStart,
        gridColumnStart,
        gridRowEnd,
        gridColumnEnd
      };
    }
    function margin(...values) {
      return generateStyles("margin", "", ...values);
    }
    function marginBlock(start, end = start) {
      return {
        marginBlockStart: start,
        marginBlockEnd: end
      };
    }
    function marginInline(start, end = start) {
      return {
        marginInlineStart: start,
        marginInlineEnd: end
      };
    }
    function padding(...values) {
      return generateStyles("padding", "", ...values);
    }
    function paddingBlock(start, end = start) {
      return {
        paddingBlockStart: start,
        paddingBlockEnd: end
      };
    }
    function paddingInline(start, end = start) {
      return {
        paddingInlineStart: start,
        paddingInlineEnd: end
      };
    }
    function overflow(overflowX, overflowY = overflowX) {
      return {
        overflowX,
        overflowY
      };
    }
    function inset(...values) {
      const [firstValue, secondValue = firstValue, thirdValue = firstValue, fourthValue = secondValue] = values;
      return {
        top: firstValue,
        right: secondValue,
        bottom: thirdValue,
        left: fourthValue
      };
    }
    function outline(outlineWidth, outlineStyle, outlineColor) {
      return {
        outlineWidth,
        ...outlineStyle && {
          outlineStyle
        },
        ...outlineColor && {
          outlineColor
        }
      };
    }
    function transition(...values) {
      if (isTransitionGlobalInputs(values)) {
        return {
          transitionDelay: values[0],
          transitionDuration: values[0],
          transitionProperty: values[0],
          transitionTimingFunction: values[0]
        };
      }
      const transitionInputs = normalizeTransitionInputs(values);
      return transitionInputs.reduce((acc, [property, duration = "0s", delay = "0s", timingFunction = "ease"], index2) => {
        if (index2 === 0) {
          acc.transitionProperty = property;
          acc.transitionDuration = duration;
          acc.transitionDelay = delay;
          acc.transitionTimingFunction = timingFunction;
        } else {
          acc.transitionProperty += `, ${property}`;
          acc.transitionDuration += `, ${duration}`;
          acc.transitionDelay += `, ${delay}`;
          acc.transitionTimingFunction += `, ${timingFunction}`;
        }
        return acc;
      }, {});
    }
    const transitionGlobalInputs = ["-moz-initial", "inherit", "initial", "revert", "unset"];
    function isTransitionGlobalInputs(values) {
      return values.length === 1 && transitionGlobalInputs.includes(values[0]);
    }
    function normalizeTransitionInputs(transitionInputs) {
      if (transitionInputs.length === 1 && Array.isArray(transitionInputs[0])) {
        return transitionInputs[0];
      }
      return [transitionInputs];
    }
    function textDecoration(value, ...values) {
      if (values.length === 0) {
        return isTextDecorationStyleInput(value) ? {
          textDecorationStyle: value
        } : {
          textDecorationLine: value
        };
      }
      const [textDecorationStyle, textDecorationColor, textDecorationThickness] = values;
      return {
        textDecorationLine: value,
        ...textDecorationStyle && {
          textDecorationStyle
        },
        ...textDecorationColor && {
          textDecorationColor
        },
        ...textDecorationThickness && {
          textDecorationThickness
        }
      };
    }
    const textDecorationStyleInputs = ["dashed", "dotted", "double", "solid", "wavy"];
    function isTextDecorationStyleInput(value) {
      return textDecorationStyleInputs.includes(value);
    }
    const __GLOBAL__$2 = typeof window === "undefined" ? global : window;
    const __NAMESPACE_PREFIX__$2 = "@griffel/";
    function getGlobalVar$2(name2, defaultValue) {
      if (!__GLOBAL__$2[Symbol.for(__NAMESPACE_PREFIX__$2 + name2)]) {
        __GLOBAL__$2[Symbol.for(__NAMESPACE_PREFIX__$2 + name2)] = defaultValue;
      }
      return __GLOBAL__$2[Symbol.for(__NAMESPACE_PREFIX__$2 + name2)];
    }
    const DEFINITION_LOOKUP_TABLE$2 = /* @__PURE__ */ getGlobalVar$2("DEFINITION_LOOKUP_TABLE", {});
    const DATA_BUCKET_ATTR$1 = "data-make-styles-bucket";
    const HASH_PREFIX = "f";
    const SEQUENCE_HASH_LENGTH$2 = 7;
    const SEQUENCE_PREFIX$2 = "___";
    const SEQUENCE_SIZE$2 = SEQUENCE_PREFIX$2.length + SEQUENCE_HASH_LENGTH$2;
    const LOOKUP_DEFINITIONS_INDEX$2 = 0;
    const LOOKUP_DIR_INDEX$2 = 1;
    const UNSUPPORTED_CSS_PROPERTIES = {
      all: 1,
      animation: 1,
      background: 1,
      backgroundPosition: 1,
      border: 1,
      borderBlock: 1,
      borderBlockEnd: 1,
      borderBlockStart: 1,
      borderBottom: 1,
      borderColor: 1,
      borderImage: 1,
      borderInline: 1,
      borderInlineEnd: 1,
      borderInlineStart: 1,
      borderLeft: 1,
      borderRadius: 1,
      borderRight: 1,
      borderStyle: 1,
      borderTop: 1,
      borderWidth: 1,
      caret: 1,
      columns: 1,
      columnRule: 1,
      containIntrinsicSize: 1,
      container: 1,
      flex: 1,
      flexFlow: 1,
      font: 1,
      gap: 1,
      grid: 1,
      gridArea: 1,
      gridColumn: 1,
      gridRow: 1,
      gridTemplate: 1,
      inset: 1,
      insetBlock: 1,
      insetInline: 1,
      lineClamp: 1,
      listStyle: 1,
      margin: 1,
      marginBlock: 1,
      marginInline: 1,
      mask: 1,
      maskBorder: 1,
      motion: 1,
      offset: 1,
      outline: 1,
      overflow: 1,
      overscrollBehavior: 1,
      padding: 1,
      paddingBlock: 1,
      paddingInline: 1,
      placeItems: 1,
      placeContent: 1,
      placeSelf: 1,
      scrollMargin: 1,
      scrollMarginBlock: 1,
      scrollMarginInline: 1,
      scrollPadding: 1,
      scrollPaddingBlock: 1,
      scrollPaddingInline: 1,
      scrollSnapMargin: 1,
      scrollTimeline: 1,
      textDecoration: 1,
      textEmphasis: 1,
      transition: 1
    };
    function murmur2$1(str) {
      var h2 = 0;
      var k2, i2 = 0, len = str.length;
      for (; len >= 4; ++i2, len -= 4) {
        k2 = str.charCodeAt(i2) & 255 | (str.charCodeAt(++i2) & 255) << 8 | (str.charCodeAt(++i2) & 255) << 16 | (str.charCodeAt(++i2) & 255) << 24;
        k2 = /* Math.imul(k, m): */
        (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
        k2 ^= /* k >>> r: */
        k2 >>> 24;
        h2 = /* Math.imul(k, m): */
        (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
        (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      }
      switch (len) {
        case 3:
          h2 ^= (str.charCodeAt(i2 + 2) & 255) << 16;
        case 2:
          h2 ^= (str.charCodeAt(i2 + 1) & 255) << 8;
        case 1:
          h2 ^= str.charCodeAt(i2) & 255;
          h2 = /* Math.imul(h, m): */
          (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      }
      h2 ^= h2 >>> 13;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
    }
    function padEndHash$2(value) {
      const hashLength = value.length;
      if (hashLength === SEQUENCE_HASH_LENGTH$2) {
        return value;
      }
      for (let i2 = hashLength; i2 < SEQUENCE_HASH_LENGTH$2; i2++) {
        value += "0";
      }
      return value;
    }
    function hashSequence$2(classes, dir, sequenceIds = []) {
      {
        return SEQUENCE_PREFIX$2 + padEndHash$2(murmur2$1(classes + dir));
      }
    }
    function reduceToClassName$2(classMap, dir) {
      let className = "";
      for (const propertyHash in classMap) {
        const classNameMapping = classMap[propertyHash];
        if (classNameMapping) {
          const hasRTLClassName = Array.isArray(classNameMapping);
          if (dir === "rtl") {
            className += (hasRTLClassName ? classNameMapping[1] : classNameMapping) + " ";
          } else {
            className += (hasRTLClassName ? classNameMapping[0] : classNameMapping) + " ";
          }
        }
      }
      return className.slice(0, -1);
    }
    function reduceToClassNameForSlots$2(classesMapBySlot, dir) {
      const classNamesForSlots = {};
      for (const slotName in classesMapBySlot) {
        const slotClasses = reduceToClassName$2(classesMapBySlot[slotName], dir);
        if (slotClasses === "") {
          classNamesForSlots[slotName] = "";
          continue;
        }
        const sequenceHash = hashSequence$2(slotClasses, dir);
        const resultSlotClasses = sequenceHash + " " + slotClasses;
        DEFINITION_LOOKUP_TABLE$2[sequenceHash] = [classesMapBySlot[slotName], dir];
        classNamesForSlots[slotName] = resultSlotClasses;
      }
      return classNamesForSlots;
    }
    const mergeClassesCachedResults$2 = {};
    function mergeClasses$2() {
      let dir = null;
      let resultClassName = "";
      let sequenceMatch = "";
      const sequencesIds = new Array(arguments.length);
      for (let i2 = 0; i2 < arguments.length; i2++) {
        const className = arguments[i2];
        if (typeof className === "string" && className !== "") {
          const sequenceIndex = className.indexOf(SEQUENCE_PREFIX$2);
          if (sequenceIndex === -1) {
            resultClassName += className + " ";
          } else {
            const sequenceId = className.substr(sequenceIndex, SEQUENCE_SIZE$2);
            if (sequenceIndex > 0) {
              resultClassName += className.slice(0, sequenceIndex);
            }
            sequenceMatch += sequenceId;
            sequencesIds[i2] = sequenceId;
          }
        }
      }
      if (sequenceMatch === "") {
        return resultClassName.slice(0, -1);
      }
      const mergeClassesResult = mergeClassesCachedResults$2[sequenceMatch];
      if (mergeClassesResult !== void 0) {
        return resultClassName + mergeClassesResult;
      }
      const sequenceMappings = [];
      for (let i2 = 0; i2 < arguments.length; i2++) {
        const sequenceId = sequencesIds[i2];
        if (sequenceId) {
          const sequenceMapping = DEFINITION_LOOKUP_TABLE$2[sequenceId];
          if (sequenceMapping) {
            sequenceMappings.push(sequenceMapping[LOOKUP_DEFINITIONS_INDEX$2]);
            dir = sequenceMapping[LOOKUP_DIR_INDEX$2];
          }
        }
      }
      const resultDefinitions = Object.assign.apply(
        Object,
        // .assign() mutates the first object, we can't mutate mappings as it will produce invalid results later
        [{}].concat(sequenceMappings)
      );
      let atomicClassNames = reduceToClassName$2(resultDefinitions, dir);
      const newSequenceHash = hashSequence$2(atomicClassNames, dir, sequencesIds);
      atomicClassNames = newSequenceHash + " " + atomicClassNames;
      mergeClassesCachedResults$2[sequenceMatch] = atomicClassNames;
      DEFINITION_LOOKUP_TABLE$2[newSequenceHash] = [resultDefinitions, dir];
      return resultClassName + atomicClassNames;
    }
    const sequenceDetails$1 = {};
    const cssRules$1 = /* @__PURE__ */ new Set();
    const debugData$1 = {
      getChildrenSequences: (debugSequenceHash) => {
        const key = Object.keys(mergeClassesCachedResults$2).find((key2) => mergeClassesCachedResults$2[key2].startsWith(debugSequenceHash));
        if (key) {
          return key.split(SEQUENCE_PREFIX$2).filter((sequence) => sequence.length).map((sequence) => SEQUENCE_PREFIX$2 + sequence);
        }
        return [];
      },
      addCSSRule: (rule) => {
        cssRules$1.add(rule);
      },
      addSequenceDetails: (classNamesForSlots, sourceURL) => {
        Object.entries(classNamesForSlots).forEach(([slotName, sequenceHash]) => {
          sequenceDetails$1[sequenceHash.substring(0, SEQUENCE_SIZE$2)] = {
            slotName,
            sourceURL
          };
        });
      },
      getCSSRules: () => {
        return Array.from(cssRules$1);
      },
      getSequenceDetails: (sequenceHash) => {
        return sequenceDetails$1[sequenceHash];
      }
    };
    function getDirectionalClassName$1(classes, direction) {
      return Array.isArray(classes) ? direction === "rtl" ? classes[1] : classes[0] : classes;
    }
    function getDebugClassNames$1(lookupItem, parentLookupItem, parentDebugClassNames, overridingSiblings) {
      const classesMapping = lookupItem[0];
      const direction = lookupItem[1];
      return Object.entries(classesMapping).map(([propertyHash, classes]) => {
        const className = getDirectionalClassName$1(classes, direction);
        let overriddenBy;
        if (parentDebugClassNames && parentLookupItem) {
          const matching = parentDebugClassNames.find(({
            className: parentClassName
          }) => parentClassName === className);
          if (!matching && parentLookupItem[0][propertyHash]) {
            overriddenBy = getDirectionalClassName$1(parentLookupItem[0][propertyHash], parentLookupItem[1]);
          } else if (matching && parentLookupItem[0][propertyHash]) {
            const siblingHasSameRule = overridingSiblings ? overridingSiblings.filter(({
              debugClassNames
            }) => debugClassNames.filter(({
              className: siblingClassName
            }) => siblingClassName === className).length > 0).length > 0 : false;
            overriddenBy = siblingHasSameRule ? matching.className : matching.overriddenBy;
          } else if (!matching && !parentLookupItem[0][propertyHash]) {
            overriddenBy = void 0;
          } else if (matching && !parentLookupItem[0][propertyHash]) {
            overriddenBy = void 0;
          }
        }
        return {
          className,
          overriddenBy
        };
      });
    }
    function getDebugTree$1(debugSequenceHash, parentNode) {
      const lookupItem = DEFINITION_LOOKUP_TABLE$2[debugSequenceHash];
      if (lookupItem === void 0) {
        return void 0;
      }
      const parentLookupItem = parentNode ? DEFINITION_LOOKUP_TABLE$2[parentNode.sequenceHash] : void 0;
      const debugClassNames = getDebugClassNames$1(lookupItem, parentLookupItem, parentNode === null || parentNode === void 0 ? void 0 : parentNode.debugClassNames, parentNode === null || parentNode === void 0 ? void 0 : parentNode.children);
      const node2 = {
        sequenceHash: debugSequenceHash,
        direction: lookupItem[1],
        children: [],
        debugClassNames
      };
      const childrenSequences = debugData$1.getChildrenSequences(node2.sequenceHash);
      childrenSequences.reverse().forEach((sequence) => {
        const child = getDebugTree$1(sequence, node2);
        if (child) {
          node2.children.push(child);
        }
      });
      if (!node2.children.length) {
        node2.rules = {};
        node2.debugClassNames.forEach(({
          className
        }) => {
          const mapData = debugData$1.getSequenceDetails(debugSequenceHash);
          if (mapData) {
            node2.slot = mapData.slotName;
            node2.sourceURL = mapData.sourceURL;
          }
          const cssRule = debugData$1.getCSSRules().find((cssRule2) => {
            return cssRule2.includes(className);
          });
          node2.rules[className] = cssRule;
        });
      }
      return node2;
    }
    function injectDevTools$1(document2) {
      const window2 = document2.defaultView;
      if (!window2 || window2.__GRIFFEL_DEVTOOLS__) {
        return;
      }
      const devtools = {
        getInfo: (element2) => {
          const rootDebugSequenceHash = Array.from(element2.classList).find((className) => className.startsWith(SEQUENCE_PREFIX$2));
          if (rootDebugSequenceHash === void 0) {
            return void 0;
          }
          return getDebugTree$1(rootDebugSequenceHash);
        }
      };
      Object.defineProperty(window2, "__GRIFFEL_DEVTOOLS__", {
        configurable: false,
        enumerable: false,
        get() {
          return devtools;
        }
      });
    }
    const isDevToolsEnabled$1 = /* @__PURE__ */ (() => {
      var _a2;
      try {
        return Boolean(typeof window !== "undefined" && ((_a2 = window.sessionStorage) === null || _a2 === void 0 ? void 0 : _a2.getItem("__GRIFFEL_DEVTOOLS__")));
      } catch (e2) {
        return false;
      }
    })();
    function normalizeCSSBucketEntry$1(entry) {
      if (!Array.isArray(entry)) {
        return [entry];
      }
      return entry;
    }
    function createIsomorphicStyleSheet$1(styleElement, bucketName, elementAttributes) {
      const __cssRulesForSSR = [];
      elementAttributes[DATA_BUCKET_ATTR$1] = bucketName;
      if (styleElement) {
        for (const attrName in elementAttributes) {
          styleElement.setAttribute(attrName, elementAttributes[attrName]);
        }
      }
      function insertRule(rule) {
        if (styleElement === null || styleElement === void 0 ? void 0 : styleElement.sheet) {
          return styleElement.sheet.insertRule(rule, styleElement.sheet.cssRules.length);
        }
        return __cssRulesForSSR.push(rule);
      }
      return {
        elementAttributes,
        insertRule,
        element: styleElement,
        bucketName,
        cssRules() {
          if (styleElement === null || styleElement === void 0 ? void 0 : styleElement.sheet) {
            return Array.from(styleElement.sheet.cssRules).map((cssRule) => cssRule.cssText);
          }
          return __cssRulesForSSR;
        }
      };
    }
    const styleBucketOrdering$1 = [
      // reset styles
      "r",
      // catch-all
      "d",
      // link
      "l",
      // visited
      "v",
      // focus-within
      "w",
      // focus
      "f",
      // focus-visible
      "i",
      // hover
      "h",
      // active
      "a",
      // at rules for reset styles
      "s",
      // keyframes
      "k",
      // at-rules
      "t",
      // @media rules
      "m",
      // @container rules
      "c"
    ];
    const styleBucketOrderingMap$1 = /* @__PURE__ */ styleBucketOrdering$1.reduce((acc, cur, j) => {
      acc[cur] = j;
      return acc;
    }, {});
    function getStyleSheetForBucket$1(bucketName, targetDocument, insertionPoint, renderer, metadata = {}) {
      const isMediaBucket = bucketName === "m";
      const stylesheetKey = isMediaBucket ? bucketName + metadata["m"] : bucketName;
      if (!renderer.stylesheets[stylesheetKey]) {
        const tag = targetDocument && targetDocument.createElement("style");
        const stylesheet2 = createIsomorphicStyleSheet$1(tag, bucketName, {
          ...renderer.styleElementAttributes,
          ...isMediaBucket && {
            media: metadata["m"]
          }
        });
        renderer.stylesheets[stylesheetKey] = stylesheet2;
        if (targetDocument && tag) {
          targetDocument.head.insertBefore(tag, findInsertionPoint(targetDocument, insertionPoint, bucketName, renderer, metadata));
        }
      }
      return renderer.stylesheets[stylesheetKey];
    }
    function findInsertionPoint(targetDocument, insertionPoint, targetBucket, renderer, metadata) {
      const targetOrder = styleBucketOrderingMap$1[targetBucket];
      let comparer = (el) => targetOrder - styleBucketOrderingMap$1[el.getAttribute(DATA_BUCKET_ATTR$1)];
      let styleElements = targetDocument.head.querySelectorAll(`[${DATA_BUCKET_ATTR$1}]`);
      if (targetBucket === "m" && metadata) {
        const mediaElements = targetDocument.head.querySelectorAll(`[${DATA_BUCKET_ATTR$1}="${targetBucket}"]`);
        if (mediaElements.length) {
          styleElements = mediaElements;
          comparer = (el) => renderer.compareMediaQueries(metadata["m"], el.media);
        }
      }
      const length2 = styleElements.length;
      let index2 = length2 - 1;
      while (index2 >= 0) {
        const styleElement = styleElements.item(index2);
        if (comparer(styleElement) > 0) {
          return styleElement.nextSibling;
        }
        index2--;
      }
      if (length2 > 0) {
        return styleElements.item(0);
      }
      return insertionPoint ? insertionPoint.nextSibling : null;
    }
    function safeInsertRule(sheet, ruleCSS) {
      try {
        sheet.insertRule(ruleCSS);
      } catch (e2) {
      }
    }
    let lastIndex$1 = 0;
    const defaultCompareMediaQueries$1 = (a2, b2) => a2 < b2 ? -1 : a2 > b2 ? 1 : 0;
    function createDOMRenderer$1(targetDocument = typeof document === "undefined" ? void 0 : document, options = {}) {
      const {
        unstable_filterCSSRule,
        insertionPoint,
        styleElementAttributes,
        compareMediaQueries = defaultCompareMediaQueries$1
      } = options;
      const renderer = {
        insertionCache: {},
        stylesheets: {},
        styleElementAttributes: Object.freeze(styleElementAttributes),
        compareMediaQueries,
        id: `d${lastIndex$1++}`,
        insertCSSRules(cssRules2) {
          for (const styleBucketName in cssRules2) {
            const cssRulesForBucket = cssRules2[styleBucketName];
            for (let i2 = 0, l2 = cssRulesForBucket.length; i2 < l2; i2++) {
              const [ruleCSS, metadata] = normalizeCSSBucketEntry$1(cssRulesForBucket[i2]);
              const sheet = getStyleSheetForBucket$1(styleBucketName, targetDocument, insertionPoint || null, renderer, metadata);
              if (renderer.insertionCache[ruleCSS]) {
                continue;
              }
              renderer.insertionCache[ruleCSS] = styleBucketName;
              if (unstable_filterCSSRule) {
                if (unstable_filterCSSRule(ruleCSS)) {
                  safeInsertRule(sheet, ruleCSS);
                }
              } else {
                safeInsertRule(sheet, ruleCSS);
              }
            }
          }
        }
      };
      if (targetDocument && false) {
        injectDevTools$1(targetDocument);
      }
      return renderer;
    }
    const insertionFactory$2 = () => {
      const insertionCache = {};
      return function insertStyles(renderer, cssRules2) {
        if (insertionCache[renderer.id] === void 0) {
          renderer.insertCSSRules(cssRules2);
          insertionCache[renderer.id] = true;
        }
      };
    };
    function arrayToObject(array) {
      return array.reduce(function(obj, _ref) {
        var prop1 = _ref[0], prop2 = _ref[1];
        obj[prop1] = prop2;
        obj[prop2] = prop1;
        return obj;
      }, {});
    }
    function isBoolean(val) {
      return typeof val === "boolean";
    }
    function isFunction$2(val) {
      return typeof val === "function";
    }
    function isNumber$2(val) {
      return typeof val === "number";
    }
    function isNullOrUndefined(val) {
      return val === null || typeof val === "undefined";
    }
    function isObject$3(val) {
      return val && typeof val === "object";
    }
    function isString$2(val) {
      return typeof val === "string";
    }
    function includes(inclusive, inclusee) {
      return inclusive.indexOf(inclusee) !== -1;
    }
    function flipSign(value) {
      if (parseFloat(value) === 0) {
        return value;
      }
      if (value[0] === "-") {
        return value.slice(1);
      }
      return "-" + value;
    }
    function flipTransformSign(match5, prefix2, offset2, suffix) {
      return prefix2 + flipSign(offset2) + suffix;
    }
    function calculateNewBackgroundPosition(value) {
      var idx = value.indexOf(".");
      if (idx === -1) {
        value = 100 - parseFloat(value) + "%";
      } else {
        var len = value.length - idx - 2;
        value = 100 - parseFloat(value);
        value = value.toFixed(len) + "%";
      }
      return value;
    }
    function getValuesAsList(value) {
      return value.replace(/ +/g, " ").split(" ").map(function(i2) {
        return i2.trim();
      }).filter(Boolean).reduce(function(_ref2, item) {
        var list2 = _ref2.list, state = _ref2.state;
        var openParansCount = (item.match(/\(/g) || []).length;
        var closedParansCount = (item.match(/\)/g) || []).length;
        if (state.parensDepth > 0) {
          list2[list2.length - 1] = list2[list2.length - 1] + " " + item;
        } else {
          list2.push(item);
        }
        state.parensDepth += openParansCount - closedParansCount;
        return {
          list: list2,
          state
        };
      }, {
        list: [],
        state: {
          parensDepth: 0
        }
      }).list;
    }
    function handleQuartetValues(value) {
      var splitValues = getValuesAsList(value);
      if (splitValues.length <= 3 || splitValues.length > 4) {
        return value;
      }
      var top = splitValues[0], right = splitValues[1], bottom = splitValues[2], left = splitValues[3];
      return [top, left, bottom, right].join(" ");
    }
    function canConvertValue(value) {
      return !isBoolean(value) && !isNullOrUndefined(value);
    }
    function splitShadow(value) {
      var shadows = [];
      var start = 0;
      var end = 0;
      var rgba = false;
      while (end < value.length) {
        if (!rgba && value[end] === ",") {
          shadows.push(value.substring(start, end).trim());
          end++;
          start = end;
        } else if (value[end] === "(") {
          rgba = true;
          end++;
        } else if (value[end] === ")") {
          rgba = false;
          end++;
        } else {
          end++;
        }
      }
      if (start != end) {
        shadows.push(value.substring(start, end + 1));
      }
      return shadows;
    }
    var propertyValueConverters = {
      padding: function padding2(_ref) {
        var value = _ref.value;
        if (isNumber$2(value)) {
          return value;
        }
        return handleQuartetValues(value);
      },
      textShadow: function textShadow(_ref2) {
        var value = _ref2.value;
        var flippedShadows = splitShadow(value).map(function(shadow) {
          return shadow.replace(/(^|\s)(-*)([.|\d]+)/, function(match5, whiteSpace, negative, number2) {
            if (number2 === "0") {
              return match5;
            }
            var doubleNegative = negative === "" ? "-" : "";
            return "" + whiteSpace + doubleNegative + number2;
          });
        });
        return flippedShadows.join(",");
      },
      borderColor: function borderColor2(_ref3) {
        var value = _ref3.value;
        return handleQuartetValues(value);
      },
      borderRadius: function borderRadius2(_ref4) {
        var value = _ref4.value;
        if (isNumber$2(value)) {
          return value;
        }
        if (includes(value, "/")) {
          var _value$split = value.split("/"), radius1 = _value$split[0], radius2 = _value$split[1];
          var convertedRadius1 = propertyValueConverters.borderRadius({
            value: radius1.trim()
          });
          var convertedRadius2 = propertyValueConverters.borderRadius({
            value: radius2.trim()
          });
          return convertedRadius1 + " / " + convertedRadius2;
        }
        var splitValues = getValuesAsList(value);
        switch (splitValues.length) {
          case 2: {
            return splitValues.reverse().join(" ");
          }
          case 4: {
            var topLeft = splitValues[0], topRight = splitValues[1], bottomRight = splitValues[2], bottomLeft = splitValues[3];
            return [topRight, topLeft, bottomLeft, bottomRight].join(" ");
          }
          default: {
            return value;
          }
        }
      },
      background: function background(_ref5) {
        var value = _ref5.value, valuesToConvert2 = _ref5.valuesToConvert, isRtl = _ref5.isRtl, bgImgDirectionRegex2 = _ref5.bgImgDirectionRegex, bgPosDirectionRegex2 = _ref5.bgPosDirectionRegex;
        if (isNumber$2(value)) {
          return value;
        }
        var backgroundPositionValue = value.replace(/(url\(.*?\))|(rgba?\(.*?\))|(hsl\(.*?\))|(#[a-fA-F0-9]+)|((^| )(\D)+( |$))/g, "").trim();
        value = value.replace(backgroundPositionValue, propertyValueConverters.backgroundPosition({
          value: backgroundPositionValue,
          valuesToConvert: valuesToConvert2,
          isRtl,
          bgPosDirectionRegex: bgPosDirectionRegex2
        }));
        return propertyValueConverters.backgroundImage({
          value,
          valuesToConvert: valuesToConvert2,
          bgImgDirectionRegex: bgImgDirectionRegex2
        });
      },
      backgroundImage: function backgroundImage(_ref6) {
        var value = _ref6.value, valuesToConvert2 = _ref6.valuesToConvert, bgImgDirectionRegex2 = _ref6.bgImgDirectionRegex;
        if (!includes(value, "url(") && !includes(value, "linear-gradient(")) {
          return value;
        }
        return value.replace(bgImgDirectionRegex2, function(match5, g1, group2) {
          return match5.replace(group2, valuesToConvert2[group2]);
        });
      },
      backgroundPosition: function backgroundPosition(_ref7) {
        var value = _ref7.value, valuesToConvert2 = _ref7.valuesToConvert, isRtl = _ref7.isRtl, bgPosDirectionRegex2 = _ref7.bgPosDirectionRegex;
        return value.replace(isRtl ? /^((-|\d|\.)+%)/ : null, function(match5, group) {
          return calculateNewBackgroundPosition(group);
        }).replace(bgPosDirectionRegex2, function(match5) {
          return valuesToConvert2[match5];
        });
      },
      backgroundPositionX: function backgroundPositionX(_ref8) {
        var value = _ref8.value, valuesToConvert2 = _ref8.valuesToConvert, isRtl = _ref8.isRtl, bgPosDirectionRegex2 = _ref8.bgPosDirectionRegex;
        if (isNumber$2(value)) {
          return value;
        }
        return propertyValueConverters.backgroundPosition({
          value,
          valuesToConvert: valuesToConvert2,
          isRtl,
          bgPosDirectionRegex: bgPosDirectionRegex2
        });
      },
      transition: function transition2(_ref9) {
        var value = _ref9.value, propertiesToConvert2 = _ref9.propertiesToConvert;
        return value.split(/,\s*/g).map(function(transition3) {
          var values = transition3.split(" ");
          values[0] = propertiesToConvert2[values[0]] || values[0];
          return values.join(" ");
        }).join(", ");
      },
      transitionProperty: function transitionProperty(_ref10) {
        var value = _ref10.value, propertiesToConvert2 = _ref10.propertiesToConvert;
        return value.split(/,\s*/g).map(function(prop) {
          return propertiesToConvert2[prop] || prop;
        }).join(", ");
      },
      transform: function transform2(_ref11) {
        var value = _ref11.value;
        var nonAsciiPattern = "[^\\u0020-\\u007e]";
        var escapePattern = "(?:(?:(?:\\[0-9a-f]{1,6})(?:\\r\\n|\\s)?)|\\\\[^\\r\\n\\f0-9a-f])";
        var signedQuantPattern = "((?:-?" + ("(?:[0-9]*\\.[0-9]+|[0-9]+)(?:\\s*(?:em|ex|px|cm|mm|in|pt|pc|deg|rad|grad|ms|s|hz|khz|%)|" + ("-?" + ("(?:[_a-z]|" + nonAsciiPattern + "|" + escapePattern + ")") + ("(?:[_a-z0-9-]|" + nonAsciiPattern + "|" + escapePattern + ")") + "*") + ")?") + ")|(?:inherit|auto))";
        var translateXRegExp = new RegExp("(translateX\\s*\\(\\s*)" + signedQuantPattern + "(\\s*\\))", "gi");
        var translateRegExp = new RegExp("(translate\\s*\\(\\s*)" + signedQuantPattern + "((?:\\s*,\\s*" + signedQuantPattern + "){0,1}\\s*\\))", "gi");
        var translate3dRegExp = new RegExp("(translate3d\\s*\\(\\s*)" + signedQuantPattern + "((?:\\s*,\\s*" + signedQuantPattern + "){0,2}\\s*\\))", "gi");
        var rotateRegExp = new RegExp("(rotate[ZY]?\\s*\\(\\s*)" + signedQuantPattern + "(\\s*\\))", "gi");
        return value.replace(translateXRegExp, flipTransformSign).replace(translateRegExp, flipTransformSign).replace(translate3dRegExp, flipTransformSign).replace(rotateRegExp, flipTransformSign);
      }
    };
    propertyValueConverters.objectPosition = propertyValueConverters.backgroundPosition;
    propertyValueConverters.margin = propertyValueConverters.padding;
    propertyValueConverters.borderWidth = propertyValueConverters.padding;
    propertyValueConverters.boxShadow = propertyValueConverters.textShadow;
    propertyValueConverters.webkitBoxShadow = propertyValueConverters.boxShadow;
    propertyValueConverters.mozBoxShadow = propertyValueConverters.boxShadow;
    propertyValueConverters.WebkitBoxShadow = propertyValueConverters.boxShadow;
    propertyValueConverters.MozBoxShadow = propertyValueConverters.boxShadow;
    propertyValueConverters.borderStyle = propertyValueConverters.borderColor;
    propertyValueConverters.webkitTransform = propertyValueConverters.transform;
    propertyValueConverters.mozTransform = propertyValueConverters.transform;
    propertyValueConverters.WebkitTransform = propertyValueConverters.transform;
    propertyValueConverters.MozTransform = propertyValueConverters.transform;
    propertyValueConverters.transformOrigin = propertyValueConverters.backgroundPosition;
    propertyValueConverters.webkitTransformOrigin = propertyValueConverters.transformOrigin;
    propertyValueConverters.mozTransformOrigin = propertyValueConverters.transformOrigin;
    propertyValueConverters.WebkitTransformOrigin = propertyValueConverters.transformOrigin;
    propertyValueConverters.MozTransformOrigin = propertyValueConverters.transformOrigin;
    propertyValueConverters.webkitTransition = propertyValueConverters.transition;
    propertyValueConverters.mozTransition = propertyValueConverters.transition;
    propertyValueConverters.WebkitTransition = propertyValueConverters.transition;
    propertyValueConverters.MozTransition = propertyValueConverters.transition;
    propertyValueConverters.webkitTransitionProperty = propertyValueConverters.transitionProperty;
    propertyValueConverters.mozTransitionProperty = propertyValueConverters.transitionProperty;
    propertyValueConverters.WebkitTransitionProperty = propertyValueConverters.transitionProperty;
    propertyValueConverters.MozTransitionProperty = propertyValueConverters.transitionProperty;
    propertyValueConverters["text-shadow"] = propertyValueConverters.textShadow;
    propertyValueConverters["border-color"] = propertyValueConverters.borderColor;
    propertyValueConverters["border-radius"] = propertyValueConverters.borderRadius;
    propertyValueConverters["background-image"] = propertyValueConverters.backgroundImage;
    propertyValueConverters["background-position"] = propertyValueConverters.backgroundPosition;
    propertyValueConverters["background-position-x"] = propertyValueConverters.backgroundPositionX;
    propertyValueConverters["object-position"] = propertyValueConverters.objectPosition;
    propertyValueConverters["border-width"] = propertyValueConverters.padding;
    propertyValueConverters["box-shadow"] = propertyValueConverters.textShadow;
    propertyValueConverters["-webkit-box-shadow"] = propertyValueConverters.textShadow;
    propertyValueConverters["-moz-box-shadow"] = propertyValueConverters.textShadow;
    propertyValueConverters["border-style"] = propertyValueConverters.borderColor;
    propertyValueConverters["-webkit-transform"] = propertyValueConverters.transform;
    propertyValueConverters["-moz-transform"] = propertyValueConverters.transform;
    propertyValueConverters["transform-origin"] = propertyValueConverters.transformOrigin;
    propertyValueConverters["-webkit-transform-origin"] = propertyValueConverters.transformOrigin;
    propertyValueConverters["-moz-transform-origin"] = propertyValueConverters.transformOrigin;
    propertyValueConverters["-webkit-transition"] = propertyValueConverters.transition;
    propertyValueConverters["-moz-transition"] = propertyValueConverters.transition;
    propertyValueConverters["transition-property"] = propertyValueConverters.transitionProperty;
    propertyValueConverters["-webkit-transition-property"] = propertyValueConverters.transitionProperty;
    propertyValueConverters["-moz-transition-property"] = propertyValueConverters.transitionProperty;
    var propertiesToConvert = arrayToObject([
      ["paddingLeft", "paddingRight"],
      ["marginLeft", "marginRight"],
      ["left", "right"],
      ["borderLeft", "borderRight"],
      ["borderLeftColor", "borderRightColor"],
      ["borderLeftStyle", "borderRightStyle"],
      ["borderLeftWidth", "borderRightWidth"],
      ["borderTopLeftRadius", "borderTopRightRadius"],
      ["borderBottomLeftRadius", "borderBottomRightRadius"],
      // kebab-case versions
      ["padding-left", "padding-right"],
      ["margin-left", "margin-right"],
      ["border-left", "border-right"],
      ["border-left-color", "border-right-color"],
      ["border-left-style", "border-right-style"],
      ["border-left-width", "border-right-width"],
      ["border-top-left-radius", "border-top-right-radius"],
      ["border-bottom-left-radius", "border-bottom-right-radius"]
    ]);
    var propsToIgnore = ["content"];
    var valuesToConvert = arrayToObject([["ltr", "rtl"], ["left", "right"], ["w-resize", "e-resize"], ["sw-resize", "se-resize"], ["nw-resize", "ne-resize"]]);
    var bgImgDirectionRegex = new RegExp("(^|\\W|_)((ltr)|(rtl)|(left)|(right))(\\W|_|$)", "g");
    var bgPosDirectionRegex = new RegExp("(left)|(right)");
    function convert$1(object) {
      return Object.keys(object).reduce(function(newObj, originalKey) {
        var originalValue = object[originalKey];
        if (isString$2(originalValue)) {
          originalValue = originalValue.trim();
        }
        if (includes(propsToIgnore, originalKey)) {
          newObj[originalKey] = originalValue;
          return newObj;
        }
        var _convertProperty = convertProperty(originalKey, originalValue), key = _convertProperty.key, value = _convertProperty.value;
        newObj[key] = value;
        return newObj;
      }, Array.isArray(object) ? [] : {});
    }
    function convertProperty(originalKey, originalValue) {
      var isNoFlip = /\/\*\s?@noflip\s?\*\//.test(originalValue);
      var key = isNoFlip ? originalKey : getPropertyDoppelganger(originalKey);
      var value = isNoFlip ? originalValue : getValueDoppelganger(key, originalValue);
      return {
        key,
        value
      };
    }
    function getPropertyDoppelganger(property) {
      return propertiesToConvert[property] || property;
    }
    function getValueDoppelganger(key, originalValue) {
      if (!canConvertValue(originalValue)) {
        return originalValue;
      }
      if (isObject$3(originalValue)) {
        return convert$1(originalValue);
      }
      var isNum = isNumber$2(originalValue);
      var isFunc = isFunction$2(originalValue);
      var importantlessValue = isNum || isFunc ? originalValue : originalValue.replace(/ !important.*?$/, "");
      var isImportant = !isNum && importantlessValue.length !== originalValue.length;
      var valueConverter = propertyValueConverters[key];
      var newValue;
      if (valueConverter) {
        newValue = valueConverter({
          value: importantlessValue,
          valuesToConvert,
          propertiesToConvert,
          isRtl: true,
          bgImgDirectionRegex,
          bgPosDirectionRegex
        });
      } else {
        newValue = valuesToConvert[importantlessValue] || importantlessValue;
      }
      if (isImportant) {
        return newValue + " !important";
      }
      return newValue;
    }
    const uppercasePattern = /[A-Z]/g;
    const msPattern = /^ms-/;
    const cache$1 = {};
    function toHyphenLower(match5) {
      return "-" + match5.toLowerCase();
    }
    function hyphenateProperty(name2) {
      if (Object.prototype.hasOwnProperty.call(cache$1, name2)) {
        return cache$1[name2];
      }
      if (name2.substr(0, 2) === "--") {
        return name2;
      }
      const hName = name2.replace(uppercasePattern, toHyphenLower);
      return cache$1[name2] = msPattern.test(hName) ? "-" + hName : hName;
    }
    function normalizeNestedProperty(nestedProperty) {
      if (nestedProperty.charAt(0) === "&") {
        return nestedProperty.slice(1);
      }
      return nestedProperty;
    }
    var MS = "-ms-";
    var MOZ = "-moz-";
    var WEBKIT = "-webkit-";
    var COMMENT = "comm";
    var RULESET = "rule";
    var DECLARATION = "decl";
    var MEDIA = "@media";
    var IMPORT = "@import";
    var SUPPORTS = "@supports";
    var KEYFRAMES = "@keyframes";
    var LAYER = "@layer";
    var abs$2 = Math.abs;
    var from$1 = String.fromCharCode;
    var assign$2 = Object.assign;
    function hash(value, length2) {
      return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
    }
    function trim$2(value) {
      return value.trim();
    }
    function match(value, pattern) {
      return (value = pattern.exec(value)) ? value[0] : value;
    }
    function replace$1(value, pattern, replacement) {
      return value.replace(pattern, replacement);
    }
    function indexof(value, search2) {
      return value.indexOf(search2);
    }
    function charat(value, index2) {
      return value.charCodeAt(index2) | 0;
    }
    function substr(value, begin, end) {
      return value.slice(begin, end);
    }
    function strlen(value) {
      return value.length;
    }
    function sizeof(value) {
      return value.length;
    }
    function append(value, array) {
      return array.push(value), value;
    }
    function combine$1(array, callback) {
      return array.map(callback).join("");
    }
    var line = 1;
    var column = 1;
    var length = 0;
    var position$4 = 0;
    var character = 0;
    var characters = "";
    function node(value, root2, parent, type, props, children, length2, siblings) {
      return { value, root: root2, parent, type, props, children, line, column, length: length2, return: "", siblings };
    }
    function copy$2(root2, props) {
      return assign$2(node("", null, null, "", null, null, 0, root2.siblings), root2, { length: -root2.length }, props);
    }
    function char() {
      return character;
    }
    function prev() {
      character = position$4 > 0 ? charat(characters, --position$4) : 0;
      if (column--, character === 10)
        column = 1, line--;
      return character;
    }
    function next() {
      character = position$4 < length ? charat(characters, position$4++) : 0;
      if (column++, character === 10)
        column = 1, line++;
      return character;
    }
    function peek() {
      return charat(characters, position$4);
    }
    function caret() {
      return position$4;
    }
    function slice(begin, end) {
      return substr(characters, begin, end);
    }
    function token$1(type) {
      switch (type) {
        case 0:
        case 9:
        case 10:
        case 13:
        case 32:
          return 5;
        case 33:
        case 43:
        case 44:
        case 47:
        case 62:
        case 64:
        case 126:
        case 59:
        case 123:
        case 125:
          return 4;
        case 58:
          return 3;
        case 34:
        case 39:
        case 40:
        case 91:
          return 2;
        case 41:
        case 93:
          return 1;
      }
      return 0;
    }
    function alloc(value) {
      return line = column = 1, length = strlen(characters = value), position$4 = 0, [];
    }
    function dealloc(value) {
      return characters = "", value;
    }
    function delimit(type) {
      return trim$2(slice(position$4 - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
    }
    function tokenize(value) {
      return dealloc(tokenizer$1(alloc(value)));
    }
    function whitespace$1(type) {
      while (character = peek())
        if (character < 33)
          next();
        else
          break;
      return token$1(type) > 2 || token$1(character) > 3 ? "" : " ";
    }
    function tokenizer$1(children) {
      while (next())
        switch (token$1(character)) {
          case 0:
            append(identifier(position$4 - 1), children);
            break;
          case 2:
            append(delimit(character), children);
            break;
          default:
            append(from$1(character), children);
        }
      return children;
    }
    function escaping(index2, count) {
      while (--count && next())
        if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
          break;
      return slice(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
    }
    function delimiter(type) {
      while (next())
        switch (character) {
          case type:
            return position$4;
          case 34:
          case 39:
            if (type !== 34 && type !== 39)
              delimiter(character);
            break;
          case 40:
            if (type === 41)
              delimiter(type);
            break;
          case 92:
            next();
            break;
        }
      return position$4;
    }
    function commenter(type, index2) {
      while (next())
        if (type + character === 47 + 10)
          break;
        else if (type + character === 42 + 42 && peek() === 47)
          break;
      return "/*" + slice(index2, position$4 - 1) + "*" + from$1(type === 47 ? type : next());
    }
    function identifier(index2) {
      while (!token$1(peek()))
        next();
      return slice(index2, position$4);
    }
    function compile(value) {
      return dealloc(parse$5("", null, null, null, [""], value = alloc(value), 0, [0], value));
    }
    function parse$5(value, root2, parent, rule, rules2, rulesets, pseudo, points, declarations) {
      var index2 = 0;
      var offset2 = 0;
      var length2 = pseudo;
      var atrule = 0;
      var property = 0;
      var previous2 = 0;
      var variable = 1;
      var scanning = 1;
      var ampersand = 1;
      var character2 = 0;
      var type = "";
      var props = rules2;
      var children = rulesets;
      var reference = rule;
      var characters2 = type;
      while (scanning)
        switch (previous2 = character2, character2 = next()) {
          case 40:
            if (previous2 != 108 && charat(characters2, length2 - 1) == 58) {
              if (indexof(characters2 += replace$1(delimit(character2), "&", "&\f"), "&\f") != -1)
                ampersand = -1;
              break;
            }
          case 34:
          case 39:
          case 91:
            characters2 += delimit(character2);
            break;
          case 9:
          case 10:
          case 13:
          case 32:
            characters2 += whitespace$1(previous2);
            break;
          case 92:
            characters2 += escaping(caret() - 1, 7);
            continue;
          case 47:
            switch (peek()) {
              case 42:
              case 47:
                append(comment$2(commenter(next(), caret()), root2, parent, declarations), declarations);
                break;
              default:
                characters2 += "/";
            }
            break;
          case 123 * variable:
            points[index2++] = strlen(characters2) * ampersand;
          case 125 * variable:
          case 59:
          case 0:
            switch (character2) {
              case 0:
              case 125:
                scanning = 0;
              case 59 + offset2:
                if (ampersand == -1)
                  characters2 = replace$1(characters2, /\f/g, "");
                if (property > 0 && strlen(characters2) - length2)
                  append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1, declarations) : declaration(replace$1(characters2, " ", "") + ";", rule, parent, length2 - 2, declarations), declarations);
                break;
              case 59:
                characters2 += ";";
              default:
                append(reference = ruleset(characters2, root2, parent, index2, offset2, rules2, points, type, props = [], children = [], length2, rulesets), rulesets);
                if (character2 === 123)
                  if (offset2 === 0)
                    parse$5(characters2, root2, reference, reference, props, rulesets, length2, points, children);
                  else
                    switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                      case 100:
                      case 108:
                      case 109:
                      case 115:
                        parse$5(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules2, points, type, rules2, props = [], length2, children), children), rules2, children, length2, points, rule ? props : children);
                        break;
                      default:
                        parse$5(characters2, reference, reference, reference, [""], children, 0, points, children);
                    }
            }
            index2 = offset2 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
            break;
          case 58:
            length2 = 1 + strlen(characters2), property = previous2;
          default:
            if (variable < 1) {
              if (character2 == 123)
                --variable;
              else if (character2 == 125 && variable++ == 0 && prev() == 125)
                continue;
            }
            switch (characters2 += from$1(character2), character2 * variable) {
              case 38:
                ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
                break;
              case 44:
                points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
                break;
              case 64:
                if (peek() === 45)
                  characters2 += delimit(next());
                atrule = peek(), offset2 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
                break;
              case 45:
                if (previous2 === 45 && strlen(characters2) == 2)
                  variable = 0;
            }
        }
      return rulesets;
    }
    function ruleset(value, root2, parent, index2, offset2, rules2, points, type, props, children, length2, siblings) {
      var post = offset2 - 1;
      var rule = offset2 === 0 ? rules2 : [""];
      var size = sizeof(rule);
      for (var i2 = 0, j = 0, k2 = 0; i2 < index2; ++i2)
        for (var x2 = 0, y2 = substr(value, post + 1, post = abs$2(j = points[i2])), z2 = value; x2 < size; ++x2)
          if (z2 = trim$2(j > 0 ? rule[x2] + " " + y2 : replace$1(y2, /&\f/g, rule[x2])))
            props[k2++] = z2;
      return node(value, root2, parent, offset2 === 0 ? RULESET : type, props, children, length2, siblings);
    }
    function comment$2(value, root2, parent, siblings) {
      return node(value, root2, parent, COMMENT, from$1(char()), substr(value, 2, -2), 0, siblings);
    }
    function declaration(value, root2, parent, length2, siblings) {
      return node(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2, siblings);
    }
    function serialize$1(children, callback) {
      var output = "";
      for (var i2 = 0; i2 < children.length; i2++)
        output += callback(children[i2], i2, children, callback) || "";
      return output;
    }
    function stringify$3(element2, index2, children, callback) {
      switch (element2.type) {
        case LAYER:
          if (element2.children.length)
            break;
        case IMPORT:
        case DECLARATION:
          return element2.return = element2.return || element2.value;
        case COMMENT:
          return "";
        case KEYFRAMES:
          return element2.return = element2.value + "{" + serialize$1(element2.children, callback) + "}";
        case RULESET:
          if (!strlen(element2.value = element2.props.join(",")))
            return "";
      }
      return strlen(children = serialize$1(element2.children, callback)) ? element2.return = element2.value + "{" + children + "}" : "";
    }
    function middleware(collection) {
      var length2 = sizeof(collection);
      return function(element2, index2, children, callback) {
        var output = "";
        for (var i2 = 0; i2 < length2; i2++)
          output += collection[i2](element2, index2, children, callback) || "";
        return output;
      };
    }
    function rulesheet(callback) {
      return function(element2) {
        if (!element2.root) {
          if (element2 = element2.return)
            callback(element2);
        }
      };
    }
    const globalPlugin = (element2) => {
      switch (element2.type) {
        case RULESET:
          if (typeof element2.props === "string") {
            return;
          }
          element2.props = element2.props.map((value) => {
            if (value.indexOf(":global(") === -1) {
              return value;
            }
            return tokenize(value).reduce((acc, value2, index2, children) => {
              if (value2 === "") {
                return acc;
              }
              if (value2 === ":" && children[index2 + 1] === "global") {
                const selector = (
                  // An inner part of ":global()"
                  children[index2 + 2].slice(1, -1) + // A separator between selectors i.e. "body .class"
                  " "
                );
                acc.unshift(selector);
                children[index2 + 1] = "";
                children[index2 + 2] = "";
                return acc;
              }
              acc.push(value2);
              return acc;
            }, []).join("");
          });
      }
    };
    function prefix(value, length2, children) {
      switch (hash(value, length2)) {
        case 5103:
          return WEBKIT + "print-" + value + value;
        case 3191:
        case 6645:
        case 3005:
        case 6391:
        case 5879:
        case 5623:
        case 6135:
        case 4599:
        case 4855:
          return WEBKIT + value + value;
        case 4789:
          return MOZ + value + value;
        case 5349:
        case 4246:
        case 6968:
          return WEBKIT + value + MOZ + value + MS + value + value;
        case 6187:
          if (!match(value, /grab/)) {
            return replace$1(replace$1(replace$1(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
          }
        case 5495:
        case 3959:
          return replace$1(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
        case 4095:
        case 3583:
        case 4068:
        case 2532:
          return replace$1(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
        case 8116:
        case 7059:
        case 5753:
        case 5535:
        case 5445:
        case 5701:
        case 4933:
        case 4677:
        case 5533:
        case 5789:
        case 5021:
        case 4765:
          if (strlen(value) - 1 - length2 > 6)
            switch (charat(value, length2 + 1)) {
              case 102:
                if (charat(value, length2 + 3) === 108) {
                  return replace$1(
                    value,
                    /(.+:)(.+)-([^]+)/,
                    // eslint-disable-next-line no-useless-concat, eqeqeq
                    "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")
                  ) + value;
                }
              case 115:
                return ~indexof(value, "stretch") ? prefix(replace$1(value, "stretch", "fill-available"), length2) + value : value;
            }
          break;
      }
      return value;
    }
    function prefixerPlugin(element2, index2, children, callback) {
      if (element2.length > -1) {
        if (!element2.return)
          switch (element2.type) {
            case DECLARATION:
              element2.return = prefix(element2.value, element2.length);
              return;
            case RULESET:
              if (element2.length)
                return combine$1(element2.props, function(value) {
                  switch (match(value, /(::plac\w+|:read-\w+)/)) {
                    case ":read-only":
                    case ":read-write":
                      return serialize$1(
                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                        // @ts-ignore
                        [copy$2(element2, {
                          props: [replace$1(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                        })],
                        callback
                      );
                    case "::placeholder":
                      return serialize$1([
                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                        // @ts-ignore
                        copy$2(element2, {
                          props: [replace$1(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                        }),
                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                        // @ts-ignore
                        copy$2(element2, {
                          props: [replace$1(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                        }),
                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                        // @ts-ignore
                        copy$2(element2, {
                          props: [replace$1(value, /:(plac\w+)/, MS + "input-$1")]
                        })
                      ], callback);
                  }
                  return "";
                });
          }
      }
      return void 0;
    }
    function isAtRuleElement(element2) {
      switch (element2.type) {
        case "@container":
        case MEDIA:
        case SUPPORTS:
        case LAYER:
          return true;
      }
      return false;
    }
    const sortClassesInAtRulesPlugin = (element2) => {
      if (isAtRuleElement(element2) && Array.isArray(element2.children)) {
        element2.children.sort((a2, b2) => a2.props[0] > b2.props[0] ? 1 : -1);
      }
    };
    function noop$3() {
    }
    function compileCSSRules(cssRules2, sortClassesInAtRules) {
      const rules2 = [];
      serialize$1(compile(cssRules2), middleware([
        globalPlugin,
        sortClassesInAtRules ? sortClassesInAtRulesPlugin : noop$3,
        prefixerPlugin,
        stringify$3,
        // 💡 we are using `.insertRule()` API for DOM operations, which does not support
        // insertion of multiple CSS rules in a single call. `rulesheet` plugin extracts
        // individual rules to be used with this API
        rulesheet((rule) => rules2.push(rule))
      ]));
      return rules2;
    }
    const PSEUDO_SELECTOR_REGEX = /,( *[^ &])/g;
    function normalizePseudoSelector(pseudoSelector) {
      return "&" + normalizeNestedProperty(
        // Regex there replaces a comma, spaces and an ampersand if it's present with comma and an ampersand.
        // This allows to normalize input, see examples in JSDoc.
        pseudoSelector.replace(PSEUDO_SELECTOR_REGEX, ",&$1")
      );
    }
    function createCSSRule(classNameSelector, cssDeclaration, pseudos) {
      let cssRule = cssDeclaration;
      if (pseudos.length > 0) {
        cssRule = pseudos.reduceRight((acc, selector) => {
          return `${normalizePseudoSelector(selector)} { ${acc} }`;
        }, cssDeclaration);
      }
      return `${classNameSelector}{${cssRule}}`;
    }
    function compileAtomicCSSRule(options) {
      const {
        className,
        media,
        layer,
        selectors,
        support,
        property,
        rtlClassName,
        rtlProperty,
        rtlValue,
        value,
        container
      } = options;
      const classNameSelector = `.${className}`;
      const cssDeclaration = Array.isArray(value) ? `${value.map((v2) => `${hyphenateProperty(property)}: ${v2}`).join(";")};` : `${hyphenateProperty(property)}: ${value};`;
      let cssRule = createCSSRule(classNameSelector, cssDeclaration, selectors);
      if (rtlProperty && rtlClassName) {
        const rtlClassNameSelector = `.${rtlClassName}`;
        const rtlCSSDeclaration = Array.isArray(rtlValue) ? `${rtlValue.map((v2) => `${hyphenateProperty(rtlProperty)}: ${v2}`).join(";")};` : `${hyphenateProperty(rtlProperty)}: ${rtlValue};`;
        cssRule += createCSSRule(rtlClassNameSelector, rtlCSSDeclaration, selectors);
      }
      if (media) {
        cssRule = `@media ${media} { ${cssRule} }`;
      }
      if (layer) {
        cssRule = `@layer ${layer} { ${cssRule} }`;
      }
      if (support) {
        cssRule = `@supports ${support} { ${cssRule} }`;
      }
      if (container) {
        cssRule = `@container ${container} { ${cssRule} }`;
      }
      return compileCSSRules(cssRule, true);
    }
    function cssifyObject(style2) {
      let css2 = "";
      for (const property in style2) {
        const value = style2[property];
        if (typeof value !== "string" && typeof value !== "number") {
          continue;
        }
        css2 += hyphenateProperty(property) + ":" + value + ";";
      }
      return css2;
    }
    function compileKeyframeRule(keyframeObject) {
      let css2 = "";
      for (const percentage in keyframeObject) {
        css2 += `${percentage}{${cssifyObject(keyframeObject[percentage])}}`;
      }
      return css2;
    }
    function compileKeyframesCSS(keyframeName, keyframeCSS) {
      const cssRule = `@keyframes ${keyframeName} {${keyframeCSS}}`;
      const rules2 = [];
      serialize$1(compile(cssRule), middleware([
        stringify$3,
        prefixerPlugin,
        // 💡 we are using `.insertRule()` API for DOM operations, which does not support
        // insertion of multiple CSS rules in a single call. `rulesheet` plugin extracts
        // individual rules to be used with this API
        rulesheet((rule) => rules2.push(rule))
      ]));
      return rules2;
    }
    function generateCombinedQuery(currentMediaQuery, nestedMediaQuery) {
      if (currentMediaQuery.length === 0) {
        return nestedMediaQuery;
      }
      return `${currentMediaQuery} and ${nestedMediaQuery}`;
    }
    function isMediaQuerySelector(property) {
      return property.substr(0, 6) === "@media";
    }
    function isLayerSelector(property) {
      return property.substr(0, 6) === "@layer";
    }
    const regex$1 = /^(:|\[|>|&)/;
    function isNestedSelector(property) {
      return regex$1.test(property);
    }
    function isSupportQuerySelector(property) {
      return property.substr(0, 9) === "@supports";
    }
    function isContainerQuerySelector(property) {
      return property.substring(0, 10) === "@container";
    }
    function isObject$2(val) {
      return val != null && typeof val === "object" && Array.isArray(val) === false;
    }
    const pseudosMap = {
      // :focus-within
      "us-w": "w",
      // :focus-visible
      "us-v": "i",
      // :link
      nk: "l",
      // :visited
      si: "v",
      // :focus
      cu: "f",
      // :hover
      ve: "h",
      // :active
      ti: "a"
    };
    function getStyleBucketName(selectors, layer, media, support, container) {
      if (media) {
        return "m";
      }
      if (layer || support) {
        return "t";
      }
      if (container) {
        return "c";
      }
      if (selectors.length > 0) {
        const normalizedPseudo = selectors[0].trim();
        if (normalizedPseudo.charCodeAt(0) === 58) {
          return pseudosMap[normalizedPseudo.slice(4, 8)] || pseudosMap[normalizedPseudo.slice(3, 5)] || "d";
        }
      }
      return "d";
    }
    function hashClassName({
      container,
      media,
      layer,
      property,
      selector,
      support,
      value
    }) {
      const classNameHash = murmur2$1(selector + container + media + layer + support + property + // Trimming of value is required to generate consistent hashes
      value.trim());
      return HASH_PREFIX + classNameHash;
    }
    function hashPropertyKey(selector, container, media, support, property) {
      const computedKey = selector + container + media + support + property;
      const hashedKey = murmur2$1(computedKey);
      const firstCharCode = hashedKey.charCodeAt(0);
      const startsWithNumber = firstCharCode >= 48 && firstCharCode <= 57;
      if (startsWithNumber) {
        return String.fromCharCode(firstCharCode + 17) + hashedKey.slice(1);
      }
      return hashedKey;
    }
    function trimSelector(selector) {
      return selector.replace(/>\s+/g, ">");
    }
    function warnAboutUnresolvedRule(property, value) {
      const ruleText = JSON.stringify(value, null, 2);
      ["@griffel/react: A rule was not resolved to CSS properly. Please check your `makeStyles` or `makeResetStyles` calls for following:", " ".repeat(2) + "makeStyles({", " ".repeat(4) + `[slot]: {`, " ".repeat(6) + `"${property}": ${ruleText.split("\n").map((l2, n2) => " ".repeat(n2 === 0 ? 0 : 6) + l2).join("\n")}`, " ".repeat(4) + "}", " ".repeat(2) + `})`, ""];
      if (property.indexOf("&") === -1)
        ;
    }
    function warnAboutUnsupportedProperties(property, value) {
    }
    function pushToClassesMap(classesMap, propertyKey, ltrClassname, rtlClassname) {
      classesMap[propertyKey] = rtlClassname ? [ltrClassname, rtlClassname] : ltrClassname;
    }
    function createBucketEntry(cssRule, metadata) {
      if (metadata) {
        return [cssRule, metadata];
      }
      return cssRule;
    }
    function pushToCSSRules(cssRulesByBucket, styleBucketName, ltrCSS, rtlCSS, media) {
      var _a2;
      let metadata;
      if (styleBucketName === "m" && media) {
        metadata = {
          m: media
        };
      }
      (_a2 = cssRulesByBucket[styleBucketName]) !== null && _a2 !== void 0 ? _a2 : cssRulesByBucket[styleBucketName] = [];
      if (ltrCSS) {
        cssRulesByBucket[styleBucketName].push(createBucketEntry(ltrCSS, metadata));
      }
      if (rtlCSS) {
        cssRulesByBucket[styleBucketName].push(createBucketEntry(rtlCSS, metadata));
      }
    }
    function resolveStyleRules(styles2, selectors = [], media = "", layer = "", support = "", container = "", cssClassesMap = {}, cssRulesByBucket = {}, rtlValue) {
      for (const property in styles2) {
        if (UNSUPPORTED_CSS_PROPERTIES.hasOwnProperty(property)) {
          warnAboutUnsupportedProperties(property, styles2[property]);
          continue;
        }
        const value = styles2[property];
        if (value == null) {
          continue;
        }
        if (typeof value === "string" || typeof value === "number") {
          const selector = trimSelector(selectors.join(""));
          const key = hashPropertyKey(selector, container, media, support, property);
          const className = hashClassName({
            container,
            media,
            layer,
            value: value.toString(),
            support,
            selector,
            property
          });
          const rtlDefinition = rtlValue && {
            key: property,
            value: rtlValue
          } || convertProperty(property, value);
          const flippedInRtl = rtlDefinition.key !== property || rtlDefinition.value !== value;
          const rtlClassName = flippedInRtl ? hashClassName({
            container,
            value: rtlDefinition.value.toString(),
            property: rtlDefinition.key,
            selector,
            media,
            layer,
            support
          }) : void 0;
          const rtlCompileOptions = flippedInRtl ? {
            rtlClassName,
            rtlProperty: rtlDefinition.key,
            rtlValue: rtlDefinition.value
          } : void 0;
          const styleBucketName = getStyleBucketName(selectors, layer, media, support, container);
          const [ltrCSS, rtlCSS] = compileAtomicCSSRule({
            className,
            media,
            layer,
            selectors,
            property,
            support,
            container,
            value,
            ...rtlCompileOptions
          });
          pushToClassesMap(cssClassesMap, key, className, rtlClassName);
          pushToCSSRules(cssRulesByBucket, styleBucketName, ltrCSS, rtlCSS, media);
        } else if (property === "animationName") {
          const animationNameValue = Array.isArray(value) ? value : [value];
          const animationNames = [];
          const rtlAnimationNames = [];
          for (const keyframeObject of animationNameValue) {
            const keyframeCSS = compileKeyframeRule(keyframeObject);
            const rtlKeyframeCSS = compileKeyframeRule(convert$1(keyframeObject));
            const animationName = HASH_PREFIX + murmur2$1(keyframeCSS);
            let rtlAnimationName;
            const keyframeRules = compileKeyframesCSS(animationName, keyframeCSS);
            let rtlKeyframeRules = [];
            if (keyframeCSS === rtlKeyframeCSS) {
              rtlAnimationName = animationName;
            } else {
              rtlAnimationName = HASH_PREFIX + murmur2$1(rtlKeyframeCSS);
              rtlKeyframeRules = compileKeyframesCSS(rtlAnimationName, rtlKeyframeCSS);
            }
            for (let i2 = 0; i2 < keyframeRules.length; i2++) {
              pushToCSSRules(
                cssRulesByBucket,
                // keyframes styles should be inserted into own bucket
                "k",
                keyframeRules[i2],
                rtlKeyframeRules[i2],
                media
              );
            }
            animationNames.push(animationName);
            rtlAnimationNames.push(rtlAnimationName);
          }
          resolveStyleRules({
            animationName: animationNames.join(", ")
          }, selectors, media, layer, support, container, cssClassesMap, cssRulesByBucket, rtlAnimationNames.join(", "));
        } else if (Array.isArray(value)) {
          if (value.length === 0) {
            continue;
          }
          const selector = trimSelector(selectors.join(""));
          const key = hashPropertyKey(selector, container, media, support, property);
          const className = hashClassName({
            container,
            media,
            layer,
            value: value.map((v2) => (v2 !== null && v2 !== void 0 ? v2 : "").toString()).join(";"),
            support,
            selector,
            property
          });
          const rtlDefinitions = value.map((v2) => convertProperty(property, v2));
          const rtlPropertyConsistent = !rtlDefinitions.some((v2) => v2.key !== rtlDefinitions[0].key);
          if (!rtlPropertyConsistent) {
            continue;
          }
          const flippedInRtl = rtlDefinitions[0].key !== property || rtlDefinitions.some((v2, i2) => v2.value !== value[i2]);
          const rtlClassName = flippedInRtl ? hashClassName({
            container,
            value: rtlDefinitions.map((v2) => {
              var _a2;
              return ((_a2 = v2 === null || v2 === void 0 ? void 0 : v2.value) !== null && _a2 !== void 0 ? _a2 : "").toString();
            }).join(";"),
            property: rtlDefinitions[0].key,
            selector,
            layer,
            media,
            support
          }) : void 0;
          const rtlCompileOptions = flippedInRtl ? {
            rtlClassName,
            rtlProperty: rtlDefinitions[0].key,
            rtlValue: rtlDefinitions.map((d2) => d2.value)
          } : void 0;
          const styleBucketName = getStyleBucketName(selectors, layer, media, support, container);
          const [ltrCSS, rtlCSS] = compileAtomicCSSRule({
            className,
            media,
            layer,
            selectors,
            property,
            support,
            container,
            value,
            ...rtlCompileOptions
          });
          pushToClassesMap(cssClassesMap, key, className, rtlClassName);
          pushToCSSRules(cssRulesByBucket, styleBucketName, ltrCSS, rtlCSS, media);
        } else if (isObject$2(value)) {
          if (isNestedSelector(property)) {
            resolveStyleRules(value, selectors.concat(normalizeNestedProperty(property)), media, layer, support, container, cssClassesMap, cssRulesByBucket);
          } else if (isMediaQuerySelector(property)) {
            const combinedMediaQuery = generateCombinedQuery(media, property.slice(6).trim());
            resolveStyleRules(value, selectors, combinedMediaQuery, layer, support, container, cssClassesMap, cssRulesByBucket);
          } else if (isLayerSelector(property)) {
            const combinedLayerQuery = (layer ? `${layer}.` : "") + property.slice(6).trim();
            resolveStyleRules(value, selectors, media, combinedLayerQuery, support, container, cssClassesMap, cssRulesByBucket);
          } else if (isSupportQuerySelector(property)) {
            const combinedSupportQuery = generateCombinedQuery(support, property.slice(9).trim());
            resolveStyleRules(value, selectors, media, layer, combinedSupportQuery, container, cssClassesMap, cssRulesByBucket);
          } else if (isContainerQuerySelector(property)) {
            const containerQuery = property.slice(10).trim();
            resolveStyleRules(value, selectors, media, layer, support, containerQuery, cssClassesMap, cssRulesByBucket);
          } else {
            warnAboutUnresolvedRule(property, value);
          }
        }
      }
      return [cssClassesMap, cssRulesByBucket];
    }
    function resolveStyleRulesForSlots(stylesBySlots) {
      const classesMapBySlot = {};
      const cssRules2 = {};
      for (const slotName in stylesBySlots) {
        const slotStyles = stylesBySlots[slotName];
        const [cssClassMap, cssRulesByBucket] = resolveStyleRules(slotStyles);
        classesMapBySlot[slotName] = cssClassMap;
        Object.keys(cssRulesByBucket).forEach((styleBucketName) => {
          cssRules2[styleBucketName] = (cssRules2[styleBucketName] || []).concat(cssRulesByBucket[styleBucketName]);
        });
      }
      return [classesMapBySlot, cssRules2];
    }
    function makeStyles$1(stylesBySlots, factory = insertionFactory$2) {
      const insertStyles = factory();
      let classesMapBySlot = null;
      let cssRules2 = null;
      let ltrClassNamesForSlots = null;
      let rtlClassNamesForSlots = null;
      function computeClasses(options) {
        const {
          dir,
          renderer
        } = options;
        if (classesMapBySlot === null) {
          [classesMapBySlot, cssRules2] = resolveStyleRulesForSlots(stylesBySlots);
        }
        const isLTR = dir === "ltr";
        if (isLTR) {
          if (ltrClassNamesForSlots === null) {
            ltrClassNamesForSlots = reduceToClassNameForSlots$2(classesMapBySlot, dir);
          }
        } else {
          if (rtlClassNamesForSlots === null) {
            rtlClassNamesForSlots = reduceToClassNameForSlots$2(classesMapBySlot, dir);
          }
        }
        insertStyles(renderer, cssRules2);
        const classNamesForSlots = isLTR ? ltrClassNamesForSlots : rtlClassNamesForSlots;
        return classNamesForSlots;
      }
      return computeClasses;
    }
    function __styles$4(classesMapBySlot, cssRules2, factory = insertionFactory$2) {
      const insertStyles = factory();
      let ltrClassNamesForSlots = null;
      let rtlClassNamesForSlots = null;
      function computeClasses(options) {
        const {
          dir,
          renderer
        } = options;
        const isLTR = dir === "ltr";
        if (isLTR) {
          if (ltrClassNamesForSlots === null) {
            ltrClassNamesForSlots = reduceToClassNameForSlots$2(classesMapBySlot, dir);
          }
        } else {
          if (rtlClassNamesForSlots === null) {
            rtlClassNamesForSlots = reduceToClassNameForSlots$2(classesMapBySlot, dir);
          }
        }
        insertStyles(renderer, cssRules2);
        const classNamesForSlots = isLTR ? ltrClassNamesForSlots : rtlClassNamesForSlots;
        return classNamesForSlots;
      }
      return computeClasses;
    }
    function __resetStyles$1(ltrClassName, rtlClassName, cssRules2, factory = insertionFactory$2) {
      const insertStyles = factory();
      function computeClassName(options) {
        const {
          dir,
          renderer
        } = options;
        const className = dir === "ltr" ? ltrClassName : rtlClassName || ltrClassName;
        insertStyles(renderer, Array.isArray(cssRules2) ? {
          r: cssRules2
        } : cssRules2);
        return className;
      }
      return computeClassName;
    }
    const shorthands = {
      border,
      borderLeft,
      borderBottom,
      borderRight,
      borderTop,
      borderColor,
      borderStyle,
      borderRadius: borderRadius$1,
      borderWidth,
      flex,
      gap,
      gridArea,
      margin,
      marginBlock,
      marginInline,
      padding,
      paddingBlock,
      paddingInline,
      overflow,
      inset,
      outline,
      transition,
      textDecoration
    };
    function canUseDOM$1() {
      return typeof window !== "undefined" && !!(window.document && window.document.createElement);
    }
    const useInsertionEffect$2 = (
      // @ts-expect-error Hack to make sure that `useInsertionEffect` will not cause bundling issues in older React versions
      // eslint-disable-next-line no-useless-concat
      React$1["useInsertionEffect"] ? React$1["useInsertionEffect"] : void 0
    );
    const insertionFactory$1 = () => {
      const insertionCache = {};
      return function insert(renderer, cssRules2) {
        if (useInsertionEffect$2 && canUseDOM$1()) {
          useInsertionEffect$2(() => {
            renderer.insertCSSRules(cssRules2);
          }, [renderer, cssRules2]);
          return;
        }
        if (insertionCache[renderer.id] === void 0) {
          renderer.insertCSSRules(cssRules2);
          insertionCache[renderer.id] = true;
        }
      };
    };
    const RendererContext$1 = /* @__PURE__ */ reactExports.createContext(/* @__PURE__ */ createDOMRenderer$1());
    function useRenderer$1() {
      return reactExports.useContext(RendererContext$1);
    }
    const TextDirectionContext$1 = /* @__PURE__ */ reactExports.createContext("ltr");
    const TextDirectionProvider = ({
      children,
      dir
    }) => {
      return /* @__PURE__ */ reactExports.createElement(TextDirectionContext$1.Provider, {
        value: dir
      }, children);
    };
    function useTextDirection$1() {
      return reactExports.useContext(TextDirectionContext$1);
    }
    function makeStyles(stylesBySlots) {
      const getStyles2 = makeStyles$1(stylesBySlots, insertionFactory$1);
      return function useClasses() {
        const dir = useTextDirection$1();
        const renderer = useRenderer$1();
        return getStyles2({
          dir,
          renderer
        });
      };
    }
    function __styles$3(classesMapBySlot, cssRules2) {
      const getStyles2 = __styles$4(classesMapBySlot, cssRules2, insertionFactory$1);
      return function useClasses() {
        const dir = useTextDirection$1();
        const renderer = useRenderer$1();
        return getStyles2({
          dir,
          renderer
        });
      };
    }
    function __resetStyles(ltrClassName, rtlClassName, cssRules2) {
      const getStyles2 = __resetStyles$1(ltrClassName, rtlClassName, cssRules2, insertionFactory$1);
      return function useClasses() {
        const dir = useTextDirection$1();
        const renderer = useRenderer$1();
        return getStyles2({
          dir,
          renderer
        });
      };
    }
    function createCSSRuleFromTheme(selector, theme) {
      if (theme) {
        const cssVarsAsString = Object.keys(theme).reduce((cssVarRule, cssVar) => {
          return `${cssVarRule}--${cssVar}: ${theme[cssVar]}; `;
        }, "");
        return `${selector} { ${cssVarsAsString} }`;
      }
      return `${selector} {}`;
    }
    const SLOT_RENDER_FUNCTION_SYMBOL = Symbol("fui.slotRenderFunction");
    const SLOT_ELEMENT_TYPE_SYMBOL = Symbol("fui.slotElementType");
    function always(value, options) {
      const { defaultProps, elementType } = options;
      const props = resolveShorthand$1(value);
      const propsWithMetadata = {
        ...defaultProps,
        ...props,
        [SLOT_ELEMENT_TYPE_SYMBOL]: elementType
      };
      if (props && typeof props.children === "function") {
        propsWithMetadata[SLOT_RENDER_FUNCTION_SYMBOL] = props.children;
        propsWithMetadata.children = defaultProps === null || defaultProps === void 0 ? void 0 : defaultProps.children;
      }
      return propsWithMetadata;
    }
    function optional(value, options) {
      if (value === null || value === void 0 && !options.renderByDefault) {
        return void 0;
      }
      return always(value, options);
    }
    function resolveShorthand$1(value) {
      if (typeof value === "string" || typeof value === "number" || Array.isArray(value) || // eslint-disable-next-line @typescript-eslint/no-explicit-any
      reactExports.isValidElement(value)) {
        return {
          children: value
        };
      }
      if (value && typeof value !== "object" && false) {
        console.error(`@fluentui/react-utilities [slot.${resolveShorthand$1.name}]:
A slot got an invalid value "${value}" (${typeof value}).
A valid value for a slot is a slot shorthand or slot properties object.
Slot shorthands can be strings, numbers, arrays or JSX elements`);
      }
      return value;
    }
    function isSlot(element2) {
      return Boolean(element2 === null || element2 === void 0 ? void 0 : element2.hasOwnProperty(SLOT_ELEMENT_TYPE_SYMBOL));
    }
    const resolveShorthand = (value, options) => optional(value, {
      ...options,
      renderByDefault: options === null || options === void 0 ? void 0 : options.required,
      // elementType as undefined is the way to identify between a slot and a resolveShorthand call
      // in the case elementType is undefined assertSlots will fail, ensuring it'll only work with slot method.
      elementType: void 0
    });
    function isResolvedShorthand(shorthand) {
      return shorthand !== null && typeof shorthand === "object" && !Array.isArray(shorthand) && !reactExports.isValidElement(shorthand);
    }
    const toObjectMap = (...items) => {
      const result = {};
      for (const item of items) {
        const keys2 = Array.isArray(item) ? item : Object.keys(item);
        for (const key of keys2) {
          result[key] = 1;
        }
      }
      return result;
    };
    const baseElementEvents = toObjectMap([
      "onAuxClick",
      "onAnimationEnd",
      "onAnimationStart",
      "onCopy",
      "onCut",
      "onPaste",
      "onCompositionEnd",
      "onCompositionStart",
      "onCompositionUpdate",
      "onFocus",
      "onFocusCapture",
      "onBlur",
      "onBlurCapture",
      "onChange",
      "onInput",
      "onSubmit",
      "onLoad",
      "onError",
      "onKeyDown",
      "onKeyDownCapture",
      "onKeyPress",
      "onKeyUp",
      "onAbort",
      "onCanPlay",
      "onCanPlayThrough",
      "onDurationChange",
      "onEmptied",
      "onEncrypted",
      "onEnded",
      "onLoadedData",
      "onLoadedMetadata",
      "onLoadStart",
      "onPause",
      "onPlay",
      "onPlaying",
      "onProgress",
      "onRateChange",
      "onSeeked",
      "onSeeking",
      "onStalled",
      "onSuspend",
      "onTimeUpdate",
      "onVolumeChange",
      "onWaiting",
      "onClick",
      "onClickCapture",
      "onContextMenu",
      "onDoubleClick",
      "onDrag",
      "onDragEnd",
      "onDragEnter",
      "onDragExit",
      "onDragLeave",
      "onDragOver",
      "onDragStart",
      "onDrop",
      "onMouseDown",
      "onMouseDownCapture",
      "onMouseEnter",
      "onMouseLeave",
      "onMouseMove",
      "onMouseOut",
      "onMouseOver",
      "onMouseUp",
      "onMouseUpCapture",
      "onSelect",
      "onTouchCancel",
      "onTouchEnd",
      "onTouchMove",
      "onTouchStart",
      "onScroll",
      "onWheel",
      "onPointerCancel",
      "onPointerDown",
      "onPointerEnter",
      "onPointerLeave",
      "onPointerMove",
      "onPointerOut",
      "onPointerOver",
      "onPointerUp",
      "onGotPointerCapture",
      "onLostPointerCapture"
    ]);
    const baseElementProperties = toObjectMap([
      "accessKey",
      "children",
      "className",
      "contentEditable",
      "dir",
      "draggable",
      "hidden",
      "htmlFor",
      "id",
      "lang",
      "ref",
      "role",
      "style",
      "tabIndex",
      "title",
      "translate",
      "spellCheck",
      "name"
    ]);
    const microdataProperties = toObjectMap([
      "itemID",
      "itemProp",
      "itemRef",
      "itemScope",
      "itemType"
    ]);
    const htmlElementProperties = toObjectMap(baseElementProperties, baseElementEvents, microdataProperties);
    const labelProperties = toObjectMap(htmlElementProperties, [
      "form"
    ]);
    const audioProperties = toObjectMap(htmlElementProperties, [
      "height",
      "loop",
      "muted",
      "preload",
      "src",
      "width"
    ]);
    const videoProperties = toObjectMap(audioProperties, [
      "poster"
    ]);
    const olProperties = toObjectMap(htmlElementProperties, [
      "start"
    ]);
    const liProperties = toObjectMap(htmlElementProperties, [
      "value"
    ]);
    const anchorProperties = toObjectMap(htmlElementProperties, [
      "download",
      "href",
      "hrefLang",
      "media",
      "rel",
      "target",
      "type"
    ]);
    const timeProperties = toObjectMap(htmlElementProperties, [
      "dateTime"
    ]);
    const buttonProperties = toObjectMap(htmlElementProperties, [
      "autoFocus",
      "disabled",
      "form",
      "formAction",
      "formEncType",
      "formMethod",
      "formNoValidate",
      "formTarget",
      "type",
      "value"
    ]);
    const inputProperties = toObjectMap(buttonProperties, [
      "accept",
      "alt",
      "autoCapitalize",
      "autoComplete",
      "checked",
      "dirname",
      "form",
      "height",
      "inputMode",
      "list",
      "max",
      "maxLength",
      "min",
      "multiple",
      "pattern",
      "placeholder",
      "readOnly",
      "required",
      "src",
      "step",
      "size",
      "type",
      "value",
      "width"
    ]);
    const textAreaProperties = toObjectMap(buttonProperties, [
      "autoCapitalize",
      "cols",
      "dirname",
      "form",
      "maxLength",
      "placeholder",
      "readOnly",
      "required",
      "rows",
      "wrap"
    ]);
    const selectProperties = toObjectMap(buttonProperties, [
      "form",
      "multiple",
      "required"
    ]);
    const optionProperties = toObjectMap(htmlElementProperties, [
      "selected",
      "value"
    ]);
    const tableProperties = toObjectMap(htmlElementProperties, [
      "cellPadding",
      "cellSpacing"
    ]);
    const trProperties = htmlElementProperties;
    const thProperties = toObjectMap(htmlElementProperties, [
      "colSpan",
      "rowSpan",
      "scope"
    ]);
    const tdProperties = toObjectMap(htmlElementProperties, [
      "colSpan",
      "headers",
      "rowSpan",
      "scope"
    ]);
    const colGroupProperties = toObjectMap(htmlElementProperties, [
      "span"
    ]);
    const colProperties = toObjectMap(htmlElementProperties, [
      "span"
    ]);
    const fieldsetProperties = toObjectMap(htmlElementProperties, [
      "disabled",
      "form"
    ]);
    const formProperties = toObjectMap(htmlElementProperties, [
      "acceptCharset",
      "action",
      "encType",
      "encType",
      "method",
      "noValidate",
      "target"
    ]);
    const iframeProperties = toObjectMap(htmlElementProperties, [
      "allow",
      "allowFullScreen",
      "allowPaymentRequest",
      "allowTransparency",
      "csp",
      "height",
      "importance",
      "referrerPolicy",
      "sandbox",
      "src",
      "srcDoc",
      "width"
    ]);
    const imgProperties = toObjectMap(htmlElementProperties, [
      "alt",
      "crossOrigin",
      "height",
      "src",
      "srcSet",
      "useMap",
      "width"
    ]);
    const dialogProperties = toObjectMap(htmlElementProperties, [
      "open",
      "onCancel",
      "onClose"
    ]);
    function getNativeProps(props, allowedPropNames, excludedPropNames) {
      const isArray2 = Array.isArray(allowedPropNames);
      const result = {};
      const keys2 = Object.keys(props);
      for (const key of keys2) {
        const isNativeProp = !isArray2 && allowedPropNames[key] || isArray2 && allowedPropNames.indexOf(key) >= 0 || key.indexOf("data-") === 0 || key.indexOf("aria-") === 0;
        if (isNativeProp && (!excludedPropNames || (excludedPropNames === null || excludedPropNames === void 0 ? void 0 : excludedPropNames.indexOf(key)) === -1)) {
          result[key] = props[key];
        }
      }
      return result;
    }
    const nativeElementMap = {
      label: labelProperties,
      audio: audioProperties,
      video: videoProperties,
      ol: olProperties,
      li: liProperties,
      a: anchorProperties,
      button: buttonProperties,
      input: inputProperties,
      textarea: textAreaProperties,
      select: selectProperties,
      option: optionProperties,
      table: tableProperties,
      tr: trProperties,
      th: thProperties,
      td: tdProperties,
      colGroup: colGroupProperties,
      col: colProperties,
      fieldset: fieldsetProperties,
      form: formProperties,
      iframe: iframeProperties,
      img: imgProperties,
      time: timeProperties,
      dialog: dialogProperties
    };
    function getNativeElementProps(tagName, props, excludedPropNames) {
      const allowedPropNames = tagName && nativeElementMap[tagName] || htmlElementProperties;
      allowedPropNames.as = 1;
      return getNativeProps(props, allowedPropNames, excludedPropNames);
    }
    const getPartitionedNativeProps = ({ primarySlotTagName, props, excludedPropNames }) => {
      return {
        root: {
          style: props.style,
          className: props.className
        },
        // eslint-disable-next-line deprecation/deprecation
        primary: getNativeElementProps(primarySlotTagName, props, [
          ...excludedPropNames || [],
          "style",
          "className"
        ])
      };
    };
    const getIntrinsicElementProps = (tagName, props, excludedPropNames) => {
      var _props_as;
      return getNativeElementProps((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : tagName, props, excludedPropNames);
    };
    function canUseDOM() {
      return (
        // eslint-disable-next-line deprecation/deprecation, no-restricted-globals
        typeof window !== "undefined" && !!(window.document && window.document.createElement)
      );
    }
    function useBrowserTimer(setTimer, cancelTimer) {
      const id2 = reactExports.useRef(void 0);
      const set2 = reactExports.useCallback((fn, delay) => {
        if (id2.current !== void 0) {
          cancelTimer(id2.current);
        }
        id2.current = setTimer(fn, delay);
        return id2.current;
      }, [
        cancelTimer,
        setTimer
      ]);
      const cancel = reactExports.useCallback(() => {
        if (id2.current !== void 0) {
          cancelTimer(id2.current);
          id2.current = void 0;
        }
      }, [
        cancelTimer
      ]);
      reactExports.useEffect(() => cancel, [
        cancel
      ]);
      return [
        set2,
        cancel
      ];
    }
    function isFactoryDispatch(newState) {
      return typeof newState === "function";
    }
    const useControllableState = (options) => {
      const [internalState, setInternalState] = reactExports.useState(() => {
        if (options.defaultState === void 0) {
          return options.initialState;
        }
        return isInitializer(options.defaultState) ? options.defaultState() : options.defaultState;
      });
      const stateValueRef = reactExports.useRef(options.state);
      reactExports.useEffect(() => {
        stateValueRef.current = options.state;
      }, [
        options.state
      ]);
      const setControlledState = reactExports.useCallback((newState) => {
        if (isFactoryDispatch(newState)) {
          newState(stateValueRef.current);
        }
      }, []);
      return useIsControlled(options.state) ? [
        options.state,
        setControlledState
      ] : [
        internalState,
        setInternalState
      ];
    };
    function isInitializer(value) {
      return typeof value === "function";
    }
    const useIsControlled = (controlledValue) => {
      const [isControlled] = reactExports.useState(() => controlledValue !== void 0);
      return isControlled;
    };
    const defaultSSRContextValue = {
      current: 0
    };
    const SSRContext = /* @__PURE__ */ reactExports.createContext(void 0);
    function useSSRContext() {
      var _React_useContext;
      return (_React_useContext = reactExports.useContext(SSRContext)) !== null && _React_useContext !== void 0 ? _React_useContext : defaultSSRContextValue;
    }
    function useIsSSR() {
      const isInSSRContext = useSSRContext() !== defaultSSRContextValue;
      const [isSSR, setIsSSR] = reactExports.useState(isInSSRContext);
      if (canUseDOM() && isInSSRContext) {
        reactExports.useLayoutEffect(() => {
          setIsSSR(false);
        }, []);
      }
      return isSSR;
    }
    const useIsomorphicLayoutEffect = canUseDOM() ? reactExports.useLayoutEffect : reactExports.useEffect;
    const useEventCallback$1 = (fn) => {
      const callbackRef = reactExports.useRef(() => {
        throw new Error("Cannot call an event handler while rendering");
      });
      useIsomorphicLayoutEffect(() => {
        callbackRef.current = fn;
      }, [
        fn
      ]);
      return reactExports.useCallback((...args) => {
        const callback = callbackRef.current;
        return callback(...args);
      }, [
        callbackRef
      ]);
    };
    const IdPrefixContext = reactExports.createContext(void 0);
    IdPrefixContext.Provider;
    function useIdPrefix() {
      return reactExports.useContext(IdPrefixContext) || "";
    }
    function useId(prefix2 = "fui-", providedId) {
      const contextValue = useSSRContext();
      const idPrefix = useIdPrefix();
      const _useId = React$1["useId"];
      if (_useId) {
        const generatedId = _useId();
        const escapedId = reactExports.useMemo(() => generatedId.replace(/:/g, ""), [
          generatedId
        ]);
        return providedId || `${idPrefix}${prefix2}${escapedId}`;
      }
      return reactExports.useMemo(() => {
        if (providedId) {
          return providedId;
        }
        return `${idPrefix}${prefix2}${++contextValue.current}`;
      }, [
        idPrefix,
        prefix2,
        providedId,
        contextValue
      ]);
    }
    function useMergedRefs(...refs) {
      const mergedCallback = reactExports.useCallback(
        (value) => {
          mergedCallback.current = value;
          for (const ref of refs) {
            if (typeof ref === "function") {
              ref(value);
            } else if (ref) {
              ref.current = value;
            }
          }
        },
        // eslint-disable-next-line react-hooks/exhaustive-deps -- already exhaustive
        [
          ...refs
        ]
      );
      return mergedCallback;
    }
    const ThemeContext = reactExports.createContext(void 0);
    const ThemeProvider = ThemeContext.Provider;
    const ThemeClassNameContext = reactExports.createContext(void 0);
    const themeClassNameContextDefaultVaue = "";
    const ThemeClassNameProvider = ThemeClassNameContext.Provider;
    function useThemeClassName() {
      var _React_useContext;
      return (_React_useContext = reactExports.useContext(ThemeClassNameContext)) !== null && _React_useContext !== void 0 ? _React_useContext : themeClassNameContextDefaultVaue;
    }
    const TooltipVisibilityContext = reactExports.createContext(void 0);
    const tooltipVisibilityContextDefaultValue = {};
    const TooltipVisibilityProvider = TooltipVisibilityContext.Provider;
    function useTooltipVisibility() {
      var _React_useContext;
      return (_React_useContext = reactExports.useContext(TooltipVisibilityContext)) !== null && _React_useContext !== void 0 ? _React_useContext : tooltipVisibilityContextDefaultValue;
    }
    const ProviderContext = reactExports.createContext(void 0);
    const providerContextDefaultValue = {
      // eslint-disable-next-line no-restricted-globals
      targetDocument: typeof document === "object" ? document : void 0,
      dir: "ltr"
    };
    const Provider = ProviderContext.Provider;
    function useFluent() {
      var _React_useContext;
      return (_React_useContext = reactExports.useContext(ProviderContext)) !== null && _React_useContext !== void 0 ? _React_useContext : providerContextDefaultValue;
    }
    const OverridesContext = reactExports.createContext(void 0);
    const OverridesProvider = OverridesContext.Provider;
    function useOverrides() {
      var _React_useContext;
      return (_React_useContext = reactExports.useContext(OverridesContext)) !== null && _React_useContext !== void 0 ? _React_useContext : {};
    }
    const CustomStyleHooksContext = reactExports.createContext(void 0);
    const noop$2 = () => {
    };
    const CustomStyleHooksProvider = CustomStyleHooksContext.Provider;
    const useCustomStyleHook = (hook) => {
      var _React_useContext;
      var _React_useContext_hook;
      return (_React_useContext_hook = (_React_useContext = reactExports.useContext(CustomStyleHooksContext)) === null || _React_useContext === void 0 ? void 0 : _React_useContext[hook]) !== null && _React_useContext_hook !== void 0 ? _React_useContext_hook : noop$2;
    };
    const BackgroundAppearanceContext = reactExports.createContext(void 0);
    BackgroundAppearanceContext.Provider;
    function useBackgroundAppearance() {
      return reactExports.useContext(BackgroundAppearanceContext);
    }
    const PortalMountNodeContext = reactExports.createContext(void 0);
    PortalMountNodeContext.Provider;
    function usePortalMountNode$1() {
      return reactExports.useContext(PortalMountNodeContext);
    }
    const DEFAULT_CONTAINS = (parent, child) => !!(parent === null || parent === void 0 ? void 0 : parent.contains(child));
    const useOnClickOutside = (options) => {
      const { targetDocument } = useFluent();
      const win = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView;
      const { refs, callback, element: element2, disabled, disabledFocusOnIframe, contains = DEFAULT_CONTAINS } = options;
      const timeoutId = reactExports.useRef(void 0);
      useIFrameFocus({
        element: element2,
        disabled: disabledFocusOnIframe || disabled,
        callback,
        refs,
        contains
      });
      const isMouseDownInsideRef = reactExports.useRef(false);
      const listener = useEventCallback$1((ev) => {
        if (isMouseDownInsideRef.current) {
          isMouseDownInsideRef.current = false;
          return;
        }
        const target = ev.composedPath()[0];
        const isOutside = refs.every((ref) => !contains(ref.current || null, target));
        if (isOutside && !disabled) {
          callback(ev);
        }
      });
      const handleMouseDown = useEventCallback$1((ev) => {
        isMouseDownInsideRef.current = refs.some((ref) => contains(ref.current || null, ev.target));
      });
      reactExports.useEffect(() => {
        if (disabled) {
          return;
        }
        let currentEvent = getWindowEvent(win);
        const conditionalHandler = (event) => {
          if (event === currentEvent) {
            currentEvent = void 0;
            return;
          }
          listener(event);
        };
        element2 === null || element2 === void 0 ? void 0 : element2.addEventListener("click", conditionalHandler, true);
        element2 === null || element2 === void 0 ? void 0 : element2.addEventListener("touchstart", conditionalHandler, true);
        element2 === null || element2 === void 0 ? void 0 : element2.addEventListener("contextmenu", conditionalHandler, true);
        element2 === null || element2 === void 0 ? void 0 : element2.addEventListener("mousedown", handleMouseDown, true);
        timeoutId.current = win === null || win === void 0 ? void 0 : win.setTimeout(() => {
          currentEvent = void 0;
        }, 1);
        return () => {
          element2 === null || element2 === void 0 ? void 0 : element2.removeEventListener("click", conditionalHandler, true);
          element2 === null || element2 === void 0 ? void 0 : element2.removeEventListener("touchstart", conditionalHandler, true);
          element2 === null || element2 === void 0 ? void 0 : element2.removeEventListener("contextmenu", conditionalHandler, true);
          element2 === null || element2 === void 0 ? void 0 : element2.removeEventListener("mousedown", handleMouseDown, true);
          win === null || win === void 0 ? void 0 : win.clearTimeout(timeoutId.current);
          currentEvent = void 0;
        };
      }, [
        listener,
        element2,
        disabled,
        handleMouseDown,
        win
      ]);
    };
    const getWindowEvent = (target) => {
      if (target) {
        var _target_ownerDocument_defaultView, _target_ownerDocument;
        if (typeof target.window === "object" && target.window === target) {
          return target.event;
        }
        var _target_ownerDocument_defaultView_event;
        return (_target_ownerDocument_defaultView_event = (_target_ownerDocument = target.ownerDocument) === null || _target_ownerDocument === void 0 ? void 0 : (_target_ownerDocument_defaultView = _target_ownerDocument.defaultView) === null || _target_ownerDocument_defaultView === void 0 ? void 0 : _target_ownerDocument_defaultView.event) !== null && _target_ownerDocument_defaultView_event !== void 0 ? _target_ownerDocument_defaultView_event : void 0;
      }
      return void 0;
    };
    const FUI_FRAME_EVENT = "fuiframefocus";
    const useIFrameFocus = (options) => {
      const { disabled, element: targetDocument, callback, contains = DEFAULT_CONTAINS, pollDuration = 1e3, refs } = options;
      const timeoutRef = reactExports.useRef();
      const listener = useEventCallback$1((e2) => {
        const isOutside = refs.every((ref) => !contains(ref.current || null, e2.target));
        if (isOutside && !disabled) {
          callback(e2);
        }
      });
      reactExports.useEffect(() => {
        if (disabled) {
          return;
        }
        targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener(FUI_FRAME_EVENT, listener, true);
        return () => {
          targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener(FUI_FRAME_EVENT, listener, true);
        };
      }, [
        targetDocument,
        disabled,
        listener
      ]);
      reactExports.useEffect(() => {
        var _targetDocument_defaultView;
        if (disabled) {
          return;
        }
        timeoutRef.current = targetDocument === null || targetDocument === void 0 ? void 0 : (_targetDocument_defaultView = targetDocument.defaultView) === null || _targetDocument_defaultView === void 0 ? void 0 : _targetDocument_defaultView.setInterval(() => {
          const activeElement = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement;
          if ((activeElement === null || activeElement === void 0 ? void 0 : activeElement.tagName) === "IFRAME" || (activeElement === null || activeElement === void 0 ? void 0 : activeElement.tagName) === "WEBVIEW") {
            const event = new CustomEvent(FUI_FRAME_EVENT, {
              bubbles: true
            });
            activeElement.dispatchEvent(event);
          }
        }, pollDuration);
        return () => {
          var _targetDocument_defaultView2;
          targetDocument === null || targetDocument === void 0 ? void 0 : (_targetDocument_defaultView2 = targetDocument.defaultView) === null || _targetDocument_defaultView2 === void 0 ? void 0 : _targetDocument_defaultView2.clearTimeout(timeoutRef.current);
        };
      }, [
        targetDocument,
        disabled,
        pollDuration
      ]);
    };
    const useOnScrollOutside = (options) => {
      const { refs, callback, element: element2, disabled, contains: containsProp } = options;
      const listener = useEventCallback$1((ev) => {
        const contains = containsProp || ((parent, child) => !!(parent === null || parent === void 0 ? void 0 : parent.contains(child)));
        const target = ev.composedPath()[0];
        const isOutside = refs.every((ref) => !contains(ref.current || null, target));
        if (isOutside && !disabled) {
          callback(ev);
        }
      });
      reactExports.useEffect(() => {
        if (disabled) {
          return;
        }
        element2 === null || element2 === void 0 ? void 0 : element2.addEventListener("wheel", listener);
        element2 === null || element2 === void 0 ? void 0 : element2.addEventListener("touchmove", listener);
        return () => {
          element2 === null || element2 === void 0 ? void 0 : element2.removeEventListener("wheel", listener);
          element2 === null || element2 === void 0 ? void 0 : element2.removeEventListener("touchmove", listener);
        };
      }, [
        listener,
        element2,
        disabled
      ]);
    };
    function useTimeout() {
      return useBrowserTimer(setTimeout, clearTimeout);
    }
    function mergeCallbacks(callback1, callback2) {
      return (...args) => {
        callback1 === null || callback1 === void 0 ? void 0 : callback1(...args);
        callback2 === null || callback2 === void 0 ? void 0 : callback2(...args);
      };
    }
    function isHTMLElement$1(element2, options) {
      var _typedElement_ownerDocument;
      const typedElement = element2;
      var _options_constructorName;
      return Boolean((typedElement === null || typedElement === void 0 ? void 0 : (_typedElement_ownerDocument = typedElement.ownerDocument) === null || _typedElement_ownerDocument === void 0 ? void 0 : _typedElement_ownerDocument.defaultView) && typedElement instanceof typedElement.ownerDocument.defaultView[(_options_constructorName = options === null || options === void 0 ? void 0 : options.constructorName) !== null && _options_constructorName !== void 0 ? _options_constructorName : "HTMLElement"]);
    }
    function isFluentTrigger(element2) {
      return Boolean(element2.type.isFluentTriggerComponent);
    }
    function applyTriggerPropsToChildren(children, triggerChildProps) {
      if (typeof children === "function") {
        return children(triggerChildProps);
      } else if (children) {
        return cloneTriggerTree(children, triggerChildProps);
      }
      return children || null;
    }
    function cloneTriggerTree(child, triggerProps) {
      if (!reactExports.isValidElement(child) || child.type === reactExports.Fragment) {
        throw new Error("A trigger element must be a single element for this component. Please ensure that you're not using React Fragments.");
      }
      if (isFluentTrigger(child)) {
        const grandchild = cloneTriggerTree(child.props.children, triggerProps);
        return reactExports.cloneElement(child, void 0, grandchild);
      } else {
        return reactExports.cloneElement(child, triggerProps);
      }
    }
    function getTriggerChild(children) {
      if (!reactExports.isValidElement(children)) {
        return null;
      }
      return isFluentTrigger(children) ? getTriggerChild(
        // FIXME: This casting should be unnecessary as isFluentTrigger is a guard type method,
        // but for some reason it's failing on build
        children.props.children
      ) : children;
    }
    function isVirtualElement(element2) {
      return element2 && !!element2._virtual;
    }
    function getVirtualParent(child) {
      return isVirtualElement(child) ? child._virtual.parent || null : null;
    }
    function getParent(child, options = {}) {
      if (!child) {
        return null;
      }
      if (!options.skipVirtual) {
        const virtualParent = getVirtualParent(child);
        if (virtualParent) {
          return virtualParent;
        }
      }
      return (child === null || child === void 0 ? void 0 : child.parentNode) || null;
    }
    function elementContains(parent, child) {
      if (!parent || !child) {
        return false;
      }
      if (parent === child) {
        return true;
      } else {
        const set2 = /* @__PURE__ */ new WeakSet();
        while (child) {
          const nextParent = getParent(child, {
            skipVirtual: set2.has(child)
          });
          set2.add(child);
          if (nextParent === parent) {
            return true;
          }
          child = nextParent;
        }
      }
      return false;
    }
    function setVirtualParent(child, parent) {
      if (!child) {
        return;
      }
      const virtualChild = child;
      if (!virtualChild._virtual) {
        virtualChild._virtual = {};
      }
      virtualChild._virtual.parent = parent;
    }
    function createCompatSlotComponent(type, props) {
      return {
        ...props,
        [SLOT_ELEMENT_TYPE_SYMBOL]: type
      };
    }
    function createJSX(runtime, slotRuntime) {
      return function jsx2(type, overrideProps, key, source, self2) {
        if (isSlot(overrideProps)) {
          return slotRuntime(createCompatSlotComponent(type, overrideProps), null, key, source, self2);
        }
        if (isSlot(type)) {
          return slotRuntime(type, overrideProps, key, source, self2);
        }
        return runtime(type, overrideProps, key, source, self2);
      };
    }
    function getMetadataFromSlotComponent(type) {
      const { as: as2, [SLOT_ELEMENT_TYPE_SYMBOL]: baseElementType, [SLOT_RENDER_FUNCTION_SYMBOL]: renderFunction, ...propsWithoutMetadata } = type;
      const props = propsWithoutMetadata;
      const elementType = typeof baseElementType === "string" ? as2 !== null && as2 !== void 0 ? as2 : baseElementType : baseElementType;
      if (typeof elementType !== "string" && as2) {
        props.as = as2;
      }
      return {
        elementType,
        props,
        renderFunction
      };
    }
    const Runtime = ReactRuntime;
    const jsxSlot = (type, overrideProps, key) => {
      const { elementType, renderFunction, props: slotProps } = getMetadataFromSlotComponent(type);
      const props = {
        ...slotProps,
        ...overrideProps
      };
      if (renderFunction) {
        return Runtime.jsx(reactExports.Fragment, {
          children: renderFunction(elementType, props)
        }, key);
      }
      return Runtime.jsx(elementType, props, key);
    };
    const jsxsSlot = (type, overrideProps, key) => {
      const { elementType, renderFunction, props: slotProps } = getMetadataFromSlotComponent(type);
      const props = {
        ...slotProps,
        ...overrideProps
      };
      if (renderFunction) {
        return Runtime.jsx(reactExports.Fragment, {
          children: renderFunction(elementType, {
            ...props,
            children: Runtime.jsxs(reactExports.Fragment, {
              children: props.children
            }, void 0)
          })
        }, key);
      }
      return Runtime.jsxs(elementType, props, key);
    };
    const jsx = createJSX(Runtime.jsx, jsxSlot);
    const jsxs = createJSX(Runtime.jsxs, jsxsSlot);
    const IconDirectionContext = reactExports.createContext(void 0);
    const IconDirectionContextDefaultValue = {};
    const IconDirectionContextProvider = IconDirectionContext.Provider;
    const useIconContext = () => reactExports.useContext(IconDirectionContext) ? reactExports.useContext(IconDirectionContext) : IconDirectionContextDefaultValue;
    const __GLOBAL__$1 = typeof window === "undefined" ? global : window;
    const __NAMESPACE_PREFIX__$1 = "@griffel/";
    function getGlobalVar$1(name2, defaultValue) {
      if (!__GLOBAL__$1[Symbol.for(__NAMESPACE_PREFIX__$1 + name2)]) {
        __GLOBAL__$1[Symbol.for(__NAMESPACE_PREFIX__$1 + name2)] = defaultValue;
      }
      return __GLOBAL__$1[Symbol.for(__NAMESPACE_PREFIX__$1 + name2)];
    }
    const DEFINITION_LOOKUP_TABLE$1 = /* @__PURE__ */ getGlobalVar$1("DEFINITION_LOOKUP_TABLE", {});
    const DATA_BUCKET_ATTR = "data-make-styles-bucket";
    const SEQUENCE_HASH_LENGTH$1 = 7;
    const SEQUENCE_PREFIX$1 = "___";
    const SEQUENCE_SIZE$1 = SEQUENCE_PREFIX$1.length + SEQUENCE_HASH_LENGTH$1;
    const LOOKUP_DEFINITIONS_INDEX$1 = 0;
    const LOOKUP_DIR_INDEX$1 = 1;
    function murmur2(str) {
      var h2 = 0;
      var k2, i2 = 0, len = str.length;
      for (; len >= 4; ++i2, len -= 4) {
        k2 = str.charCodeAt(i2) & 255 | (str.charCodeAt(++i2) & 255) << 8 | (str.charCodeAt(++i2) & 255) << 16 | (str.charCodeAt(++i2) & 255) << 24;
        k2 = /* Math.imul(k, m): */
        (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
        k2 ^= /* k >>> r: */
        k2 >>> 24;
        h2 = /* Math.imul(k, m): */
        (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
        (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      }
      switch (len) {
        case 3:
          h2 ^= (str.charCodeAt(i2 + 2) & 255) << 16;
        case 2:
          h2 ^= (str.charCodeAt(i2 + 1) & 255) << 8;
        case 1:
          h2 ^= str.charCodeAt(i2) & 255;
          h2 = /* Math.imul(h, m): */
          (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      }
      h2 ^= h2 >>> 13;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
    }
    function padEndHash$1(value) {
      const hashLength = value.length;
      if (hashLength === SEQUENCE_HASH_LENGTH$1) {
        return value;
      }
      for (let i2 = hashLength; i2 < SEQUENCE_HASH_LENGTH$1; i2++) {
        value += "0";
      }
      return value;
    }
    function hashSequence$1(classes, dir, sequenceIds = []) {
      {
        return SEQUENCE_PREFIX$1 + padEndHash$1(murmur2(classes + dir));
      }
    }
    function reduceToClassName$1(classMap, dir) {
      let className = "";
      for (const propertyHash in classMap) {
        const classNameMapping = classMap[propertyHash];
        if (classNameMapping) {
          const hasRTLClassName = Array.isArray(classNameMapping);
          if (dir === "rtl") {
            className += (hasRTLClassName ? classNameMapping[1] : classNameMapping) + " ";
          } else {
            className += (hasRTLClassName ? classNameMapping[0] : classNameMapping) + " ";
          }
        }
      }
      return className.slice(0, -1);
    }
    function reduceToClassNameForSlots$1(classesMapBySlot, dir) {
      const classNamesForSlots = {};
      for (const slotName in classesMapBySlot) {
        const slotClasses = reduceToClassName$1(classesMapBySlot[slotName], dir);
        if (slotClasses === "") {
          classNamesForSlots[slotName] = "";
          continue;
        }
        const sequenceHash = hashSequence$1(slotClasses, dir);
        const resultSlotClasses = sequenceHash + " " + slotClasses;
        DEFINITION_LOOKUP_TABLE$1[sequenceHash] = [classesMapBySlot[slotName], dir];
        classNamesForSlots[slotName] = resultSlotClasses;
      }
      return classNamesForSlots;
    }
    const mergeClassesCachedResults$1 = {};
    function mergeClasses$1() {
      let dir = null;
      let resultClassName = "";
      let sequenceMatch = "";
      const sequencesIds = new Array(arguments.length);
      for (let i2 = 0; i2 < arguments.length; i2++) {
        const className = arguments[i2];
        if (typeof className === "string" && className !== "") {
          const sequenceIndex = className.indexOf(SEQUENCE_PREFIX$1);
          if (sequenceIndex === -1) {
            resultClassName += className + " ";
          } else {
            const sequenceId = className.substr(sequenceIndex, SEQUENCE_SIZE$1);
            if (sequenceIndex > 0) {
              resultClassName += className.slice(0, sequenceIndex);
            }
            sequenceMatch += sequenceId;
            sequencesIds[i2] = sequenceId;
          }
        }
      }
      if (sequenceMatch === "") {
        return resultClassName.slice(0, -1);
      }
      const mergeClassesResult = mergeClassesCachedResults$1[sequenceMatch];
      if (mergeClassesResult !== void 0) {
        return resultClassName + mergeClassesResult;
      }
      const sequenceMappings = [];
      for (let i2 = 0; i2 < arguments.length; i2++) {
        const sequenceId = sequencesIds[i2];
        if (sequenceId) {
          const sequenceMapping = DEFINITION_LOOKUP_TABLE$1[sequenceId];
          if (sequenceMapping) {
            sequenceMappings.push(sequenceMapping[LOOKUP_DEFINITIONS_INDEX$1]);
            dir = sequenceMapping[LOOKUP_DIR_INDEX$1];
          }
        }
      }
      const resultDefinitions = Object.assign.apply(
        Object,
        // .assign() mutates the first object, we can't mutate mappings as it will produce invalid results later
        [{}].concat(sequenceMappings)
      );
      let atomicClassNames = reduceToClassName$1(resultDefinitions, dir);
      const newSequenceHash = hashSequence$1(atomicClassNames, dir, sequencesIds);
      atomicClassNames = newSequenceHash + " " + atomicClassNames;
      mergeClassesCachedResults$1[sequenceMatch] = atomicClassNames;
      DEFINITION_LOOKUP_TABLE$1[newSequenceHash] = [resultDefinitions, dir];
      return resultClassName + atomicClassNames;
    }
    const sequenceDetails = {};
    const cssRules = /* @__PURE__ */ new Set();
    const debugData = {
      getChildrenSequences: (debugSequenceHash) => {
        const key = Object.keys(mergeClassesCachedResults$1).find((key2) => mergeClassesCachedResults$1[key2].startsWith(debugSequenceHash));
        if (key) {
          return key.split(SEQUENCE_PREFIX$1).filter((sequence) => sequence.length).map((sequence) => SEQUENCE_PREFIX$1 + sequence);
        }
        return [];
      },
      addCSSRule: (rule) => {
        cssRules.add(rule);
      },
      addSequenceDetails: (classNamesForSlots, sourceURL) => {
        Object.entries(classNamesForSlots).forEach(([slotName, sequenceHash]) => {
          sequenceDetails[sequenceHash.substring(0, SEQUENCE_SIZE$1)] = {
            slotName,
            sourceURL
          };
        });
      },
      getCSSRules: () => {
        return Array.from(cssRules);
      },
      getSequenceDetails: (sequenceHash) => {
        return sequenceDetails[sequenceHash];
      }
    };
    function getDirectionalClassName(classes, direction) {
      return Array.isArray(classes) ? direction === "rtl" ? classes[1] : classes[0] : classes;
    }
    function getDebugClassNames(lookupItem, parentLookupItem, parentDebugClassNames, overridingSiblings) {
      const classesMapping = lookupItem[0];
      const direction = lookupItem[1];
      return Object.entries(classesMapping).map(([propertyHash, classes]) => {
        const className = getDirectionalClassName(classes, direction);
        let overriddenBy;
        if (parentDebugClassNames && parentLookupItem) {
          const matching = parentDebugClassNames.find(({
            className: parentClassName
          }) => parentClassName === className);
          if (!matching && parentLookupItem[0][propertyHash]) {
            overriddenBy = getDirectionalClassName(parentLookupItem[0][propertyHash], parentLookupItem[1]);
          } else if (matching && parentLookupItem[0][propertyHash]) {
            const siblingHasSameRule = overridingSiblings ? overridingSiblings.filter(({
              debugClassNames
            }) => debugClassNames.filter(({
              className: siblingClassName
            }) => siblingClassName === className).length > 0).length > 0 : false;
            overriddenBy = siblingHasSameRule ? matching.className : matching.overriddenBy;
          } else if (!matching && !parentLookupItem[0][propertyHash]) {
            overriddenBy = void 0;
          } else if (matching && !parentLookupItem[0][propertyHash]) {
            overriddenBy = void 0;
          }
        }
        return {
          className,
          overriddenBy
        };
      });
    }
    function getDebugTree(debugSequenceHash, parentNode) {
      const lookupItem = DEFINITION_LOOKUP_TABLE$1[debugSequenceHash];
      if (lookupItem === void 0) {
        return void 0;
      }
      const parentLookupItem = parentNode ? DEFINITION_LOOKUP_TABLE$1[parentNode.sequenceHash] : void 0;
      const debugClassNames = getDebugClassNames(lookupItem, parentLookupItem, parentNode === null || parentNode === void 0 ? void 0 : parentNode.debugClassNames, parentNode === null || parentNode === void 0 ? void 0 : parentNode.children);
      const node2 = {
        sequenceHash: debugSequenceHash,
        direction: lookupItem[1],
        children: [],
        debugClassNames
      };
      const childrenSequences = debugData.getChildrenSequences(node2.sequenceHash);
      childrenSequences.reverse().forEach((sequence) => {
        const child = getDebugTree(sequence, node2);
        if (child) {
          node2.children.push(child);
        }
      });
      if (!node2.children.length) {
        node2.rules = {};
        node2.debugClassNames.forEach(({
          className
        }) => {
          const mapData = debugData.getSequenceDetails(debugSequenceHash);
          if (mapData) {
            node2.slot = mapData.slotName;
            node2.sourceURL = mapData.sourceURL;
          }
          const cssRule = debugData.getCSSRules().find((cssRule2) => {
            return cssRule2.includes(className);
          });
          node2.rules[className] = cssRule;
        });
      }
      return node2;
    }
    function injectDevTools(document2) {
      const window2 = document2.defaultView;
      if (!window2 || window2.__GRIFFEL_DEVTOOLS__) {
        return;
      }
      const devtools = {
        getInfo: (element2) => {
          const rootDebugSequenceHash = Array.from(element2.classList).find((className) => className.startsWith(SEQUENCE_PREFIX$1));
          if (rootDebugSequenceHash === void 0) {
            return void 0;
          }
          return getDebugTree(rootDebugSequenceHash);
        }
      };
      Object.defineProperty(window2, "__GRIFFEL_DEVTOOLS__", {
        configurable: false,
        enumerable: false,
        get() {
          return devtools;
        }
      });
    }
    const isDevToolsEnabled = /* @__PURE__ */ (() => {
      var _a2;
      try {
        return Boolean(typeof window !== "undefined" && ((_a2 = window.sessionStorage) === null || _a2 === void 0 ? void 0 : _a2.getItem("__GRIFFEL_DEVTOOLS__")));
      } catch (e2) {
        return false;
      }
    })();
    function normalizeCSSBucketEntry(entry) {
      if (!Array.isArray(entry)) {
        return [entry];
      }
      return entry;
    }
    function createIsomorphicStyleSheet(styleElement, bucketName, elementAttributes) {
      const __cssRulesForSSR = [];
      elementAttributes[DATA_BUCKET_ATTR] = bucketName;
      if (styleElement) {
        for (const attrName in elementAttributes) {
          styleElement.setAttribute(attrName, elementAttributes[attrName]);
        }
      }
      function insertRule(rule) {
        if (styleElement === null || styleElement === void 0 ? void 0 : styleElement.sheet) {
          return styleElement.sheet.insertRule(rule, styleElement.sheet.cssRules.length);
        }
        return __cssRulesForSSR.push(rule);
      }
      return {
        elementAttributes,
        insertRule,
        element: styleElement,
        bucketName,
        cssRules() {
          if (styleElement === null || styleElement === void 0 ? void 0 : styleElement.sheet) {
            return Array.from(styleElement.sheet.cssRules).map((cssRule) => cssRule.cssText);
          }
          return __cssRulesForSSR;
        }
      };
    }
    const styleBucketOrdering = [
      // reset styles
      "r",
      // catch-all
      "d",
      // link
      "l",
      // visited
      "v",
      // focus-within
      "w",
      // focus
      "f",
      // focus-visible
      "i",
      // hover
      "h",
      // active
      "a",
      // keyframes
      "k",
      // at-rules
      "t",
      // @media rules
      "m"
    ];
    const styleBucketOrderingMap = /* @__PURE__ */ styleBucketOrdering.reduce((acc, cur, j) => {
      acc[cur] = j;
      return acc;
    }, {});
    function getStyleSheetForBucket(bucketName, target, renderer, metadata = {}) {
      const isMediaBucket = bucketName === "m";
      const stylesheetKey = isMediaBucket ? bucketName + metadata["m"] : bucketName;
      if (!renderer.stylesheets[stylesheetKey]) {
        const tag = target && target.createElement("style");
        const stylesheet2 = createIsomorphicStyleSheet(tag, bucketName, Object.assign(Object.assign({}, renderer.styleElementAttributes), isMediaBucket && {
          media: metadata["m"]
        }));
        renderer.stylesheets[stylesheetKey] = stylesheet2;
        if (target && tag) {
          const elementSibling = findElementSibling(target, bucketName, renderer, metadata);
          target.head.insertBefore(tag, elementSibling);
        }
      }
      return renderer.stylesheets[stylesheetKey];
    }
    function findElementSibling(target, targetBucket, renderer, metadata) {
      const targetOrder = styleBucketOrderingMap[targetBucket];
      let comparer = (el) => targetOrder - styleBucketOrderingMap[el.getAttribute(DATA_BUCKET_ATTR)];
      let styleElements = target.head.querySelectorAll(`[${DATA_BUCKET_ATTR}]`);
      if (targetBucket === "m" && metadata) {
        const mediaElements = target.head.querySelectorAll(`[${DATA_BUCKET_ATTR}="${targetBucket}"]`);
        if (mediaElements.length) {
          styleElements = mediaElements;
          comparer = (el) => renderer.compareMediaQueries(metadata["m"], el.media);
        }
      }
      for (const styleElement of styleElements) {
        if (comparer(styleElement) < 0) {
          return styleElement;
        }
      }
      return null;
    }
    let lastIndex = 0;
    const defaultCompareMediaQueries = (a2, b2) => a2 < b2 ? -1 : a2 > b2 ? 1 : 0;
    function createDOMRenderer(target = typeof document === "undefined" ? void 0 : document, options = {}) {
      const {
        unstable_filterCSSRule,
        styleElementAttributes,
        compareMediaQueries = defaultCompareMediaQueries
      } = options;
      const renderer = {
        insertionCache: {},
        stylesheets: {},
        styleElementAttributes: Object.freeze(styleElementAttributes),
        compareMediaQueries,
        id: `d${lastIndex++}`,
        insertCSSRules(cssRules2) {
          for (const styleBucketName in cssRules2) {
            const cssRulesForBucket = cssRules2[styleBucketName];
            for (let i2 = 0, l2 = cssRulesForBucket.length; i2 < l2; i2++) {
              const [ruleCSS, metadata] = normalizeCSSBucketEntry(cssRulesForBucket[i2]);
              const sheet = getStyleSheetForBucket(styleBucketName, target, renderer, metadata);
              if (renderer.insertionCache[ruleCSS]) {
                continue;
              }
              renderer.insertionCache[ruleCSS] = styleBucketName;
              try {
                if (unstable_filterCSSRule) {
                  if (unstable_filterCSSRule(ruleCSS)) {
                    sheet.insertRule(ruleCSS);
                  }
                } else {
                  sheet.insertRule(ruleCSS);
                }
              } catch (e2) {
              }
            }
          }
        }
      };
      if (target && false) {
        injectDevTools(target);
      }
      return renderer;
    }
    function __styles$2(classesMapBySlot, cssRules2) {
      const insertionCache = {};
      let ltrClassNamesForSlots = null;
      let rtlClassNamesForSlots = null;
      function computeClasses(options) {
        const {
          dir,
          renderer
        } = options;
        const isLTR = dir === "ltr";
        const rendererId = isLTR ? renderer.id : renderer.id + "r";
        if (isLTR) {
          if (ltrClassNamesForSlots === null) {
            ltrClassNamesForSlots = reduceToClassNameForSlots$1(classesMapBySlot, dir);
          }
        } else {
          if (rtlClassNamesForSlots === null) {
            rtlClassNamesForSlots = reduceToClassNameForSlots$1(classesMapBySlot, dir);
          }
        }
        if (insertionCache[rendererId] === void 0) {
          renderer.insertCSSRules(cssRules2);
          insertionCache[rendererId] = true;
        }
        const classNamesForSlots = isLTR ? ltrClassNamesForSlots : rtlClassNamesForSlots;
        return classNamesForSlots;
      }
      return computeClasses;
    }
    const RendererContext = /* @__PURE__ */ reactExports.createContext(/* @__PURE__ */ createDOMRenderer());
    function useRenderer() {
      return reactExports.useContext(RendererContext);
    }
    const TextDirectionContext = /* @__PURE__ */ reactExports.createContext("ltr");
    function useTextDirection() {
      return reactExports.useContext(TextDirectionContext);
    }
    function __styles$1(classesMapBySlot, cssRules2) {
      const getStyles2 = __styles$2(classesMapBySlot, cssRules2);
      return function useClasses() {
        const dir = useTextDirection();
        const renderer = useRenderer();
        return getStyles2({
          dir,
          renderer
        });
      };
    }
    const useRootStyles$6 = __styles$1({
      "root": {
        "mc9l5x": "f1w7gpdv",
        "Bg96gwp": "fez10in",
        "ycbfsm": "fg4l7m0"
      },
      "rtl": {
        "Bz10aip": "f13rod7r"
      }
    }, {
      "d": [".f1w7gpdv{display:inline;}", ".fez10in{line-height:0;}", ".f13rod7r{-webkit-transform:scaleX(-1);-moz-transform:scaleX(-1);-ms-transform:scaleX(-1);transform:scaleX(-1);}"],
      "t": ["@media (forced-colors: active){.fg4l7m0{forced-color-adjust:auto;}}"]
    });
    const useIconState = (props, options) => {
      const {
        title,
        primaryFill = "currentColor",
        ...rest
      } = props;
      const state = {
        ...rest,
        title: void 0,
        fill: primaryFill
      };
      const styles2 = useRootStyles$6();
      const iconContext = useIconContext();
      state.className = mergeClasses$1(styles2.root, (options === null || options === void 0 ? void 0 : options.flipInRtl) && (iconContext === null || iconContext === void 0 ? void 0 : iconContext.textDirection) === "rtl" && styles2.rtl, state.className);
      if (title) {
        state["aria-label"] = title;
      }
      if (!state["aria-label"] && !state["aria-labelledby"]) {
        state["aria-hidden"] = true;
      } else {
        state["role"] = "img";
      }
      return state;
    };
    const createFluentIcon = (displayName, width, paths, options) => {
      const viewBoxWidth = width === "1em" ? "20" : width;
      const Icon2 = reactExports.forwardRef((props, ref) => {
        const state = {
          ...useIconState(props, {
            flipInRtl: options === null || options === void 0 ? void 0 : options.flipInRtl
          }),
          ref,
          width,
          height: width,
          viewBox: `0 0 ${viewBoxWidth} ${viewBoxWidth}`,
          xmlns: "http://www.w3.org/2000/svg"
        };
        return reactExports.createElement("svg", state, ...paths.map((d2) => reactExports.createElement("path", {
          d: d2,
          fill: state.fill
        })));
      });
      Icon2.displayName = displayName;
      return Icon2;
    };
    const ChevronLeftFilled = /* @__PURE__ */ createFluentIcon("ChevronLeftFilled", "1em", ["M12.27 15.8a.75.75 0 0 1-1.06-.03l-5-5.25a.75.75 0 0 1 0-1.04l5-5.25a.75.75 0 1 1 1.08 1.04L7.8 10l4.5 4.73c.29.3.28.78-.02 1.06Z"]);
    const ChevronLeftRegular = /* @__PURE__ */ createFluentIcon("ChevronLeftRegular", "1em", ["M12.35 15.85a.5.5 0 0 1-.7 0L6.16 10.4a.55.55 0 0 1 0-.78l5.49-5.46a.5.5 0 1 1 .7.7L7.2 10l5.16 5.15c.2.2.2.5 0 .7Z"]);
    const ChevronRightFilled = /* @__PURE__ */ createFluentIcon("ChevronRightFilled", "1em", ["M7.73 4.2a.75.75 0 0 1 1.06.03l5 5.25c.28.3.28.75 0 1.04l-5 5.25a.75.75 0 1 1-1.08-1.04L12.2 10l-4.5-4.73a.75.75 0 0 1 .02-1.06Z"]);
    const ChevronRightRegular = /* @__PURE__ */ createFluentIcon("ChevronRightRegular", "1em", ["M7.65 4.15c.2-.2.5-.2.7 0l5.49 5.46c.21.22.21.57 0 .78l-5.49 5.46a.5.5 0 0 1-.7-.7L12.8 10 7.65 4.85a.5.5 0 0 1 0-.7Z"]);
    const CircleFilled = /* @__PURE__ */ createFluentIcon("CircleFilled", "1em", ["M10 2a8 8 0 1 0 0 16 8 8 0 0 0 0-16Z"]);
    const PersonRegular = /* @__PURE__ */ createFluentIcon("PersonRegular", "1em", ["M10 2a4 4 0 1 0 0 8 4 4 0 0 0 0-8ZM7 6a3 3 0 1 1 6 0 3 3 0 0 1-6 0Zm-2 5a2 2 0 0 0-2 2c0 1.7.83 2.97 2.13 3.8A9.14 9.14 0 0 0 10 18c1.85 0 3.58-.39 4.87-1.2A4.35 4.35 0 0 0 17 13a2 2 0 0 0-2-2H5Zm-1 2a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1c0 1.3-.62 2.28-1.67 2.95A8.16 8.16 0 0 1 10 17a8.16 8.16 0 0 1-4.33-1.05A3.36 3.36 0 0 1 4 13Z"]);
    const Add24Filled = /* @__PURE__ */ createFluentIcon("Add24Filled", "24", ["M11.88 3H12a1 1 0 0 1 1 .88V11h7a1 1 0 0 1 1 .88V12a1 1 0 0 1-.88 1H13v7a1 1 0 0 1-.88 1H12a1 1 0 0 1-1-.88V13H4a1 1 0 0 1-1-.88V12a1 1 0 0 1 .88-1H11V4a1 1 0 0 1 .88-1H12h-.12Z"]);
    const Add24Regular = /* @__PURE__ */ createFluentIcon("Add24Regular", "24", ["M11.75 3c.38 0 .7.28.74.65l.01.1V11h7.25a.75.75 0 0 1 .1 1.5H12.5v7.25a.75.75 0 0 1-1.49.1V12.5H3.74a.75.75 0 0 1-.1-1.5H11V3.75c0-.41.34-.75.75-.75Z"]);
    const Broom16Filled = /* @__PURE__ */ createFluentIcon("Broom16Filled", "16", ["M14.85 1.15c.2.2.2.5 0 .7L10.9 5.81a4.78 4.78 0 0 0-.71-.7l3.96-3.96c.2-.2.5-.2.7 0ZM4.65 6.19l-.39.36 5.2 5.2.4-.4a3.67 3.67 0 1 0-5.2-5.16ZM1.3 8.04l2.1-.95 5.52 5.52-.95 2.1a.5.5 0 0 1-.81.14l-6-6a.5.5 0 0 1 .14-.8Z"]);
    const CheckmarkCircle12Filled = /* @__PURE__ */ createFluentIcon("CheckmarkCircle12Filled", "12", ["M1 6a5 5 0 1 1 10 0A5 5 0 0 1 1 6Zm7.35-.9a.5.5 0 1 0-.7-.7L5.5 6.54 4.35 5.4a.5.5 0 1 0-.7.7l1.5 1.5c.2.2.5.2.7 0l2.5-2.5Z"]);
    const Copy24Regular = /* @__PURE__ */ createFluentIcon("Copy24Regular", "24", ["M5.5 4.63V17.25c0 1.8 1.46 3.25 3.25 3.25h8.62c-.31.88-1.15 1.5-2.13 1.5H8.75A4.75 4.75 0 0 1 4 17.25V6.75c0-.98.63-1.81 1.5-2.12ZM17.75 2C18.99 2 20 3 20 4.25v13c0 1.24-1 2.25-2.25 2.25h-9c-1.24 0-2.25-1-2.25-2.25v-13C6.5 3.01 7.5 2 8.75 2h9Zm0 1.5h-9a.75.75 0 0 0-.75.75v13c0 .41.34.75.75.75h9c.41 0 .75-.34.75-.75v-13a.75.75 0 0 0-.75-.75Z"]);
    const Delete24Regular = /* @__PURE__ */ createFluentIcon("Delete24Regular", "24", ["M10 5h4a2 2 0 1 0-4 0ZM8.5 5a3.5 3.5 0 1 1 7 0h5.75a.75.75 0 0 1 0 1.5h-1.32l-1.17 12.11A3.75 3.75 0 0 1 15.03 22H8.97a3.75 3.75 0 0 1-3.73-3.39L4.07 6.5H2.75a.75.75 0 0 1 0-1.5H8.5Zm2 4.75a.75.75 0 0 0-1.5 0v7.5a.75.75 0 0 0 1.5 0v-7.5ZM14.25 9c.41 0 .75.34.75.75v7.5a.75.75 0 0 1-1.5 0v-7.5c0-.41.34-.75.75-.75Zm-7.52 9.47a2.25 2.25 0 0 0 2.24 2.03h6.06c1.15 0 2.12-.88 2.24-2.03L18.42 6.5H5.58l1.15 11.97Z"]);
    const Dismiss16Regular = /* @__PURE__ */ createFluentIcon("Dismiss16Regular", "16", ["m2.59 2.72.06-.07a.5.5 0 0 1 .63-.06l.07.06L8 7.29l4.65-4.64a.5.5 0 0 1 .7.7L8.71 8l4.64 4.65c.18.17.2.44.06.63l-.06.07a.5.5 0 0 1-.63.06l-.07-.06L8 8.71l-4.65 4.64a.5.5 0 0 1-.7-.7L7.29 8 2.65 3.35a.5.5 0 0 1-.06-.63l.06-.07-.06.07Z"]);
    const Dismiss20Regular = /* @__PURE__ */ createFluentIcon("Dismiss20Regular", "20", ["m4.09 4.22.06-.07a.5.5 0 0 1 .63-.06l.07.06L10 9.29l5.15-5.14a.5.5 0 0 1 .63-.06l.07.06c.18.17.2.44.06.63l-.06.07L10.71 10l5.14 5.15c.18.17.2.44.06.63l-.06.07a.5.5 0 0 1-.63.06l-.07-.06L10 10.71l-5.15 5.14a.5.5 0 0 1-.63.06l-.07-.06a.5.5 0 0 1-.06-.63l.06-.07L9.29 10 4.15 4.85a.5.5 0 0 1-.06-.63l.06-.07-.06.07Z"]);
    const Dismiss24Filled = /* @__PURE__ */ createFluentIcon("Dismiss24Filled", "24", ["m4.21 4.39.08-.1a1 1 0 0 1 1.32-.08l.1.08L12 10.6l6.3-6.3a1 1 0 1 1 1.4 1.42L13.42 12l6.3 6.3a1 1 0 0 1 .08 1.31l-.08.1a1 1 0 0 1-1.32.08l-.1-.08L12 13.4l-6.3 6.3a1 1 0 0 1-1.4-1.42L10.58 12l-6.3-6.3a1 1 0 0 1-.08-1.31l.08-.1-.08.1Z"]);
    const Dismiss24Regular = /* @__PURE__ */ createFluentIcon("Dismiss24Regular", "24", ["m4.4 4.55.07-.08a.75.75 0 0 1 .98-.07l.08.07L12 10.94l6.47-6.47a.75.75 0 1 1 1.06 1.06L13.06 12l6.47 6.47c.27.27.3.68.07.98l-.07.08a.75.75 0 0 1-.98.07l-.08-.07L12 13.06l-6.47 6.47a.75.75 0 0 1-1.06-1.06L10.94 12 4.47 5.53a.75.75 0 0 1-.07-.98l.07-.08-.07.08Z"]);
    const Edit24Filled = /* @__PURE__ */ createFluentIcon("Edit24Filled", "24", ["M15.9 3.05a3.58 3.58 0 1 1 5.05 5.06l-.89.9L15 3.93l.9-.9ZM13.93 5l-10 10c-.4.4-.7.92-.82 1.48l-1.1 4.6a.75.75 0 0 0 .9.9l4.6-1.1A3.1 3.1 0 0 0 9 20.07l10-10L13.94 5Z"]);
    const ErrorCircle12Filled = /* @__PURE__ */ createFluentIcon("ErrorCircle12Filled", "12", ["M6 11A5 5 0 1 0 6 1a5 5 0 0 0 0 10Zm-.75-2.75a.75.75 0 1 1 1.5 0 .75.75 0 0 1-1.5 0Zm.26-4.84a.5.5 0 0 1 .98 0l.01.09v2.59a.5.5 0 0 1-1 0V3.41Z"]);
    const FullScreenMaximize16Regular = /* @__PURE__ */ createFluentIcon("FullScreenMaximize16Regular", "16", ["M3.75 3a.75.75 0 0 0-.75.75V5.5a.5.5 0 0 1-1 0V3.75C2 2.78 2.78 2 3.75 2H5.5a.5.5 0 0 1 0 1H3.75ZM10 2.5c0-.28.22-.5.5-.5h1.75c.97 0 1.75.78 1.75 1.75V5.5a.5.5 0 0 1-1 0V3.75a.75.75 0 0 0-.75-.75H10.5a.5.5 0 0 1-.5-.5ZM2.5 10c.28 0 .5.22.5.5v1.75c0 .41.34.75.75.75H5.5a.5.5 0 0 1 0 1H3.75C2.78 14 2 13.22 2 12.25V10.5c0-.28.22-.5.5-.5Zm11 0c.28 0 .5.22.5.5v1.75c0 .97-.78 1.75-1.75 1.75H10.5a.5.5 0 0 1 0-1h1.75c.41 0 .75-.34.75-.75V10.5c0-.28.22-.5.5-.5Z"]);
    const FullScreenMinimize16Regular = /* @__PURE__ */ createFluentIcon("FullScreenMinimize16Regular", "16", ["M11 4a1 1 0 0 0 1 1h1.5a.5.5 0 0 1 0 1H12a2 2 0 0 1-2-2V2.5a.5.5 0 0 1 1 0V4Zm0 8a1 1 0 0 1 1-1h1.5a.5.5 0 0 0 0-1H12a2 2 0 0 0-2 2v1.5a.5.5 0 0 0 1 0V12Zm-7-1a1 1 0 0 1 1 1v1.5a.5.5 0 0 0 1 0V12a2 2 0 0 0-2-2H2.5a.5.5 0 0 0 0 1H4Zm1-7a1 1 0 0 1-1 1H2.5a.5.5 0 0 0 0 1H4a2 2 0 0 0 2-2V2.5a.5.5 0 0 0-1 0V4Z"]);
    const Info16Regular = /* @__PURE__ */ createFluentIcon("Info16Regular", "16", ["M8 7c.28 0 .5.22.5.5v3a.5.5 0 0 1-1 0v-3c0-.28.22-.5.5-.5Zm0-.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5ZM2 8a6 6 0 1 1 12 0A6 6 0 0 1 2 8Zm6-5a5 5 0 1 0 0 10A5 5 0 0 0 8 3Z"]);
    const MoreVertical24Filled = /* @__PURE__ */ createFluentIcon("MoreVertical24Filled", "24", ["M12 8a2 2 0 1 1 0-4 2 2 0 0 1 0 4Zm0 6a2 2 0 1 1 0-4 2 2 0 0 1 0 4Zm-2 4a2 2 0 1 0 4 0 2 2 0 0 0-4 0Z"]);
    const PresenceAvailable10Filled = /* @__PURE__ */ createFluentIcon("PresenceAvailable10Filled", "10", ["M5 10A5 5 0 1 0 5 0a5 5 0 0 0 0 10Zm2.1-5.9L4.85 6.35a.5.5 0 0 1-.7 0l-1-1a.5.5 0 0 1 .7-.7l.65.64 1.9-1.9a.5.5 0 0 1 .7.71Z"]);
    const PresenceAvailable10Regular = /* @__PURE__ */ createFluentIcon("PresenceAvailable10Regular", "10", ["M5 0a5 5 0 1 0 0 10A5 5 0 0 0 5 0ZM1 5a4 4 0 1 1 8 0 4 4 0 0 1-8 0Zm6.1-1.6c.2.2.2.5 0 .7L4.85 6.35a.5.5 0 0 1-.7 0l-1-1a.5.5 0 1 1 .7-.7l.65.64 1.9-1.9c.2-.19.5-.19.7 0Z"]);
    const PresenceAvailable12Filled = /* @__PURE__ */ createFluentIcon("PresenceAvailable12Filled", "12", ["M6 12A6 6 0 1 0 6 0a6 6 0 0 0 0 12Zm2.53-6.72L5.78 8.03c-.3.3-.77.3-1.06 0l-1-1a.75.75 0 0 1 1.06-1.06l.47.47 2.22-2.22a.75.75 0 0 1 1.06 1.06Z"]);
    const PresenceAvailable12Regular = /* @__PURE__ */ createFluentIcon("PresenceAvailable12Regular", "12", ["M6 0a6 6 0 1 0 0 12A6 6 0 0 0 6 0ZM1.5 6a4.5 4.5 0 1 1 9 0 4.5 4.5 0 0 1-9 0Zm7.03-1.78c.3.3.3.77 0 1.06L5.78 8.03c-.3.3-.77.3-1.06 0l-1-1a.75.75 0 0 1 1.06-1.06l.47.47 2.22-2.22c.3-.3.77-.3 1.06 0Z"]);
    const PresenceAvailable16Filled = /* @__PURE__ */ createFluentIcon("PresenceAvailable16Filled", "16", ["M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16Zm3.7-9.3-4 4a1 1 0 0 1-1.41 0l-2-2a1 1 0 1 1 1.42-1.4L7 8.58l3.3-3.3a1 1 0 0 1 1.4 1.42Z"]);
    const PresenceAvailable16Regular = /* @__PURE__ */ createFluentIcon("PresenceAvailable16Regular", "16", ["M11.7 6.7a1 1 0 0 0-1.4-1.4L7 8.58l-1.3-1.3a1 1 0 0 0-1.4 1.42l2 2a1 1 0 0 0 1.4 0l4-4ZM0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6a6 6 0 1 0 0 12A6 6 0 0 0 8 2Z"]);
    const PresenceAvailable20Filled = /* @__PURE__ */ createFluentIcon("PresenceAvailable20Filled", "20", ["M10 20a10 10 0 1 0 0-20 10 10 0 0 0 0 20Zm4.2-11.8-4.5 4.5a1 1 0 0 1-1.4 0l-2-2a1 1 0 1 1 1.4-1.4L9 10.58l3.8-3.8a1 1 0 1 1 1.4 1.42Z"]);
    const PresenceAvailable20Regular = /* @__PURE__ */ createFluentIcon("PresenceAvailable20Regular", "20", ["M10 0a10 10 0 1 0 0 20 10 10 0 0 0 0-20ZM2 10a8 8 0 1 1 16 0 8 8 0 0 1-16 0Zm12.2-3.2a1 1 0 0 1 0 1.4l-4.5 4.5a1 1 0 0 1-1.4 0l-2-2a1 1 0 0 1 1.4-1.4L9 10.58l3.8-3.8a1 1 0 0 1 1.4 0Z"]);
    const PresenceAway10Filled = /* @__PURE__ */ createFluentIcon("PresenceAway10Filled", "10", ["M5 10A5 5 0 1 0 5 0a5 5 0 0 0 0 10Zm0-7v1.8l1.35 1.35a.5.5 0 1 1-.7.7l-1.5-1.5A.5.5 0 0 1 4 5V3a.5.5 0 0 1 1 0Z"]);
    const PresenceAway12Filled = /* @__PURE__ */ createFluentIcon("PresenceAway12Filled", "12", ["M6 12A6 6 0 1 0 6 0a6 6 0 0 0 0 12Zm.5-8.75v2.4l1.49 1.28A.75.75 0 1 1 7 8.07l-1.75-1.5A.75.75 0 0 1 5 6V3.25a.75.75 0 0 1 1.5 0Z"]);
    const PresenceAway16Filled = /* @__PURE__ */ createFluentIcon("PresenceAway16Filled", "16", ["M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16Zm.5-11.5v3.02l2.12 1.7a1 1 0 1 1-1.24 1.56l-2.5-2A1 1 0 0 1 6.5 8V4.5a1 1 0 0 1 2 0Z"]);
    const PresenceAway20Filled = /* @__PURE__ */ createFluentIcon("PresenceAway20Filled", "20", ["M10 20a10 10 0 1 0 0-20 10 10 0 0 0 0 20Zm0-14V9.6l2.7 2.7a1 1 0 0 1-1.4 1.42l-3-3A1 1 0 0 1 8 10V6a1 1 0 1 1 2 0Z"]);
    const PresenceBlocked10Regular = /* @__PURE__ */ createFluentIcon("PresenceBlocked10Regular", "10", ["M10 5A5 5 0 1 0 0 5a5 5 0 0 0 10 0ZM9 5a4 4 0 0 1-6.45 3.16l5.61-5.61C8.69 3.22 9 4.08 9 5ZM7.45 1.84 1.84 7.45a4 4 0 0 1 5.61-5.61Z"]);
    const PresenceBlocked12Regular = /* @__PURE__ */ createFluentIcon("PresenceBlocked12Regular", "12", ["M12 6A6 6 0 1 1 0 6a6 6 0 0 1 12 0Zm-1.5 0c0-.97-.3-1.87-.83-2.6L3.39 9.66A4.5 4.5 0 0 0 10.5 6ZM8.6 2.33a4.5 4.5 0 0 0-6.28 6.28l6.29-6.28Z"]);
    const PresenceBlocked16Regular = /* @__PURE__ */ createFluentIcon("PresenceBlocked16Regular", "16", ["M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0Zm-2 0c0-1.3-.41-2.5-1.1-3.48L4.51 12.9A6 6 0 0 0 14 8Zm-2.52-4.9a6 6 0 0 0-8.37 8.37l8.37-8.36Z"]);
    const PresenceBlocked20Regular = /* @__PURE__ */ createFluentIcon("PresenceBlocked20Regular", "20", ["M20 10a10 10 0 1 0-20 0 10 10 0 0 0 20 0Zm-2 0a8 8 0 0 1-12.9 6.32L16.31 5.09A7.97 7.97 0 0 1 18 10Zm-3.1-6.32L3.69 14.91A8 8 0 0 1 14.91 3.68Z"]);
    const PresenceBusy10Filled = /* @__PURE__ */ createFluentIcon("PresenceBusy10Filled", "10", ["M10 5A5 5 0 1 1 0 5a5 5 0 0 1 10 0Z"]);
    const PresenceBusy12Filled = /* @__PURE__ */ createFluentIcon("PresenceBusy12Filled", "12", ["M12 6A6 6 0 1 1 0 6a6 6 0 0 1 12 0Z"]);
    const PresenceBusy16Filled = /* @__PURE__ */ createFluentIcon("PresenceBusy16Filled", "16", ["M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0Z"]);
    const PresenceBusy20Filled = /* @__PURE__ */ createFluentIcon("PresenceBusy20Filled", "20", ["M20 10a10 10 0 1 1-20 0 10 10 0 0 1 20 0Z"]);
    const PresenceDnd10Filled = /* @__PURE__ */ createFluentIcon("PresenceDnd10Filled", "10", ["M5 10A5 5 0 1 0 5 0a5 5 0 0 0 0 10ZM3.5 4.5h3a.5.5 0 0 1 0 1h-3a.5.5 0 0 1 0-1Z"]);
    const PresenceDnd10Regular = /* @__PURE__ */ createFluentIcon("PresenceDnd10Regular", "10", ["M5 0a5 5 0 1 0 0 10A5 5 0 0 0 5 0ZM1 5a4 4 0 1 1 8 0 4 4 0 0 1-8 0Zm2 0c0-.28.22-.5.5-.5h3a.5.5 0 0 1 0 1h-3A.5.5 0 0 1 3 5Z"]);
    const PresenceDnd12Filled = /* @__PURE__ */ createFluentIcon("PresenceDnd12Filled", "12", ["M6 12A6 6 0 1 0 6 0a6 6 0 0 0 0 12ZM3.75 5.25h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5Z"]);
    const PresenceDnd12Regular = /* @__PURE__ */ createFluentIcon("PresenceDnd12Regular", "12", ["M6 0a6 6 0 1 0 0 12A6 6 0 0 0 6 0ZM1.5 6a4.5 4.5 0 1 1 9 0 4.5 4.5 0 0 1-9 0ZM3 6c0-.41.34-.75.75-.75h4.5a.75.75 0 0 1 0 1.5h-4.5A.75.75 0 0 1 3 6Z"]);
    const PresenceDnd16Filled = /* @__PURE__ */ createFluentIcon("PresenceDnd16Filled", "16", ["M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16ZM5.25 7h5.5a1 1 0 1 1 0 2h-5.5a1 1 0 1 1 0-2Z"]);
    const PresenceDnd16Regular = /* @__PURE__ */ createFluentIcon("PresenceDnd16Regular", "16", ["M5.25 7a1 1 0 0 0 0 2h5.5a1 1 0 1 0 0-2h-5.5ZM0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6a6 6 0 1 0 0 12A6 6 0 0 0 8 2Z"]);
    const PresenceDnd20Filled = /* @__PURE__ */ createFluentIcon("PresenceDnd20Filled", "20", ["M10 20a10 10 0 1 0 0-20 10 10 0 0 0 0 20ZM7 9h6a1 1 0 1 1 0 2H7a1 1 0 1 1 0-2Z"]);
    const PresenceDnd20Regular = /* @__PURE__ */ createFluentIcon("PresenceDnd20Regular", "20", ["M10 0a10 10 0 1 0 0 20 10 10 0 0 0 0-20ZM2 10a8 8 0 1 1 16 0 8 8 0 0 1-16 0Zm4 0a1 1 0 0 1 1-1h6a1 1 0 1 1 0 2H7a1 1 0 0 1-1-1Z"]);
    const PresenceOffline10Regular = /* @__PURE__ */ createFluentIcon("PresenceOffline10Regular", "10", ["M6.85 3.15c.2.2.2.5 0 .7L5.71 5l1.14 1.15a.5.5 0 1 1-.7.7L5 5.71 3.85 6.85a.5.5 0 1 1-.7-.7L4.29 5 3.15 3.85a.5.5 0 1 1 .7-.7L5 4.29l1.15-1.14c.2-.2.5-.2.7 0ZM0 5a5 5 0 1 1 10 0A5 5 0 0 1 0 5Zm5-4a4 4 0 1 0 0 8 4 4 0 0 0 0-8Z"]);
    const PresenceOffline12Regular = /* @__PURE__ */ createFluentIcon("PresenceOffline12Regular", "12", ["M8.03 3.97c.3.3.3.77 0 1.06L7.06 6l.97.97a.75.75 0 0 1-1.06 1.06L6 7.06l-.97.97a.75.75 0 0 1-1.06-1.06L4.94 6l-.97-.97a.75.75 0 0 1 1.06-1.06l.97.97.97-.97c.3-.3.77-.3 1.06 0ZM0 6a6 6 0 1 1 12 0A6 6 0 0 1 0 6Zm6-4.5a4.5 4.5 0 1 0 0 9 4.5 4.5 0 0 0 0-9Z"]);
    const PresenceOffline16Regular = /* @__PURE__ */ createFluentIcon("PresenceOffline16Regular", "16", ["M10.7 5.3a1 1 0 0 1 0 1.4L9.42 8l1.3 1.3a1 1 0 0 1-1.42 1.4L8 9.42l-1.3 1.3a1 1 0 0 1-1.4-1.42L6.58 8l-1.3-1.3a1 1 0 0 1 1.42-1.4L8 6.58l1.3-1.3a1 1 0 0 1 1.4 0ZM0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6a6 6 0 1 0 0 12A6 6 0 0 0 8 2Z"]);
    const PresenceOffline20Regular = /* @__PURE__ */ createFluentIcon("PresenceOffline20Regular", "20", ["M13.7 6.3a1 1 0 0 1 0 1.4L11.42 10l2.3 2.3a1 1 0 0 1-1.42 1.4L10 11.42l-2.3 2.3a1 1 0 0 1-1.4-1.42L8.58 10l-2.3-2.3a1 1 0 0 1 1.42-1.4L10 8.58l2.3-2.3a1 1 0 0 1 1.4 0ZM0 10a10 10 0 1 1 20 0 10 10 0 0 1-20 0Zm10-8a8 8 0 1 0 0 16 8 8 0 0 0 0-16Z"]);
    const PresenceOof10Regular = /* @__PURE__ */ createFluentIcon("PresenceOof10Regular", "10", ["M5.35 3.85a.5.5 0 1 0-.7-.7l-1.5 1.5a.5.5 0 0 0 0 .7l1.5 1.5a.5.5 0 1 0 .7-.7L4.7 5.5h1.8a.5.5 0 1 0 0-1H4.7l.65-.65ZM5 0a5 5 0 1 0 0 10A5 5 0 0 0 5 0ZM1 5a4 4 0 1 1 8 0 4 4 0 0 1-8 0Z"]);
    const PresenceOof12Regular = /* @__PURE__ */ createFluentIcon("PresenceOof12Regular", "12", ["M6.28 4.53a.75.75 0 0 0-1.06-1.06l-2 2c-.3.3-.3.77 0 1.06l2 2a.75.75 0 0 0 1.06-1.06l-.72-.72h2.69a.75.75 0 1 0 0-1.5h-2.7l.73-.72ZM6 0a6 6 0 1 0 0 12A6 6 0 0 0 6 0ZM1.5 6a4.5 4.5 0 1 1 9 0 4.5 4.5 0 0 1-9 0Z"]);
    const PresenceOof16Regular = /* @__PURE__ */ createFluentIcon("PresenceOof16Regular", "16", ["M8.2 6.2a1 1 0 1 0-1.4-1.4L4.3 7.3a1 1 0 0 0 0 1.4l2.5 2.5a1 1 0 0 0 1.4-1.4L7.42 9H11a1 1 0 1 0 0-2H7.41l.8-.8ZM8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0ZM2 8a6 6 0 1 1 12 0A6 6 0 0 1 2 8Z"]);
    const PresenceOof20Regular = /* @__PURE__ */ createFluentIcon("PresenceOof20Regular", "20", ["M10.7 7.7A1 1 0 1 0 9.28 6.3l-3 3a1 1 0 0 0 0 1.41l3 3a1 1 0 1 0 1.42-1.41l-1.3-1.3H13a1 1 0 1 0 0-2H9.4l1.3-1.29ZM10 0a10 10 0 1 0 0 20 10 10 0 0 0 0-20ZM2 10a8 8 0 1 1 16 0 8 8 0 0 1-16 0Z"]);
    const PresenceUnknown10Regular = /* @__PURE__ */ createFluentIcon("PresenceUnknown10Regular", "10", ["M5 1a4 4 0 1 0 0 8 4 4 0 0 0 0-8ZM0 5a5 5 0 1 1 10 0A5 5 0 0 1 0 5Z"]);
    const PresenceUnknown12Regular = /* @__PURE__ */ createFluentIcon("PresenceUnknown12Regular", "12", ["M6 1.5a4.5 4.5 0 1 0 0 9 4.5 4.5 0 0 0 0-9ZM0 6a6 6 0 1 1 12 0A6 6 0 0 1 0 6Z"]);
    const PresenceUnknown16Regular = /* @__PURE__ */ createFluentIcon("PresenceUnknown16Regular", "16", ["M8 2a6 6 0 1 0 0 12A6 6 0 0 0 8 2ZM0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Z"]);
    const PresenceUnknown20Regular = /* @__PURE__ */ createFluentIcon("PresenceUnknown20Regular", "20", ["M10 2a8 8 0 1 0 0 16 8 8 0 0 0 0-16ZM0 10a10 10 0 1 1 20 0 10 10 0 0 1-20 0Z"]);
    const Send16Filled = /* @__PURE__ */ createFluentIcon("Send16Filled", "16", ["M1.72 1.05a.5.5 0 0 0-.71.55l1.4 4.85c.06.18.21.32.4.35l5.69.95c.27.06.27.44 0 .5l-5.69.95a.5.5 0 0 0-.4.35l-1.4 4.85a.5.5 0 0 0 .71.55l13-6.5a.5.5 0 0 0 0-.9l-13-6.5Z"], {
      flipInRtl: true
    });
    const Send24Regular = /* @__PURE__ */ createFluentIcon("Send24Regular", "24", ["M5.7 12 2.3 3.27a.75.75 0 0 1 .94-.98l.1.04 18 9c.51.26.54.97.1 1.28l-.1.06-18 9a.75.75 0 0 1-1.07-.85l.03-.1L5.7 12 2.3 3.27 5.7 12ZM4.4 4.54l2.61 6.7 6.63.01c.38 0 .7.28.74.65v.1c0 .38-.27.7-.64.74l-.1.01H7l-2.6 6.7L19.31 12 4.4 4.54Z"], {
      flipInRtl: true
    });
    const Settings24Regular = /* @__PURE__ */ createFluentIcon("Settings24Regular", "24", ["M12.01 2.25c.74 0 1.47.1 2.18.25.32.07.55.33.59.65l.17 1.53a1.38 1.38 0 0 0 1.92 1.11l1.4-.61c.3-.13.64-.06.85.17a9.8 9.8 0 0 1 2.2 3.8c.1.3 0 .63-.26.82l-1.25.92a1.38 1.38 0 0 0 0 2.22l1.25.92c.26.19.36.52.27.82a9.8 9.8 0 0 1-2.2 3.8.75.75 0 0 1-.85.17l-1.4-.62a1.38 1.38 0 0 0-1.93 1.12l-.17 1.52a.75.75 0 0 1-.58.65 9.52 9.52 0 0 1-4.4 0 .75.75 0 0 1-.57-.65l-.17-1.52a1.38 1.38 0 0 0-1.93-1.11l-1.4.62a.75.75 0 0 1-.85-.18 9.8 9.8 0 0 1-2.2-3.8c-.1-.3 0-.63.26-.82l1.25-.92a1.38 1.38 0 0 0 0-2.22l-1.24-.92a.75.75 0 0 1-.28-.82 9.8 9.8 0 0 1 2.2-3.8c.23-.23.57-.3.86-.17l1.4.62c.4.17.86.15 1.25-.08.38-.22.63-.6.68-1.04l.17-1.53a.75.75 0 0 1 .58-.65c.72-.16 1.45-.24 2.2-.25Zm0 1.5c-.45 0-.9.04-1.35.12l-.11.97a2.89 2.89 0 0 1-4.03 2.33l-.9-.4A8.3 8.3 0 0 0 4.29 9.1l.8.59a2.88 2.88 0 0 1 0 4.64l-.8.59a8.3 8.3 0 0 0 1.35 2.32l.9-.4a2.88 2.88 0 0 1 4.02 2.32l.1.99c.9.15 1.8.15 2.7 0l.1-.99a2.88 2.88 0 0 1 4.02-2.32l.9.4a8.3 8.3 0 0 0 1.35-2.32l-.8-.59a2.88 2.88 0 0 1 0-4.64l.8-.59a8.3 8.3 0 0 0-1.35-2.32l-.9.4a2.88 2.88 0 0 1-4.02-2.32l-.1-.98c-.45-.08-.9-.11-1.34-.12ZM12 8.25a3.75 3.75 0 1 1 0 7.5 3.75 3.75 0 0 1 0-7.5Zm0 1.5a2.25 2.25 0 1 0 0 4.5 2.25 2.25 0 0 0 0-4.5Z"]);
    const Warning12Filled = /* @__PURE__ */ createFluentIcon("Warning12Filled", "12", ["M5.21 1.46a.9.9 0 0 1 1.58 0l4.09 7.17a.92.92 0 0 1-.79 1.37H1.91a.92.92 0 0 1-.79-1.37l4.1-7.17ZM5.5 4.5v1a.5.5 0 0 0 1 0v-1a.5.5 0 0 0-1 0ZM6 6.75a.75.75 0 1 0 0 1.5.75.75 0 0 0 0-1.5Z"]);
    const iconFilledClassName = "fui-Icon-filled";
    const iconRegularClassName = "fui-Icon-regular";
    const useBundledIconStyles = __styles$1({
      "root": {
        "mc9l5x": "fjseox"
      },
      "visible": {
        "mc9l5x": "f1w7gpdv"
      }
    }, {
      "d": [".fjseox{display:none;}", ".f1w7gpdv{display:inline;}"]
    });
    const bundleIcon = (FilledIcon, RegularIcon) => {
      const Component = (props) => {
        const {
          className,
          primaryFill = "currentColor",
          filled,
          ...rest
        } = props;
        const styles2 = useBundledIconStyles();
        return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(FilledIcon, Object.assign({}, rest, {
          className: mergeClasses$1(styles2.root, filled && styles2.visible, iconFilledClassName, className),
          fill: primaryFill
        })), reactExports.createElement(RegularIcon, Object.assign({}, rest, {
          className: mergeClasses$1(styles2.root, !filled && styles2.visible, iconRegularClassName, className),
          fill: primaryFill
        })));
      };
      Component.displayName = "CompoundIcon";
      return Component;
    };
    const bundleIcon$1 = bundleIcon;
    const renderFluentProvider_unstable = (state, contextValues) => {
      return /* @__PURE__ */ jsx(Provider, {
        value: contextValues.provider,
        children: /* @__PURE__ */ jsx(ThemeProvider, {
          value: contextValues.theme,
          children: /* @__PURE__ */ jsx(ThemeClassNameProvider, {
            value: contextValues.themeClassName,
            children: /* @__PURE__ */ jsx(CustomStyleHooksProvider, {
              value: contextValues.customStyleHooks_unstable,
              children: /* @__PURE__ */ jsx(TooltipVisibilityProvider, {
                value: contextValues.tooltip,
                children: /* @__PURE__ */ jsx(TextDirectionProvider, {
                  dir: contextValues.textDirection,
                  children: /* @__PURE__ */ jsx(IconDirectionContextProvider, {
                    value: contextValues.iconDirection,
                    children: /* @__PURE__ */ jsx(OverridesProvider, {
                      value: contextValues.overrides_unstable,
                      children: /* @__PURE__ */ jsxs(state.root, {
                        children: [
                          canUseDOM() ? null : /* @__PURE__ */ jsx("style", {
                            // Using dangerous HTML because react can escape characters
                            // which can lead to invalid CSS.
                            // eslint-disable-next-line react/no-danger
                            dangerouslySetInnerHTML: {
                              __html: state.serverStyleProps.cssRule
                            },
                            ...state.serverStyleProps.attributes
                          }),
                          state.root.children
                        ]
                      })
                    })
                  })
                })
              })
            })
          })
        })
      });
    };
    /*!
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    const _canUseWeakRef = typeof WeakRef !== "undefined";
    class WeakRefInstance {
      constructor(instance) {
        if (_canUseWeakRef && typeof instance === "object") {
          this._weakRef = new WeakRef(instance);
        } else {
          this._instance = instance;
        }
      }
      /**
       * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef/deref}
       */
      deref() {
        var _a2, _b, _c;
        let instance;
        if (this._weakRef) {
          instance = (_a2 = this._weakRef) === null || _a2 === void 0 ? void 0 : _a2.deref();
          if (!instance) {
            delete this._weakRef;
          }
        } else {
          instance = this._instance;
          if ((_c = (_b = instance) === null || _b === void 0 ? void 0 : _b.isDisposed) === null || _c === void 0 ? void 0 : _c.call(_b)) {
            delete this._instance;
          }
        }
        return instance;
      }
    }
    /*!
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    const KEYBORG_FOCUSIN = "keyborg:focusin";
    function canOverrideNativeFocus(win) {
      const HTMLElement2 = win.HTMLElement;
      const origFocus = HTMLElement2.prototype.focus;
      let isCustomFocusCalled = false;
      HTMLElement2.prototype.focus = function focus() {
        isCustomFocusCalled = true;
      };
      const btn = win.document.createElement("button");
      btn.focus();
      HTMLElement2.prototype.focus = origFocus;
      return isCustomFocusCalled;
    }
    let _canOverrideNativeFocus = false;
    function nativeFocus(element2) {
      const focus = element2.focus;
      if (focus.__keyborgNativeFocus) {
        focus.__keyborgNativeFocus.call(element2);
      } else {
        element2.focus();
      }
    }
    function setupFocusEvent(win) {
      const kwin = win;
      if (!_canOverrideNativeFocus) {
        _canOverrideNativeFocus = canOverrideNativeFocus(kwin);
      }
      const origFocus = kwin.HTMLElement.prototype.focus;
      if (origFocus.__keyborgNativeFocus) {
        return;
      }
      kwin.HTMLElement.prototype.focus = focus;
      const focusOutShadowRootHandler = (e2) => {
        const relatedTarget = e2.relatedTarget;
        const currentTarget = e2.currentTarget;
        if (!currentTarget.contains(relatedTarget)) {
          currentTarget.removeEventListener("focusin", focusInHandler);
          currentTarget.removeEventListener("focusout", focusOutShadowRootHandler);
        }
      };
      const focusInHandler = (e2) => {
        var _a2;
        let target = e2.target;
        if (!target) {
          return;
        }
        if (target.shadowRoot) {
          target.shadowRoot.addEventListener("focusin", focusInHandler);
          target.shadowRoot.addEventListener("focusout", focusOutShadowRootHandler);
          target = e2.composedPath()[0];
        }
        const details = {
          relatedTarget: e2.relatedTarget || void 0
        };
        const event = new CustomEvent(KEYBORG_FOCUSIN, {
          cancelable: true,
          bubbles: true,
          // Allows the event to bubble past an open shadow root
          composed: true,
          detail: details
        });
        event.details = details;
        if (_canOverrideNativeFocus || data.lastFocusedProgrammatically) {
          details.isFocusedProgrammatically = target === ((_a2 = data.lastFocusedProgrammatically) === null || _a2 === void 0 ? void 0 : _a2.deref());
          data.lastFocusedProgrammatically = void 0;
        }
        target.dispatchEvent(event);
      };
      const data = kwin.__keyborgData = {
        focusInHandler
      };
      kwin.document.addEventListener("focusin", kwin.__keyborgData.focusInHandler, true);
      function focus() {
        const keyborgNativeFocusEvent = kwin.__keyborgData;
        if (keyborgNativeFocusEvent) {
          keyborgNativeFocusEvent.lastFocusedProgrammatically = new WeakRefInstance(this);
        }
        return origFocus.apply(this, arguments);
      }
      focus.__keyborgNativeFocus = origFocus;
    }
    function disposeFocusEvent(win) {
      const kwin = win;
      const proto2 = kwin.HTMLElement.prototype;
      const origFocus = proto2.focus.__keyborgNativeFocus;
      const keyborgNativeFocusEvent = kwin.__keyborgData;
      if (keyborgNativeFocusEvent) {
        kwin.document.removeEventListener("focusin", keyborgNativeFocusEvent.focusInHandler, true);
        delete kwin.__keyborgData;
      }
      if (origFocus) {
        proto2.focus = origFocus;
      }
    }
    /*!
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    const _dismissTimeout = 500;
    let _lastId = 0;
    class KeyborgState {
      constructor() {
        this.__keyborgCoreRefs = {};
        this._isNavigatingWithKeyboard = false;
      }
      add(keyborg) {
        const id2 = keyborg.id;
        if (!(id2 in this.__keyborgCoreRefs)) {
          this.__keyborgCoreRefs[id2] = new WeakRefInstance(keyborg);
        }
      }
      remove(id2) {
        delete this.__keyborgCoreRefs[id2];
        if (Object.keys(this.__keyborgCoreRefs).length === 0) {
          this._isNavigatingWithKeyboard = false;
        }
      }
      setVal(isNavigatingWithKeyboard) {
        if (this._isNavigatingWithKeyboard === isNavigatingWithKeyboard) {
          return;
        }
        this._isNavigatingWithKeyboard = isNavigatingWithKeyboard;
        for (const id2 of Object.keys(this.__keyborgCoreRefs)) {
          const ref = this.__keyborgCoreRefs[id2];
          const keyborg = ref.deref();
          if (keyborg) {
            keyborg.update(isNavigatingWithKeyboard);
          } else {
            this.remove(id2);
          }
        }
      }
      getVal() {
        return this._isNavigatingWithKeyboard;
      }
    }
    const _state = /* @__PURE__ */ new KeyborgState();
    class KeyborgCore {
      constructor(win, props) {
        this._onFocusIn = (e2) => {
          if (this._isMouseUsedTimer) {
            return;
          }
          if (_state.getVal()) {
            return;
          }
          const details = e2.detail;
          if (!details.relatedTarget) {
            return;
          }
          if (details.isFocusedProgrammatically || details.isFocusedProgrammatically === void 0) {
            return;
          }
          _state.setVal(true);
        };
        this._onMouseDown = (e2) => {
          if (e2.buttons === 0 || e2.clientX === 0 && e2.clientY === 0 && e2.screenX === 0 && e2.screenY === 0) {
            return;
          }
          const win2 = this._win;
          if (win2) {
            if (this._isMouseUsedTimer) {
              win2.clearTimeout(this._isMouseUsedTimer);
            }
            this._isMouseUsedTimer = win2.setTimeout(() => {
              delete this._isMouseUsedTimer;
            }, 1e3);
          }
          _state.setVal(false);
        };
        this._onKeyDown = (e2) => {
          var _a2, _b;
          const isNavigatingWithKeyboard = _state.getVal();
          const keyCode = e2.keyCode;
          const triggerKeys = this._triggerKeys;
          if (!isNavigatingWithKeyboard && (!triggerKeys || triggerKeys.has(keyCode))) {
            const activeElement = (_a2 = this._win) === null || _a2 === void 0 ? void 0 : _a2.document.activeElement;
            if (activeElement && (activeElement.tagName === "INPUT" || activeElement.tagName === "TEXTAREA" || activeElement.contentEditable === "true")) {
              return;
            }
            _state.setVal(true);
          } else if (isNavigatingWithKeyboard && ((_b = this._dismissKeys) === null || _b === void 0 ? void 0 : _b.has(keyCode))) {
            this._scheduleDismiss();
          }
        };
        this.id = "c" + ++_lastId;
        this._win = win;
        const doc = win.document;
        if (props) {
          const triggerKeys = props.triggerKeys;
          const dismissKeys = props.dismissKeys;
          if (triggerKeys === null || triggerKeys === void 0 ? void 0 : triggerKeys.length) {
            this._triggerKeys = new Set(triggerKeys);
          }
          if (dismissKeys === null || dismissKeys === void 0 ? void 0 : dismissKeys.length) {
            this._dismissKeys = new Set(dismissKeys);
          }
        }
        doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);
        doc.addEventListener("mousedown", this._onMouseDown, true);
        win.addEventListener("keydown", this._onKeyDown, true);
        setupFocusEvent(win);
        _state.add(this);
      }
      dispose() {
        const win = this._win;
        if (win) {
          if (this._isMouseUsedTimer) {
            win.clearTimeout(this._isMouseUsedTimer);
            this._isMouseUsedTimer = void 0;
          }
          if (this._dismissTimer) {
            win.clearTimeout(this._dismissTimer);
            this._dismissTimer = void 0;
          }
          disposeFocusEvent(win);
          const doc = win.document;
          doc.removeEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);
          doc.removeEventListener("mousedown", this._onMouseDown, true);
          win.removeEventListener("keydown", this._onKeyDown, true);
          delete this._win;
          _state.remove(this.id);
        }
      }
      isDisposed() {
        return !!this._win;
      }
      /**
       * Updates all keyborg instances with the keyboard navigation state
       */
      update(isNavigatingWithKeyboard) {
        var _a2, _b;
        const keyborgs = (_b = (_a2 = this._win) === null || _a2 === void 0 ? void 0 : _a2.__keyborg) === null || _b === void 0 ? void 0 : _b.refs;
        if (keyborgs) {
          for (const id2 of Object.keys(keyborgs)) {
            Keyborg.update(keyborgs[id2], isNavigatingWithKeyboard);
          }
        }
      }
      _scheduleDismiss() {
        const win = this._win;
        if (win) {
          if (this._dismissTimer) {
            win.clearTimeout(this._dismissTimer);
            this._dismissTimer = void 0;
          }
          const was = win.document.activeElement;
          this._dismissTimer = win.setTimeout(() => {
            this._dismissTimer = void 0;
            const cur = win.document.activeElement;
            if (was && cur && was === cur) {
              _state.setVal(false);
            }
          }, _dismissTimeout);
        }
      }
    }
    class Keyborg {
      constructor(win, props) {
        this._cb = [];
        this._id = "k" + ++_lastId;
        this._win = win;
        const current = win.__keyborg;
        if (current) {
          this._core = current.core;
          current.refs[this._id] = this;
        } else {
          this._core = new KeyborgCore(win, props);
          win.__keyborg = {
            core: this._core,
            refs: {
              [this._id]: this
            }
          };
        }
      }
      static create(win, props) {
        return new Keyborg(win, props);
      }
      static dispose(instance) {
        instance.dispose();
      }
      /**
       * Updates all subscribed callbacks with the keyboard navigation state
       */
      static update(instance, isNavigatingWithKeyboard) {
        instance._cb.forEach((callback) => callback(isNavigatingWithKeyboard));
      }
      dispose() {
        var _a2;
        const current = (_a2 = this._win) === null || _a2 === void 0 ? void 0 : _a2.__keyborg;
        if (current === null || current === void 0 ? void 0 : current.refs[this._id]) {
          delete current.refs[this._id];
          if (Object.keys(current.refs).length === 0) {
            current.core.dispose();
            delete this._win.__keyborg;
          }
        }
        this._cb = [];
        delete this._core;
        delete this._win;
      }
      /**
       * @returns Whether the user is navigating with keyboard
       */
      isNavigatingWithKeyboard() {
        return _state.getVal();
      }
      /**
       * @param callback - Called when the keyboard navigation state changes
       */
      subscribe(callback) {
        this._cb.push(callback);
      }
      /**
       * @param callback - Registered with subscribe
       */
      unsubscribe(callback) {
        const index2 = this._cb.indexOf(callback);
        if (index2 >= 0) {
          this._cb.splice(index2, 1);
        }
      }
      /**
       * Manually set the keyboard navigtion state
       */
      setVal(isNavigatingWithKeyboard) {
        _state.setVal(isNavigatingWithKeyboard);
      }
    }
    function createKeyborg(win, props) {
      return Keyborg.create(win, props);
    }
    function disposeKeyborg(instance) {
      Keyborg.dispose(instance);
    }
    /*!
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    const TabsterAttributeName = "data-tabster";
    const TabsterDummyInputAttributeName = "data-tabster-dummy";
    const DeloserEventName = "tabster:deloser";
    const ModalizerActiveEventName = "tabster:modalizer:active";
    const ModalizerInactiveEventName = "tabster:modalizer:inactive";
    const ModalizerFocusInEventName = "tabster:modalizer:focusin";
    const ModalizerFocusOutEventName = "tabster:modalizer:focusout";
    const ModalizerBeforeFocusOutEventName = "tabster:modalizer:beforefocusout";
    const MoverEventName = "tabster:mover";
    const FocusInEventName = "tabster:focusin";
    const FocusOutEventName = "tabster:focusout";
    const MoveFocusEventName = "tabster:movefocus";
    const FocusableSelector = /* @__PURE__ */ ["a[href]", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])", "*[tabindex]", "*[contenteditable]"].join(", ");
    const ObservedElementAccesibilities = {
      Any: 0,
      Accessible: 1,
      Focusable: 2
    };
    const RestoreFocusOrders = {
      History: 0,
      DeloserDefault: 1,
      RootDefault: 2,
      DeloserFirst: 3,
      RootFirst: 4
    };
    const Visibilities = {
      Invisible: 0,
      PartiallyVisible: 1,
      Visible: 2
    };
    const RestorerTypes = {
      Source: 0,
      Target: 1
    };
    const MoverDirections = {
      Both: 0,
      Vertical: 1,
      Horizontal: 2,
      Grid: 3,
      GridLinear: 4
    };
    const GroupperTabbabilities = {
      Unlimited: 0,
      Limited: 1,
      LimitedTrapFocus: 2
    };
    const SysDummyInputsPositions = {
      Auto: 0,
      Inside: 1,
      Outside: 2
    };
    var Types = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      TabsterAttributeName,
      TabsterDummyInputAttributeName,
      DeloserEventName,
      ModalizerActiveEventName,
      ModalizerInactiveEventName,
      ModalizerFocusInEventName,
      ModalizerFocusOutEventName,
      ModalizerBeforeFocusOutEventName,
      MoverEventName,
      FocusInEventName,
      FocusOutEventName,
      MoveFocusEventName,
      FocusableSelector,
      ObservedElementAccesibilities,
      RestoreFocusOrders,
      Visibilities,
      RestorerTypes,
      MoverDirections,
      GroupperTabbabilities,
      SysDummyInputsPositions
    });
    /*!
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    function getTabsterOnElement(tabster, element2) {
      var _a2;
      return (_a2 = tabster.storageEntry(element2)) === null || _a2 === void 0 ? void 0 : _a2.tabster;
    }
    function updateTabsterByAttribute(tabster, element2, dispose) {
      var _a2, _b;
      const newAttrValue = dispose || tabster._noop ? void 0 : element2.getAttribute(TabsterAttributeName);
      let entry = tabster.storageEntry(element2);
      let newAttr;
      if (newAttrValue) {
        if (newAttrValue !== ((_a2 = entry === null || entry === void 0 ? void 0 : entry.attr) === null || _a2 === void 0 ? void 0 : _a2.string)) {
          try {
            const newValue = JSON.parse(newAttrValue);
            if (typeof newValue !== "object") {
              throw new Error(`Value is not a JSON object, got '${newAttrValue}'.`);
            }
            newAttr = {
              string: newAttrValue,
              object: newValue
            };
          } catch (e2) {
          }
        } else {
          return;
        }
      } else if (!entry) {
        return;
      }
      if (!entry) {
        entry = tabster.storageEntry(element2, true);
      }
      if (!entry.tabster) {
        entry.tabster = {};
      }
      const tabsterOnElement = entry.tabster || {};
      const oldTabsterProps = ((_b = entry.attr) === null || _b === void 0 ? void 0 : _b.object) || {};
      const newTabsterProps = (newAttr === null || newAttr === void 0 ? void 0 : newAttr.object) || {};
      for (const key of Object.keys(oldTabsterProps)) {
        if (!newTabsterProps[key]) {
          if (key === "root") {
            const root2 = tabsterOnElement[key];
            if (root2) {
              tabster.root.onRoot(root2, true);
            }
          }
          switch (key) {
            case "deloser":
            case "root":
            case "groupper":
            case "modalizer":
            case "restorer":
            case "mover":
              const part = tabsterOnElement[key];
              if (part) {
                part.dispose();
                delete tabsterOnElement[key];
              }
              break;
            case "observed":
              delete tabsterOnElement[key];
              if (tabster.observedElement) {
                tabster.observedElement.onObservedElementUpdate(element2);
              }
              break;
            case "focusable":
            case "outline":
            case "uncontrolled":
            case "sys":
              delete tabsterOnElement[key];
              break;
          }
        }
      }
      for (const key of Object.keys(newTabsterProps)) {
        const sys = newTabsterProps.sys;
        switch (key) {
          case "deloser":
            if (tabsterOnElement.deloser) {
              tabsterOnElement.deloser.setProps(newTabsterProps.deloser);
            } else {
              if (tabster.deloser) {
                tabsterOnElement.deloser = tabster.deloser.createDeloser(element2, newTabsterProps.deloser);
              }
            }
            break;
          case "root":
            if (tabsterOnElement.root) {
              tabsterOnElement.root.setProps(newTabsterProps.root);
            } else {
              tabsterOnElement.root = tabster.root.createRoot(element2, newTabsterProps.root, sys);
            }
            tabster.root.onRoot(tabsterOnElement.root);
            break;
          case "modalizer":
            if (tabsterOnElement.modalizer) {
              tabsterOnElement.modalizer.setProps(newTabsterProps.modalizer);
            } else {
              if (tabster.modalizer) {
                tabsterOnElement.modalizer = tabster.modalizer.createModalizer(element2, newTabsterProps.modalizer, sys);
              }
            }
            break;
          case "restorer":
            if (tabsterOnElement.restorer) {
              tabsterOnElement.restorer.setProps(newTabsterProps.restorer);
            } else {
              if (tabster.restorer) {
                if (newTabsterProps.restorer) {
                  tabsterOnElement.restorer = tabster.restorer.createRestorer(element2, newTabsterProps.restorer);
                }
              }
            }
            break;
          case "focusable":
            tabsterOnElement.focusable = newTabsterProps.focusable;
            break;
          case "groupper":
            if (tabsterOnElement.groupper) {
              tabsterOnElement.groupper.setProps(newTabsterProps.groupper);
            } else {
              if (tabster.groupper) {
                tabsterOnElement.groupper = tabster.groupper.createGroupper(element2, newTabsterProps.groupper, sys);
              }
            }
            break;
          case "mover":
            if (tabsterOnElement.mover) {
              tabsterOnElement.mover.setProps(newTabsterProps.mover);
            } else {
              if (tabster.mover) {
                tabsterOnElement.mover = tabster.mover.createMover(element2, newTabsterProps.mover, sys);
              }
            }
            break;
          case "observed":
            if (tabster.observedElement) {
              tabsterOnElement.observed = newTabsterProps.observed;
              tabster.observedElement.onObservedElementUpdate(element2);
            }
            break;
          case "uncontrolled":
            tabsterOnElement.uncontrolled = newTabsterProps.uncontrolled;
            break;
          case "outline":
            if (tabster.outline) {
              tabsterOnElement.outline = newTabsterProps.outline;
            }
            break;
          case "sys":
            tabsterOnElement.sys = newTabsterProps.sys;
            break;
          default:
            console.error(`Unknown key '${key}' in data-tabster attribute value.`);
        }
      }
      if (newAttr) {
        entry.attr = newAttr;
      } else {
        if (Object.keys(tabsterOnElement).length === 0) {
          delete entry.tabster;
          delete entry.attr;
        }
        tabster.storageEntry(element2, false);
      }
    }
    /*!
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    function createEventTarget(getWindow2) {
      const global2 = getWindow2();
      try {
        if (global2.EventTarget) {
          return new global2.EventTarget();
        }
      } catch (error) {
        if (!(error instanceof TypeError)) {
          throw error;
        }
      }
      return global2.document.createElement("div");
    }
    /*!
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    let _isBrokenIE11;
    const _DOMRect = typeof DOMRect !== "undefined" ? DOMRect : class {
      constructor(x2, y2, width, height) {
        this.left = x2 || 0;
        this.top = y2 || 0;
        this.right = (x2 || 0) + (width || 0);
        this.bottom = (y2 || 0) + (height || 0);
      }
    };
    let _uidCounter = 0;
    try {
      document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT);
      _isBrokenIE11 = false;
    } catch (e2) {
      _isBrokenIE11 = true;
    }
    const _updateDummyInputsTimeout = 100;
    function getInstanceContext(getWindow2) {
      const win = getWindow2();
      let ctx = win.__tabsterInstanceContext;
      if (!ctx) {
        ctx = {
          elementByUId: {},
          basics: {
            Promise: win.Promise || void 0,
            WeakRef: win.WeakRef || void 0
          },
          containerBoundingRectCache: {},
          lastContainerBoundingRectCacheId: 0,
          fakeWeakRefs: [],
          fakeWeakRefsStarted: false
        };
        win.__tabsterInstanceContext = ctx;
      }
      return ctx;
    }
    function disposeInstanceContext(win) {
      const ctx = win.__tabsterInstanceContext;
      if (ctx) {
        ctx.elementByUId = {};
        delete ctx.WeakRef;
        ctx.containerBoundingRectCache = {};
        if (ctx.containerBoundingRectCacheTimer) {
          win.clearTimeout(ctx.containerBoundingRectCacheTimer);
        }
        if (ctx.fakeWeakRefsTimer) {
          win.clearTimeout(ctx.fakeWeakRefsTimer);
        }
        ctx.fakeWeakRefs = [];
        delete win.__tabsterInstanceContext;
      }
    }
    function createWeakMap(win) {
      const ctx = win.__tabsterInstanceContext;
      return new ((ctx === null || ctx === void 0 ? void 0 : ctx.basics.WeakMap) || WeakMap)();
    }
    function hasSubFocusable(element2) {
      return !!element2.querySelector(FocusableSelector);
    }
    class FakeWeakRef {
      constructor(target) {
        this._target = target;
      }
      deref() {
        return this._target;
      }
      static cleanup(fwr, forceRemove) {
        if (!fwr._target) {
          return true;
        }
        if (forceRemove || !documentContains(fwr._target.ownerDocument, fwr._target)) {
          delete fwr._target;
          return true;
        }
        return false;
      }
    }
    class WeakHTMLElement {
      constructor(getWindow2, element2, data) {
        const context = getInstanceContext(getWindow2);
        let ref;
        if (context.WeakRef) {
          ref = new context.WeakRef(element2);
        } else {
          ref = new FakeWeakRef(element2);
          context.fakeWeakRefs.push(ref);
        }
        this._ref = ref;
        this._data = data;
      }
      get() {
        const ref = this._ref;
        let element2;
        if (ref) {
          element2 = ref.deref();
          if (!element2) {
            delete this._ref;
          }
        }
        return element2;
      }
      getData() {
        return this._data;
      }
    }
    function cleanupFakeWeakRefs(getWindow2, forceRemove) {
      const context = getInstanceContext(getWindow2);
      context.fakeWeakRefs = context.fakeWeakRefs.filter((e2) => !FakeWeakRef.cleanup(e2, forceRemove));
    }
    function startFakeWeakRefsCleanup(getWindow2) {
      const context = getInstanceContext(getWindow2);
      if (!context.fakeWeakRefsStarted) {
        context.fakeWeakRefsStarted = true;
        context.WeakRef = getWeakRef(context);
      }
      if (!context.fakeWeakRefsTimer) {
        context.fakeWeakRefsTimer = getWindow2().setTimeout(() => {
          context.fakeWeakRefsTimer = void 0;
          cleanupFakeWeakRefs(getWindow2);
          startFakeWeakRefsCleanup(getWindow2);
        }, 2 * 60 * 1e3);
      }
    }
    function stopFakeWeakRefsCleanupAndClearStorage(getWindow2) {
      const context = getInstanceContext(getWindow2);
      context.fakeWeakRefsStarted = false;
      if (context.fakeWeakRefsTimer) {
        getWindow2().clearTimeout(context.fakeWeakRefsTimer);
        context.fakeWeakRefsTimer = void 0;
        context.fakeWeakRefs = [];
      }
    }
    function createElementTreeWalker(doc, root2, acceptNode) {
      if (root2.nodeType !== Node.ELEMENT_NODE) {
        return void 0;
      }
      const filter = _isBrokenIE11 ? acceptNode : {
        acceptNode
      };
      return doc.createTreeWalker(
        root2,
        NodeFilter.SHOW_ELEMENT,
        filter,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore: We still don't want to completely break IE11, so, entityReferenceExpansion argument is not optional.
        false
        /* Last argument is not optional for IE11! */
      );
    }
    function getBoundingRect(getWindow2, element2) {
      let cacheId = element2.__tabsterCacheId;
      const context = getInstanceContext(getWindow2);
      const cached = cacheId ? context.containerBoundingRectCache[cacheId] : void 0;
      if (cached) {
        return cached.rect;
      }
      const scrollingElement = element2.ownerDocument && element2.ownerDocument.documentElement;
      if (!scrollingElement) {
        return new _DOMRect();
      }
      let left = 0;
      let top = 0;
      let right = scrollingElement.clientWidth;
      let bottom = scrollingElement.clientHeight;
      if (element2 !== scrollingElement) {
        const r2 = element2.getBoundingClientRect();
        left = Math.max(left, r2.left);
        top = Math.max(top, r2.top);
        right = Math.min(right, r2.right);
        bottom = Math.min(bottom, r2.bottom);
      }
      const rect = new _DOMRect(left < right ? left : -1, top < bottom ? top : -1, left < right ? right - left : 0, top < bottom ? bottom - top : 0);
      if (!cacheId) {
        cacheId = "r-" + ++context.lastContainerBoundingRectCacheId;
        element2.__tabsterCacheId = cacheId;
      }
      context.containerBoundingRectCache[cacheId] = {
        rect,
        element: element2
      };
      if (!context.containerBoundingRectCacheTimer) {
        context.containerBoundingRectCacheTimer = window.setTimeout(() => {
          context.containerBoundingRectCacheTimer = void 0;
          for (const cId of Object.keys(context.containerBoundingRectCache)) {
            delete context.containerBoundingRectCache[cId].element.__tabsterCacheId;
          }
          context.containerBoundingRectCache = {};
        }, 50);
      }
      return rect;
    }
    function isElementVerticallyVisibleInContainer(getWindow2, element2, tolerance) {
      const container = getScrollableContainer(element2);
      if (!container) {
        return false;
      }
      const containerRect = getBoundingRect(getWindow2, container);
      const elementRect = element2.getBoundingClientRect();
      const intersectionTolerance = elementRect.height * (1 - tolerance);
      const topIntersection = Math.max(0, containerRect.top - elementRect.top);
      const bottomIntersection = Math.max(0, elementRect.bottom - containerRect.bottom);
      const totalIntersection = topIntersection + bottomIntersection;
      return totalIntersection === 0 || totalIntersection <= intersectionTolerance;
    }
    function scrollIntoView(getWindow2, element2, alignToTop) {
      const container = getScrollableContainer(element2);
      if (container) {
        const containerRect = getBoundingRect(getWindow2, container);
        const elementRect = element2.getBoundingClientRect();
        if (alignToTop) {
          container.scrollTop += elementRect.top - containerRect.top;
        } else {
          container.scrollTop += elementRect.bottom - containerRect.bottom;
        }
      }
    }
    function getScrollableContainer(element2) {
      const doc = element2.ownerDocument;
      if (doc) {
        for (let el = element2.parentElement; el; el = el.parentElement) {
          if (el.scrollWidth > el.clientWidth || el.scrollHeight > el.clientHeight) {
            return el;
          }
        }
        return doc.documentElement;
      }
      return null;
    }
    function makeFocusIgnored(element2) {
      element2.__shouldIgnoreFocus = true;
    }
    function shouldIgnoreFocus(element2) {
      return !!element2.__shouldIgnoreFocus;
    }
    function getUId(wnd) {
      const rnd = new Uint32Array(4);
      if (wnd.crypto && wnd.crypto.getRandomValues) {
        wnd.crypto.getRandomValues(rnd);
      } else if (wnd.msCrypto && wnd.msCrypto.getRandomValues) {
        wnd.msCrypto.getRandomValues(rnd);
      } else {
        for (let i2 = 0; i2 < rnd.length; i2++) {
          rnd[i2] = 4294967295 * Math.random();
        }
      }
      const srnd = [];
      for (let i2 = 0; i2 < rnd.length; i2++) {
        srnd.push(rnd[i2].toString(36));
      }
      srnd.push("|");
      srnd.push((++_uidCounter).toString(36));
      srnd.push("|");
      srnd.push(Date.now().toString(36));
      return srnd.join("");
    }
    function getElementUId(getWindow2, element2) {
      const context = getInstanceContext(getWindow2);
      let uid = element2.__tabsterElementUID;
      if (!uid) {
        uid = element2.__tabsterElementUID = getUId(getWindow2());
      }
      if (!context.elementByUId[uid] && documentContains(element2.ownerDocument, element2)) {
        context.elementByUId[uid] = new WeakHTMLElement(getWindow2, element2);
      }
      return uid;
    }
    function clearElementCache(getWindow2, parent) {
      const context = getInstanceContext(getWindow2);
      for (const key of Object.keys(context.elementByUId)) {
        const wel = context.elementByUId[key];
        const el = wel && wel.get();
        if (el && parent) {
          if (!parent.contains(el)) {
            continue;
          }
        }
        delete context.elementByUId[key];
      }
    }
    function documentContains(doc, element2) {
      var _a2;
      return !!((_a2 = doc === null || doc === void 0 ? void 0 : doc.body) === null || _a2 === void 0 ? void 0 : _a2.contains(element2));
    }
    function matchesSelector(element2, selector) {
      const matches = element2.matches || element2.matchesSelector || element2.msMatchesSelector || element2.webkitMatchesSelector;
      return matches && matches.call(element2, selector);
    }
    function getPromise(getWindow2) {
      const context = getInstanceContext(getWindow2);
      if (context.basics.Promise) {
        return context.basics.Promise;
      }
      throw new Error("No Promise defined.");
    }
    function getWeakRef(context) {
      return context.basics.WeakRef;
    }
    let _lastTabsterPartId = 0;
    class TabsterPart {
      constructor(tabster, element2, props) {
        const getWindow2 = tabster.getWindow;
        this._tabster = tabster;
        this._element = new WeakHTMLElement(getWindow2, element2);
        this._props = {
          ...props
        };
        this.id = "i" + ++_lastTabsterPartId;
      }
      getElement() {
        return this._element.get();
      }
      getProps() {
        return this._props;
      }
      setProps(props) {
        this._props = {
          ...props
        };
      }
    }
    class DummyInput {
      constructor(getWindow2, isOutside, props, element2, fixedTarget) {
        var _a2;
        this._focusIn = (e2) => {
          if (this._fixedTarget) {
            const target = this._fixedTarget.get();
            if (target) {
              nativeFocus(target);
            }
            return;
          }
          const input2 = this.input;
          if (this.onFocusIn && input2) {
            const relatedTarget = e2.relatedTarget;
            this.onFocusIn(this, this._isBackward(true, input2, relatedTarget), relatedTarget);
          }
        };
        this._focusOut = (e2) => {
          if (this._fixedTarget) {
            return;
          }
          this.useDefaultAction = false;
          const input2 = this.input;
          if (this.onFocusOut && input2) {
            const relatedTarget = e2.relatedTarget;
            this.onFocusOut(this, this._isBackward(false, input2, relatedTarget), relatedTarget);
          }
        };
        const win = getWindow2();
        const input = win.document.createElement("i");
        input.tabIndex = 0;
        input.setAttribute("role", "none");
        input.setAttribute(TabsterDummyInputAttributeName, "");
        input.setAttribute("aria-hidden", "true");
        const style2 = input.style;
        style2.position = "fixed";
        style2.width = style2.height = "1px";
        style2.opacity = "0.001";
        style2.zIndex = "-1";
        style2.setProperty("content-visibility", "hidden");
        makeFocusIgnored(input);
        this.input = input;
        this.isFirst = props.isFirst;
        this.isOutside = isOutside;
        this._isPhantom = (_a2 = props.isPhantom) !== null && _a2 !== void 0 ? _a2 : false;
        this._fixedTarget = fixedTarget;
        input.addEventListener("focusin", this._focusIn);
        input.addEventListener("focusout", this._focusOut);
        input.__tabsterDummyContainer = element2;
        if (this._isPhantom) {
          this._disposeTimer = win.setTimeout(() => {
            delete this._disposeTimer;
            this.dispose();
          }, 0);
          this._clearDisposeTimeout = () => {
            if (this._disposeTimer) {
              win.clearTimeout(this._disposeTimer);
              delete this._disposeTimer;
            }
            delete this._clearDisposeTimeout;
          };
        }
      }
      dispose() {
        var _a2;
        if (this._clearDisposeTimeout) {
          this._clearDisposeTimeout();
        }
        const input = this.input;
        if (!input) {
          return;
        }
        delete this._fixedTarget;
        delete this.onFocusIn;
        delete this.onFocusOut;
        delete this.input;
        input.removeEventListener("focusin", this._focusIn);
        input.removeEventListener("focusout", this._focusOut);
        delete input.__tabsterDummyContainer;
        (_a2 = input.parentElement) === null || _a2 === void 0 ? void 0 : _a2.removeChild(input);
      }
      setTopLeft(top, left) {
        var _a2;
        const style2 = (_a2 = this.input) === null || _a2 === void 0 ? void 0 : _a2.style;
        if (style2) {
          style2.top = `${top}px`;
          style2.left = `${left}px`;
        }
      }
      _isBackward(isIn, current, previous2) {
        return isIn && !previous2 ? !this.isFirst : !!(previous2 && current.compareDocumentPosition(previous2) & Node.DOCUMENT_POSITION_FOLLOWING);
      }
    }
    const DummyInputManagerPriorities = {
      Root: 1,
      Modalizer: 2,
      Mover: 3,
      Groupper: 4
    };
    class DummyInputManager {
      constructor(tabster, element2, priority, sys, outsideByDefault, callForDefaultAction) {
        this._element = element2;
        this._instance = new DummyInputManagerCore(tabster, element2, this, priority, sys, outsideByDefault, callForDefaultAction);
      }
      _setHandlers(onFocusIn, onFocusOut) {
        this._onFocusIn = onFocusIn;
        this._onFocusOut = onFocusOut;
      }
      moveOut(backwards) {
        var _a2;
        (_a2 = this._instance) === null || _a2 === void 0 ? void 0 : _a2.moveOut(backwards);
      }
      moveOutWithDefaultAction(backwards, relatedEvent) {
        var _a2;
        (_a2 = this._instance) === null || _a2 === void 0 ? void 0 : _a2.moveOutWithDefaultAction(backwards, relatedEvent);
      }
      getHandler(isIn) {
        return isIn ? this._onFocusIn : this._onFocusOut;
      }
      setTabbable(tabbable) {
        var _a2;
        (_a2 = this._instance) === null || _a2 === void 0 ? void 0 : _a2.setTabbable(this, tabbable);
      }
      dispose() {
        if (this._instance) {
          this._instance.dispose(this);
          delete this._instance;
        }
        delete this._onFocusIn;
        delete this._onFocusOut;
      }
      static moveWithPhantomDummy(tabster, element2, moveOutOfElement, isBackward, relatedEvent) {
        var _a2;
        const dummy = new DummyInput(tabster.getWindow, true, {
          isPhantom: true,
          isFirst: true
        });
        const input = dummy.input;
        if (input) {
          let parent;
          let insertBefore2;
          if (element2.tagName === "BODY") {
            parent = element2;
            insertBefore2 = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? element2.firstElementChild : null;
          } else {
            if (moveOutOfElement && (!isBackward || isBackward && !tabster.focusable.isFocusable(element2, false, true, true))) {
              parent = element2;
              insertBefore2 = isBackward ? element2.firstElementChild : null;
            } else {
              parent = element2.parentElement;
              insertBefore2 = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? element2 : element2.nextElementSibling;
            }
            let potentialDummy;
            let dummyFor;
            do {
              potentialDummy = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? insertBefore2 === null || insertBefore2 === void 0 ? void 0 : insertBefore2.previousElementSibling : insertBefore2;
              dummyFor = (_a2 = potentialDummy === null || potentialDummy === void 0 ? void 0 : potentialDummy.__tabsterDummyContainer) === null || _a2 === void 0 ? void 0 : _a2.get();
              if (dummyFor === element2) {
                insertBefore2 = moveOutOfElement && isBackward || !moveOutOfElement && !isBackward ? potentialDummy : potentialDummy === null || potentialDummy === void 0 ? void 0 : potentialDummy.nextElementSibling;
              } else {
                dummyFor = void 0;
              }
            } while (dummyFor);
          }
          if (parent && triggerMoveFocusEvent({
            by: "root",
            owner: parent,
            next: null,
            relatedEvent
          })) {
            parent.insertBefore(input, insertBefore2);
            nativeFocus(input);
          }
        }
      }
      static addPhantomDummyWithTarget(tabster, sourceElement, isBackward, targetElement) {
        const dummy = new DummyInput(tabster.getWindow, true, {
          isPhantom: true,
          isFirst: true
        }, void 0, new WeakHTMLElement(tabster.getWindow, targetElement));
        const input = dummy.input;
        if (input) {
          let dummyParent;
          let insertBefore2;
          if (hasSubFocusable(sourceElement) && !isBackward) {
            dummyParent = sourceElement;
            insertBefore2 = sourceElement.firstElementChild;
          } else {
            dummyParent = sourceElement.parentElement;
            insertBefore2 = isBackward ? sourceElement : sourceElement.nextElementSibling;
          }
          dummyParent === null || dummyParent === void 0 ? void 0 : dummyParent.insertBefore(input, insertBefore2);
        }
      }
    }
    class DummyInputObserver {
      constructor(win) {
        this._updateQueue = /* @__PURE__ */ new Set();
        this._lastUpdateQueueTime = 0;
        this._changedParents = /* @__PURE__ */ new WeakSet();
        this._dummyElements = [];
        this._dummyCallbacks = /* @__PURE__ */ new WeakMap();
        this._domChanged = (parent) => {
          var _a2;
          if (this._changedParents.has(parent)) {
            return;
          }
          this._changedParents.add(parent);
          if (this._updateDummyInputsTimer) {
            return;
          }
          this._updateDummyInputsTimer = (_a2 = this._win) === null || _a2 === void 0 ? void 0 : _a2.call(this).setTimeout(() => {
            delete this._updateDummyInputsTimer;
            for (const ref of this._dummyElements) {
              const dummyElement = ref.get();
              if (dummyElement) {
                const callback = this._dummyCallbacks.get(dummyElement);
                if (callback) {
                  const dummyParent = dummyElement.parentElement;
                  if (!dummyParent || this._changedParents.has(dummyParent)) {
                    callback();
                  }
                }
              }
            }
            this._changedParents = /* @__PURE__ */ new WeakSet();
          }, _updateDummyInputsTimeout);
        };
        this._win = win;
      }
      add(dummy, callback) {
        if (!this._dummyCallbacks.has(dummy) && this._win) {
          this._dummyElements.push(new WeakHTMLElement(this._win, dummy));
          this._dummyCallbacks.set(dummy, callback);
          this.domChanged = this._domChanged;
        }
      }
      remove(dummy) {
        this._dummyElements = this._dummyElements.filter((ref) => {
          const element2 = ref.get();
          return element2 && element2 !== dummy;
        });
        this._dummyCallbacks.delete(dummy);
        if (this._dummyElements.length === 0) {
          delete this.domChanged;
        }
      }
      dispose() {
        var _a2;
        const win = (_a2 = this._win) === null || _a2 === void 0 ? void 0 : _a2.call(this);
        if (this._updateTimer) {
          win === null || win === void 0 ? void 0 : win.clearTimeout(this._updateTimer);
          delete this._updateTimer;
        }
        if (this._updateDummyInputsTimer) {
          win === null || win === void 0 ? void 0 : win.clearTimeout(this._updateDummyInputsTimer);
          delete this._updateDummyInputsTimer;
        }
        this._changedParents = /* @__PURE__ */ new WeakSet();
        this._dummyCallbacks = /* @__PURE__ */ new WeakMap();
        this._dummyElements = [];
        this._updateQueue.clear();
        delete this.domChanged;
        delete this._win;
      }
      updatePositions(compute) {
        if (!this._win) {
          return;
        }
        this._updateQueue.add(compute);
        this._lastUpdateQueueTime = Date.now();
        this._scheduledUpdatePositions();
      }
      _scheduledUpdatePositions() {
        var _a2;
        if (this._updateTimer) {
          return;
        }
        this._updateTimer = (_a2 = this._win) === null || _a2 === void 0 ? void 0 : _a2.call(this).setTimeout(() => {
          delete this._updateTimer;
          if (this._lastUpdateQueueTime + _updateDummyInputsTimeout <= Date.now()) {
            const scrollTopLeftCache = /* @__PURE__ */ new Map();
            const setTopLeftCallbacks = [];
            for (const compute of this._updateQueue) {
              setTopLeftCallbacks.push(compute(scrollTopLeftCache));
            }
            this._updateQueue.clear();
            for (const setTopLeft of setTopLeftCallbacks) {
              setTopLeft();
            }
            scrollTopLeftCache.clear();
          } else {
            this._scheduledUpdatePositions();
          }
        }, _updateDummyInputsTimeout);
      }
    }
    class DummyInputManagerCore {
      constructor(tabster, element2, manager, priority, sys, outsideByDefault, callForDefaultAction) {
        this._wrappers = [];
        this._isOutside = false;
        this._transformElements = /* @__PURE__ */ new Set();
        this._onFocusIn = (dummyInput, isBackward, relatedTarget) => {
          this._onFocus(true, dummyInput, isBackward, relatedTarget);
        };
        this._onFocusOut = (dummyInput, isBackward, relatedTarget) => {
          this._onFocus(false, dummyInput, isBackward, relatedTarget);
        };
        this.moveOut = (backwards) => {
          var _a2;
          const first = this._firstDummy;
          const last = this._lastDummy;
          if (first && last) {
            this._ensurePosition();
            const firstInput = first.input;
            const lastInput = last.input;
            const element3 = (_a2 = this._element) === null || _a2 === void 0 ? void 0 : _a2.get();
            if (firstInput && lastInput && element3) {
              let toFocus;
              if (backwards) {
                firstInput.tabIndex = 0;
                toFocus = firstInput;
              } else {
                lastInput.tabIndex = 0;
                toFocus = lastInput;
              }
              if (toFocus) {
                nativeFocus(toFocus);
              }
            }
          }
        };
        this.moveOutWithDefaultAction = (backwards, relatedEvent) => {
          var _a2;
          const first = this._firstDummy;
          const last = this._lastDummy;
          if (first && last) {
            this._ensurePosition();
            const firstInput = first.input;
            const lastInput = last.input;
            const element3 = (_a2 = this._element) === null || _a2 === void 0 ? void 0 : _a2.get();
            if (firstInput && lastInput && element3) {
              let toFocus;
              if (backwards) {
                if (!first.isOutside && this._tabster.focusable.isFocusable(element3, true, true, true)) {
                  toFocus = element3;
                } else {
                  first.useDefaultAction = true;
                  firstInput.tabIndex = 0;
                  toFocus = firstInput;
                }
              } else {
                last.useDefaultAction = true;
                lastInput.tabIndex = 0;
                toFocus = lastInput;
              }
              if (toFocus && triggerMoveFocusEvent({
                by: "root",
                owner: element3,
                next: null,
                relatedEvent
              })) {
                nativeFocus(toFocus);
              }
            }
          }
        };
        this.setTabbable = (manager2, tabbable) => {
          var _a2, _b;
          for (const w2 of this._wrappers) {
            if (w2.manager === manager2) {
              w2.tabbable = tabbable;
              break;
            }
          }
          const wrapper = this._getCurrent();
          if (wrapper) {
            const tabIndex = wrapper.tabbable ? 0 : -1;
            let input = (_a2 = this._firstDummy) === null || _a2 === void 0 ? void 0 : _a2.input;
            if (input) {
              input.tabIndex = tabIndex;
            }
            input = (_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.input;
            if (input) {
              input.tabIndex = tabIndex;
            }
          }
        };
        this._addDummyInputs = () => {
          if (this._addTimer) {
            return;
          }
          this._addTimer = this._getWindow().setTimeout(() => {
            delete this._addTimer;
            this._ensurePosition();
            this._addTransformOffsets();
          }, 0);
        };
        this._addTransformOffsets = () => {
          this._tabster._dummyObserver.updatePositions(this._computeTransformOffsets);
        };
        this._computeTransformOffsets = (scrollTopLeftCache) => {
          var _a2, _b;
          const from2 = ((_a2 = this._firstDummy) === null || _a2 === void 0 ? void 0 : _a2.input) || ((_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.input);
          const transformElements = this._transformElements;
          const newTransformElements = /* @__PURE__ */ new Set();
          let scrollTop = 0;
          let scrollLeft = 0;
          const win = this._getWindow();
          for (let element3 = from2; element3 && element3.nodeType === Node.ELEMENT_NODE; element3 = element3.parentElement) {
            let scrollTopLeft = scrollTopLeftCache.get(element3);
            if (scrollTopLeft === void 0) {
              const transform2 = win.getComputedStyle(element3).transform;
              if (transform2 && transform2 !== "none") {
                scrollTopLeft = {
                  scrollTop: element3.scrollTop,
                  scrollLeft: element3.scrollLeft
                };
              }
              scrollTopLeftCache.set(element3, scrollTopLeft || null);
            }
            if (scrollTopLeft) {
              newTransformElements.add(element3);
              if (!transformElements.has(element3)) {
                element3.addEventListener("scroll", this._addTransformOffsets);
              }
              scrollTop += scrollTopLeft.scrollTop;
              scrollLeft += scrollTopLeft.scrollLeft;
            }
          }
          for (const el2 of transformElements) {
            if (!newTransformElements.has(el2)) {
              el2.removeEventListener("scroll", this._addTransformOffsets);
            }
          }
          this._transformElements = newTransformElements;
          return () => {
            var _a3, _b2;
            (_a3 = this._firstDummy) === null || _a3 === void 0 ? void 0 : _a3.setTopLeft(scrollTop, scrollLeft);
            (_b2 = this._lastDummy) === null || _b2 === void 0 ? void 0 : _b2.setTopLeft(scrollTop, scrollLeft);
          };
        };
        const el = element2.get();
        if (!el) {
          throw new Error("No element");
        }
        this._tabster = tabster;
        this._getWindow = tabster.getWindow;
        this._callForDefaultAction = callForDefaultAction;
        const instance = el.__tabsterDummy;
        (instance || this)._wrappers.push({
          manager,
          priority,
          tabbable: true
        });
        if (instance) {
          return instance;
        }
        el.__tabsterDummy = this;
        const forcedDummyPosition = sys === null || sys === void 0 ? void 0 : sys.dummyInputsPosition;
        const tagName = el.tagName;
        this._isOutside = !forcedDummyPosition ? (outsideByDefault || tagName === "UL" || tagName === "OL" || tagName === "TABLE") && !(tagName === "LI" || tagName === "TD" || tagName === "TH") : forcedDummyPosition === SysDummyInputsPositions.Outside;
        this._firstDummy = new DummyInput(this._getWindow, this._isOutside, {
          isFirst: true
        }, element2);
        this._lastDummy = new DummyInput(this._getWindow, this._isOutside, {
          isFirst: false
        }, element2);
        const dummyElement = this._firstDummy.input;
        dummyElement && tabster._dummyObserver.add(dummyElement, this._addDummyInputs);
        this._firstDummy.onFocusIn = this._onFocusIn;
        this._firstDummy.onFocusOut = this._onFocusOut;
        this._lastDummy.onFocusIn = this._onFocusIn;
        this._lastDummy.onFocusOut = this._onFocusOut;
        this._element = element2;
        this._addDummyInputs();
      }
      dispose(manager, force) {
        var _a2, _b, _c, _d;
        const wrappers = this._wrappers = this._wrappers.filter((w2) => w2.manager !== manager && !force);
        if (wrappers.length === 0) {
          delete ((_a2 = this._element) === null || _a2 === void 0 ? void 0 : _a2.get()).__tabsterDummy;
          for (const el of this._transformElements) {
            el.removeEventListener("scroll", this._addTransformOffsets);
          }
          this._transformElements.clear();
          const win = this._getWindow();
          if (this._addTimer) {
            win.clearTimeout(this._addTimer);
            delete this._addTimer;
          }
          const dummyElement = (_b = this._firstDummy) === null || _b === void 0 ? void 0 : _b.input;
          dummyElement && this._tabster._dummyObserver.remove(dummyElement);
          (_c = this._firstDummy) === null || _c === void 0 ? void 0 : _c.dispose();
          (_d = this._lastDummy) === null || _d === void 0 ? void 0 : _d.dispose();
        }
      }
      _onFocus(isIn, dummyInput, isBackward, relatedTarget) {
        var _a2;
        const wrapper = this._getCurrent();
        if (wrapper && (!dummyInput.useDefaultAction || this._callForDefaultAction)) {
          (_a2 = wrapper.manager.getHandler(isIn)) === null || _a2 === void 0 ? void 0 : _a2(dummyInput, isBackward, relatedTarget);
        }
      }
      _getCurrent() {
        this._wrappers.sort((a2, b2) => {
          if (a2.tabbable !== b2.tabbable) {
            return a2.tabbable ? -1 : 1;
          }
          return a2.priority - b2.priority;
        });
        return this._wrappers[0];
      }
      _ensurePosition() {
        var _a2, _b, _c;
        const element2 = (_a2 = this._element) === null || _a2 === void 0 ? void 0 : _a2.get();
        const firstDummyInput = (_b = this._firstDummy) === null || _b === void 0 ? void 0 : _b.input;
        const lastDummyInput = (_c = this._lastDummy) === null || _c === void 0 ? void 0 : _c.input;
        if (!element2 || !firstDummyInput || !lastDummyInput) {
          return;
        }
        if (this._isOutside) {
          const elementParent = element2.parentElement;
          if (elementParent) {
            const nextSibling = element2.nextElementSibling;
            if (nextSibling !== lastDummyInput) {
              elementParent.insertBefore(lastDummyInput, nextSibling);
            }
            if (element2.previousElementSibling !== firstDummyInput) {
              elementParent.insertBefore(firstDummyInput, element2);
            }
          }
        } else {
          if (element2.lastElementChild !== lastDummyInput) {
            element2.appendChild(lastDummyInput);
          }
          const firstElementChild = element2.firstElementChild;
          if (firstElementChild && firstElementChild !== firstDummyInput) {
            element2.insertBefore(firstDummyInput, firstElementChild);
          }
        }
      }
    }
    function getLastChild(container) {
      let lastChild = null;
      for (let i2 = container.lastElementChild; i2; i2 = i2.lastElementChild) {
        lastChild = i2;
      }
      return lastChild || void 0;
    }
    function triggerEvent(target, name2, details) {
      const event = document.createEvent("HTMLEvents");
      event.initEvent(name2, true, true);
      event.details = details;
      target.dispatchEvent(event);
      return !event.defaultPrevented;
    }
    function triggerMoveFocusEvent(details) {
      return triggerEvent(details.owner, MoveFocusEventName, details);
    }
    function augmentAttribute(tabster, element2, name2, value) {
      const entry = tabster.storageEntry(element2, true);
      let ret = false;
      if (!entry.aug) {
        if (value === void 0) {
          return ret;
        }
        entry.aug = {};
      }
      if (value === void 0) {
        if (name2 in entry.aug) {
          const origVal = entry.aug[name2];
          delete entry.aug[name2];
          if (origVal === null) {
            element2.removeAttribute(name2);
          } else {
            element2.setAttribute(name2, origVal);
          }
          ret = true;
        }
      } else {
        let origValue;
        if (!(name2 in entry.aug)) {
          origValue = element2.getAttribute(name2);
        }
        if (origValue !== void 0 && origValue !== value) {
          entry.aug[name2] = origValue;
          if (value === null) {
            element2.removeAttribute(name2);
          } else {
            element2.setAttribute(name2, value);
          }
          ret = true;
        }
      }
      if (value === void 0 && Object.keys(entry.aug).length === 0) {
        delete entry.aug;
        tabster.storageEntry(element2, false);
      }
      return ret;
    }
    /*!
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    function getTabsterAttribute(props, plain) {
      const attr = JSON.stringify(props);
      if (plain === true) {
        return attr;
      }
      return {
        [TabsterAttributeName]: attr
      };
    }
    function mergeTabsterProps(props, newProps) {
      for (const key of Object.keys(newProps)) {
        const value = newProps[key];
        if (value) {
          props[key] = value;
        } else {
          delete props[key];
        }
      }
    }
    function setTabsterAttribute(element2, newProps, update) {
      let props;
      if (update) {
        const attr = element2.getAttribute(TabsterAttributeName);
        if (attr) {
          try {
            props = JSON.parse(attr);
          } catch (e2) {
          }
        }
      }
      if (!props) {
        props = {};
      }
      mergeTabsterProps(props, newProps);
      if (Object.keys(props).length > 0) {
        element2.setAttribute(TabsterAttributeName, getTabsterAttribute(props, true));
      } else {
        element2.removeAttribute(TabsterAttributeName);
      }
    }
    class RootDummyManager extends DummyInputManager {
      constructor(tabster, element2, setFocused, sys) {
        super(tabster, element2, DummyInputManagerPriorities.Root, sys, void 0, true);
        this._onDummyInputFocus = (dummyInput) => {
          var _a2;
          if (dummyInput.useDefaultAction) {
            this._setFocused(false);
          } else {
            this._tabster.keyboardNavigation.setNavigatingWithKeyboard(true);
            const element3 = this._element.get();
            if (element3) {
              this._setFocused(true);
              const toFocus = this._tabster.focusedElement.getFirstOrLastTabbable(dummyInput.isFirst, {
                container: element3,
                ignoreAccessibility: true
              });
              if (toFocus) {
                nativeFocus(toFocus);
                return;
              }
            }
            (_a2 = dummyInput.input) === null || _a2 === void 0 ? void 0 : _a2.blur();
          }
        };
        this._setHandlers(this._onDummyInputFocus);
        this._tabster = tabster;
        this._setFocused = setFocused;
      }
    }
    class Root extends TabsterPart {
      constructor(tabster, element2, onDispose, props, sys) {
        super(tabster, element2, props);
        this._isFocused = false;
        this._setFocused = (hasFocused) => {
          var _a2;
          if (this._setFocusedTimer) {
            this._tabster.getWindow().clearTimeout(this._setFocusedTimer);
            delete this._setFocusedTimer;
          }
          if (this._isFocused === hasFocused) {
            return;
          }
          const element3 = this._element.get();
          if (element3) {
            if (hasFocused) {
              this._isFocused = true;
              (_a2 = this._dummyManager) === null || _a2 === void 0 ? void 0 : _a2.setTabbable(false);
              triggerEvent(this._tabster.root.eventTarget, "focus", {
                element: element3
              });
            } else {
              this._setFocusedTimer = this._tabster.getWindow().setTimeout(() => {
                var _a3;
                delete this._setFocusedTimer;
                this._isFocused = false;
                (_a3 = this._dummyManager) === null || _a3 === void 0 ? void 0 : _a3.setTabbable(true);
                triggerEvent(this._tabster.root.eventTarget, "blur", {
                  element: element3
                });
              }, 0);
            }
          }
        };
        this._onFocusIn = (event) => {
          const getParent2 = this._tabster.getParent;
          const rootElement = this._element.get();
          let curElement = event.target;
          do {
            if (curElement === rootElement) {
              this._setFocused(true);
              return;
            }
            curElement = curElement && getParent2(curElement);
          } while (curElement);
        };
        this._onFocusOut = () => {
          this._setFocused(false);
        };
        this._onDispose = onDispose;
        const win = tabster.getWindow;
        this.uid = getElementUId(win, element2);
        this._sys = sys;
        if (tabster.controlTab || tabster.rootDummyInputs) {
          this.addDummyInputs();
        }
        const w2 = win();
        w2.document.addEventListener("focusin", this._onFocusIn);
        w2.document.addEventListener("focusout", this._onFocusOut);
        this._add();
      }
      addDummyInputs() {
        if (!this._dummyManager) {
          this._dummyManager = new RootDummyManager(this._tabster, this._element, this._setFocused, this._sys);
        }
      }
      dispose() {
        var _a2;
        this._onDispose(this);
        const win = this._tabster.getWindow();
        win.document.removeEventListener("focusin", this._onFocusIn);
        win.document.removeEventListener("focusout", this._onFocusOut);
        if (this._setFocusedTimer) {
          win.clearTimeout(this._setFocusedTimer);
          delete this._setFocusedTimer;
        }
        (_a2 = this._dummyManager) === null || _a2 === void 0 ? void 0 : _a2.dispose();
        this._remove();
      }
      moveOutWithDefaultAction(isBackward, relatedEvent) {
        const dummyManager = this._dummyManager;
        if (dummyManager) {
          dummyManager.moveOutWithDefaultAction(isBackward, relatedEvent);
        } else {
          const el = this.getElement();
          if (el) {
            RootDummyManager.moveWithPhantomDummy(this._tabster, el, true, isBackward, relatedEvent);
          }
        }
      }
      _add() {
      }
      _remove() {
      }
    }
    class RootAPI {
      constructor(tabster, autoRoot) {
        this._autoRootWaiting = false;
        this._roots = {};
        this._forceDummy = false;
        this.rootById = {};
        this._autoRootCreate = () => {
          var _a2;
          const doc = this._win().document;
          const body = doc.body;
          if (body) {
            this._autoRootUnwait(doc);
            const props = this._autoRoot;
            if (props) {
              setTabsterAttribute(body, {
                root: props
              }, true);
              updateTabsterByAttribute(this._tabster, body);
              return (_a2 = getTabsterOnElement(this._tabster, body)) === null || _a2 === void 0 ? void 0 : _a2.root;
            }
          } else if (!this._autoRootWaiting) {
            this._autoRootWaiting = true;
            doc.addEventListener("readystatechange", this._autoRootCreate);
          }
          return void 0;
        };
        this._onRootDispose = (root2) => {
          delete this._roots[root2.id];
        };
        this._tabster = tabster;
        this._win = tabster.getWindow;
        this._autoRoot = autoRoot;
        this.eventTarget = createEventTarget(this._win);
        tabster.queueInit(() => {
          if (this._autoRoot) {
            this._autoRootCreate();
          }
        });
      }
      _autoRootUnwait(doc) {
        doc.removeEventListener("readystatechange", this._autoRootCreate);
        this._autoRootWaiting = false;
      }
      dispose() {
        const win = this._win();
        this._autoRootUnwait(win.document);
        delete this._autoRoot;
        Object.keys(this._roots).forEach((rootId) => {
          if (this._roots[rootId]) {
            this._roots[rootId].dispose();
            delete this._roots[rootId];
          }
        });
        this.rootById = {};
      }
      createRoot(element2, props, sys) {
        const newRoot = new Root(this._tabster, element2, this._onRootDispose, props, sys);
        this._roots[newRoot.id] = newRoot;
        if (this._forceDummy) {
          newRoot.addDummyInputs();
        }
        return newRoot;
      }
      addDummyInputs() {
        this._forceDummy = true;
        const roots = this._roots;
        for (const id2 of Object.keys(roots)) {
          roots[id2].addDummyInputs();
        }
      }
      static getRootByUId(getWindow2, id2) {
        const tabster = getWindow2().__tabsterInstance;
        return tabster && tabster.root.rootById[id2];
      }
      /**
       * Fetches the tabster context for an element walking up its ancestors
       *
       * @param tabster Tabster instance
       * @param element The element the tabster context should represent
       * @param options Additional options
       * @returns undefined if the element is not a child of a tabster root, otherwise all applicable tabster behaviours and configurations
       */
      static getTabsterContext(tabster, element2, options) {
        if (options === void 0) {
          options = {};
        }
        var _a2, _b, _c, _d;
        if (!element2.ownerDocument) {
          return void 0;
        }
        const {
          checkRtl,
          referenceElement
        } = options;
        const getParent2 = tabster.getParent;
        tabster.drainInitQueue();
        let root2;
        let modalizer;
        let groupper;
        let mover;
        let excludedFromMover = false;
        let groupperBeforeMover;
        let modalizerInGroupper;
        let dirRightToLeft;
        let uncontrolled;
        let curElement = referenceElement || element2;
        const ignoreKeydown = {};
        while (curElement && (!root2 || checkRtl)) {
          const tabsterOnElement = getTabsterOnElement(tabster, curElement);
          if (checkRtl && dirRightToLeft === void 0) {
            const dir = curElement.dir;
            if (dir) {
              dirRightToLeft = dir.toLowerCase() === "rtl";
            }
          }
          if (!tabsterOnElement) {
            curElement = getParent2(curElement);
            continue;
          }
          const tagName = curElement.tagName;
          if (tabsterOnElement.uncontrolled || tagName === "IFRAME" || tagName === "WEBVIEW") {
            uncontrolled = curElement;
          }
          if (!mover && ((_a2 = tabsterOnElement.focusable) === null || _a2 === void 0 ? void 0 : _a2.excludeFromMover) && !groupper) {
            excludedFromMover = true;
          }
          const curModalizer = tabsterOnElement.modalizer;
          const curGroupper = tabsterOnElement.groupper;
          const curMover = tabsterOnElement.mover;
          if (!modalizer && curModalizer) {
            modalizer = curModalizer;
          }
          if (!groupper && curGroupper && (!modalizer || curModalizer)) {
            if (modalizer) {
              if (!curGroupper.isActive() && curGroupper.getProps().tabbability && modalizer.userId !== ((_b = tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {
                modalizer = void 0;
                groupper = curGroupper;
              }
              modalizerInGroupper = curGroupper;
            } else {
              groupper = curGroupper;
            }
          }
          if (!mover && curMover && (!modalizer || curModalizer) && (!curGroupper || curElement !== element2)) {
            mover = curMover;
            groupperBeforeMover = !!groupper && groupper !== curGroupper;
          }
          if (tabsterOnElement.root) {
            root2 = tabsterOnElement.root;
          }
          if ((_c = tabsterOnElement.focusable) === null || _c === void 0 ? void 0 : _c.ignoreKeydown) {
            Object.assign(ignoreKeydown, tabsterOnElement.focusable.ignoreKeydown);
          }
          curElement = getParent2(curElement);
        }
        if (!root2) {
          const rootAPI = tabster.root;
          const autoRoot = rootAPI._autoRoot;
          if (autoRoot) {
            if ((_d = element2.ownerDocument) === null || _d === void 0 ? void 0 : _d.body) {
              root2 = rootAPI._autoRootCreate();
            }
          }
        }
        if (groupper && !mover) {
          groupperBeforeMover = true;
        }
        const shouldIgnoreKeydown = (event) => !!ignoreKeydown[event.key];
        return root2 ? {
          root: root2,
          modalizer,
          groupper,
          mover,
          groupperBeforeMover,
          modalizerInGroupper,
          rtl: checkRtl ? !!dirRightToLeft : void 0,
          uncontrolled,
          excludedFromMover,
          ignoreKeydown: shouldIgnoreKeydown
        } : void 0;
      }
      static getRoot(tabster, element2) {
        var _a2;
        const getParent2 = tabster.getParent;
        for (let el = element2; el; el = getParent2(el)) {
          const root2 = (_a2 = getTabsterOnElement(tabster, el)) === null || _a2 === void 0 ? void 0 : _a2.root;
          if (root2) {
            return root2;
          }
        }
        return void 0;
      }
      onRoot(root2, removed) {
        if (removed) {
          delete this.rootById[root2.uid];
        } else {
          this.rootById[root2.uid] = root2;
        }
      }
    }
    /*!
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    let Subscribable$1 = class Subscribable {
      constructor() {
        this._callbacks = [];
      }
      dispose() {
        this._callbacks = [];
        delete this._val;
      }
      subscribe(callback) {
        const callbacks = this._callbacks;
        const index2 = callbacks.indexOf(callback);
        if (index2 < 0) {
          callbacks.push(callback);
        }
      }
      subscribeFirst(callback) {
        const callbacks = this._callbacks;
        const index2 = callbacks.indexOf(callback);
        if (index2 >= 0) {
          callbacks.splice(index2, 1);
        }
        callbacks.unshift(callback);
      }
      unsubscribe(callback) {
        const index2 = this._callbacks.indexOf(callback);
        if (index2 >= 0) {
          this._callbacks.splice(index2, 1);
        }
      }
      setVal(val, details) {
        if (this._val === val) {
          return;
        }
        this._val = val;
        this._callCallbacks(val, details);
      }
      getVal() {
        return this._val;
      }
      trigger(val, details) {
        this._callCallbacks(val, details);
      }
      _callCallbacks(val, details) {
        this._callbacks.forEach((callback) => callback(val, details));
      }
    };
    /*!
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    class FocusableAPI {
      constructor(tabster) {
        this._tabster = tabster;
      }
      dispose() {
      }
      getProps(element2) {
        const tabsterOnElement = getTabsterOnElement(this._tabster, element2);
        return tabsterOnElement && tabsterOnElement.focusable || {};
      }
      isFocusable(el, includeProgrammaticallyFocusable, noVisibleCheck, noAccessibleCheck) {
        if (matchesSelector(el, FocusableSelector) && (includeProgrammaticallyFocusable || el.tabIndex !== -1)) {
          return (noVisibleCheck || this.isVisible(el)) && (noAccessibleCheck || this.isAccessible(el));
        }
        return false;
      }
      isVisible(el) {
        if (!el.ownerDocument || el.nodeType !== Node.ELEMENT_NODE) {
          return false;
        }
        if (el.offsetParent === null && el.ownerDocument.body !== el) {
          return false;
        }
        const win = el.ownerDocument.defaultView;
        if (!win) {
          return false;
        }
        const rect = el.ownerDocument.body.getBoundingClientRect();
        if (rect.width === 0 && rect.height === 0) {
          return false;
        }
        const computedStyle = win.getComputedStyle(el);
        if (computedStyle.visibility === "hidden") {
          return false;
        }
        return true;
      }
      isAccessible(el) {
        var _a2;
        for (let e2 = el; e2; e2 = e2.parentElement) {
          const tabsterOnElement = getTabsterOnElement(this._tabster, e2);
          if (this._isHidden(e2)) {
            return false;
          }
          const ignoreDisabled = (_a2 = tabsterOnElement === null || tabsterOnElement === void 0 ? void 0 : tabsterOnElement.focusable) === null || _a2 === void 0 ? void 0 : _a2.ignoreAriaDisabled;
          if (!ignoreDisabled && this._isDisabled(e2)) {
            return false;
          }
        }
        return true;
      }
      _isDisabled(el) {
        return el.hasAttribute("disabled");
      }
      _isHidden(el) {
        var _a2;
        const attrVal = el.getAttribute("aria-hidden");
        if (attrVal && attrVal.toLowerCase() === "true") {
          if (!((_a2 = this._tabster.modalizer) === null || _a2 === void 0 ? void 0 : _a2.isAugmented(el))) {
            return true;
          }
        }
        return false;
      }
      findFirst(options, out) {
        return this.findElement({
          ...options
        }, out);
      }
      findLast(options, out) {
        return this.findElement({
          isBackward: true,
          ...options
        }, out);
      }
      findNext(options, out) {
        return this.findElement({
          ...options
        }, out);
      }
      findPrev(options, out) {
        return this.findElement({
          ...options,
          isBackward: true
        }, out);
      }
      findDefault(options, out) {
        return this.findElement({
          ...options,
          acceptCondition: (el) => this.isFocusable(el, options.includeProgrammaticallyFocusable) && !!this.getProps(el).isDefault
        }, out) || null;
      }
      findAll(options) {
        return this._findElements(true, options) || [];
      }
      findElement(options, out) {
        const found = this._findElements(false, options, out);
        return found ? found[0] : found;
      }
      _findElements(findAll, options, out) {
        var _a2, _b, _c;
        const {
          container,
          currentElement = null,
          includeProgrammaticallyFocusable,
          useActiveModalizer,
          ignoreAccessibility,
          modalizerId,
          isBackward,
          onElement
        } = options;
        if (!out) {
          out = {};
        }
        const elements = [];
        let {
          acceptCondition
        } = options;
        const hasCustomCondition = !!acceptCondition;
        if (!container) {
          return null;
        }
        if (!acceptCondition) {
          acceptCondition = (el) => this.isFocusable(el, includeProgrammaticallyFocusable, false, ignoreAccessibility);
        }
        const acceptElementState = {
          container,
          modalizerUserId: modalizerId === void 0 && useActiveModalizer ? (_a2 = this._tabster.modalizer) === null || _a2 === void 0 ? void 0 : _a2.activeId : modalizerId || ((_c = (_b = RootAPI.getTabsterContext(this._tabster, container)) === null || _b === void 0 ? void 0 : _b.modalizer) === null || _c === void 0 ? void 0 : _c.userId),
          from: currentElement || container,
          isBackward,
          acceptCondition,
          hasCustomCondition,
          includeProgrammaticallyFocusable,
          ignoreAccessibility,
          cachedGrouppers: {}
        };
        const walker = createElementTreeWalker(container.ownerDocument, container, (node2) => this._acceptElement(node2, acceptElementState));
        if (!walker) {
          return null;
        }
        const prepareForNextElement = (shouldContinueIfNotFound) => {
          var _a3, _b2;
          const foundElement = (_a3 = acceptElementState.foundElement) !== null && _a3 !== void 0 ? _a3 : acceptElementState.foundBackward;
          if (foundElement) {
            elements.push(foundElement);
          }
          if (findAll) {
            if (foundElement) {
              acceptElementState.found = false;
              delete acceptElementState.foundElement;
              delete acceptElementState.foundBackward;
              delete acceptElementState.fromCtx;
              acceptElementState.from = foundElement;
              if (onElement && !onElement(foundElement)) {
                return false;
              }
            }
            return !!(foundElement || shouldContinueIfNotFound);
          } else {
            if (foundElement && out) {
              out.uncontrolled = (_b2 = RootAPI.getTabsterContext(this._tabster, foundElement)) === null || _b2 === void 0 ? void 0 : _b2.uncontrolled;
            }
            return !!(shouldContinueIfNotFound && !foundElement);
          }
        };
        if (!currentElement) {
          out.outOfDOMOrder = true;
        }
        if (currentElement) {
          walker.currentNode = currentElement;
        } else if (isBackward) {
          const lastChild = getLastChild(container);
          if (!lastChild) {
            return null;
          }
          if (this._acceptElement(lastChild, acceptElementState) === NodeFilter.FILTER_ACCEPT && !prepareForNextElement(true)) {
            if (acceptElementState.skippedFocusable) {
              out.outOfDOMOrder = true;
            }
            return elements;
          }
          walker.currentNode = lastChild;
        }
        do {
          if (isBackward) {
            walker.previousNode();
          } else {
            walker.nextNode();
          }
        } while (prepareForNextElement());
        if (acceptElementState.skippedFocusable) {
          out.outOfDOMOrder = true;
        }
        return elements.length ? elements : null;
      }
      _acceptElement(element2, state) {
        var _a2, _b, _c, _d;
        if (state.found) {
          return NodeFilter.FILTER_ACCEPT;
        }
        const foundBackward = state.foundBackward;
        if (foundBackward && (element2 === foundBackward || !foundBackward.contains(element2))) {
          state.found = true;
          state.foundElement = foundBackward;
          return NodeFilter.FILTER_ACCEPT;
        }
        const container = state.container;
        if (element2 === container) {
          return NodeFilter.FILTER_SKIP;
        }
        if (!container.contains(element2)) {
          return NodeFilter.FILTER_REJECT;
        }
        if (element2.__tabsterDummyContainer) {
          return NodeFilter.FILTER_REJECT;
        }
        if ((_a2 = state.rejectElementsFrom) === null || _a2 === void 0 ? void 0 : _a2.contains(element2)) {
          return NodeFilter.FILTER_REJECT;
        }
        const ctx = state.currentCtx = RootAPI.getTabsterContext(this._tabster, element2);
        if (!ctx) {
          return NodeFilter.FILTER_SKIP;
        }
        if (shouldIgnoreFocus(element2)) {
          if (this.isFocusable(element2, void 0, true, true)) {
            state.skippedFocusable = true;
          }
          return NodeFilter.FILTER_SKIP;
        }
        if (!state.hasCustomCondition && (element2.tagName === "IFRAME" || element2.tagName === "WEBVIEW")) {
          if (((_b = ctx.modalizer) === null || _b === void 0 ? void 0 : _b.userId) === ((_c = this._tabster.modalizer) === null || _c === void 0 ? void 0 : _c.activeId)) {
            state.found = true;
            state.rejectElementsFrom = state.foundElement = element2;
            return NodeFilter.FILTER_ACCEPT;
          } else {
            return NodeFilter.FILTER_REJECT;
          }
        }
        if (!state.ignoreAccessibility && !this.isAccessible(element2)) {
          if (this.isFocusable(element2, false, true, true)) {
            state.skippedFocusable = true;
          }
          return NodeFilter.FILTER_REJECT;
        }
        let result;
        let fromCtx = state.fromCtx;
        if (!fromCtx) {
          fromCtx = state.fromCtx = RootAPI.getTabsterContext(this._tabster, state.from);
        }
        const fromMover = fromCtx === null || fromCtx === void 0 ? void 0 : fromCtx.mover;
        let groupper = ctx.groupper;
        let mover = ctx.mover;
        result = (_d = this._tabster.modalizer) === null || _d === void 0 ? void 0 : _d.acceptElement(element2, state);
        if (result !== void 0) {
          state.skippedFocusable = true;
        }
        if (result === void 0 && (groupper || mover || fromMover)) {
          const groupperElement = groupper === null || groupper === void 0 ? void 0 : groupper.getElement();
          const fromMoverElement = fromMover === null || fromMover === void 0 ? void 0 : fromMover.getElement();
          let moverElement = mover === null || mover === void 0 ? void 0 : mover.getElement();
          if (moverElement && (fromMoverElement === null || fromMoverElement === void 0 ? void 0 : fromMoverElement.contains(moverElement)) && container.contains(fromMoverElement) && (!groupperElement || !mover || fromMoverElement.contains(groupperElement))) {
            mover = fromMover;
            moverElement = fromMoverElement;
          }
          if (groupperElement && (groupperElement === container || !container.contains(groupperElement))) {
            groupper = void 0;
          }
          if (moverElement && !container.contains(moverElement)) {
            mover = void 0;
          }
          if (groupper && mover) {
            if (moverElement && groupperElement && !groupperElement.contains(moverElement)) {
              mover = void 0;
            } else {
              groupper = void 0;
            }
          }
          if (groupper) {
            result = groupper.acceptElement(element2, state);
          }
          if (mover) {
            result = mover.acceptElement(element2, state);
          }
        }
        if (result === void 0) {
          result = state.acceptCondition(element2) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
          if (result === NodeFilter.FILTER_SKIP && this.isFocusable(element2, false, true, true)) {
            state.skippedFocusable = true;
          }
        }
        if (result === NodeFilter.FILTER_ACCEPT && !state.found) {
          if (state.isBackward) {
            state.foundBackward = element2;
            result = NodeFilter.FILTER_SKIP;
          } else {
            state.found = true;
            state.foundElement = element2;
          }
        }
        return result;
      }
    }
    /*!
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    const Keys = {
      Tab: 9,
      Enter: 13,
      Esc: 27,
      Space: 32,
      PageUp: 33,
      PageDown: 34,
      End: 35,
      Home: 36,
      Left: 37,
      Up: 38,
      Right: 39,
      Down: 40
    };
    /*!
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    function getUncontrolledCompletelyContainer(tabster, element2) {
      var _a2;
      const getParent2 = tabster.getParent;
      let el = element2;
      do {
        const uncontrolledOnElement = (_a2 = getTabsterOnElement(tabster, el)) === null || _a2 === void 0 ? void 0 : _a2.uncontrolled;
        if (uncontrolledOnElement && tabster.uncontrolled.isUncontrolledCompletely(el, !!uncontrolledOnElement.completely)) {
          return el;
        }
        el = getParent2(el);
      } while (el);
      return void 0;
    }
    class FocusedElementState extends Subscribable$1 {
      constructor(tabster, getWindow2) {
        super();
        this._init = () => {
          const win = this._win();
          const doc = win.document;
          doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);
          doc.addEventListener("focusout", this._onFocusOut, true);
          win.addEventListener("keydown", this._onKeyDown, true);
          const activeElement = doc.activeElement;
          if (activeElement && activeElement !== doc.body) {
            this._setFocusedElement(activeElement);
          }
          this.subscribe(this._onChanged);
        };
        this._onFocusIn = (e2) => {
          this._setFocusedElement(e2.target, e2.details.relatedTarget, e2.details.isFocusedProgrammatically);
        };
        this._onFocusOut = (e2) => {
          this._setFocusedElement(void 0, e2.relatedTarget);
        };
        this._validateFocusedElement = (element2) => {
        };
        this._onKeyDown = (event) => {
          if (event.keyCode !== Keys.Tab || event.ctrlKey) {
            return;
          }
          const currentElement = this.getVal();
          if (!currentElement || !currentElement.ownerDocument || currentElement.contentEditable === "true") {
            return;
          }
          const tabster2 = this._tabster;
          const controlTab = tabster2.controlTab;
          const ctx = RootAPI.getTabsterContext(tabster2, currentElement);
          if (!ctx || ctx.ignoreKeydown(event)) {
            return;
          }
          const isBackward = event.shiftKey;
          const next2 = FocusedElementState.findNextTabbable(tabster2, ctx, void 0, currentElement, void 0, isBackward, true);
          const rootElement = ctx.root.getElement();
          if (!rootElement) {
            return;
          }
          const nextElement = next2 === null || next2 === void 0 ? void 0 : next2.element;
          const uncontrolledCompletelyContainer = getUncontrolledCompletelyContainer(tabster2, currentElement);
          if (nextElement) {
            const nextUncontrolled = next2.uncontrolled;
            if (ctx.uncontrolled || (nextUncontrolled === null || nextUncontrolled === void 0 ? void 0 : nextUncontrolled.contains(currentElement))) {
              if (!next2.outOfDOMOrder && nextUncontrolled === ctx.uncontrolled || uncontrolledCompletelyContainer && !uncontrolledCompletelyContainer.contains(nextElement)) {
                return;
              }
              DummyInputManager.addPhantomDummyWithTarget(tabster2, currentElement, isBackward, nextElement);
              return;
            }
            if (nextUncontrolled || nextElement.tagName === "IFRAME") {
              if (triggerMoveFocusEvent({
                by: "root",
                owner: rootElement,
                next: nextElement,
                relatedEvent: event
              })) {
                DummyInputManager.moveWithPhantomDummy(this._tabster, nextUncontrolled !== null && nextUncontrolled !== void 0 ? nextUncontrolled : nextElement, false, isBackward, event);
              }
              return;
            }
            if (controlTab || (next2 === null || next2 === void 0 ? void 0 : next2.outOfDOMOrder)) {
              if (triggerMoveFocusEvent({
                by: "root",
                owner: rootElement,
                next: nextElement,
                relatedEvent: event
              })) {
                event.preventDefault();
                event.stopImmediatePropagation();
                nativeFocus(nextElement);
              }
            }
          } else {
            if (!uncontrolledCompletelyContainer && triggerMoveFocusEvent({
              by: "root",
              owner: rootElement,
              next: null,
              relatedEvent: event
            })) {
              ctx.root.moveOutWithDefaultAction(isBackward, event);
            }
          }
        };
        this._onChanged = (element2, details) => {
          var _a2, _b;
          if (element2) {
            triggerEvent(element2, FocusInEventName, details);
          } else {
            const last = (_a2 = this._lastVal) === null || _a2 === void 0 ? void 0 : _a2.get();
            if (last) {
              const d2 = {
                ...details
              };
              const lastCtx = RootAPI.getTabsterContext(this._tabster, last);
              const modalizerId = (_b = lastCtx === null || lastCtx === void 0 ? void 0 : lastCtx.modalizer) === null || _b === void 0 ? void 0 : _b.userId;
              if (modalizerId) {
                d2.modalizerId = modalizerId;
              }
              triggerEvent(last, FocusOutEventName, d2);
            }
          }
        };
        this._tabster = tabster;
        this._win = getWindow2;
        tabster.queueInit(this._init);
      }
      dispose() {
        super.dispose();
        const win = this._win();
        win.document.removeEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);
        win.document.removeEventListener("focusout", this._onFocusOut, true);
        win.removeEventListener("keydown", this._onKeyDown, true);
        this.unsubscribe(this._onChanged);
        delete FocusedElementState._lastResetElement;
        delete this._nextVal;
        delete this._lastVal;
      }
      static forgetMemorized(instance, parent) {
        var _a2, _b;
        let wel = FocusedElementState._lastResetElement;
        let el = wel && wel.get();
        if (el && parent.contains(el)) {
          delete FocusedElementState._lastResetElement;
        }
        el = (_b = (_a2 = instance._nextVal) === null || _a2 === void 0 ? void 0 : _a2.element) === null || _b === void 0 ? void 0 : _b.get();
        if (el && parent.contains(el)) {
          delete instance._nextVal;
        }
        wel = instance._lastVal;
        el = wel && wel.get();
        if (el && parent.contains(el)) {
          delete instance._lastVal;
        }
      }
      getFocusedElement() {
        return this.getVal();
      }
      getLastFocusedElement() {
        var _a2;
        let el = (_a2 = this._lastVal) === null || _a2 === void 0 ? void 0 : _a2.get();
        if (!el || el && !documentContains(el.ownerDocument, el)) {
          this._lastVal = el = void 0;
        }
        return el;
      }
      focus(element2, noFocusedProgrammaticallyFlag, noAccessibleCheck) {
        if (!this._tabster.focusable.isFocusable(element2, noFocusedProgrammaticallyFlag, false, noAccessibleCheck)) {
          return false;
        }
        element2.focus();
        return true;
      }
      focusDefault(container) {
        const el = this._tabster.focusable.findDefault({
          container
        });
        if (el) {
          this._tabster.focusedElement.focus(el);
          return true;
        }
        return false;
      }
      getFirstOrLastTabbable(isFirst, props) {
        var _a2;
        const {
          container,
          ignoreAccessibility
        } = props;
        let toFocus;
        if (container) {
          const ctx = RootAPI.getTabsterContext(this._tabster, container);
          if (ctx) {
            toFocus = (_a2 = FocusedElementState.findNextTabbable(this._tabster, ctx, container, void 0, void 0, !isFirst, ignoreAccessibility)) === null || _a2 === void 0 ? void 0 : _a2.element;
          }
        }
        if (toFocus && !(container === null || container === void 0 ? void 0 : container.contains(toFocus))) {
          toFocus = void 0;
        }
        return toFocus || void 0;
      }
      _focusFirstOrLast(isFirst, props) {
        const toFocus = this.getFirstOrLastTabbable(isFirst, props);
        if (toFocus) {
          this.focus(toFocus, false, true);
          return true;
        }
        return false;
      }
      focusFirst(props) {
        return this._focusFirstOrLast(true, props);
      }
      focusLast(props) {
        return this._focusFirstOrLast(false, props);
      }
      resetFocus(container) {
        if (!this._tabster.focusable.isVisible(container)) {
          return false;
        }
        if (!this._tabster.focusable.isFocusable(container, true, true, true)) {
          const prevTabIndex = container.getAttribute("tabindex");
          const prevAriaHidden = container.getAttribute("aria-hidden");
          container.tabIndex = -1;
          container.setAttribute("aria-hidden", "true");
          FocusedElementState._lastResetElement = new WeakHTMLElement(this._win, container);
          this.focus(container, true, true);
          this._setOrRemoveAttribute(container, "tabindex", prevTabIndex);
          this._setOrRemoveAttribute(container, "aria-hidden", prevAriaHidden);
        } else {
          this.focus(container);
        }
        return true;
      }
      _setOrRemoveAttribute(element2, name2, value) {
        if (value === null) {
          element2.removeAttribute(name2);
        } else {
          element2.setAttribute(name2, value);
        }
      }
      _setFocusedElement(element2, relatedTarget, isFocusedProgrammatically) {
        var _a2, _b;
        if (this._tabster._noop) {
          return;
        }
        const details = {
          relatedTarget
        };
        if (element2) {
          const lastResetElement = (_a2 = FocusedElementState._lastResetElement) === null || _a2 === void 0 ? void 0 : _a2.get();
          FocusedElementState._lastResetElement = void 0;
          if (lastResetElement === element2 || shouldIgnoreFocus(element2)) {
            return;
          }
          details.isFocusedProgrammatically = isFocusedProgrammatically;
          const ctx = RootAPI.getTabsterContext(this._tabster, element2);
          const modalizerId = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer) === null || _b === void 0 ? void 0 : _b.userId;
          if (modalizerId) {
            details.modalizerId = modalizerId;
          }
        }
        const nextVal = this._nextVal = {
          element: element2 ? new WeakHTMLElement(this._win, element2) : void 0,
          details
        };
        if (element2 && element2 !== this._val) {
          this._validateFocusedElement(element2);
        }
        if (this._nextVal === nextVal) {
          this.setVal(element2, details);
        }
        this._nextVal = void 0;
      }
      setVal(val, details) {
        super.setVal(val, details);
        if (val) {
          this._lastVal = new WeakHTMLElement(this._win, val);
        }
      }
      static findNextTabbable(tabster, ctx, container, currentElement, referenceElement, isBackward, ignoreAccessibility) {
        const actualContainer = container || ctx.root.getElement();
        if (!actualContainer) {
          return null;
        }
        let next2 = null;
        const isTabbingTimer = FocusedElementState._isTabbingTimer;
        const win = tabster.getWindow();
        if (isTabbingTimer) {
          win.clearTimeout(isTabbingTimer);
        }
        FocusedElementState.isTabbing = true;
        FocusedElementState._isTabbingTimer = win.setTimeout(() => {
          delete FocusedElementState._isTabbingTimer;
          FocusedElementState.isTabbing = false;
        }, 0);
        const modalizer = ctx.modalizer;
        const groupper = ctx.groupper;
        const mover = ctx.mover;
        const callFindNext = (what) => {
          var _a2;
          next2 = what.findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility);
          if (currentElement && !(next2 === null || next2 === void 0 ? void 0 : next2.element)) {
            const parentElement = what !== modalizer && ((_a2 = what.getElement()) === null || _a2 === void 0 ? void 0 : _a2.parentElement);
            if (parentElement) {
              const parentCtx = RootAPI.getTabsterContext(tabster, currentElement, {
                referenceElement: parentElement
              });
              if (parentCtx) {
                const currentScopeElement = what.getElement();
                const newCurrent = isBackward ? currentScopeElement : currentScopeElement && getLastChild(currentScopeElement) || currentScopeElement;
                if (newCurrent) {
                  next2 = FocusedElementState.findNextTabbable(tabster, parentCtx, container, newCurrent, parentElement, isBackward, ignoreAccessibility);
                  if (next2) {
                    next2.outOfDOMOrder = true;
                  }
                }
              }
            }
          }
        };
        if (groupper && mover) {
          callFindNext(ctx.groupperBeforeMover ? groupper : mover);
        } else if (groupper) {
          callFindNext(groupper);
        } else if (mover) {
          callFindNext(mover);
        } else if (modalizer) {
          callFindNext(modalizer);
        } else {
          const findProps = {
            container: actualContainer,
            currentElement,
            referenceElement,
            ignoreAccessibility,
            useActiveModalizer: true
          };
          const findPropsOut = {};
          const nextElement = tabster.focusable[isBackward ? "findPrev" : "findNext"](findProps, findPropsOut);
          next2 = {
            element: nextElement,
            outOfDOMOrder: findPropsOut.outOfDOMOrder,
            uncontrolled: findPropsOut.uncontrolled
          };
        }
        return next2;
      }
    }
    FocusedElementState.isTabbing = false;
    /*!
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    class KeyboardNavigationState extends Subscribable$1 {
      constructor(getWindow2) {
        super();
        this._onChange = (isNavigatingWithKeyboard) => {
          this.setVal(isNavigatingWithKeyboard, void 0);
        };
        this._keyborg = createKeyborg(getWindow2());
        this._keyborg.subscribe(this._onChange);
      }
      dispose() {
        super.dispose();
        if (this._keyborg) {
          this._keyborg.unsubscribe(this._onChange);
          disposeKeyborg(this._keyborg);
          delete this._keyborg;
        }
      }
      setNavigatingWithKeyboard(isNavigatingWithKeyboard) {
        var _a2;
        (_a2 = this._keyborg) === null || _a2 === void 0 ? void 0 : _a2.setVal(isNavigatingWithKeyboard);
      }
      isNavigatingWithKeyboard() {
        var _a2;
        return !!((_a2 = this._keyborg) === null || _a2 === void 0 ? void 0 : _a2.isNavigatingWithKeyboard());
      }
    }
    /*!
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    let _wasFocusedCounter = 0;
    const _ariaHidden = "aria-hidden";
    class ModalizerDummyManager extends DummyInputManager {
      constructor(element2, tabster, sys) {
        super(tabster, element2, DummyInputManagerPriorities.Modalizer, sys);
        this._setHandlers((dummyInput, isBackward) => {
          var _a2, _b, _c;
          const el = element2.get();
          const container = el && ((_a2 = RootAPI.getRoot(tabster, el)) === null || _a2 === void 0 ? void 0 : _a2.getElement());
          const input = dummyInput.input;
          let toFocus;
          if (container && input) {
            const dummyContainer = (_b = input.__tabsterDummyContainer) === null || _b === void 0 ? void 0 : _b.get();
            const ctx = RootAPI.getTabsterContext(tabster, dummyContainer || input);
            if (ctx) {
              toFocus = (_c = FocusedElementState.findNextTabbable(tabster, ctx, container, input, void 0, isBackward, true)) === null || _c === void 0 ? void 0 : _c.element;
            }
            if (toFocus) {
              nativeFocus(toFocus);
            }
          }
        });
      }
    }
    class Modalizer extends TabsterPart {
      constructor(tabster, element2, onDispose, props, sys, activeElements) {
        super(tabster, element2, props);
        this._wasFocused = 0;
        this.userId = props.id;
        this._onDispose = onDispose;
        this._activeElements = activeElements;
        if (!tabster.controlTab) {
          this.dummyManager = new ModalizerDummyManager(this._element, tabster, sys);
        }
      }
      makeActive(isActive) {
        if (this._isActive !== isActive) {
          this._isActive = isActive;
          const element2 = this.getElement();
          if (element2) {
            const activeElements = this._activeElements;
            const index2 = activeElements.map((e2) => e2.get()).indexOf(element2);
            if (isActive) {
              if (index2 < 0) {
                activeElements.push(new WeakHTMLElement(this._tabster.getWindow, element2));
              }
            } else {
              if (index2 >= 0) {
                activeElements.splice(index2, 1);
              }
            }
          }
          this.triggerFocusEvent(isActive ? ModalizerActiveEventName : ModalizerInactiveEventName);
        }
      }
      focused(noIncrement) {
        if (!noIncrement) {
          this._wasFocused = ++_wasFocusedCounter;
        }
        return this._wasFocused;
      }
      setProps(props) {
        if (props.id) {
          this.userId = props.id;
        }
        this._props = {
          ...props
        };
      }
      dispose() {
        var _a2;
        this.makeActive(false);
        this._onDispose(this);
        (_a2 = this.dummyManager) === null || _a2 === void 0 ? void 0 : _a2.dispose();
        delete this.dummyManager;
        this._activeElements = [];
        this._remove();
      }
      isActive() {
        return !!this._isActive;
      }
      contains(element2) {
        var _a2;
        return !!((_a2 = this.getElement()) === null || _a2 === void 0 ? void 0 : _a2.contains(element2));
      }
      findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility) {
        var _a2, _b;
        const modalizerElement = this.getElement();
        if (!modalizerElement) {
          return null;
        }
        const tabster = this._tabster;
        let next2 = null;
        let outOfDOMOrder = false;
        let uncontrolled;
        const container = currentElement && ((_a2 = RootAPI.getRoot(tabster, currentElement)) === null || _a2 === void 0 ? void 0 : _a2.getElement());
        if (container) {
          const findProps = {
            container,
            currentElement,
            referenceElement,
            ignoreAccessibility,
            useActiveModalizer: true
          };
          const findPropsOut = {};
          next2 = tabster.focusable[isBackward ? "findPrev" : "findNext"](findProps, findPropsOut);
          if (!next2 && this._props.isTrapped && ((_b = tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {
            next2 = tabster.focusable[isBackward ? "findLast" : "findFirst"]({
              container,
              ignoreAccessibility,
              useActiveModalizer: true
            }, findPropsOut);
            outOfDOMOrder = true;
          } else {
            outOfDOMOrder = !!findPropsOut.outOfDOMOrder;
          }
          uncontrolled = findPropsOut.uncontrolled;
        }
        return {
          element: next2,
          uncontrolled,
          outOfDOMOrder
        };
      }
      triggerFocusEvent(eventName, allElements) {
        const element2 = this.getElement();
        let defaultPrevented = false;
        if (element2) {
          const elements = allElements ? this._activeElements.map((e2) => e2.get()) : [element2];
          for (const el of elements) {
            if (el && !triggerEvent(el, eventName, {
              id: this.userId,
              element: element2,
              eventName
            })) {
              defaultPrevented = true;
            }
          }
        }
        return defaultPrevented;
      }
      _remove() {
      }
    }
    class ModalizerAPI {
      constructor(tabster, alwaysAccessibleSelector, accessibleCheck) {
        this._onModalizerDispose = (modalizer) => {
          const id2 = modalizer.id;
          const userId = modalizer.userId;
          const part = this._parts[userId];
          delete this._modalizers[id2];
          if (part) {
            delete part[id2];
            if (Object.keys(part).length === 0) {
              delete this._parts[userId];
              if (this.activeId === userId) {
                this.setActive(void 0);
              }
            }
          }
        };
        this._onKeyDown = (event) => {
          var _a2;
          if (event.keyCode !== Keys.Esc) {
            return;
          }
          const tabster2 = this._tabster;
          const element2 = tabster2.focusedElement.getFocusedElement();
          if (element2) {
            const ctx = RootAPI.getTabsterContext(tabster2, element2);
            const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;
            if (ctx && !ctx.groupper && (modalizer === null || modalizer === void 0 ? void 0 : modalizer.isActive()) && !ctx.ignoreKeydown(event)) {
              const activeId = modalizer.userId;
              if (activeId) {
                const part = this._parts[activeId];
                if (part) {
                  const focusedSince = Object.keys(part).map((id2) => {
                    var _a3;
                    const m2 = part[id2];
                    const el = m2.getElement();
                    let groupper;
                    if (el) {
                      groupper = (_a3 = getTabsterOnElement(this._tabster, el)) === null || _a3 === void 0 ? void 0 : _a3.groupper;
                    }
                    return m2 && el && groupper ? {
                      el,
                      focusedSince: m2.focused(true)
                    } : {
                      focusedSince: 0
                    };
                  }).filter((f2) => f2.focusedSince > 0).sort((a2, b2) => a2.focusedSince > b2.focusedSince ? -1 : a2.focusedSince < b2.focusedSince ? 1 : 0);
                  if (focusedSince.length) {
                    const groupperElement = focusedSince[0].el;
                    if (groupperElement) {
                      (_a2 = tabster2.groupper) === null || _a2 === void 0 ? void 0 : _a2.handleKeyPress(groupperElement, event, true);
                    }
                  }
                }
              }
            }
          }
        };
        this._onFocus = (focusedElement, details) => {
          var _a2, _b;
          const ctx = focusedElement && RootAPI.getTabsterContext(this._tabster, focusedElement);
          if (!ctx || !focusedElement) {
            return;
          }
          const augmentedMap = this._augMap;
          for (let e2 = focusedElement; e2; e2 = e2.parentElement) {
            if (augmentedMap.has(e2)) {
              augmentedMap.delete(e2);
              augmentAttribute(this._tabster, e2, _ariaHidden);
            }
          }
          const modalizer = ctx.modalizer;
          (_b = modalizer || ((_a2 = getTabsterOnElement(this._tabster, focusedElement)) === null || _a2 === void 0 ? void 0 : _a2.modalizer)) === null || _b === void 0 ? void 0 : _b.focused();
          if ((modalizer === null || modalizer === void 0 ? void 0 : modalizer.userId) === this.activeId) {
            this.currentIsOthersAccessible = modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isOthersAccessible;
            return;
          }
          if (details.isFocusedProgrammatically || this.currentIsOthersAccessible || (modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isAlwaysAccessible)) {
            this.setActive(modalizer);
          } else {
            const win2 = this._win();
            win2.clearTimeout(this._restoreModalizerFocusTimer);
            this._restoreModalizerFocusTimer = win2.setTimeout(() => this._restoreModalizerFocus(focusedElement), 100);
          }
        };
        this._tabster = tabster;
        this._win = tabster.getWindow;
        this._modalizers = {};
        this._parts = {};
        this._augMap = /* @__PURE__ */ new WeakMap();
        this._aug = [];
        this._alwaysAccessibleSelector = alwaysAccessibleSelector;
        this._accessibleCheck = accessibleCheck;
        this.activeElements = [];
        if (!tabster.controlTab) {
          tabster.root.addDummyInputs();
        }
        const win = this._win();
        win.addEventListener("keydown", this._onKeyDown, true);
        tabster.queueInit(() => {
          this._tabster.focusedElement.subscribe(this._onFocus);
        });
      }
      dispose() {
        const win = this._win();
        win.removeEventListener("keydown", this._onKeyDown, true);
        Object.keys(this._modalizers).forEach((modalizerId) => {
          if (this._modalizers[modalizerId]) {
            this._modalizers[modalizerId].dispose();
            delete this._modalizers[modalizerId];
          }
        });
        win.clearTimeout(this._restoreModalizerFocusTimer);
        win.clearTimeout(this._hiddenUpdateTimer);
        this._parts = {};
        delete this.activeId;
        this.activeElements = [];
        this._augMap = /* @__PURE__ */ new WeakMap();
        this._aug = [];
        this._tabster.focusedElement.unsubscribe(this._onFocus);
      }
      createModalizer(element2, props, sys) {
        var _a2;
        const modalizer = new Modalizer(this._tabster, element2, this._onModalizerDispose, props, sys, this.activeElements);
        const id2 = modalizer.id;
        const userId = props.id;
        this._modalizers[id2] = modalizer;
        let part = this._parts[userId];
        if (!part) {
          part = this._parts[userId] = {};
        }
        part[id2] = modalizer;
        if (element2.contains((_a2 = this._tabster.focusedElement.getFocusedElement()) !== null && _a2 !== void 0 ? _a2 : null)) {
          if (userId !== this.activeId) {
            this.setActive(modalizer);
          } else {
            modalizer.makeActive(true);
          }
        }
        return modalizer;
      }
      isAugmented(element2) {
        return this._augMap.has(element2);
      }
      hiddenUpdate() {
        if (this._hiddenUpdateTimer) {
          return;
        }
        this._hiddenUpdateTimer = this._win().setTimeout(() => {
          delete this._hiddenUpdateTimer;
          this._hiddenUpdate();
        }, 250);
      }
      setActive(modalizer) {
        const userId = modalizer === null || modalizer === void 0 ? void 0 : modalizer.userId;
        const activeId = this.activeId;
        if (activeId === userId) {
          return;
        }
        this.activeId = userId;
        if (activeId) {
          const part = this._parts[activeId];
          if (part) {
            for (const id2 of Object.keys(part)) {
              part[id2].makeActive(false);
            }
          }
        }
        if (userId) {
          const part = this._parts[userId];
          if (part) {
            for (const id2 of Object.keys(part)) {
              part[id2].makeActive(true);
            }
          }
        }
        this.currentIsOthersAccessible = modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isOthersAccessible;
        this.hiddenUpdate();
      }
      focus(elementFromModalizer, noFocusFirst, noFocusDefault) {
        const ctx = RootAPI.getTabsterContext(this._tabster, elementFromModalizer);
        const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;
        if (modalizer) {
          this.setActive(modalizer);
          const props = modalizer.getProps();
          const modalizerRoot = modalizer.getElement();
          if (modalizerRoot) {
            if (noFocusFirst === void 0) {
              noFocusFirst = props.isNoFocusFirst;
            }
            if (!noFocusFirst && this._tabster.keyboardNavigation.isNavigatingWithKeyboard() && this._tabster.focusedElement.focusFirst({
              container: modalizerRoot
            })) {
              return true;
            }
            if (noFocusDefault === void 0) {
              noFocusDefault = props.isNoFocusDefault;
            }
            if (!noFocusDefault && this._tabster.focusedElement.focusDefault(modalizerRoot)) {
              return true;
            }
            this._tabster.focusedElement.resetFocus(modalizerRoot);
          }
        }
        return false;
      }
      acceptElement(element2, state) {
        var _a2;
        const modalizerUserId = state.modalizerUserId;
        const currentModalizer = (_a2 = state.currentCtx) === null || _a2 === void 0 ? void 0 : _a2.modalizer;
        if (modalizerUserId) {
          for (const e2 of this.activeElements) {
            const el = e2.get();
            if (el && (element2.contains(el) || el === element2)) {
              return NodeFilter.FILTER_SKIP;
            }
          }
        }
        const ret = modalizerUserId === (currentModalizer === null || currentModalizer === void 0 ? void 0 : currentModalizer.userId) || !modalizerUserId && (currentModalizer === null || currentModalizer === void 0 ? void 0 : currentModalizer.getProps().isAlwaysAccessible) ? void 0 : NodeFilter.FILTER_SKIP;
        if (ret !== void 0) {
          state.skippedFocusable = true;
        }
        return ret;
      }
      _hiddenUpdate() {
        var _a2;
        const tabster = this._tabster;
        const body = tabster.getWindow().document.body;
        const activeId = this.activeId;
        const parts = this._parts;
        const visibleElements = [];
        const hiddenElements = [];
        const alwaysAccessibleSelector = this._alwaysAccessibleSelector;
        const alwaysAccessibleElements = alwaysAccessibleSelector ? Array.from(body.querySelectorAll(alwaysAccessibleSelector)) : [];
        const activeModalizerElements = [];
        for (const userId of Object.keys(parts)) {
          const modalizerParts = parts[userId];
          for (const id2 of Object.keys(modalizerParts)) {
            const modalizer = modalizerParts[id2];
            const el = modalizer.getElement();
            const props = modalizer.getProps();
            const isAlwaysAccessible = props.isAlwaysAccessible;
            if (el) {
              if (userId === activeId) {
                activeModalizerElements.push(el);
                if (!this.currentIsOthersAccessible) {
                  visibleElements.push(el);
                }
              } else if (isAlwaysAccessible) {
                alwaysAccessibleElements.push(el);
              } else {
                hiddenElements.push(el);
              }
            }
          }
        }
        const augmentedMap = this._augMap;
        const allVisibleElements = visibleElements.length > 0 ? [...visibleElements, ...alwaysAccessibleElements] : void 0;
        const newAugmented = [];
        const newAugmentedMap = /* @__PURE__ */ new WeakMap();
        const toggle = (element2, hide) => {
          var _a3;
          const tagName = element2.tagName;
          if (tagName === "SCRIPT" || tagName === "STYLE") {
            return;
          }
          let isAugmented = false;
          if (augmentedMap.has(element2)) {
            if (hide) {
              isAugmented = true;
            } else {
              augmentedMap.delete(element2);
              augmentAttribute(tabster, element2, _ariaHidden);
            }
          } else if (hide && !((_a3 = this._accessibleCheck) === null || _a3 === void 0 ? void 0 : _a3.call(this, element2, activeModalizerElements)) && augmentAttribute(tabster, element2, _ariaHidden, "true")) {
            augmentedMap.set(element2, true);
            isAugmented = true;
          }
          if (isAugmented) {
            newAugmented.push(new WeakHTMLElement(tabster.getWindow, element2));
            newAugmentedMap.set(element2, true);
          }
        };
        const walk = (element2) => {
          for (let el = element2.firstElementChild; el; el = el.nextElementSibling) {
            let skip = false;
            let containsModalizer = false;
            if (allVisibleElements) {
              for (const c2 of allVisibleElements) {
                if (el === c2) {
                  skip = true;
                  break;
                }
                if (el.contains(c2)) {
                  containsModalizer = true;
                  break;
                }
              }
              if (containsModalizer) {
                walk(el);
              } else if (!skip) {
                toggle(el, true);
              }
            } else {
              toggle(el, false);
            }
          }
        };
        if (!allVisibleElements) {
          alwaysAccessibleElements.forEach((e2) => toggle(e2, false));
        }
        hiddenElements.forEach((e2) => toggle(e2, true));
        if (body) {
          walk(body);
        }
        (_a2 = this._aug) === null || _a2 === void 0 ? void 0 : _a2.map((e2) => e2.get()).forEach((e2) => {
          if (e2 && !newAugmentedMap.get(e2)) {
            toggle(e2, false);
          }
        });
        this._aug = newAugmented;
        this._augMap = newAugmentedMap;
      }
      /**
       * Called when an element is focused outside of an active modalizer.
       * Attempts to pull focus back into the active modalizer
       * @param outsideElement - An element being focused outside of the modalizer
       */
      _restoreModalizerFocus(outsideElement) {
        const ownerDocument = outsideElement === null || outsideElement === void 0 ? void 0 : outsideElement.ownerDocument;
        if (!outsideElement || !ownerDocument) {
          return;
        }
        const ctx = RootAPI.getTabsterContext(this._tabster, outsideElement);
        const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;
        const activeId = this.activeId;
        if (!modalizer && !activeId || modalizer && activeId === modalizer.userId) {
          return;
        }
        const container = ctx === null || ctx === void 0 ? void 0 : ctx.root.getElement();
        if (container) {
          let toFocus = this._tabster.focusable.findFirst({
            container,
            useActiveModalizer: true
          });
          if (toFocus) {
            if (outsideElement.compareDocumentPosition(toFocus) & document.DOCUMENT_POSITION_PRECEDING) {
              toFocus = this._tabster.focusable.findLast({
                container,
                useActiveModalizer: true
              });
              if (!toFocus) {
                throw new Error("Something went wrong.");
              }
            }
            this._tabster.focusedElement.focus(toFocus);
            return;
          }
        }
        outsideElement.blur();
      }
    }
    /*!
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    const _inputSelector = /* @__PURE__ */ ["input", "textarea", "*[contenteditable]"].join(", ");
    class MoverDummyManager extends DummyInputManager {
      constructor(element2, tabster, getMemorized, sys) {
        super(tabster, element2, DummyInputManagerPriorities.Mover, sys);
        this._onFocusDummyInput = (dummyInput) => {
          var _a2, _b;
          const container = this._element.get();
          const input = dummyInput.input;
          if (container && input) {
            const ctx = RootAPI.getTabsterContext(this._tabster, container);
            let toFocus;
            if (ctx) {
              toFocus = (_a2 = FocusedElementState.findNextTabbable(this._tabster, ctx, void 0, input, void 0, !dummyInput.isFirst, true)) === null || _a2 === void 0 ? void 0 : _a2.element;
            }
            const memorized = (_b = this._getMemorized()) === null || _b === void 0 ? void 0 : _b.get();
            if (memorized) {
              toFocus = memorized;
            }
            if (toFocus) {
              nativeFocus(toFocus);
            }
          }
        };
        this._tabster = tabster;
        this._getMemorized = getMemorized;
        this._setHandlers(this._onFocusDummyInput);
      }
    }
    const _moverUpdateAdd = 1;
    const _moverUpdateAttr = 2;
    const _moverUpdateRemove = 3;
    class Mover extends TabsterPart {
      constructor(tabster, element2, onDispose, props, sys) {
        var _a2;
        super(tabster, element2, props);
        this._visible = {};
        this._onIntersection = (entries) => {
          for (const entry of entries) {
            const el = entry.target;
            const id2 = getElementUId(this._win, el);
            let newVisibility;
            let fullyVisible = this._fullyVisible;
            if (entry.intersectionRatio >= 0.25) {
              newVisibility = entry.intersectionRatio >= 0.75 ? Visibilities.Visible : Visibilities.PartiallyVisible;
              if (newVisibility === Visibilities.Visible) {
                fullyVisible = id2;
              }
            } else {
              newVisibility = Visibilities.Invisible;
            }
            if (this._visible[id2] !== newVisibility) {
              if (newVisibility === void 0) {
                delete this._visible[id2];
                if (fullyVisible === id2) {
                  delete this._fullyVisible;
                }
              } else {
                this._visible[id2] = newVisibility;
                this._fullyVisible = fullyVisible;
              }
              const state = this.getState(el);
              if (state) {
                triggerEvent(el, MoverEventName, state);
              }
            }
          }
        };
        this._win = tabster.getWindow;
        this.visibilityTolerance = (_a2 = props.visibilityTolerance) !== null && _a2 !== void 0 ? _a2 : 0.8;
        if (this._props.trackState || this._props.visibilityAware) {
          this._intersectionObserver = new IntersectionObserver(this._onIntersection, {
            threshold: [0, 0.25, 0.5, 0.75, 1]
          });
          this._observeState();
        }
        this._onDispose = onDispose;
        const getMemorized = () => props.memorizeCurrent ? this._current : void 0;
        if (!tabster.controlTab) {
          this.dummyManager = new MoverDummyManager(this._element, tabster, getMemorized, sys);
        }
      }
      dispose() {
        var _a2;
        this._onDispose(this);
        if (this._intersectionObserver) {
          this._intersectionObserver.disconnect();
          delete this._intersectionObserver;
        }
        delete this._current;
        delete this._fullyVisible;
        delete this._allElements;
        delete this._updateQueue;
        if (this._unobserve) {
          this._unobserve();
          delete this._unobserve;
        }
        const win = this._win();
        if (this._setCurrentTimer) {
          win.clearTimeout(this._setCurrentTimer);
          delete this._setCurrentTimer;
        }
        if (this._updateTimer) {
          win.clearTimeout(this._updateTimer);
          delete this._updateTimer;
        }
        (_a2 = this.dummyManager) === null || _a2 === void 0 ? void 0 : _a2.dispose();
        delete this.dummyManager;
      }
      setCurrent(element2) {
        if (element2) {
          this._current = new WeakHTMLElement(this._win, element2);
        } else {
          this._current = void 0;
        }
        if ((this._props.trackState || this._props.visibilityAware) && !this._setCurrentTimer) {
          this._setCurrentTimer = this._win().setTimeout(() => {
            var _a2;
            delete this._setCurrentTimer;
            const changed = [];
            if (this._current !== this._prevCurrent) {
              changed.push(this._current);
              changed.push(this._prevCurrent);
              this._prevCurrent = this._current;
            }
            for (const weak of changed) {
              const el = weak === null || weak === void 0 ? void 0 : weak.get();
              if (el && ((_a2 = this._allElements) === null || _a2 === void 0 ? void 0 : _a2.get(el)) === this) {
                const props = this._props;
                if (el && (props.visibilityAware !== void 0 || props.trackState)) {
                  const state = this.getState(el);
                  if (state) {
                    triggerEvent(el, MoverEventName, state);
                  }
                }
              }
            }
          });
        }
      }
      getCurrent() {
        var _a2;
        return ((_a2 = this._current) === null || _a2 === void 0 ? void 0 : _a2.get()) || null;
      }
      findNextTabbable(currentElement, referenceElement, isBackward, ignoreAccessibility) {
        var _a2;
        const container = this.getElement();
        const currentIsDummy = container && ((_a2 = currentElement === null || currentElement === void 0 ? void 0 : currentElement.__tabsterDummyContainer) === null || _a2 === void 0 ? void 0 : _a2.get()) === container;
        if (!container) {
          return null;
        }
        let next2 = null;
        let outOfDOMOrder = false;
        let uncontrolled;
        if (this._props.tabbable || currentIsDummy || currentElement && !container.contains(currentElement)) {
          const findProps = {
            currentElement,
            referenceElement,
            container,
            ignoreAccessibility,
            useActiveModalizer: true
          };
          const findPropsOut = {};
          next2 = this._tabster.focusable[isBackward ? "findPrev" : "findNext"](findProps, findPropsOut);
          outOfDOMOrder = !!findPropsOut.outOfDOMOrder;
          uncontrolled = findPropsOut.uncontrolled;
        }
        return {
          element: next2,
          uncontrolled,
          outOfDOMOrder
        };
      }
      acceptElement(element2, state) {
        var _a2, _b, _c;
        if (!FocusedElementState.isTabbing) {
          return ((_a2 = state.currentCtx) === null || _a2 === void 0 ? void 0 : _a2.excludedFromMover) ? NodeFilter.FILTER_REJECT : void 0;
        }
        const {
          memorizeCurrent,
          visibilityAware,
          hasDefault = true
        } = this._props;
        const moverElement = this.getElement();
        if (moverElement && (memorizeCurrent || visibilityAware || hasDefault) && (!moverElement.contains(state.from) || ((_b = state.from.__tabsterDummyContainer) === null || _b === void 0 ? void 0 : _b.get()) === moverElement)) {
          let found;
          if (memorizeCurrent) {
            const current = (_c = this._current) === null || _c === void 0 ? void 0 : _c.get();
            if (current && state.acceptCondition(current)) {
              found = current;
            }
          }
          if (!found && hasDefault) {
            found = this._tabster.focusable.findDefault({
              container: moverElement,
              useActiveModalizer: true
            });
          }
          if (!found && visibilityAware) {
            found = this._tabster.focusable.findElement({
              container: moverElement,
              useActiveModalizer: true,
              isBackward: state.isBackward,
              acceptCondition: (el) => {
                var _a3;
                const id2 = getElementUId(this._win, el);
                const visibility = this._visible[id2];
                return moverElement !== el && !!((_a3 = this._allElements) === null || _a3 === void 0 ? void 0 : _a3.get(el)) && state.acceptCondition(el) && (visibility === Visibilities.Visible || visibility === Visibilities.PartiallyVisible && (visibilityAware === Visibilities.PartiallyVisible || !this._fullyVisible));
              }
            });
          }
          if (found) {
            state.found = true;
            state.foundElement = found;
            state.rejectElementsFrom = moverElement;
            state.skippedFocusable = true;
            return NodeFilter.FILTER_ACCEPT;
          }
        }
        return void 0;
      }
      _observeState() {
        const element2 = this.getElement();
        if (this._unobserve || !element2 || typeof MutationObserver === "undefined") {
          return;
        }
        const win = this._win();
        const allElements = this._allElements = /* @__PURE__ */ new WeakMap();
        const tabsterFocusable = this._tabster.focusable;
        let updateQueue = this._updateQueue = [];
        const observer = new MutationObserver((mutations) => {
          for (const mutation of mutations) {
            const target = mutation.target;
            const removed = mutation.removedNodes;
            const added = mutation.addedNodes;
            if (mutation.type === "attributes") {
              if (mutation.attributeName === "tabindex") {
                updateQueue.push({
                  element: target,
                  type: _moverUpdateAttr
                });
              }
            } else {
              for (let i2 = 0; i2 < removed.length; i2++) {
                updateQueue.push({
                  element: removed[i2],
                  type: _moverUpdateRemove
                });
              }
              for (let i2 = 0; i2 < added.length; i2++) {
                updateQueue.push({
                  element: added[i2],
                  type: _moverUpdateAdd
                });
              }
            }
          }
          requestUpdate();
        });
        const setElement = (element3, remove) => {
          var _a2, _b;
          const current = allElements.get(element3);
          if (current && remove) {
            (_a2 = this._intersectionObserver) === null || _a2 === void 0 ? void 0 : _a2.unobserve(element3);
            allElements.delete(element3);
          }
          if (!current && !remove) {
            allElements.set(element3, this);
            (_b = this._intersectionObserver) === null || _b === void 0 ? void 0 : _b.observe(element3);
          }
        };
        const updateElement = (element3) => {
          const isFocusable = tabsterFocusable.isFocusable(element3);
          const current = allElements.get(element3);
          if (current) {
            if (!isFocusable) {
              setElement(element3, true);
            }
          } else {
            if (isFocusable) {
              setElement(element3);
            }
          }
        };
        const addNewElements = (element3) => {
          const {
            mover
          } = getMoverGroupper(element3);
          if (mover && mover !== this) {
            if (mover.getElement() === element3 && tabsterFocusable.isFocusable(element3)) {
              setElement(element3);
            } else {
              return;
            }
          }
          const walker = createElementTreeWalker(win.document, element3, (node2) => {
            const {
              mover: mover2,
              groupper
            } = getMoverGroupper(node2);
            if (mover2 && mover2 !== this) {
              return NodeFilter.FILTER_REJECT;
            }
            const groupperFirstFocusable = groupper === null || groupper === void 0 ? void 0 : groupper.getFirst(true);
            if (groupper && groupper.getElement() !== node2 && groupperFirstFocusable && groupperFirstFocusable !== node2) {
              return NodeFilter.FILTER_REJECT;
            }
            if (tabsterFocusable.isFocusable(node2)) {
              setElement(node2);
            }
            return NodeFilter.FILTER_SKIP;
          });
          if (walker) {
            walker.currentNode = element3;
            while (walker.nextNode()) {
            }
          }
        };
        const removeWalk = (element3) => {
          const current = allElements.get(element3);
          if (current) {
            setElement(element3, true);
          }
          for (let el = element3.firstElementChild; el; el = el.nextElementSibling) {
            removeWalk(el);
          }
        };
        const requestUpdate = () => {
          if (!this._updateTimer && updateQueue.length) {
            this._updateTimer = win.setTimeout(() => {
              delete this._updateTimer;
              for (const {
                element: element3,
                type
              } of updateQueue) {
                switch (type) {
                  case _moverUpdateAttr:
                    updateElement(element3);
                    break;
                  case _moverUpdateAdd:
                    addNewElements(element3);
                    break;
                  case _moverUpdateRemove:
                    removeWalk(element3);
                    break;
                }
              }
              updateQueue = this._updateQueue = [];
            }, 0);
          }
        };
        const getMoverGroupper = (element3) => {
          const ret = {};
          for (let el = element3; el; el = el.parentElement) {
            const toe = getTabsterOnElement(this._tabster, el);
            if (toe) {
              if (toe.groupper && !ret.groupper) {
                ret.groupper = toe.groupper;
              }
              if (toe.mover) {
                ret.mover = toe.mover;
                break;
              }
            }
          }
          return ret;
        };
        updateQueue.push({
          element: element2,
          type: _moverUpdateAdd
        });
        requestUpdate();
        observer.observe(element2, {
          childList: true,
          subtree: true,
          attributes: true,
          attributeFilter: ["tabindex"]
        });
        this._unobserve = () => {
          observer.disconnect();
        };
      }
      getState(element2) {
        const id2 = getElementUId(this._win, element2);
        if (id2 in this._visible) {
          const visibility = this._visible[id2] || Visibilities.Invisible;
          const isCurrent = this._current ? this._current.get() === element2 : void 0;
          return {
            isCurrent,
            visibility
          };
        }
        return void 0;
      }
    }
    function getDistance(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {
      const xDistance = ax2 < bx1 ? bx1 - ax2 : bx2 < ax1 ? ax1 - bx2 : 0;
      const yDistance = ay2 < by1 ? by1 - ay2 : by2 < ay1 ? ay1 - by2 : 0;
      return xDistance === 0 ? yDistance : yDistance === 0 ? xDistance : Math.sqrt(xDistance * xDistance + yDistance * yDistance);
    }
    class MoverAPI {
      constructor(tabster, getWindow2) {
        this._init = () => {
          const win = this._win();
          win.addEventListener("keydown", this._onKeyDown, true);
          this._tabster.focusedElement.subscribe(this._onFocus);
        };
        this._onMoverDispose = (mover) => {
          delete this._movers[mover.id];
        };
        this._onFocus = (element2) => {
          var _a2;
          let currentFocusableElement = element2;
          let deepestFocusableElement = element2;
          for (let el = element2 === null || element2 === void 0 ? void 0 : element2.parentElement; el; el = el.parentElement) {
            const mover = (_a2 = getTabsterOnElement(this._tabster, el)) === null || _a2 === void 0 ? void 0 : _a2.mover;
            if (mover) {
              mover.setCurrent(deepestFocusableElement);
              currentFocusableElement = void 0;
            }
            if (!currentFocusableElement && this._tabster.focusable.isFocusable(el)) {
              currentFocusableElement = deepestFocusableElement = el;
            }
          }
        };
        this._onKeyDown = async (event) => {
          var _a2, _b, _c, _d;
          if (this._ignoredInputTimer) {
            this._win().clearTimeout(this._ignoredInputTimer);
            delete this._ignoredInputTimer;
          }
          (_a2 = this._ignoredInputResolve) === null || _a2 === void 0 ? void 0 : _a2.call(this, false);
          let keyCode = event.keyCode;
          if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {
            return;
          }
          switch (keyCode) {
            case Keys.Down:
            case Keys.Right:
            case Keys.Up:
            case Keys.Left:
            case Keys.PageDown:
            case Keys.PageUp:
            case Keys.Home:
            case Keys.End:
              break;
            default:
              return;
          }
          const tabster2 = this._tabster;
          const focused = tabster2.focusedElement.getFocusedElement();
          if (!focused || await this._isIgnoredInput(focused, keyCode)) {
            return;
          }
          const ctx = RootAPI.getTabsterContext(tabster2, focused, {
            checkRtl: true
          });
          if (!ctx || !ctx.mover || ctx.excludedFromMover || ctx.ignoreKeydown(event)) {
            return;
          }
          const mover = ctx.mover;
          const container = mover.getElement();
          if (ctx.groupperBeforeMover) {
            const groupper = ctx.groupper;
            if (groupper && !groupper.isActive(true)) {
              for (let el = (_b = groupper.getElement()) === null || _b === void 0 ? void 0 : _b.parentElement; el && el !== container; el = el.parentElement) {
                if ((_d = (_c = getTabsterOnElement(tabster2, el)) === null || _c === void 0 ? void 0 : _c.groupper) === null || _d === void 0 ? void 0 : _d.isActive(true)) {
                  return;
                }
              }
            } else {
              return;
            }
          }
          if (!container) {
            return;
          }
          const focusable = tabster2.focusable;
          const moverProps = mover.getProps();
          const direction = moverProps.direction || MoverDirections.Both;
          const isBoth = direction === MoverDirections.Both;
          const isVertical = isBoth || direction === MoverDirections.Vertical;
          const isHorizontal = isBoth || direction === MoverDirections.Horizontal;
          const isGridLinear = direction === MoverDirections.GridLinear;
          const isGrid = isGridLinear || direction === MoverDirections.Grid;
          const isCyclic = moverProps.cyclic;
          let next2;
          let scrollIntoViewArg;
          let focusedElementRect;
          let focusedElementX1 = 0;
          let focusedElementX2 = 0;
          if (isGrid) {
            focusedElementRect = focused.getBoundingClientRect();
            focusedElementX1 = Math.ceil(focusedElementRect.left);
            focusedElementX2 = Math.floor(focusedElementRect.right);
          }
          if (ctx.rtl) {
            if (keyCode === Keys.Right) {
              keyCode = Keys.Left;
            } else if (keyCode === Keys.Left) {
              keyCode = Keys.Right;
            }
          }
          if (keyCode === Keys.Down && isVertical || keyCode === Keys.Right && (isHorizontal || isGrid)) {
            next2 = focusable.findNext({
              currentElement: focused,
              container,
              useActiveModalizer: true
            });
            if (next2 && isGrid) {
              const nextElementX1 = Math.ceil(next2.getBoundingClientRect().left);
              if (!isGridLinear && focusedElementX2 > nextElementX1) {
                next2 = void 0;
              }
            } else if (!next2 && isCyclic) {
              next2 = focusable.findFirst({
                container,
                useActiveModalizer: true
              });
            }
          } else if (keyCode === Keys.Up && isVertical || keyCode === Keys.Left && (isHorizontal || isGrid)) {
            next2 = focusable.findPrev({
              currentElement: focused,
              container,
              useActiveModalizer: true
            });
            if (next2 && isGrid) {
              const nextElementX2 = Math.floor(next2.getBoundingClientRect().right);
              if (!isGridLinear && nextElementX2 > focusedElementX1) {
                next2 = void 0;
              }
            } else if (!next2 && isCyclic) {
              next2 = focusable.findLast({
                container,
                useActiveModalizer: true
              });
            }
          } else if (keyCode === Keys.Home) {
            if (isGrid) {
              focusable.findElement({
                container,
                currentElement: focused,
                useActiveModalizer: true,
                isBackward: true,
                acceptCondition: (el) => {
                  var _a3;
                  if (!focusable.isFocusable(el)) {
                    return false;
                  }
                  const nextElementX1 = Math.ceil((_a3 = el.getBoundingClientRect().left) !== null && _a3 !== void 0 ? _a3 : 0);
                  if (el !== focused && focusedElementX1 <= nextElementX1) {
                    return true;
                  }
                  next2 = el;
                  return false;
                }
              });
            } else {
              next2 = focusable.findFirst({
                container,
                useActiveModalizer: true
              });
            }
          } else if (keyCode === Keys.End) {
            if (isGrid) {
              focusable.findElement({
                container,
                currentElement: focused,
                useActiveModalizer: true,
                acceptCondition: (el) => {
                  var _a3;
                  if (!focusable.isFocusable(el)) {
                    return false;
                  }
                  const nextElementX1 = Math.ceil((_a3 = el.getBoundingClientRect().left) !== null && _a3 !== void 0 ? _a3 : 0);
                  if (el !== focused && focusedElementX1 >= nextElementX1) {
                    return true;
                  }
                  next2 = el;
                  return false;
                }
              });
            } else {
              next2 = focusable.findLast({
                container,
                useActiveModalizer: true
              });
            }
          } else if (keyCode === Keys.PageUp) {
            focusable.findElement({
              currentElement: focused,
              container,
              useActiveModalizer: true,
              isBackward: true,
              acceptCondition: (el) => {
                if (!focusable.isFocusable(el)) {
                  return false;
                }
                if (isElementVerticallyVisibleInContainer(this._win, el, mover.visibilityTolerance)) {
                  next2 = el;
                  return false;
                }
                return true;
              }
            });
            if (isGrid && next2) {
              const firstColumnX1 = Math.ceil(next2.getBoundingClientRect().left);
              focusable.findElement({
                currentElement: next2,
                container,
                useActiveModalizer: true,
                acceptCondition: (el) => {
                  if (!focusable.isFocusable(el)) {
                    return false;
                  }
                  const nextElementX1 = Math.ceil(el.getBoundingClientRect().left);
                  if (focusedElementX1 < nextElementX1 || firstColumnX1 >= nextElementX1) {
                    return true;
                  }
                  next2 = el;
                  return false;
                }
              });
            }
            scrollIntoViewArg = false;
          } else if (keyCode === Keys.PageDown) {
            focusable.findElement({
              currentElement: focused,
              container,
              useActiveModalizer: true,
              acceptCondition: (el) => {
                if (!focusable.isFocusable(el)) {
                  return false;
                }
                if (isElementVerticallyVisibleInContainer(this._win, el, mover.visibilityTolerance)) {
                  next2 = el;
                  return false;
                }
                return true;
              }
            });
            if (isGrid && next2) {
              const lastColumnX1 = Math.ceil(next2.getBoundingClientRect().left);
              focusable.findElement({
                currentElement: next2,
                container,
                useActiveModalizer: true,
                isBackward: true,
                acceptCondition: (el) => {
                  if (!focusable.isFocusable(el)) {
                    return false;
                  }
                  const nextElementX1 = Math.ceil(el.getBoundingClientRect().left);
                  if (focusedElementX1 > nextElementX1 || lastColumnX1 <= nextElementX1) {
                    return true;
                  }
                  next2 = el;
                  return false;
                }
              });
            }
            scrollIntoViewArg = true;
          } else if (isGrid) {
            const isBackward = keyCode === Keys.Up;
            const ax1 = focusedElementX1;
            const ay1 = Math.ceil(focusedElementRect.top);
            const ax2 = focusedElementX2;
            const ay2 = Math.floor(focusedElementRect.bottom);
            let targetElement;
            let lastDistance;
            let lastIntersection = 0;
            focusable.findAll({
              container,
              currentElement: focused,
              isBackward,
              onElement: (el) => {
                const rect = el.getBoundingClientRect();
                const bx1 = Math.ceil(rect.left);
                const by1 = Math.ceil(rect.top);
                const bx2 = Math.floor(rect.right);
                const by2 = Math.floor(rect.bottom);
                if (isBackward && ay1 < by2 || !isBackward && ay2 > by1) {
                  return true;
                }
                const xIntersectionWidth = Math.ceil(Math.min(ax2, bx2)) - Math.floor(Math.max(ax1, bx1));
                const minWidth = Math.ceil(Math.min(ax2 - ax1, bx2 - bx1));
                if (xIntersectionWidth > 0 && minWidth >= xIntersectionWidth) {
                  const intersection = xIntersectionWidth / minWidth;
                  if (intersection > lastIntersection) {
                    targetElement = el;
                    lastIntersection = intersection;
                  }
                } else if (lastIntersection === 0) {
                  const distance = getDistance(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2);
                  if (lastDistance === void 0 || distance < lastDistance) {
                    lastDistance = distance;
                    targetElement = el;
                  }
                } else if (lastIntersection > 0) {
                  return false;
                }
                return true;
              }
            });
            next2 = targetElement;
          }
          if (next2 && triggerMoveFocusEvent({
            by: "mover",
            owner: container,
            next: next2,
            relatedEvent: event
          })) {
            if (scrollIntoViewArg !== void 0) {
              scrollIntoView(this._win, next2, scrollIntoViewArg);
            }
            event.preventDefault();
            event.stopImmediatePropagation();
            nativeFocus(next2);
          }
        };
        this._tabster = tabster;
        this._win = getWindow2;
        this._movers = {};
        tabster.queueInit(this._init);
      }
      dispose() {
        var _a2;
        const win = this._win();
        this._tabster.focusedElement.unsubscribe(this._onFocus);
        (_a2 = this._ignoredInputResolve) === null || _a2 === void 0 ? void 0 : _a2.call(this, false);
        if (this._ignoredInputTimer) {
          win.clearTimeout(this._ignoredInputTimer);
          delete this._ignoredInputTimer;
        }
        win.removeEventListener("keydown", this._onKeyDown, true);
        Object.keys(this._movers).forEach((moverId) => {
          if (this._movers[moverId]) {
            this._movers[moverId].dispose();
            delete this._movers[moverId];
          }
        });
      }
      createMover(element2, props, sys) {
        const newMover = new Mover(this._tabster, element2, this._onMoverDispose, props, sys);
        this._movers[newMover.id] = newMover;
        return newMover;
      }
      async _isIgnoredInput(element2, keyCode) {
        var _a2;
        if (element2.getAttribute("aria-expanded") === "true" && element2.hasAttribute("aria-activedescendant")) {
          return true;
        }
        if (matchesSelector(element2, _inputSelector)) {
          let selectionStart = 0;
          let selectionEnd = 0;
          let textLength = 0;
          let asyncRet;
          if (element2.tagName === "INPUT" || element2.tagName === "TEXTAREA") {
            const type = element2.type;
            const value = element2.value;
            textLength = (value || "").length;
            if (type === "email" || type === "number") {
              if (textLength) {
                const selection = (_a2 = element2.ownerDocument.defaultView) === null || _a2 === void 0 ? void 0 : _a2.getSelection();
                if (selection) {
                  const initialLength = selection.toString().length;
                  const isBackward = keyCode === Keys.Left || keyCode === Keys.Up;
                  selection.modify("extend", isBackward ? "backward" : "forward", "character");
                  if (initialLength !== selection.toString().length) {
                    selection.modify("extend", isBackward ? "forward" : "backward", "character");
                    return true;
                  } else {
                    textLength = 0;
                  }
                }
              }
            } else {
              const selStart = element2.selectionStart;
              if (selStart === null) {
                return type === "hidden";
              }
              selectionStart = selStart || 0;
              selectionEnd = element2.selectionEnd || 0;
            }
          } else if (element2.contentEditable === "true") {
            asyncRet = new (getPromise(this._win))((resolve) => {
              this._ignoredInputResolve = (value) => {
                delete this._ignoredInputResolve;
                resolve(value);
              };
              const win = this._win();
              if (this._ignoredInputTimer) {
                win.clearTimeout(this._ignoredInputTimer);
              }
              const {
                anchorNode: prevAnchorNode,
                focusNode: prevFocusNode,
                anchorOffset: prevAnchorOffset,
                focusOffset: prevFocusOffset
              } = win.getSelection() || {};
              this._ignoredInputTimer = win.setTimeout(() => {
                var _a3, _b, _c;
                delete this._ignoredInputTimer;
                const {
                  anchorNode,
                  focusNode,
                  anchorOffset,
                  focusOffset
                } = win.getSelection() || {};
                if (anchorNode !== prevAnchorNode || focusNode !== prevFocusNode || anchorOffset !== prevAnchorOffset || focusOffset !== prevFocusOffset) {
                  (_a3 = this._ignoredInputResolve) === null || _a3 === void 0 ? void 0 : _a3.call(this, false);
                  return;
                }
                selectionStart = anchorOffset || 0;
                selectionEnd = focusOffset || 0;
                textLength = ((_b = element2.textContent) === null || _b === void 0 ? void 0 : _b.length) || 0;
                if (anchorNode && focusNode) {
                  if (element2.contains(anchorNode) && element2.contains(focusNode)) {
                    if (anchorNode !== element2) {
                      let anchorFound = false;
                      const addOffsets = (node2) => {
                        if (node2 === anchorNode) {
                          anchorFound = true;
                        } else if (node2 === focusNode) {
                          return true;
                        }
                        const nodeText = node2.textContent;
                        if (nodeText && !node2.firstChild) {
                          const len = nodeText.length;
                          if (anchorFound) {
                            if (focusNode !== anchorNode) {
                              selectionEnd += len;
                            }
                          } else {
                            selectionStart += len;
                            selectionEnd += len;
                          }
                        }
                        let stop = false;
                        for (let e2 = node2.firstChild; e2 && !stop; e2 = e2.nextSibling) {
                          stop = addOffsets(e2);
                        }
                        return stop;
                      };
                      addOffsets(element2);
                    }
                  }
                }
                (_c = this._ignoredInputResolve) === null || _c === void 0 ? void 0 : _c.call(this, true);
              }, 0);
            });
          }
          if (asyncRet && !await asyncRet) {
            return true;
          }
          if (selectionStart !== selectionEnd) {
            return true;
          }
          if (selectionStart > 0 && (keyCode === Keys.Left || keyCode === Keys.Up || keyCode === Keys.Home)) {
            return true;
          }
          if (selectionStart < textLength && (keyCode === Keys.Right || keyCode === Keys.Down || keyCode === Keys.End)) {
            return true;
          }
        }
        return false;
      }
    }
    /*!
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    function observeMutations(doc, tabster, updateTabsterByAttribute2, syncState) {
      if (typeof MutationObserver === "undefined") {
        return () => {
        };
      }
      const getWindow2 = tabster.getWindow;
      let elementByUId;
      const onMutation = (mutations) => {
        var _a2, _b, _c, _d, _e;
        for (const mutation of mutations) {
          const target = mutation.target;
          const removed = mutation.removedNodes;
          const added = mutation.addedNodes;
          if (mutation.type === "attributes") {
            if (mutation.attributeName === TabsterAttributeName) {
              updateTabsterByAttribute2(tabster, target);
            }
          } else {
            for (let i2 = 0; i2 < removed.length; i2++) {
              updateTabsterElements(removed[i2], true);
              (_b = (_a2 = tabster._dummyObserver).domChanged) === null || _b === void 0 ? void 0 : _b.call(_a2, target);
            }
            for (let i2 = 0; i2 < added.length; i2++) {
              updateTabsterElements(added[i2]);
              (_d = (_c = tabster._dummyObserver).domChanged) === null || _d === void 0 ? void 0 : _d.call(_c, target);
            }
          }
        }
        (_e = tabster.modalizer) === null || _e === void 0 ? void 0 : _e.hiddenUpdate();
      };
      function updateTabsterElements(node2, removed) {
        if (!elementByUId) {
          elementByUId = getInstanceContext(getWindow2).elementByUId;
        }
        processNode(node2, removed);
        const walker = createElementTreeWalker(doc, node2, (element2) => {
          return processNode(element2, removed);
        });
        if (walker) {
          while (walker.nextNode()) {
          }
        }
      }
      function processNode(element2, removed) {
        var _a2;
        if (!element2.getAttribute) {
          return NodeFilter.FILTER_SKIP;
        }
        const uid = element2.__tabsterElementUID;
        if (uid && elementByUId) {
          if (removed) {
            delete elementByUId[uid];
          } else {
            (_a2 = elementByUId[uid]) !== null && _a2 !== void 0 ? _a2 : elementByUId[uid] = new WeakHTMLElement(getWindow2, element2);
          }
        }
        if (getTabsterOnElement(tabster, element2) || element2.hasAttribute(TabsterAttributeName)) {
          updateTabsterByAttribute2(tabster, element2, removed);
        }
        return NodeFilter.FILTER_SKIP;
      }
      const observer = new MutationObserver(onMutation);
      if (syncState) {
        updateTabsterElements(getWindow2().document.body);
      }
      observer.observe(doc, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: [TabsterAttributeName]
      });
      return () => {
        observer.disconnect();
      };
    }
    /*!
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    class UncontrolledAPI {
      constructor(isUncontrolledCompletely) {
        this._isUncontrolledCompletely = isUncontrolledCompletely;
      }
      isUncontrolledCompletely(element2, completely) {
        var _a2;
        const isUncontrolledCompletely = (_a2 = this._isUncontrolledCompletely) === null || _a2 === void 0 ? void 0 : _a2.call(this, element2, completely);
        return isUncontrolledCompletely === void 0 ? completely : isUncontrolledCompletely;
      }
    }
    /*!
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    const EVENT_NAME = "restorer:restorefocus";
    const HISOTRY_DEPTH = 10;
    class Restorer extends TabsterPart {
      constructor(tabster, element2, props) {
        var _a2;
        super(tabster, element2, props);
        this._hasFocus = false;
        this._onFocusOut = (e2) => {
          var _a3;
          const element3 = (_a3 = this._element) === null || _a3 === void 0 ? void 0 : _a3.get();
          if (element3 && e2.relatedTarget === null) {
            element3.dispatchEvent(new Event(EVENT_NAME, {
              bubbles: true
            }));
          }
          if (element3 && !element3.contains(e2.relatedTarget)) {
            this._hasFocus = false;
          }
        };
        this._onFocusIn = () => {
          this._hasFocus = true;
        };
        if (this._props.type === RestorerTypes.Source) {
          const element3 = (_a2 = this._element) === null || _a2 === void 0 ? void 0 : _a2.get();
          element3 === null || element3 === void 0 ? void 0 : element3.addEventListener("focusout", this._onFocusOut);
          element3 === null || element3 === void 0 ? void 0 : element3.addEventListener("focusin", this._onFocusIn);
        }
      }
      dispose() {
        var _a2, _b;
        if (this._props.type === RestorerTypes.Source) {
          const element2 = (_a2 = this._element) === null || _a2 === void 0 ? void 0 : _a2.get();
          element2 === null || element2 === void 0 ? void 0 : element2.removeEventListener("focusout", this._onFocusOut);
          element2 === null || element2 === void 0 ? void 0 : element2.removeEventListener("focusin", this._onFocusIn);
          if (this._hasFocus) {
            const doc = this._tabster.getWindow().document;
            (_b = doc.body) === null || _b === void 0 ? void 0 : _b.dispatchEvent(new Event(EVENT_NAME, {
              bubbles: true
            }));
          }
        }
      }
    }
    class RestorerAPI {
      constructor(tabster) {
        this._history = [];
        this._restoreFocusTimeout = 0;
        this._onRestoreFocus = (e2) => {
          const win = this._getWindow();
          if (this._restoreFocusTimeout) {
            win.clearTimeout(this._restoreFocusTimeout);
          }
          this._restoreFocusTimeout = win.setTimeout(() => this._restoreFocus(e2.target));
        };
        this._onFocusIn = (element2) => {
          var _a2;
          if (!element2) {
            return;
          }
          const tabsterAttribute = getTabsterOnElement(this._tabster, element2);
          if (((_a2 = tabsterAttribute === null || tabsterAttribute === void 0 ? void 0 : tabsterAttribute.restorer) === null || _a2 === void 0 ? void 0 : _a2.getProps().type) !== RestorerTypes.Target) {
            return;
          }
          this._addToHistory(element2);
        };
        this._restoreFocus = (source) => {
          var _a2, _b, _c;
          const doc = this._getWindow().document;
          if (doc.activeElement !== doc.body) {
            return;
          }
          if (
            // clicking on any empty space focuses body - this is can be a false positive
            !this._keyboardNavState.isNavigatingWithKeyboard() && // Source no longer exists on DOM - always restore focus
            doc.body.contains(source)
          ) {
            return;
          }
          let weakElement = this._history.pop();
          while (weakElement && !doc.body.contains((_b = (_a2 = weakElement.get()) === null || _a2 === void 0 ? void 0 : _a2.parentElement) !== null && _b !== void 0 ? _b : null)) {
            weakElement = this._history.pop();
          }
          (_c = weakElement === null || weakElement === void 0 ? void 0 : weakElement.get()) === null || _c === void 0 ? void 0 : _c.focus();
        };
        this._tabster = tabster;
        this._getWindow = tabster.getWindow;
        this._getWindow().addEventListener(EVENT_NAME, this._onRestoreFocus);
        this._keyboardNavState = tabster.keyboardNavigation;
        this._focusedElementState = tabster.focusedElement;
        this._focusedElementState.subscribe(this._onFocusIn);
      }
      dispose() {
        const win = this._getWindow();
        this._focusedElementState.unsubscribe(this._onFocusIn);
        win.removeEventListener(EVENT_NAME, this._onRestoreFocus);
        if (this._restoreFocusTimeout) {
          win.clearTimeout(this._restoreFocusTimeout);
        }
      }
      _addToHistory(element2) {
        var _a2;
        if (((_a2 = this._history[this._history.length - 1]) === null || _a2 === void 0 ? void 0 : _a2.get()) === element2) {
          return;
        }
        if (this._history.length > HISOTRY_DEPTH) {
          this._history.shift();
        }
        this._history.push(new WeakHTMLElement(this._getWindow, element2));
      }
      createRestorer(element2, props) {
        const restorer = new Restorer(this._tabster, element2, props);
        if (props.type === RestorerTypes.Target && element2.ownerDocument.activeElement === element2) {
          this._addToHistory(element2);
        }
        return restorer;
      }
    }
    /*!
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License.
     */
    class Tabster {
      constructor(tabster) {
        this.keyboardNavigation = tabster.keyboardNavigation;
        this.focusedElement = tabster.focusedElement;
        this.focusable = tabster.focusable;
        this.root = tabster.root;
        this.uncontrolled = tabster.uncontrolled;
        this.core = tabster;
      }
    }
    class TabsterCore {
      constructor(win, props) {
        var _a2, _b;
        this._forgetMemorizedElements = [];
        this._wrappers = /* @__PURE__ */ new Set();
        this._initQueue = [];
        this._version = "5.2.0";
        this._noop = false;
        this.getWindow = () => {
          if (!this._win) {
            throw new Error("Using disposed Tabster.");
          }
          return this._win;
        };
        this._storage = createWeakMap(win);
        this._win = win;
        const getWindow2 = this.getWindow;
        this.keyboardNavigation = new KeyboardNavigationState(getWindow2);
        this.focusedElement = new FocusedElementState(this, getWindow2);
        this.focusable = new FocusableAPI(this);
        this.root = new RootAPI(this, props === null || props === void 0 ? void 0 : props.autoRoot);
        this.uncontrolled = new UncontrolledAPI(
          // TODO: Remove checkUncontrolledTrappingFocus in the next major version.
          (props === null || props === void 0 ? void 0 : props.checkUncontrolledCompletely) || (props === null || props === void 0 ? void 0 : props.checkUncontrolledTrappingFocus)
        );
        this.controlTab = (_a2 = props === null || props === void 0 ? void 0 : props.controlTab) !== null && _a2 !== void 0 ? _a2 : true;
        this.rootDummyInputs = !!(props === null || props === void 0 ? void 0 : props.rootDummyInputs);
        this._dummyObserver = new DummyInputObserver(getWindow2);
        this.getParent = (_b = props === null || props === void 0 ? void 0 : props.getParent) !== null && _b !== void 0 ? _b : (el) => el.parentElement;
        this.internal = {
          stopObserver: () => {
            if (this._unobserve) {
              this._unobserve();
              delete this._unobserve;
            }
          },
          resumeObserver: (syncState) => {
            if (!this._unobserve) {
              const doc = getWindow2().document;
              this._unobserve = observeMutations(doc, this, updateTabsterByAttribute, syncState);
            }
          }
        };
        startFakeWeakRefsCleanup(getWindow2);
        this.queueInit(() => {
          this.internal.resumeObserver(true);
        });
      }
      /**
       * Merges external props with the current props. Not all
       * props can/should be mergeable, so let's add more as we move on.
       * @param props Tabster props
       */
      _mergeProps(props) {
        var _a2;
        if (!props) {
          return;
        }
        this.getParent = (_a2 = props.getParent) !== null && _a2 !== void 0 ? _a2 : this.getParent;
      }
      createTabster(noRefCount, props) {
        const wrapper = new Tabster(this);
        if (!noRefCount) {
          this._wrappers.add(wrapper);
        }
        this._mergeProps(props);
        return wrapper;
      }
      disposeTabster(wrapper, allInstances) {
        if (allInstances) {
          this._wrappers.clear();
        } else {
          this._wrappers.delete(wrapper);
        }
        if (this._wrappers.size === 0) {
          this.dispose();
        }
      }
      dispose() {
        var _a2, _b, _c, _d, _e, _f, _g, _h;
        this.internal.stopObserver();
        const win = this._win;
        win === null || win === void 0 ? void 0 : win.clearTimeout(this._initTimer);
        delete this._initTimer;
        this._initQueue = [];
        this._forgetMemorizedElements = [];
        if (win && this._forgetMemorizedTimer) {
          win.clearTimeout(this._forgetMemorizedTimer);
          delete this._forgetMemorizedTimer;
        }
        (_a2 = this.outline) === null || _a2 === void 0 ? void 0 : _a2.dispose();
        (_b = this.crossOrigin) === null || _b === void 0 ? void 0 : _b.dispose();
        (_c = this.deloser) === null || _c === void 0 ? void 0 : _c.dispose();
        (_d = this.groupper) === null || _d === void 0 ? void 0 : _d.dispose();
        (_e = this.mover) === null || _e === void 0 ? void 0 : _e.dispose();
        (_f = this.modalizer) === null || _f === void 0 ? void 0 : _f.dispose();
        (_g = this.observedElement) === null || _g === void 0 ? void 0 : _g.dispose();
        (_h = this.restorer) === null || _h === void 0 ? void 0 : _h.dispose();
        this.keyboardNavigation.dispose();
        this.focusable.dispose();
        this.focusedElement.dispose();
        this.root.dispose();
        this._dummyObserver.dispose();
        stopFakeWeakRefsCleanupAndClearStorage(this.getWindow);
        clearElementCache(this.getWindow);
        this._storage = /* @__PURE__ */ new WeakMap();
        this._wrappers.clear();
        if (win) {
          disposeInstanceContext(win);
          delete win.__tabsterInstance;
          delete this._win;
        }
      }
      storageEntry(element2, addremove) {
        const storage = this._storage;
        let entry = storage.get(element2);
        if (entry) {
          if (addremove === false && Object.keys(entry).length === 0) {
            storage.delete(element2);
          }
        } else if (addremove === true) {
          entry = {};
          storage.set(element2, entry);
        }
        return entry;
      }
      forceCleanup() {
        if (!this._win) {
          return;
        }
        this._forgetMemorizedElements.push(this._win.document.body);
        if (this._forgetMemorizedTimer) {
          return;
        }
        this._forgetMemorizedTimer = this._win.setTimeout(() => {
          delete this._forgetMemorizedTimer;
          for (let el = this._forgetMemorizedElements.shift(); el; el = this._forgetMemorizedElements.shift()) {
            clearElementCache(this.getWindow, el);
            FocusedElementState.forgetMemorized(this.focusedElement, el);
          }
        }, 0);
        cleanupFakeWeakRefs(this.getWindow, true);
      }
      queueInit(callback) {
        var _a2;
        if (!this._win) {
          return;
        }
        this._initQueue.push(callback);
        if (!this._initTimer) {
          this._initTimer = (_a2 = this._win) === null || _a2 === void 0 ? void 0 : _a2.setTimeout(() => {
            delete this._initTimer;
            this.drainInitQueue();
          }, 0);
        }
      }
      drainInitQueue() {
        if (!this._win) {
          return;
        }
        const queue = this._initQueue;
        this._initQueue = [];
        queue.forEach((callback) => callback());
      }
    }
    function createTabster(win, props) {
      let tabster = getCurrentTabster(win);
      if (tabster) {
        return tabster.createTabster(false, props);
      }
      tabster = new TabsterCore(win, props);
      win.__tabsterInstance = tabster;
      return tabster.createTabster();
    }
    function getMover(tabster) {
      const tabsterCore = tabster.core;
      if (!tabsterCore.mover) {
        tabsterCore.mover = new MoverAPI(tabsterCore, tabsterCore.getWindow);
      }
      return tabsterCore.mover;
    }
    function getModalizer(tabster, alwaysAccessibleSelector, accessibleCheck) {
      const tabsterCore = tabster.core;
      if (!tabsterCore.modalizer) {
        tabsterCore.modalizer = new ModalizerAPI(tabsterCore, alwaysAccessibleSelector, accessibleCheck);
      }
      return tabsterCore.modalizer;
    }
    function getRestorer(tabster) {
      const tabsterCore = tabster.core;
      if (!tabsterCore.restorer) {
        tabsterCore.restorer = new RestorerAPI(tabsterCore);
      }
      return tabsterCore.restorer;
    }
    function disposeTabster(tabster, allInstances) {
      tabster.core.disposeTabster(tabster, allInstances);
    }
    function getCurrentTabster(win) {
      return win.__tabsterInstance;
    }
    const useTabster = () => {
      const { targetDocument } = useFluent();
      const defaultView = (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) || void 0;
      const tabster = reactExports.useMemo(() => {
        if (!defaultView) {
          return null;
        }
        return createTabster(defaultView, {
          autoRoot: {},
          controlTab: false,
          getParent,
          checkUncontrolledTrappingFocus: (element2) => {
            var _element_firstElementChild;
            return !!((_element_firstElementChild = element2.firstElementChild) === null || _element_firstElementChild === void 0 ? void 0 : _element_firstElementChild.hasAttribute("data-is-focus-trap-zone-bumper"));
          }
        });
      }, [
        defaultView
      ]);
      useIsomorphicLayoutEffect(() => {
        return () => {
          if (tabster) {
            disposeTabster(tabster);
          }
        };
      }, [
        tabster
      ]);
      return tabster;
    };
    const useTabsterAttributes = (props) => {
      useTabster();
      return getTabsterAttribute(props);
    };
    const useArrowNavigationGroup = (options = {}) => {
      const {
        circular,
        axis,
        memorizeCurrent,
        tabbable,
        ignoreDefaultKeydown,
        // eslint-disable-next-line @typescript-eslint/naming-convention
        unstable_hasDefault
      } = options;
      const tabster = useTabster();
      if (tabster) {
        getMover(tabster);
      }
      return useTabsterAttributes({
        mover: {
          cyclic: !!circular,
          direction: axisToMoverDirection(axis !== null && axis !== void 0 ? axis : "vertical"),
          memorizeCurrent,
          tabbable,
          hasDefault: unstable_hasDefault
        },
        ...ignoreDefaultKeydown && {
          focusable: {
            ignoreKeydown: ignoreDefaultKeydown
          }
        }
      });
    };
    function axisToMoverDirection(axis) {
      switch (axis) {
        case "horizontal":
          return Types.MoverDirections.Horizontal;
        case "grid":
          return Types.MoverDirections.Grid;
        case "grid-linear":
          return Types.MoverDirections.GridLinear;
        case "both":
          return Types.MoverDirections.Both;
        case "vertical":
        default:
          return Types.MoverDirections.Vertical;
      }
    }
    const useFocusFinders = () => {
      const tabster = useTabster();
      const { targetDocument } = useFluent();
      const findAllFocusable = reactExports.useCallback((container, acceptCondition) => (tabster === null || tabster === void 0 ? void 0 : tabster.focusable.findAll({
        container,
        acceptCondition
      })) || [], [
        tabster
      ]);
      const findFirstFocusable = reactExports.useCallback((container) => tabster === null || tabster === void 0 ? void 0 : tabster.focusable.findFirst({
        container
      }), [
        tabster
      ]);
      const findLastFocusable = reactExports.useCallback((container) => tabster === null || tabster === void 0 ? void 0 : tabster.focusable.findLast({
        container
      }), [
        tabster
      ]);
      const findNextFocusable = reactExports.useCallback((currentElement, options = {}) => {
        if (!tabster || !targetDocument) {
          return null;
        }
        const { container = targetDocument.body } = options;
        return tabster.focusable.findNext({
          currentElement,
          container
        });
      }, [
        tabster,
        targetDocument
      ]);
      const findPrevFocusable = reactExports.useCallback((currentElement, options = {}) => {
        if (!tabster || !targetDocument) {
          return null;
        }
        const { container = targetDocument.body } = options;
        return tabster.focusable.findPrev({
          currentElement,
          container
        });
      }, [
        tabster,
        targetDocument
      ]);
      return {
        findAllFocusable,
        findFirstFocusable,
        findLastFocusable,
        findNextFocusable,
        findPrevFocusable
      };
    };
    const FOCUS_VISIBLE_ATTR = "data-fui-focus-visible";
    const FOCUS_WITHIN_ATTR = "data-fui-focus-within";
    function applyFocusVisiblePolyfill(scope, targetWindow) {
      if (alreadyInScope(scope)) {
        return () => void 0;
      }
      const state = {
        current: void 0
      };
      const keyborg = createKeyborg(targetWindow);
      function registerElementIfNavigating(el) {
        if (keyborg.isNavigatingWithKeyboard() && isHTMLElement$1(el)) {
          state.current = el;
          el.setAttribute(FOCUS_VISIBLE_ATTR, "");
        }
      }
      function disposeCurrentElement() {
        if (state.current) {
          state.current.removeAttribute(FOCUS_VISIBLE_ATTR);
          state.current = void 0;
        }
      }
      keyborg.subscribe((isNavigatingWithKeyboard) => {
        if (!isNavigatingWithKeyboard) {
          disposeCurrentElement();
        }
      });
      const keyborgListener = (e2) => {
        disposeCurrentElement();
        registerElementIfNavigating(e2.target);
      };
      const blurListener = (e2) => {
        if (!e2.relatedTarget || isHTMLElement$1(e2.relatedTarget) && !scope.contains(e2.relatedTarget)) {
          disposeCurrentElement();
        }
      };
      scope.addEventListener(KEYBORG_FOCUSIN, keyborgListener);
      scope.addEventListener("focusout", blurListener);
      scope.focusVisible = true;
      registerElementIfNavigating(targetWindow.document.activeElement);
      return () => {
        disposeCurrentElement();
        scope.removeEventListener(KEYBORG_FOCUSIN, keyborgListener);
        scope.removeEventListener("focusout", blurListener);
        delete scope.focusVisible;
        disposeKeyborg(keyborg);
      };
    }
    function alreadyInScope(el) {
      if (!el) {
        return false;
      }
      if (el.focusVisible) {
        return true;
      }
      return alreadyInScope(el === null || el === void 0 ? void 0 : el.parentElement);
    }
    function useFocusVisible(options = {}) {
      const contextValue = useFluent();
      const scopeRef = reactExports.useRef(null);
      var _options_targetDocument;
      const targetDocument = (_options_targetDocument = options.targetDocument) !== null && _options_targetDocument !== void 0 ? _options_targetDocument : contextValue.targetDocument;
      reactExports.useEffect(() => {
        if ((targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) && scopeRef.current) {
          return applyFocusVisiblePolyfill(scopeRef.current, targetDocument.defaultView);
        }
      }, [
        scopeRef,
        targetDocument
      ]);
      return scopeRef;
    }
    function applyFocusWithinPolyfill(element2, win) {
      const keyborg = createKeyborg(win);
      keyborg.subscribe((isNavigatingWithKeyboard) => {
        if (!isNavigatingWithKeyboard) {
          removeFocusWithinClass(element2);
        }
      });
      const keyborgListener = (e2) => {
        if (keyborg.isNavigatingWithKeyboard() && isHTMLElement(e2.target)) {
          applyFocusWithinClass(element2);
        }
      };
      const blurListener = (e2) => {
        if (!e2.relatedTarget || isHTMLElement(e2.relatedTarget) && !element2.contains(e2.relatedTarget)) {
          removeFocusWithinClass(element2);
        }
      };
      element2.addEventListener(KEYBORG_FOCUSIN, keyborgListener);
      element2.addEventListener("focusout", blurListener);
      return () => {
        element2.removeEventListener(KEYBORG_FOCUSIN, keyborgListener);
        element2.removeEventListener("focusout", blurListener);
        disposeKeyborg(keyborg);
      };
    }
    function applyFocusWithinClass(el) {
      el.setAttribute(FOCUS_WITHIN_ATTR, "");
    }
    function removeFocusWithinClass(el) {
      el.removeAttribute(FOCUS_WITHIN_ATTR);
    }
    function isHTMLElement(target) {
      if (!target) {
        return false;
      }
      return Boolean(target && typeof target === "object" && "classList" in target && "contains" in target);
    }
    function useFocusWithin() {
      const { targetDocument } = useFluent();
      const elementRef = reactExports.useRef(null);
      reactExports.useEffect(() => {
        if ((targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView) && elementRef.current) {
          return applyFocusWithinPolyfill(elementRef.current, targetDocument.defaultView);
        }
      }, [
        elementRef,
        targetDocument
      ]);
      return elementRef;
    }
    const useModalAttributes = (options = {}) => {
      const { trapFocus, alwaysFocusable, legacyTrapFocus } = options;
      const tabster = useTabster();
      if (tabster) {
        getModalizer(tabster);
        getRestorer(tabster);
      }
      const id2 = useId("modal-", options.id);
      const modalAttributes = useTabsterAttributes({
        restorer: {
          type: Types.RestorerTypes.Source
        },
        ...trapFocus && {
          modalizer: {
            id: id2,
            isOthersAccessible: !trapFocus,
            isAlwaysAccessible: alwaysFocusable,
            isTrapped: legacyTrapFocus && trapFocus
          }
        }
      });
      const triggerAttributes = useTabsterAttributes({
        restorer: {
          type: Types.RestorerTypes.Target
        }
      });
      return {
        modalAttributes,
        triggerAttributes
      };
    };
    function useRestoreFocusTarget() {
      const tabster = useTabster();
      if (tabster) {
        getRestorer(tabster);
      }
      return getTabsterAttribute({
        restorer: {
          type: Types.RestorerTypes.Target
        }
      });
    }
    function useRestoreFocusSource() {
      const tabster = useTabster();
      if (tabster) {
        getRestorer(tabster);
      }
      return getTabsterAttribute({
        restorer: {
          type: Types.RestorerTypes.Source
        }
      });
    }
    const grey = {
      "2": "#050505",
      "4": "#0a0a0a",
      "6": "#0f0f0f",
      "8": "#141414",
      "10": "#1a1a1a",
      "12": "#1f1f1f",
      "14": "#242424",
      "16": "#292929",
      "18": "#2e2e2e",
      "20": "#333333",
      "22": "#383838",
      "24": "#3d3d3d",
      "26": "#424242",
      "28": "#474747",
      "30": "#4d4d4d",
      "32": "#525252",
      "34": "#575757",
      "36": "#5c5c5c",
      "38": "#616161",
      "40": "#666666",
      "42": "#6b6b6b",
      "44": "#707070",
      "46": "#757575",
      "48": "#7a7a7a",
      "50": "#808080",
      "52": "#858585",
      "54": "#8a8a8a",
      "56": "#8f8f8f",
      "58": "#949494",
      "60": "#999999",
      "62": "#9e9e9e",
      "64": "#a3a3a3",
      "66": "#a8a8a8",
      "68": "#adadad",
      "70": "#b3b3b3",
      "72": "#b8b8b8",
      "74": "#bdbdbd",
      "76": "#c2c2c2",
      "78": "#c7c7c7",
      "80": "#cccccc",
      "82": "#d1d1d1",
      "84": "#d6d6d6",
      "86": "#dbdbdb",
      "88": "#e0e0e0",
      "90": "#e6e6e6",
      "92": "#ebebeb",
      "94": "#f0f0f0",
      "96": "#f5f5f5",
      "98": "#fafafa"
    };
    const whiteAlpha = {
      "5": "rgba(255, 255, 255, 0.05)",
      "10": "rgba(255, 255, 255, 0.1)",
      "20": "rgba(255, 255, 255, 0.2)",
      "30": "rgba(255, 255, 255, 0.3)",
      "40": "rgba(255, 255, 255, 0.4)",
      "50": "rgba(255, 255, 255, 0.5)",
      "60": "rgba(255, 255, 255, 0.6)",
      "70": "rgba(255, 255, 255, 0.7)",
      "80": "rgba(255, 255, 255, 0.8)",
      "90": "rgba(255, 255, 255, 0.9)"
    };
    const blackAlpha = {
      "5": "rgba(0, 0, 0, 0.05)",
      "10": "rgba(0, 0, 0, 0.1)",
      "20": "rgba(0, 0, 0, 0.2)",
      "30": "rgba(0, 0, 0, 0.3)",
      "40": "rgba(0, 0, 0, 0.4)",
      "50": "rgba(0, 0, 0, 0.5)",
      "60": "rgba(0, 0, 0, 0.6)",
      "70": "rgba(0, 0, 0, 0.7)",
      "80": "rgba(0, 0, 0, 0.8)",
      "90": "rgba(0, 0, 0, 0.9)"
    };
    const grey10Alpha = {
      "5": "rgba(26, 26, 26, 0.05)",
      "10": "rgba(26, 26, 26, 0.1)",
      "20": "rgba(26, 26, 26, 0.2)",
      "30": "rgba(26, 26, 26, 0.3)",
      "40": "rgba(26, 26, 26, 0.4)",
      "50": "rgba(26, 26, 26, 0.5)",
      "60": "rgba(26, 26, 26, 0.6)",
      "70": "rgba(26, 26, 26, 0.7)",
      "80": "rgba(26, 26, 26, 0.8)",
      "90": "rgba(26, 26, 26, 0.9)"
    };
    const grey12Alpha = {
      "5": "rgba(31, 31, 31, 0.05)",
      "10": "rgba(31, 31, 31, 0.1)",
      "20": "rgba(31, 31, 31, 0.2)",
      "30": "rgba(31, 31, 31, 0.3)",
      "40": "rgba(31, 31, 31, 0.4)",
      "50": "rgba(31, 31, 31, 0.5)",
      "60": "rgba(31, 31, 31, 0.6)",
      "70": "rgba(31, 31, 31, 0.7)",
      "80": "rgba(31, 31, 31, 0.8)",
      "90": "rgba(31, 31, 31, 0.9)"
    };
    const grey14Alpha = {
      "5": "rgba(36, 36, 36, 0.05)",
      "10": "rgba(36, 36, 36, 0.1)",
      "20": "rgba(36, 36, 36, 0.2)",
      "30": "rgba(36, 36, 36, 0.3)",
      "40": "rgba(36, 36, 36, 0.4)",
      "50": "rgba(36, 36, 36, 0.5)",
      "60": "rgba(36, 36, 36, 0.6)",
      "70": "rgba(36, 36, 36, 0.7)",
      "80": "rgba(36, 36, 36, 0.8)",
      "90": "rgba(36, 36, 36, 0.9)"
    };
    const white = "#ffffff";
    const black = "#000000";
    const darkRed = {
      shade50: "#130204",
      shade40: "#230308",
      shade30: "#420610",
      shade20: "#590815",
      shade10: "#690a19",
      primary: "#750b1c",
      tint10: "#861b2c",
      tint20: "#962f3f",
      tint30: "#ac4f5e",
      tint40: "#d69ca5",
      tint50: "#e9c7cd",
      tint60: "#f9f0f2"
    };
    const cranberry = {
      shade50: "#200205",
      shade40: "#3b0509",
      shade30: "#6e0811",
      shade20: "#960b18",
      shade10: "#b10e1c",
      primary: "#c50f1f",
      tint10: "#cc2635",
      tint20: "#d33f4c",
      tint30: "#dc626d",
      tint40: "#eeacb2",
      tint50: "#f6d1d5",
      tint60: "#fdf3f4"
    };
    const red = {
      shade50: "#210809",
      shade40: "#3f1011",
      shade30: "#751d1f",
      shade20: "#9f282b",
      shade10: "#bc2f32",
      primary: "#d13438",
      tint10: "#d7494c",
      tint20: "#dc5e62",
      tint30: "#e37d80",
      tint40: "#f1bbbc",
      tint50: "#f8dadb",
      tint60: "#fdf6f6"
    };
    const darkOrange = {
      shade50: "#230900",
      shade40: "#411200",
      shade30: "#7a2101",
      shade20: "#a62d01",
      shade10: "#c43501",
      primary: "#da3b01",
      tint10: "#de501c",
      tint20: "#e36537",
      tint30: "#e9835e",
      tint40: "#f4bfab",
      tint50: "#f9dcd1",
      tint60: "#fdf6f3"
    };
    const pumpkin = {
      shade50: "#200d03",
      shade40: "#3d1805",
      shade30: "#712d09",
      shade20: "#9a3d0c",
      shade10: "#b6480e",
      primary: "#ca5010",
      tint10: "#d06228",
      tint20: "#d77440",
      tint30: "#df8e64",
      tint40: "#efc4ad",
      tint50: "#f7dfd2",
      tint60: "#fdf7f4"
    };
    const orange = {
      shade50: "#271002",
      shade40: "#4a1e04",
      shade30: "#8a3707",
      shade20: "#bc4b09",
      shade10: "#de590b",
      primary: "#f7630c",
      tint10: "#f87528",
      tint20: "#f98845",
      tint30: "#faa06b",
      tint40: "#fdcfb4",
      tint50: "#fee5d7",
      tint60: "#fff9f5"
    };
    const peach = {
      shade50: "#291600",
      shade40: "#4d2a00",
      shade30: "#8f4e00",
      shade20: "#c26a00",
      shade10: "#e67e00",
      primary: "#ff8c00",
      tint10: "#ff9a1f",
      tint20: "#ffa83d",
      tint30: "#ffba66",
      tint40: "#ffddb3",
      tint50: "#ffedd6",
      tint60: "#fffaf5"
    };
    const marigold = {
      shade50: "#251a00",
      shade40: "#463100",
      shade30: "#835b00",
      shade20: "#b27c00",
      shade10: "#d39300",
      primary: "#eaa300",
      tint10: "#edad1c",
      tint20: "#efb839",
      tint30: "#f2c661",
      tint40: "#f9e2ae",
      tint50: "#fcefd3",
      tint60: "#fefbf4"
    };
    const yellow = {
      primary: "#fde300",
      shade10: "#e4cc00",
      shade20: "#c0ad00",
      shade30: "#817400",
      shade40: "#4c4400",
      shade50: "#282400",
      tint10: "#fde61e",
      tint20: "#fdea3d",
      tint30: "#feee66",
      tint40: "#fef7b2",
      tint50: "#fffad6",
      tint60: "#fffef5"
    };
    const gold = {
      shade50: "#1f1900",
      shade40: "#3a2f00",
      shade30: "#6c5700",
      shade20: "#937700",
      shade10: "#ae8c00",
      primary: "#c19c00",
      tint10: "#c8a718",
      tint20: "#d0b232",
      tint30: "#dac157",
      tint40: "#ecdfa5",
      tint50: "#f5eece",
      tint60: "#fdfbf2"
    };
    const brass = {
      shade50: "#181202",
      shade40: "#2e2103",
      shade30: "#553e06",
      shade20: "#745408",
      shade10: "#89640a",
      primary: "#986f0b",
      tint10: "#a47d1e",
      tint20: "#b18c34",
      tint30: "#c1a256",
      tint40: "#e0cea2",
      tint50: "#efe4cb",
      tint60: "#fbf8f2"
    };
    const brown = {
      shade50: "#170e07",
      shade40: "#2b1a0e",
      shade30: "#50301a",
      shade20: "#6c4123",
      shade10: "#804d29",
      primary: "#8e562e",
      tint10: "#9c663f",
      tint20: "#a97652",
      tint30: "#bb8f6f",
      tint40: "#ddc3b0",
      tint50: "#edded3",
      tint60: "#faf7f4"
    };
    const forest = {
      shade50: "#0c1501",
      shade40: "#162702",
      shade30: "#294903",
      shade20: "#376304",
      shade10: "#427505",
      primary: "#498205",
      tint10: "#599116",
      tint20: "#6ba02b",
      tint30: "#85b44c",
      tint40: "#bdd99b",
      tint50: "#dbebc7",
      tint60: "#f6faf0"
    };
    const seafoam = {
      shade50: "#002111",
      shade40: "#003d20",
      shade30: "#00723b",
      shade20: "#009b51",
      shade10: "#00b85f",
      primary: "#00cc6a",
      tint10: "#19d279",
      tint20: "#34d889",
      tint30: "#5ae0a0",
      tint40: "#a8f0cd",
      tint50: "#cff7e4",
      tint60: "#f3fdf8"
    };
    const lightGreen = {
      shade50: "#031a02",
      shade40: "#063004",
      shade30: "#0b5a08",
      shade20: "#0e7a0b",
      shade10: "#11910d",
      primary: "#13a10e",
      tint10: "#27ac22",
      tint20: "#3db838",
      tint30: "#5ec75a",
      tint40: "#a7e3a5",
      tint50: "#cef0cd",
      tint60: "#f2fbf2"
    };
    const green = {
      shade50: "#031403",
      shade40: "#052505",
      shade30: "#094509",
      shade20: "#0c5e0c",
      shade10: "#0e700e",
      primary: "#107c10",
      tint10: "#218c21",
      tint20: "#359b35",
      tint30: "#54b054",
      tint40: "#9fd89f",
      tint50: "#c9eac9",
      tint60: "#f1faf1"
    };
    const darkGreen = {
      shade50: "#021102",
      shade40: "#032003",
      shade30: "#063b06",
      shade20: "#085108",
      shade10: "#0a5f0a",
      primary: "#0b6a0b",
      tint10: "#1a7c1a",
      tint20: "#2d8e2d",
      tint30: "#4da64d",
      tint40: "#9ad29a",
      tint50: "#c6e7c6",
      tint60: "#f0f9f0"
    };
    const lightTeal = {
      shade50: "#001d1f",
      shade40: "#00373a",
      shade30: "#00666d",
      shade20: "#008b94",
      shade10: "#00a5af",
      primary: "#00b7c3",
      tint10: "#18bfca",
      tint20: "#32c8d1",
      tint30: "#58d3db",
      tint40: "#a6e9ed",
      tint50: "#cef3f5",
      tint60: "#f2fcfd"
    };
    const teal = {
      shade50: "#001516",
      shade40: "#012728",
      shade30: "#02494c",
      shade20: "#026467",
      shade10: "#037679",
      primary: "#038387",
      tint10: "#159195",
      tint20: "#2aa0a4",
      tint30: "#4cb4b7",
      tint40: "#9bd9db",
      tint50: "#c7ebec",
      tint60: "#f0fafa"
    };
    const steel = {
      shade50: "#000f12",
      shade40: "#001b22",
      shade30: "#00333f",
      shade20: "#004555",
      shade10: "#005265",
      primary: "#005b70",
      tint10: "#0f6c81",
      tint20: "#237d92",
      tint30: "#4496a9",
      tint40: "#94c8d4",
      tint50: "#c3e1e8",
      tint60: "#eff7f9"
    };
    const blue = {
      shade50: "#001322",
      shade40: "#002440",
      shade30: "#004377",
      shade20: "#005ba1",
      shade10: "#006cbf",
      primary: "#0078d4",
      tint10: "#1a86d9",
      tint20: "#3595de",
      tint30: "#5caae5",
      tint40: "#a9d3f2",
      tint50: "#d0e7f8",
      tint60: "#f3f9fd"
    };
    const royalBlue = {
      shade50: "#000c16",
      shade40: "#00172a",
      shade30: "#002c4e",
      shade20: "#003b6a",
      shade10: "#00467e",
      primary: "#004e8c",
      tint10: "#125e9a",
      tint20: "#286fa8",
      tint30: "#4a89ba",
      tint40: "#9abfdc",
      tint50: "#c7dced",
      tint60: "#f0f6fa"
    };
    const cornflower = {
      shade50: "#0d1126",
      shade40: "#182047",
      shade30: "#2c3c85",
      shade20: "#3c51b4",
      shade10: "#4760d5",
      primary: "#4f6bed",
      tint10: "#637cef",
      tint20: "#778df1",
      tint30: "#93a4f4",
      tint40: "#c8d1fa",
      tint50: "#e1e6fc",
      tint60: "#f7f9fe"
    };
    const navy = {
      shade50: "#00061d",
      shade40: "#000c36",
      shade30: "#001665",
      shade20: "#001e89",
      shade10: "#0023a2",
      primary: "#0027b4",
      tint10: "#173bbd",
      tint20: "#3050c6",
      tint30: "#546fd2",
      tint40: "#a3b2e8",
      tint50: "#ccd5f3",
      tint60: "#f2f4fc"
    };
    const lavender = {
      shade50: "#120f25",
      shade40: "#221d46",
      shade30: "#3f3682",
      shade20: "#5649b0",
      shade10: "#6656d1",
      primary: "#7160e8",
      tint10: "#8172eb",
      tint20: "#9184ee",
      tint30: "#a79cf1",
      tint40: "#d2ccf8",
      tint50: "#e7e4fb",
      tint60: "#f9f8fe"
    };
    const purple = {
      shade50: "#0f0717",
      shade40: "#1c0e2b",
      shade30: "#341a51",
      shade20: "#46236e",
      shade10: "#532982",
      primary: "#5c2e91",
      tint10: "#6b3f9e",
      tint20: "#7c52ab",
      tint30: "#9470bd",
      tint40: "#c6b1de",
      tint50: "#e0d3ed",
      tint60: "#f7f4fb"
    };
    const grape = {
      shade50: "#160418",
      shade40: "#29072e",
      shade30: "#4c0d55",
      shade20: "#671174",
      shade10: "#7a1589",
      primary: "#881798",
      tint10: "#952aa4",
      tint20: "#a33fb1",
      tint30: "#b55fc1",
      tint40: "#d9a7e0",
      tint50: "#eaceef",
      tint60: "#faf2fb"
    };
    const berry = {
      shade50: "#1f091d",
      shade40: "#3a1136",
      shade30: "#6d2064",
      shade20: "#932b88",
      shade10: "#af33a1",
      primary: "#c239b3",
      tint10: "#c94cbc",
      tint20: "#d161c4",
      tint30: "#da7ed0",
      tint40: "#edbbe7",
      tint50: "#f5daf2",
      tint60: "#fdf5fc"
    };
    const lilac = {
      shade50: "#1c0b1f",
      shade40: "#35153a",
      shade30: "#63276d",
      shade20: "#863593",
      shade10: "#9f3faf",
      primary: "#b146c2",
      tint10: "#ba58c9",
      tint20: "#c36bd1",
      tint30: "#cf87da",
      tint40: "#e6bfed",
      tint50: "#f2dcf5",
      tint60: "#fcf6fd"
    };
    const pink = {
      shade50: "#24091b",
      shade40: "#441232",
      shade30: "#80215d",
      shade20: "#ad2d7e",
      shade10: "#cd3595",
      primary: "#e43ba6",
      tint10: "#e750b0",
      tint20: "#ea66ba",
      tint30: "#ef85c8",
      tint40: "#f7c0e3",
      tint50: "#fbddf0",
      tint60: "#fef6fb"
    };
    const magenta = {
      shade50: "#1f0013",
      shade40: "#390024",
      shade30: "#6b0043",
      shade20: "#91005a",
      shade10: "#ac006b",
      primary: "#bf0077",
      tint10: "#c71885",
      tint20: "#ce3293",
      tint30: "#d957a8",
      tint40: "#eca5d1",
      tint50: "#f5cee6",
      tint60: "#fcf2f9"
    };
    const plum = {
      shade50: "#13000c",
      shade40: "#240017",
      shade30: "#43002b",
      shade20: "#5a003b",
      shade10: "#6b0045",
      primary: "#77004d",
      tint10: "#87105d",
      tint20: "#98246f",
      tint30: "#ad4589",
      tint40: "#d696c0",
      tint50: "#e9c4dc",
      tint60: "#faf0f6"
    };
    const beige = {
      shade50: "#141313",
      shade40: "#252323",
      shade30: "#444241",
      shade20: "#5d5958",
      shade10: "#6e6968",
      primary: "#7a7574",
      tint10: "#8a8584",
      tint20: "#9a9594",
      tint30: "#afabaa",
      tint40: "#d7d4d4",
      tint50: "#eae8e8",
      tint60: "#faf9f9"
    };
    const mink = {
      shade50: "#0f0e0e",
      shade40: "#1c1b1a",
      shade30: "#343231",
      shade20: "#474443",
      shade10: "#54514f",
      primary: "#5d5a58",
      tint10: "#706d6b",
      tint20: "#84817e",
      tint30: "#9e9b99",
      tint40: "#cecccb",
      tint50: "#e5e4e3",
      tint60: "#f8f8f8"
    };
    const platinum = {
      shade50: "#111314",
      shade40: "#1f2426",
      shade30: "#3b4447",
      shade20: "#505c60",
      shade10: "#5f6d71",
      primary: "#69797e",
      tint10: "#79898d",
      tint20: "#89989d",
      tint30: "#a0adb2",
      tint40: "#cdd6d8",
      tint50: "#e4e9ea",
      tint60: "#f8f9fa"
    };
    const anchor = {
      shade50: "#090a0b",
      shade40: "#111315",
      shade30: "#202427",
      shade20: "#2b3135",
      shade10: "#333a3f",
      primary: "#394146",
      tint10: "#4d565c",
      tint20: "#626c72",
      tint30: "#808a90",
      tint40: "#bcc3c7",
      tint50: "#dbdfe1",
      tint60: "#f6f7f8"
    };
    const statusSharedColors = {
      red,
      green,
      darkOrange,
      yellow,
      berry,
      lightGreen,
      marigold
    };
    const personaSharedColors = {
      darkRed,
      cranberry,
      pumpkin,
      peach,
      gold,
      brass,
      brown,
      forest,
      seafoam,
      darkGreen,
      lightTeal,
      teal,
      steel,
      blue,
      royalBlue,
      cornflower,
      navy,
      lavender,
      purple,
      grape,
      lilac,
      pink,
      magenta,
      plum,
      beige,
      mink,
      platinum,
      anchor
    };
    const mappedStatusColors = {
      cranberry,
      green,
      orange
    };
    const statusSharedColorNames = [
      "red",
      "green",
      "darkOrange",
      "yellow",
      "berry",
      "lightGreen",
      "marigold"
    ];
    const personaSharedColorNames = [
      "darkRed",
      "cranberry",
      "pumpkin",
      "peach",
      "gold",
      "brass",
      "brown",
      "forest",
      "seafoam",
      "darkGreen",
      "lightTeal",
      "teal",
      "steel",
      "blue",
      "royalBlue",
      "cornflower",
      "navy",
      "lavender",
      "purple",
      "grape",
      "lilac",
      "pink",
      "magenta",
      "plum",
      "beige",
      "mink",
      "platinum",
      "anchor"
    ];
    const statusColorMapping = {
      success: "green",
      warning: "orange",
      danger: "cranberry"
    };
    const statusColorPaletteTokens$1 = statusSharedColorNames.reduce((acc, sharedColor) => {
      const color2 = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
      const sharedColorTokens = {
        [`colorPalette${color2}Background1`]: statusSharedColors[sharedColor].tint60,
        [`colorPalette${color2}Background2`]: statusSharedColors[sharedColor].tint40,
        [`colorPalette${color2}Background3`]: statusSharedColors[sharedColor].primary,
        [`colorPalette${color2}Foreground1`]: statusSharedColors[sharedColor].shade10,
        [`colorPalette${color2}Foreground2`]: statusSharedColors[sharedColor].shade30,
        [`colorPalette${color2}Foreground3`]: statusSharedColors[sharedColor].primary,
        [`colorPalette${color2}BorderActive`]: statusSharedColors[sharedColor].primary,
        [`colorPalette${color2}Border1`]: statusSharedColors[sharedColor].tint40,
        [`colorPalette${color2}Border2`]: statusSharedColors[sharedColor].primary
      };
      return Object.assign(acc, sharedColorTokens);
    }, {});
    statusColorPaletteTokens$1.colorPaletteYellowForeground1 = statusSharedColors.yellow.shade30;
    statusColorPaletteTokens$1.colorPaletteRedForegroundInverted = statusSharedColors.red.tint20;
    statusColorPaletteTokens$1.colorPaletteGreenForegroundInverted = statusSharedColors.green.tint20;
    statusColorPaletteTokens$1.colorPaletteYellowForegroundInverted = statusSharedColors.yellow.tint40;
    const personaColorPaletteTokens$1 = personaSharedColorNames.reduce((acc, sharedColor) => {
      const color2 = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
      const sharedColorTokens = {
        [`colorPalette${color2}Background2`]: personaSharedColors[sharedColor].tint40,
        [`colorPalette${color2}Foreground2`]: personaSharedColors[sharedColor].shade30,
        [`colorPalette${color2}BorderActive`]: personaSharedColors[sharedColor].primary
      };
      return Object.assign(acc, sharedColorTokens);
    }, {});
    const colorPaletteTokens$1 = {
      ...statusColorPaletteTokens$1,
      ...personaColorPaletteTokens$1
    };
    const colorStatusTokens$1 = Object.entries(statusColorMapping).reduce((acc, [statusColor, sharedColor]) => {
      const color2 = statusColor.slice(0, 1).toUpperCase() + statusColor.slice(1);
      const statusColorTokens = {
        [`colorStatus${color2}Background1`]: mappedStatusColors[sharedColor].tint60,
        [`colorStatus${color2}Background2`]: mappedStatusColors[sharedColor].tint40,
        [`colorStatus${color2}Background3`]: mappedStatusColors[sharedColor].primary,
        [`colorStatus${color2}Foreground1`]: mappedStatusColors[sharedColor].shade10,
        [`colorStatus${color2}Foreground2`]: mappedStatusColors[sharedColor].shade30,
        [`colorStatus${color2}Foreground3`]: mappedStatusColors[sharedColor].primary,
        [`colorStatus${color2}ForegroundInverted`]: mappedStatusColors[sharedColor].tint30,
        [`colorStatus${color2}BorderActive`]: mappedStatusColors[sharedColor].primary,
        [`colorStatus${color2}Border1`]: mappedStatusColors[sharedColor].tint40,
        [`colorStatus${color2}Border2`]: mappedStatusColors[sharedColor].primary
      };
      return Object.assign(acc, statusColorTokens);
    }, {});
    colorStatusTokens$1.colorStatusWarningForeground1 = mappedStatusColors[statusColorMapping.warning].shade20;
    colorStatusTokens$1.colorStatusWarningForeground3 = mappedStatusColors[statusColorMapping.warning].shade20;
    colorStatusTokens$1.colorStatusWarningBorder2 = mappedStatusColors[statusColorMapping.warning].shade20;
    const generateColorTokens$1 = (brand) => ({
      colorNeutralForeground1: grey[14],
      colorNeutralForeground1Hover: grey[14],
      colorNeutralForeground1Pressed: grey[14],
      colorNeutralForeground1Selected: grey[14],
      colorNeutralForeground2: grey[26],
      colorNeutralForeground2Hover: grey[14],
      colorNeutralForeground2Pressed: grey[14],
      colorNeutralForeground2Selected: grey[14],
      colorNeutralForeground2BrandHover: brand[80],
      colorNeutralForeground2BrandPressed: brand[70],
      colorNeutralForeground2BrandSelected: brand[80],
      colorNeutralForeground3: grey[38],
      colorNeutralForeground3Hover: grey[26],
      colorNeutralForeground3Pressed: grey[26],
      colorNeutralForeground3Selected: grey[26],
      colorNeutralForeground3BrandHover: brand[80],
      colorNeutralForeground3BrandPressed: brand[70],
      colorNeutralForeground3BrandSelected: brand[80],
      colorNeutralForeground4: grey[44],
      colorNeutralForegroundDisabled: grey[74],
      colorNeutralForegroundInvertedDisabled: whiteAlpha[40],
      colorBrandForegroundLink: brand[70],
      colorBrandForegroundLinkHover: brand[60],
      colorBrandForegroundLinkPressed: brand[40],
      colorBrandForegroundLinkSelected: brand[70],
      colorNeutralForeground2Link: grey[26],
      colorNeutralForeground2LinkHover: grey[14],
      colorNeutralForeground2LinkPressed: grey[14],
      colorNeutralForeground2LinkSelected: grey[14],
      colorCompoundBrandForeground1: brand[80],
      colorCompoundBrandForeground1Hover: brand[70],
      colorCompoundBrandForeground1Pressed: brand[60],
      colorBrandForeground1: brand[80],
      colorBrandForeground2: brand[70],
      colorBrandForeground2Hover: brand[60],
      colorBrandForeground2Pressed: brand[30],
      colorNeutralForeground1Static: grey[14],
      colorNeutralForegroundStaticInverted: white,
      colorNeutralForegroundInverted: white,
      colorNeutralForegroundInvertedHover: white,
      colorNeutralForegroundInvertedPressed: white,
      colorNeutralForegroundInvertedSelected: white,
      colorNeutralForegroundInverted2: white,
      colorNeutralForegroundOnBrand: white,
      colorNeutralForegroundInvertedLink: white,
      colorNeutralForegroundInvertedLinkHover: white,
      colorNeutralForegroundInvertedLinkPressed: white,
      colorNeutralForegroundInvertedLinkSelected: white,
      colorBrandForegroundInverted: brand[100],
      colorBrandForegroundInvertedHover: brand[110],
      colorBrandForegroundInvertedPressed: brand[100],
      colorBrandForegroundOnLight: brand[80],
      colorBrandForegroundOnLightHover: brand[70],
      colorBrandForegroundOnLightPressed: brand[50],
      colorBrandForegroundOnLightSelected: brand[60],
      colorNeutralBackground1: white,
      colorNeutralBackground1Hover: grey[96],
      colorNeutralBackground1Pressed: grey[88],
      colorNeutralBackground1Selected: grey[92],
      colorNeutralBackground2: grey[98],
      colorNeutralBackground2Hover: grey[94],
      colorNeutralBackground2Pressed: grey[86],
      colorNeutralBackground2Selected: grey[90],
      colorNeutralBackground3: grey[96],
      colorNeutralBackground3Hover: grey[92],
      colorNeutralBackground3Pressed: grey[84],
      colorNeutralBackground3Selected: grey[88],
      colorNeutralBackground4: grey[94],
      colorNeutralBackground4Hover: grey[98],
      colorNeutralBackground4Pressed: grey[96],
      colorNeutralBackground4Selected: white,
      colorNeutralBackground5: grey[92],
      colorNeutralBackground5Hover: grey[96],
      colorNeutralBackground5Pressed: grey[94],
      colorNeutralBackground5Selected: grey[98],
      colorNeutralBackground6: grey[90],
      colorNeutralBackgroundInverted: grey[16],
      colorNeutralBackgroundStatic: grey[20],
      colorNeutralBackgroundAlpha: whiteAlpha[50],
      colorNeutralBackgroundAlpha2: whiteAlpha[80],
      colorSubtleBackground: "transparent",
      colorSubtleBackgroundHover: grey[96],
      colorSubtleBackgroundPressed: grey[88],
      colorSubtleBackgroundSelected: grey[92],
      colorSubtleBackgroundLightAlphaHover: whiteAlpha[70],
      colorSubtleBackgroundLightAlphaPressed: whiteAlpha[50],
      colorSubtleBackgroundLightAlphaSelected: "transparent",
      colorSubtleBackgroundInverted: "transparent",
      colorSubtleBackgroundInvertedHover: blackAlpha[10],
      colorSubtleBackgroundInvertedPressed: blackAlpha[30],
      colorSubtleBackgroundInvertedSelected: blackAlpha[20],
      colorTransparentBackground: "transparent",
      colorTransparentBackgroundHover: "transparent",
      colorTransparentBackgroundPressed: "transparent",
      colorTransparentBackgroundSelected: "transparent",
      colorNeutralBackgroundDisabled: grey[94],
      colorNeutralBackgroundInvertedDisabled: whiteAlpha[10],
      colorNeutralStencil1: grey[90],
      colorNeutralStencil2: grey[98],
      colorNeutralStencil1Alpha: blackAlpha[10],
      colorNeutralStencil2Alpha: blackAlpha[5],
      colorBackgroundOverlay: blackAlpha[40],
      colorScrollbarOverlay: blackAlpha[50],
      colorBrandBackground: brand[80],
      colorBrandBackgroundHover: brand[70],
      colorBrandBackgroundPressed: brand[40],
      colorBrandBackgroundSelected: brand[60],
      colorCompoundBrandBackground: brand[80],
      colorCompoundBrandBackgroundHover: brand[70],
      colorCompoundBrandBackgroundPressed: brand[60],
      colorBrandBackgroundStatic: brand[80],
      colorBrandBackground2: brand[160],
      colorBrandBackground2Hover: brand[150],
      colorBrandBackground2Pressed: brand[130],
      colorBrandBackgroundInverted: white,
      colorBrandBackgroundInvertedHover: brand[160],
      colorBrandBackgroundInvertedPressed: brand[140],
      colorBrandBackgroundInvertedSelected: brand[150],
      colorNeutralStrokeAccessible: grey[38],
      colorNeutralStrokeAccessibleHover: grey[34],
      colorNeutralStrokeAccessiblePressed: grey[30],
      colorNeutralStrokeAccessibleSelected: brand[80],
      colorNeutralStroke1: grey[82],
      colorNeutralStroke1Hover: grey[78],
      colorNeutralStroke1Pressed: grey[70],
      colorNeutralStroke1Selected: grey[74],
      colorNeutralStroke2: grey[88],
      colorNeutralStroke3: grey[94],
      colorNeutralStrokeSubtle: grey[88],
      colorNeutralStrokeOnBrand: white,
      colorNeutralStrokeOnBrand2: white,
      colorNeutralStrokeOnBrand2Hover: white,
      colorNeutralStrokeOnBrand2Pressed: white,
      colorNeutralStrokeOnBrand2Selected: white,
      colorBrandStroke1: brand[80],
      colorBrandStroke2: brand[140],
      colorBrandStroke2Hover: brand[120],
      colorBrandStroke2Pressed: brand[80],
      colorBrandStroke2Contrast: brand[140],
      colorCompoundBrandStroke: brand[80],
      colorCompoundBrandStrokeHover: brand[70],
      colorCompoundBrandStrokePressed: brand[60],
      colorNeutralStrokeDisabled: grey[88],
      colorNeutralStrokeInvertedDisabled: whiteAlpha[40],
      colorTransparentStroke: "transparent",
      colorTransparentStrokeInteractive: "transparent",
      colorTransparentStrokeDisabled: "transparent",
      colorNeutralStrokeAlpha: blackAlpha[5],
      colorNeutralStrokeAlpha2: whiteAlpha[20],
      colorStrokeFocus1: white,
      colorStrokeFocus2: black,
      colorNeutralShadowAmbient: "rgba(0,0,0,0.12)",
      colorNeutralShadowKey: "rgba(0,0,0,0.14)",
      colorNeutralShadowAmbientLighter: "rgba(0,0,0,0.06)",
      colorNeutralShadowKeyLighter: "rgba(0,0,0,0.07)",
      colorNeutralShadowAmbientDarker: "rgba(0,0,0,0.20)",
      colorNeutralShadowKeyDarker: "rgba(0,0,0,0.24)",
      colorBrandShadowAmbient: "rgba(0,0,0,0.30)",
      colorBrandShadowKey: "rgba(0,0,0,0.25)"
    });
    const borderRadius = {
      borderRadiusNone: "0",
      borderRadiusSmall: "2px",
      borderRadiusMedium: "4px",
      borderRadiusLarge: "6px",
      borderRadiusXLarge: "8px",
      borderRadiusCircular: "10000px"
    };
    const curves = {
      curveAccelerateMax: "cubic-bezier(0.9,0.1,1,0.2)",
      curveAccelerateMid: "cubic-bezier(1,0,1,1)",
      curveAccelerateMin: "cubic-bezier(0.8,0,0.78,1)",
      curveDecelerateMax: "cubic-bezier(0.1,0.9,0.2,1)",
      curveDecelerateMid: "cubic-bezier(0,0,0,1)",
      curveDecelerateMin: "cubic-bezier(0.33,0,0.1,1)",
      curveEasyEaseMax: "cubic-bezier(0.8,0,0.2,1)",
      curveEasyEase: "cubic-bezier(0.33,0,0.67,1)",
      curveLinear: "cubic-bezier(0,0,1,1)"
    };
    const durations = {
      durationUltraFast: "50ms",
      durationFaster: "100ms",
      durationFast: "150ms",
      durationNormal: "200ms",
      durationGentle: "250ms",
      durationSlow: "300ms",
      durationSlower: "400ms",
      durationUltraSlow: "500ms"
    };
    const fontSizes = {
      fontSizeBase100: "10px",
      fontSizeBase200: "12px",
      fontSizeBase300: "14px",
      fontSizeBase400: "16px",
      fontSizeBase500: "20px",
      fontSizeBase600: "24px",
      fontSizeHero700: "28px",
      fontSizeHero800: "32px",
      fontSizeHero900: "40px",
      fontSizeHero1000: "68px"
    };
    const lineHeights = {
      lineHeightBase100: "14px",
      lineHeightBase200: "16px",
      lineHeightBase300: "20px",
      lineHeightBase400: "22px",
      lineHeightBase500: "28px",
      lineHeightBase600: "32px",
      lineHeightHero700: "36px",
      lineHeightHero800: "40px",
      lineHeightHero900: "52px",
      lineHeightHero1000: "92px"
    };
    const fontWeights = {
      fontWeightRegular: 400,
      fontWeightMedium: 500,
      fontWeightSemibold: 600,
      fontWeightBold: 700
    };
    const fontFamilies = {
      fontFamilyBase: (
        // eslint-disable-next-line @fluentui/max-len
        "'Segoe UI', 'Segoe UI Web (West European)', -apple-system, BlinkMacSystemFont, Roboto, 'Helvetica Neue', sans-serif"
      ),
      fontFamilyMonospace: "Consolas, 'Courier New', Courier, monospace",
      fontFamilyNumeric: (
        // eslint-disable-next-line @fluentui/max-len
        "Bahnschrift, 'Segoe UI', 'Segoe UI Web (West European)', -apple-system, BlinkMacSystemFont, Roboto, 'Helvetica Neue', sans-serif"
      )
    };
    const spacings = {
      none: "0",
      xxs: "2px",
      xs: "4px",
      sNudge: "6px",
      s: "8px",
      mNudge: "10px",
      m: "12px",
      l: "16px",
      xl: "20px",
      xxl: "24px",
      xxxl: "32px"
    };
    const horizontalSpacings = {
      spacingHorizontalNone: spacings.none,
      spacingHorizontalXXS: spacings.xxs,
      spacingHorizontalXS: spacings.xs,
      spacingHorizontalSNudge: spacings.sNudge,
      spacingHorizontalS: spacings.s,
      spacingHorizontalMNudge: spacings.mNudge,
      spacingHorizontalM: spacings.m,
      spacingHorizontalL: spacings.l,
      spacingHorizontalXL: spacings.xl,
      spacingHorizontalXXL: spacings.xxl,
      spacingHorizontalXXXL: spacings.xxxl
    };
    const verticalSpacings = {
      spacingVerticalNone: spacings.none,
      spacingVerticalXXS: spacings.xxs,
      spacingVerticalXS: spacings.xs,
      spacingVerticalSNudge: spacings.sNudge,
      spacingVerticalS: spacings.s,
      spacingVerticalMNudge: spacings.mNudge,
      spacingVerticalM: spacings.m,
      spacingVerticalL: spacings.l,
      spacingVerticalXL: spacings.xl,
      spacingVerticalXXL: spacings.xxl,
      spacingVerticalXXXL: spacings.xxxl
    };
    const strokeWidths = {
      strokeWidthThin: "1px",
      strokeWidthThick: "2px",
      strokeWidthThicker: "3px",
      strokeWidthThickest: "4px"
    };
    const tokens$1 = {
      // Color tokens
      colorNeutralForeground1: "var(--colorNeutralForeground1)",
      colorNeutralForeground1Hover: "var(--colorNeutralForeground1Hover)",
      colorNeutralForeground1Pressed: "var(--colorNeutralForeground1Pressed)",
      colorNeutralForeground1Selected: "var(--colorNeutralForeground1Selected)",
      colorNeutralForeground2: "var(--colorNeutralForeground2)",
      colorNeutralForeground2Hover: "var(--colorNeutralForeground2Hover)",
      colorNeutralForeground2Pressed: "var(--colorNeutralForeground2Pressed)",
      colorNeutralForeground2Selected: "var(--colorNeutralForeground2Selected)",
      colorNeutralForeground2BrandHover: "var(--colorNeutralForeground2BrandHover)",
      colorNeutralForeground2BrandPressed: "var(--colorNeutralForeground2BrandPressed)",
      colorNeutralForeground2BrandSelected: "var(--colorNeutralForeground2BrandSelected)",
      colorNeutralForeground3: "var(--colorNeutralForeground3)",
      colorNeutralForeground3Hover: "var(--colorNeutralForeground3Hover)",
      colorNeutralForeground3Pressed: "var(--colorNeutralForeground3Pressed)",
      colorNeutralForeground3Selected: "var(--colorNeutralForeground3Selected)",
      colorNeutralForeground3BrandHover: "var(--colorNeutralForeground3BrandHover)",
      colorNeutralForeground3BrandPressed: "var(--colorNeutralForeground3BrandPressed)",
      colorNeutralForeground3BrandSelected: "var(--colorNeutralForeground3BrandSelected)",
      colorNeutralForeground4: "var(--colorNeutralForeground4)",
      colorNeutralForegroundDisabled: "var(--colorNeutralForegroundDisabled)",
      colorBrandForegroundLink: "var(--colorBrandForegroundLink)",
      colorBrandForegroundLinkHover: "var(--colorBrandForegroundLinkHover)",
      colorBrandForegroundLinkPressed: "var(--colorBrandForegroundLinkPressed)",
      colorBrandForegroundLinkSelected: "var(--colorBrandForegroundLinkSelected)",
      colorNeutralForeground2Link: "var(--colorNeutralForeground2Link)",
      colorNeutralForeground2LinkHover: "var(--colorNeutralForeground2LinkHover)",
      colorNeutralForeground2LinkPressed: "var(--colorNeutralForeground2LinkPressed)",
      colorNeutralForeground2LinkSelected: "var(--colorNeutralForeground2LinkSelected)",
      colorCompoundBrandForeground1: "var(--colorCompoundBrandForeground1)",
      colorCompoundBrandForeground1Hover: "var(--colorCompoundBrandForeground1Hover)",
      colorCompoundBrandForeground1Pressed: "var(--colorCompoundBrandForeground1Pressed)",
      colorNeutralForegroundOnBrand: "var(--colorNeutralForegroundOnBrand)",
      colorNeutralForegroundInverted: "var(--colorNeutralForegroundInverted)",
      colorNeutralForegroundInvertedHover: "var(--colorNeutralForegroundInvertedHover)",
      colorNeutralForegroundInvertedPressed: "var(--colorNeutralForegroundInvertedPressed)",
      colorNeutralForegroundInvertedSelected: "var(--colorNeutralForegroundInvertedSelected)",
      colorNeutralForegroundInverted2: "var(--colorNeutralForegroundInverted2)",
      colorNeutralForegroundStaticInverted: "var(--colorNeutralForegroundStaticInverted)",
      colorNeutralForegroundInvertedLink: "var(--colorNeutralForegroundInvertedLink)",
      colorNeutralForegroundInvertedLinkHover: "var(--colorNeutralForegroundInvertedLinkHover)",
      colorNeutralForegroundInvertedLinkPressed: "var(--colorNeutralForegroundInvertedLinkPressed)",
      colorNeutralForegroundInvertedLinkSelected: "var(--colorNeutralForegroundInvertedLinkSelected)",
      colorNeutralForegroundInvertedDisabled: "var(--colorNeutralForegroundInvertedDisabled)",
      colorBrandForeground1: "var(--colorBrandForeground1)",
      colorBrandForeground2: "var(--colorBrandForeground2)",
      colorBrandForeground2Hover: "var(--colorBrandForeground2Hover)",
      colorBrandForeground2Pressed: "var(--colorBrandForeground2Pressed)",
      colorNeutralForeground1Static: "var(--colorNeutralForeground1Static)",
      colorBrandForegroundInverted: "var(--colorBrandForegroundInverted)",
      colorBrandForegroundInvertedHover: "var(--colorBrandForegroundInvertedHover)",
      colorBrandForegroundInvertedPressed: "var(--colorBrandForegroundInvertedPressed)",
      colorBrandForegroundOnLight: "var(--colorBrandForegroundOnLight)",
      colorBrandForegroundOnLightHover: "var(--colorBrandForegroundOnLightHover)",
      colorBrandForegroundOnLightPressed: "var(--colorBrandForegroundOnLightPressed)",
      colorBrandForegroundOnLightSelected: "var(--colorBrandForegroundOnLightSelected)",
      colorNeutralBackground1: "var(--colorNeutralBackground1)",
      colorNeutralBackground1Hover: "var(--colorNeutralBackground1Hover)",
      colorNeutralBackground1Pressed: "var(--colorNeutralBackground1Pressed)",
      colorNeutralBackground1Selected: "var(--colorNeutralBackground1Selected)",
      colorNeutralBackground2: "var(--colorNeutralBackground2)",
      colorNeutralBackground2Hover: "var(--colorNeutralBackground2Hover)",
      colorNeutralBackground2Pressed: "var(--colorNeutralBackground2Pressed)",
      colorNeutralBackground2Selected: "var(--colorNeutralBackground2Selected)",
      colorNeutralBackground3: "var(--colorNeutralBackground3)",
      colorNeutralBackground3Hover: "var(--colorNeutralBackground3Hover)",
      colorNeutralBackground3Pressed: "var(--colorNeutralBackground3Pressed)",
      colorNeutralBackground3Selected: "var(--colorNeutralBackground3Selected)",
      colorNeutralBackground4: "var(--colorNeutralBackground4)",
      colorNeutralBackground4Hover: "var(--colorNeutralBackground4Hover)",
      colorNeutralBackground4Pressed: "var(--colorNeutralBackground4Pressed)",
      colorNeutralBackground4Selected: "var(--colorNeutralBackground4Selected)",
      colorNeutralBackground5: "var(--colorNeutralBackground5)",
      colorNeutralBackground5Hover: "var(--colorNeutralBackground5Hover)",
      colorNeutralBackground5Pressed: "var(--colorNeutralBackground5Pressed)",
      colorNeutralBackground5Selected: "var(--colorNeutralBackground5Selected)",
      colorNeutralBackground6: "var(--colorNeutralBackground6)",
      colorNeutralBackgroundInverted: "var(--colorNeutralBackgroundInverted)",
      colorNeutralBackgroundStatic: "var(--colorNeutralBackgroundStatic)",
      colorNeutralBackgroundAlpha: "var(--colorNeutralBackgroundAlpha)",
      colorNeutralBackgroundAlpha2: "var(--colorNeutralBackgroundAlpha2)",
      colorSubtleBackground: "var(--colorSubtleBackground)",
      colorSubtleBackgroundHover: "var(--colorSubtleBackgroundHover)",
      colorSubtleBackgroundPressed: "var(--colorSubtleBackgroundPressed)",
      colorSubtleBackgroundSelected: "var(--colorSubtleBackgroundSelected)",
      colorSubtleBackgroundLightAlphaHover: "var(--colorSubtleBackgroundLightAlphaHover)",
      colorSubtleBackgroundLightAlphaPressed: "var(--colorSubtleBackgroundLightAlphaPressed)",
      colorSubtleBackgroundLightAlphaSelected: "var(--colorSubtleBackgroundLightAlphaSelected)",
      colorSubtleBackgroundInverted: "var(--colorSubtleBackgroundInverted)",
      colorSubtleBackgroundInvertedHover: "var(--colorSubtleBackgroundInvertedHover)",
      colorSubtleBackgroundInvertedPressed: "var(--colorSubtleBackgroundInvertedPressed)",
      colorSubtleBackgroundInvertedSelected: "var(--colorSubtleBackgroundInvertedSelected)",
      colorTransparentBackground: "var(--colorTransparentBackground)",
      colorTransparentBackgroundHover: "var(--colorTransparentBackgroundHover)",
      colorTransparentBackgroundPressed: "var(--colorTransparentBackgroundPressed)",
      colorTransparentBackgroundSelected: "var(--colorTransparentBackgroundSelected)",
      colorNeutralBackgroundDisabled: "var(--colorNeutralBackgroundDisabled)",
      colorNeutralBackgroundInvertedDisabled: "var(--colorNeutralBackgroundInvertedDisabled)",
      colorNeutralStencil1: "var(--colorNeutralStencil1)",
      colorNeutralStencil2: "var(--colorNeutralStencil2)",
      colorNeutralStencil1Alpha: "var(--colorNeutralStencil1Alpha)",
      colorNeutralStencil2Alpha: "var(--colorNeutralStencil2Alpha)",
      colorBackgroundOverlay: "var(--colorBackgroundOverlay)",
      colorScrollbarOverlay: "var(--colorScrollbarOverlay)",
      colorBrandBackground: "var(--colorBrandBackground)",
      colorBrandBackgroundHover: "var(--colorBrandBackgroundHover)",
      colorBrandBackgroundPressed: "var(--colorBrandBackgroundPressed)",
      colorBrandBackgroundSelected: "var(--colorBrandBackgroundSelected)",
      colorCompoundBrandBackground: "var(--colorCompoundBrandBackground)",
      colorCompoundBrandBackgroundHover: "var(--colorCompoundBrandBackgroundHover)",
      colorCompoundBrandBackgroundPressed: "var(--colorCompoundBrandBackgroundPressed)",
      colorBrandBackgroundStatic: "var(--colorBrandBackgroundStatic)",
      colorBrandBackground2: "var(--colorBrandBackground2)",
      colorBrandBackground2Hover: "var(--colorBrandBackground2Hover)",
      colorBrandBackground2Pressed: "var(--colorBrandBackground2Pressed)",
      colorBrandBackgroundInverted: "var(--colorBrandBackgroundInverted)",
      colorBrandBackgroundInvertedHover: "var(--colorBrandBackgroundInvertedHover)",
      colorBrandBackgroundInvertedPressed: "var(--colorBrandBackgroundInvertedPressed)",
      colorBrandBackgroundInvertedSelected: "var(--colorBrandBackgroundInvertedSelected)",
      colorNeutralStrokeAccessible: "var(--colorNeutralStrokeAccessible)",
      colorNeutralStrokeAccessibleHover: "var(--colorNeutralStrokeAccessibleHover)",
      colorNeutralStrokeAccessiblePressed: "var(--colorNeutralStrokeAccessiblePressed)",
      colorNeutralStrokeAccessibleSelected: "var(--colorNeutralStrokeAccessibleSelected)",
      colorNeutralStroke1: "var(--colorNeutralStroke1)",
      colorNeutralStroke1Hover: "var(--colorNeutralStroke1Hover)",
      colorNeutralStroke1Pressed: "var(--colorNeutralStroke1Pressed)",
      colorNeutralStroke1Selected: "var(--colorNeutralStroke1Selected)",
      colorNeutralStroke2: "var(--colorNeutralStroke2)",
      colorNeutralStroke3: "var(--colorNeutralStroke3)",
      colorNeutralStrokeSubtle: "var(--colorNeutralStrokeSubtle)",
      colorNeutralStrokeOnBrand: "var(--colorNeutralStrokeOnBrand)",
      colorNeutralStrokeOnBrand2: "var(--colorNeutralStrokeOnBrand2)",
      colorNeutralStrokeOnBrand2Hover: "var(--colorNeutralStrokeOnBrand2Hover)",
      colorNeutralStrokeOnBrand2Pressed: "var(--colorNeutralStrokeOnBrand2Pressed)",
      colorNeutralStrokeOnBrand2Selected: "var(--colorNeutralStrokeOnBrand2Selected)",
      colorBrandStroke1: "var(--colorBrandStroke1)",
      colorBrandStroke2: "var(--colorBrandStroke2)",
      colorBrandStroke2Hover: "var(--colorBrandStroke2Hover)",
      colorBrandStroke2Pressed: "var(--colorBrandStroke2Pressed)",
      colorBrandStroke2Contrast: "var(--colorBrandStroke2Contrast)",
      colorCompoundBrandStroke: "var(--colorCompoundBrandStroke)",
      colorCompoundBrandStrokeHover: "var(--colorCompoundBrandStrokeHover)",
      colorCompoundBrandStrokePressed: "var(--colorCompoundBrandStrokePressed)",
      colorNeutralStrokeDisabled: "var(--colorNeutralStrokeDisabled)",
      colorNeutralStrokeInvertedDisabled: "var(--colorNeutralStrokeInvertedDisabled)",
      colorTransparentStroke: "var(--colorTransparentStroke)",
      colorTransparentStrokeInteractive: "var(--colorTransparentStrokeInteractive)",
      colorTransparentStrokeDisabled: "var(--colorTransparentStrokeDisabled)",
      colorNeutralStrokeAlpha: "var(--colorNeutralStrokeAlpha)",
      colorNeutralStrokeAlpha2: "var(--colorNeutralStrokeAlpha2)",
      colorStrokeFocus1: "var(--colorStrokeFocus1)",
      colorStrokeFocus2: "var(--colorStrokeFocus2)",
      colorNeutralShadowAmbient: "var(--colorNeutralShadowAmbient)",
      colorNeutralShadowKey: "var(--colorNeutralShadowKey)",
      colorNeutralShadowAmbientLighter: "var(--colorNeutralShadowAmbientLighter)",
      colorNeutralShadowKeyLighter: "var(--colorNeutralShadowKeyLighter)",
      colorNeutralShadowAmbientDarker: "var(--colorNeutralShadowAmbientDarker)",
      colorNeutralShadowKeyDarker: "var(--colorNeutralShadowKeyDarker)",
      colorBrandShadowAmbient: "var(--colorBrandShadowAmbient)",
      colorBrandShadowKey: "var(--colorBrandShadowKey)",
      // Color palette tokens
      // Color palette red tokens
      colorPaletteRedBackground1: "var(--colorPaletteRedBackground1)",
      colorPaletteRedBackground2: "var(--colorPaletteRedBackground2)",
      colorPaletteRedBackground3: "var(--colorPaletteRedBackground3)",
      colorPaletteRedBorderActive: "var(--colorPaletteRedBorderActive)",
      colorPaletteRedBorder1: "var(--colorPaletteRedBorder1)",
      colorPaletteRedBorder2: "var(--colorPaletteRedBorder2)",
      colorPaletteRedForeground1: "var(--colorPaletteRedForeground1)",
      colorPaletteRedForeground2: "var(--colorPaletteRedForeground2)",
      colorPaletteRedForeground3: "var(--colorPaletteRedForeground3)",
      colorPaletteRedForegroundInverted: "var(--colorPaletteRedForegroundInverted)",
      // Color palette green tokens
      colorPaletteGreenBackground1: "var(--colorPaletteGreenBackground1)",
      colorPaletteGreenBackground2: "var(--colorPaletteGreenBackground2)",
      colorPaletteGreenBackground3: "var(--colorPaletteGreenBackground3)",
      colorPaletteGreenBorderActive: "var(--colorPaletteGreenBorderActive)",
      colorPaletteGreenBorder1: "var(--colorPaletteGreenBorder1)",
      colorPaletteGreenBorder2: "var(--colorPaletteGreenBorder2)",
      colorPaletteGreenForeground1: "var(--colorPaletteGreenForeground1)",
      colorPaletteGreenForeground2: "var(--colorPaletteGreenForeground2)",
      colorPaletteGreenForeground3: "var(--colorPaletteGreenForeground3)",
      colorPaletteGreenForegroundInverted: "var(--colorPaletteGreenForegroundInverted)",
      // Color palette dark orange tokens
      colorPaletteDarkOrangeBackground1: "var(--colorPaletteDarkOrangeBackground1)",
      colorPaletteDarkOrangeBackground2: "var(--colorPaletteDarkOrangeBackground2)",
      colorPaletteDarkOrangeBackground3: "var(--colorPaletteDarkOrangeBackground3)",
      colorPaletteDarkOrangeBorderActive: "var(--colorPaletteDarkOrangeBorderActive)",
      colorPaletteDarkOrangeBorder1: "var(--colorPaletteDarkOrangeBorder1)",
      colorPaletteDarkOrangeBorder2: "var(--colorPaletteDarkOrangeBorder2)",
      colorPaletteDarkOrangeForeground1: "var(--colorPaletteDarkOrangeForeground1)",
      colorPaletteDarkOrangeForeground2: "var(--colorPaletteDarkOrangeForeground2)",
      colorPaletteDarkOrangeForeground3: "var(--colorPaletteDarkOrangeForeground3)",
      // Color palette yellow tokens
      colorPaletteYellowBackground1: "var(--colorPaletteYellowBackground1)",
      colorPaletteYellowBackground2: "var(--colorPaletteYellowBackground2)",
      colorPaletteYellowBackground3: "var(--colorPaletteYellowBackground3)",
      colorPaletteYellowBorderActive: "var(--colorPaletteYellowBorderActive)",
      colorPaletteYellowBorder1: "var(--colorPaletteYellowBorder1)",
      colorPaletteYellowBorder2: "var(--colorPaletteYellowBorder2)",
      colorPaletteYellowForeground1: "var(--colorPaletteYellowForeground1)",
      colorPaletteYellowForeground2: "var(--colorPaletteYellowForeground2)",
      colorPaletteYellowForeground3: "var(--colorPaletteYellowForeground3)",
      colorPaletteYellowForegroundInverted: "var(--colorPaletteYellowForegroundInverted)",
      // Color palette berry tokens
      colorPaletteBerryBackground1: "var(--colorPaletteBerryBackground1)",
      colorPaletteBerryBackground2: "var(--colorPaletteBerryBackground2)",
      colorPaletteBerryBackground3: "var(--colorPaletteBerryBackground3)",
      colorPaletteBerryBorderActive: "var(--colorPaletteBerryBorderActive)",
      colorPaletteBerryBorder1: "var(--colorPaletteBerryBorder1)",
      colorPaletteBerryBorder2: "var(--colorPaletteBerryBorder2)",
      colorPaletteBerryForeground1: "var(--colorPaletteBerryForeground1)",
      colorPaletteBerryForeground2: "var(--colorPaletteBerryForeground2)",
      colorPaletteBerryForeground3: "var(--colorPaletteBerryForeground3)",
      // Color palette marigold tokens
      colorPaletteMarigoldBackground1: "var(--colorPaletteMarigoldBackground1)",
      colorPaletteMarigoldBackground2: "var(--colorPaletteMarigoldBackground2)",
      colorPaletteMarigoldBackground3: "var(--colorPaletteMarigoldBackground3)",
      colorPaletteMarigoldBorderActive: "var(--colorPaletteMarigoldBorderActive)",
      colorPaletteMarigoldBorder1: "var(--colorPaletteMarigoldBorder1)",
      colorPaletteMarigoldBorder2: "var(--colorPaletteMarigoldBorder2)",
      colorPaletteMarigoldForeground1: "var(--colorPaletteMarigoldForeground1)",
      colorPaletteMarigoldForeground2: "var(--colorPaletteMarigoldForeground2)",
      colorPaletteMarigoldForeground3: "var(--colorPaletteMarigoldForeground3)",
      // Color palette light green tokens
      colorPaletteLightGreenBackground1: "var(--colorPaletteLightGreenBackground1)",
      colorPaletteLightGreenBackground2: "var(--colorPaletteLightGreenBackground2)",
      colorPaletteLightGreenBackground3: "var(--colorPaletteLightGreenBackground3)",
      colorPaletteLightGreenBorderActive: "var(--colorPaletteLightGreenBorderActive)",
      colorPaletteLightGreenBorder1: "var(--colorPaletteLightGreenBorder1)",
      colorPaletteLightGreenBorder2: "var(--colorPaletteLightGreenBorder2)",
      colorPaletteLightGreenForeground1: "var(--colorPaletteLightGreenForeground1)",
      colorPaletteLightGreenForeground2: "var(--colorPaletteLightGreenForeground2)",
      colorPaletteLightGreenForeground3: "var(--colorPaletteLightGreenForeground3)",
      // Color palette anchor tokens
      colorPaletteAnchorBackground2: "var(--colorPaletteAnchorBackground2)",
      colorPaletteAnchorBorderActive: "var(--colorPaletteAnchorBorderActive)",
      colorPaletteAnchorForeground2: "var(--colorPaletteAnchorForeground2)",
      // Color palette beige tokens
      colorPaletteBeigeBackground2: "var(--colorPaletteBeigeBackground2)",
      colorPaletteBeigeBorderActive: "var(--colorPaletteBeigeBorderActive)",
      colorPaletteBeigeForeground2: "var(--colorPaletteBeigeForeground2)",
      // Color palette blue tokens
      colorPaletteBlueBackground2: "var(--colorPaletteBlueBackground2)",
      colorPaletteBlueBorderActive: "var(--colorPaletteBlueBorderActive)",
      colorPaletteBlueForeground2: "var(--colorPaletteBlueForeground2)",
      // Color palette brass tokens
      colorPaletteBrassBackground2: "var(--colorPaletteBrassBackground2)",
      colorPaletteBrassBorderActive: "var(--colorPaletteBrassBorderActive)",
      colorPaletteBrassForeground2: "var(--colorPaletteBrassForeground2)",
      // Color palette brown tokens
      colorPaletteBrownBackground2: "var(--colorPaletteBrownBackground2)",
      colorPaletteBrownBorderActive: "var(--colorPaletteBrownBorderActive)",
      colorPaletteBrownForeground2: "var(--colorPaletteBrownForeground2)",
      // Color palette cornflower tokens
      colorPaletteCornflowerBackground2: "var(--colorPaletteCornflowerBackground2)",
      colorPaletteCornflowerBorderActive: "var(--colorPaletteCornflowerBorderActive)",
      colorPaletteCornflowerForeground2: "var(--colorPaletteCornflowerForeground2)",
      // Color palette cranberry tokens
      colorPaletteCranberryBackground2: "var(--colorPaletteCranberryBackground2)",
      colorPaletteCranberryBorderActive: "var(--colorPaletteCranberryBorderActive)",
      colorPaletteCranberryForeground2: "var(--colorPaletteCranberryForeground2)",
      // Color palette dark green tokens
      colorPaletteDarkGreenBackground2: "var(--colorPaletteDarkGreenBackground2)",
      colorPaletteDarkGreenBorderActive: "var(--colorPaletteDarkGreenBorderActive)",
      colorPaletteDarkGreenForeground2: "var(--colorPaletteDarkGreenForeground2)",
      // Color palette dark red tokens
      colorPaletteDarkRedBackground2: "var(--colorPaletteDarkRedBackground2)",
      colorPaletteDarkRedBorderActive: "var(--colorPaletteDarkRedBorderActive)",
      colorPaletteDarkRedForeground2: "var(--colorPaletteDarkRedForeground2)",
      // Color palette forest tokens
      colorPaletteForestBackground2: "var(--colorPaletteForestBackground2)",
      colorPaletteForestBorderActive: "var(--colorPaletteForestBorderActive)",
      colorPaletteForestForeground2: "var(--colorPaletteForestForeground2)",
      // Color palette gold tokens
      colorPaletteGoldBackground2: "var(--colorPaletteGoldBackground2)",
      colorPaletteGoldBorderActive: "var(--colorPaletteGoldBorderActive)",
      colorPaletteGoldForeground2: "var(--colorPaletteGoldForeground2)",
      // Color palette grape tokens
      colorPaletteGrapeBackground2: "var(--colorPaletteGrapeBackground2)",
      colorPaletteGrapeBorderActive: "var(--colorPaletteGrapeBorderActive)",
      colorPaletteGrapeForeground2: "var(--colorPaletteGrapeForeground2)",
      // Color palette lavender tokens
      colorPaletteLavenderBackground2: "var(--colorPaletteLavenderBackground2)",
      colorPaletteLavenderBorderActive: "var(--colorPaletteLavenderBorderActive)",
      colorPaletteLavenderForeground2: "var(--colorPaletteLavenderForeground2)",
      // Color palette light teal tokens
      colorPaletteLightTealBackground2: "var(--colorPaletteLightTealBackground2)",
      colorPaletteLightTealBorderActive: "var(--colorPaletteLightTealBorderActive)",
      colorPaletteLightTealForeground2: "var(--colorPaletteLightTealForeground2)",
      // Color palette lilac tokens
      colorPaletteLilacBackground2: "var(--colorPaletteLilacBackground2)",
      colorPaletteLilacBorderActive: "var(--colorPaletteLilacBorderActive)",
      colorPaletteLilacForeground2: "var(--colorPaletteLilacForeground2)",
      // Color palette magenta tokens
      colorPaletteMagentaBackground2: "var(--colorPaletteMagentaBackground2)",
      colorPaletteMagentaBorderActive: "var(--colorPaletteMagentaBorderActive)",
      colorPaletteMagentaForeground2: "var(--colorPaletteMagentaForeground2)",
      // Color palette mink tokens
      colorPaletteMinkBackground2: "var(--colorPaletteMinkBackground2)",
      colorPaletteMinkBorderActive: "var(--colorPaletteMinkBorderActive)",
      colorPaletteMinkForeground2: "var(--colorPaletteMinkForeground2)",
      // Color palette navy tokens
      colorPaletteNavyBackground2: "var(--colorPaletteNavyBackground2)",
      colorPaletteNavyBorderActive: "var(--colorPaletteNavyBorderActive)",
      colorPaletteNavyForeground2: "var(--colorPaletteNavyForeground2)",
      // Color palette peach tokens
      colorPalettePeachBackground2: "var(--colorPalettePeachBackground2)",
      colorPalettePeachBorderActive: "var(--colorPalettePeachBorderActive)",
      colorPalettePeachForeground2: "var(--colorPalettePeachForeground2)",
      // Color palette pink tokens
      colorPalettePinkBackground2: "var(--colorPalettePinkBackground2)",
      colorPalettePinkBorderActive: "var(--colorPalettePinkBorderActive)",
      colorPalettePinkForeground2: "var(--colorPalettePinkForeground2)",
      // Color palette platinum tokens
      colorPalettePlatinumBackground2: "var(--colorPalettePlatinumBackground2)",
      colorPalettePlatinumBorderActive: "var(--colorPalettePlatinumBorderActive)",
      colorPalettePlatinumForeground2: "var(--colorPalettePlatinumForeground2)",
      // Color palette plum tokens
      colorPalettePlumBackground2: "var(--colorPalettePlumBackground2)",
      colorPalettePlumBorderActive: "var(--colorPalettePlumBorderActive)",
      colorPalettePlumForeground2: "var(--colorPalettePlumForeground2)",
      // Color palette pumpkin tokens
      colorPalettePumpkinBackground2: "var(--colorPalettePumpkinBackground2)",
      colorPalettePumpkinBorderActive: "var(--colorPalettePumpkinBorderActive)",
      colorPalettePumpkinForeground2: "var(--colorPalettePumpkinForeground2)",
      // Color palette purple tokens
      colorPalettePurpleBackground2: "var(--colorPalettePurpleBackground2)",
      colorPalettePurpleBorderActive: "var(--colorPalettePurpleBorderActive)",
      colorPalettePurpleForeground2: "var(--colorPalettePurpleForeground2)",
      // Color palette royal blue tokens
      colorPaletteRoyalBlueBackground2: "var(--colorPaletteRoyalBlueBackground2)",
      colorPaletteRoyalBlueBorderActive: "var(--colorPaletteRoyalBlueBorderActive)",
      colorPaletteRoyalBlueForeground2: "var(--colorPaletteRoyalBlueForeground2)",
      // Color palette seafoam tokens
      colorPaletteSeafoamBackground2: "var(--colorPaletteSeafoamBackground2)",
      colorPaletteSeafoamBorderActive: "var(--colorPaletteSeafoamBorderActive)",
      colorPaletteSeafoamForeground2: "var(--colorPaletteSeafoamForeground2)",
      // Color palette steel tokens
      colorPaletteSteelBackground2: "var(--colorPaletteSteelBackground2)",
      colorPaletteSteelBorderActive: "var(--colorPaletteSteelBorderActive)",
      colorPaletteSteelForeground2: "var(--colorPaletteSteelForeground2)",
      // Color palette teal tokens
      colorPaletteTealBackground2: "var(--colorPaletteTealBackground2)",
      colorPaletteTealBorderActive: "var(--colorPaletteTealBorderActive)",
      colorPaletteTealForeground2: "var(--colorPaletteTealForeground2)",
      // Color status success tokens
      colorStatusSuccessBackground1: "var(--colorStatusSuccessBackground1)",
      colorStatusSuccessBackground2: "var(--colorStatusSuccessBackground2)",
      colorStatusSuccessBackground3: "var(--colorStatusSuccessBackground3)",
      colorStatusSuccessForeground1: "var(--colorStatusSuccessForeground1)",
      colorStatusSuccessForeground2: "var(--colorStatusSuccessForeground2)",
      colorStatusSuccessForeground3: "var(--colorStatusSuccessForeground3)",
      colorStatusSuccessForegroundInverted: "var(--colorStatusSuccessForegroundInverted)",
      colorStatusSuccessBorderActive: "var(--colorStatusSuccessBorderActive)",
      colorStatusSuccessBorder1: "var(--colorStatusSuccessBorder1)",
      colorStatusSuccessBorder2: "var(--colorStatusSuccessBorder2)",
      // Color status warning tokens
      colorStatusWarningBackground1: "var(--colorStatusWarningBackground1)",
      colorStatusWarningBackground2: "var(--colorStatusWarningBackground2)",
      colorStatusWarningBackground3: "var(--colorStatusWarningBackground3)",
      colorStatusWarningForeground1: "var(--colorStatusWarningForeground1)",
      colorStatusWarningForeground2: "var(--colorStatusWarningForeground2)",
      colorStatusWarningForeground3: "var(--colorStatusWarningForeground3)",
      colorStatusWarningForegroundInverted: "var(--colorStatusWarningForegroundInverted)",
      colorStatusWarningBorderActive: "var(--colorStatusWarningBorderActive)",
      colorStatusWarningBorder1: "var(--colorStatusWarningBorder1)",
      colorStatusWarningBorder2: "var(--colorStatusWarningBorder2)",
      // Color status danger tokens
      colorStatusDangerBackground1: "var(--colorStatusDangerBackground1)",
      colorStatusDangerBackground2: "var(--colorStatusDangerBackground2)",
      colorStatusDangerBackground3: "var(--colorStatusDangerBackground3)",
      colorStatusDangerForeground1: "var(--colorStatusDangerForeground1)",
      colorStatusDangerForeground2: "var(--colorStatusDangerForeground2)",
      colorStatusDangerForeground3: "var(--colorStatusDangerForeground3)",
      colorStatusDangerForegroundInverted: "var(--colorStatusDangerForegroundInverted)",
      colorStatusDangerBorderActive: "var(--colorStatusDangerBorderActive)",
      colorStatusDangerBorder1: "var(--colorStatusDangerBorder1)",
      colorStatusDangerBorder2: "var(--colorStatusDangerBorder2)",
      // Border radius tokens
      borderRadiusNone: "var(--borderRadiusNone)",
      borderRadiusSmall: "var(--borderRadiusSmall)",
      borderRadiusMedium: "var(--borderRadiusMedium)",
      borderRadiusLarge: "var(--borderRadiusLarge)",
      borderRadiusXLarge: "var(--borderRadiusXLarge)",
      borderRadiusCircular: "var(--borderRadiusCircular)",
      // Font family tokens
      fontFamilyBase: "var(--fontFamilyBase)",
      fontFamilyMonospace: "var(--fontFamilyMonospace)",
      fontFamilyNumeric: "var(--fontFamilyNumeric)",
      // Font size tokens
      fontSizeBase100: "var(--fontSizeBase100)",
      fontSizeBase200: "var(--fontSizeBase200)",
      fontSizeBase300: "var(--fontSizeBase300)",
      fontSizeBase400: "var(--fontSizeBase400)",
      fontSizeBase500: "var(--fontSizeBase500)",
      fontSizeBase600: "var(--fontSizeBase600)",
      fontSizeHero700: "var(--fontSizeHero700)",
      fontSizeHero800: "var(--fontSizeHero800)",
      fontSizeHero900: "var(--fontSizeHero900)",
      fontSizeHero1000: "var(--fontSizeHero1000)",
      // Font weight tokens
      fontWeightRegular: "var(--fontWeightRegular)",
      fontWeightMedium: "var(--fontWeightMedium)",
      fontWeightSemibold: "var(--fontWeightSemibold)",
      fontWeightBold: "var(--fontWeightBold)",
      // Line height tokens
      lineHeightBase100: "var(--lineHeightBase100)",
      lineHeightBase200: "var(--lineHeightBase200)",
      lineHeightBase300: "var(--lineHeightBase300)",
      lineHeightBase400: "var(--lineHeightBase400)",
      lineHeightBase500: "var(--lineHeightBase500)",
      lineHeightBase600: "var(--lineHeightBase600)",
      lineHeightHero700: "var(--lineHeightHero700)",
      lineHeightHero800: "var(--lineHeightHero800)",
      lineHeightHero900: "var(--lineHeightHero900)",
      lineHeightHero1000: "var(--lineHeightHero1000)",
      // Shadow tokens
      shadow2: "var(--shadow2)",
      shadow4: "var(--shadow4)",
      shadow8: "var(--shadow8)",
      shadow16: "var(--shadow16)",
      shadow28: "var(--shadow28)",
      shadow64: "var(--shadow64)",
      // Shadow brand tokens
      shadow2Brand: "var(--shadow2Brand)",
      shadow4Brand: "var(--shadow4Brand)",
      shadow8Brand: "var(--shadow8Brand)",
      shadow16Brand: "var(--shadow16Brand)",
      shadow28Brand: "var(--shadow28Brand)",
      shadow64Brand: "var(--shadow64Brand)",
      // Stroke width tokens
      strokeWidthThin: "var(--strokeWidthThin)",
      strokeWidthThick: "var(--strokeWidthThick)",
      strokeWidthThicker: "var(--strokeWidthThicker)",
      strokeWidthThickest: "var(--strokeWidthThickest)",
      // Spacings
      spacingHorizontalNone: "var(--spacingHorizontalNone)",
      spacingHorizontalXXS: "var(--spacingHorizontalXXS)",
      spacingHorizontalXS: "var(--spacingHorizontalXS)",
      spacingHorizontalSNudge: "var(--spacingHorizontalSNudge)",
      spacingHorizontalS: "var(--spacingHorizontalS)",
      spacingHorizontalMNudge: "var(--spacingHorizontalMNudge)",
      spacingHorizontalM: "var(--spacingHorizontalM)",
      spacingHorizontalL: "var(--spacingHorizontalL)",
      spacingHorizontalXL: "var(--spacingHorizontalXL)",
      spacingHorizontalXXL: "var(--spacingHorizontalXXL)",
      spacingHorizontalXXXL: "var(--spacingHorizontalXXXL)",
      spacingVerticalNone: "var(--spacingVerticalNone)",
      spacingVerticalXXS: "var(--spacingVerticalXXS)",
      spacingVerticalXS: "var(--spacingVerticalXS)",
      spacingVerticalSNudge: "var(--spacingVerticalSNudge)",
      spacingVerticalS: "var(--spacingVerticalS)",
      spacingVerticalMNudge: "var(--spacingVerticalMNudge)",
      spacingVerticalM: "var(--spacingVerticalM)",
      spacingVerticalL: "var(--spacingVerticalL)",
      spacingVerticalXL: "var(--spacingVerticalXL)",
      spacingVerticalXXL: "var(--spacingVerticalXXL)",
      spacingVerticalXXXL: "var(--spacingVerticalXXXL)",
      // Durations
      durationUltraFast: "var(--durationUltraFast)",
      durationFaster: "var(--durationFaster)",
      durationFast: "var(--durationFast)",
      durationNormal: "var(--durationNormal)",
      durationGentle: "var(--durationGentle)",
      durationSlow: "var(--durationSlow)",
      durationSlower: "var(--durationSlower)",
      durationUltraSlow: "var(--durationUltraSlow)",
      // Curves
      curveAccelerateMax: "var(--curveAccelerateMax)",
      curveAccelerateMid: "var(--curveAccelerateMid)",
      curveAccelerateMin: "var(--curveAccelerateMin)",
      curveDecelerateMax: "var(--curveDecelerateMax)",
      curveDecelerateMid: "var(--curveDecelerateMid)",
      curveDecelerateMin: "var(--curveDecelerateMin)",
      curveEasyEaseMax: "var(--curveEasyEaseMax)",
      curveEasyEase: "var(--curveEasyEase)",
      curveLinear: "var(--curveLinear)"
    };
    function createShadowTokens(ambientColor, keyColor, tokenSuffix = "") {
      return {
        [`shadow2${tokenSuffix}`]: `0 0 2px ${ambientColor}, 0 1px 2px ${keyColor}`,
        [`shadow4${tokenSuffix}`]: `0 0 2px ${ambientColor}, 0 2px 4px ${keyColor}`,
        [`shadow8${tokenSuffix}`]: `0 0 2px ${ambientColor}, 0 4px 8px ${keyColor}`,
        [`shadow16${tokenSuffix}`]: `0 0 2px ${ambientColor}, 0 8px 16px ${keyColor}`,
        [`shadow28${tokenSuffix}`]: `0 0 8px ${ambientColor}, 0 14px 28px ${keyColor}`,
        [`shadow64${tokenSuffix}`]: `0 0 8px ${ambientColor}, 0 32px 64px ${keyColor}`
      };
    }
    const createLightTheme = (brand) => {
      const colorTokens = generateColorTokens$1(brand);
      return {
        ...borderRadius,
        ...fontSizes,
        ...lineHeights,
        ...fontFamilies,
        ...fontWeights,
        ...strokeWidths,
        ...horizontalSpacings,
        ...verticalSpacings,
        ...durations,
        ...curves,
        ...colorTokens,
        ...colorPaletteTokens$1,
        ...colorStatusTokens$1,
        ...createShadowTokens(colorTokens.colorNeutralShadowAmbient, colorTokens.colorNeutralShadowKey),
        ...createShadowTokens(colorTokens.colorBrandShadowAmbient, colorTokens.colorBrandShadowKey, "Brand")
      };
    };
    const brandTeams = {
      10: `#2b2b40`,
      20: `#2f2f4a`,
      30: `#333357`,
      40: `#383966`,
      50: `#3d3e78`,
      60: `#444791`,
      70: `#4f52b2`,
      80: `#5b5fc7`,
      90: `#7579eb`,
      100: `#7f85f5`,
      110: `#9299f7`,
      120: `#aab1fa`,
      130: `#b6bcfa`,
      140: `#c5cbfa`,
      150: `#dce0fa`,
      160: `#e8ebfa`
    };
    const teamsLightTheme = createLightTheme(brandTeams);
    const statusColorPaletteTokens = statusSharedColorNames.reduce((acc, sharedColor) => {
      const color2 = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
      const sharedColorTokens = {
        [`colorPalette${color2}Background1`]: statusSharedColors[sharedColor].shade40,
        [`colorPalette${color2}Background2`]: statusSharedColors[sharedColor].shade30,
        [`colorPalette${color2}Background3`]: statusSharedColors[sharedColor].primary,
        [`colorPalette${color2}Foreground1`]: statusSharedColors[sharedColor].tint30,
        [`colorPalette${color2}Foreground2`]: statusSharedColors[sharedColor].tint40,
        [`colorPalette${color2}Foreground3`]: statusSharedColors[sharedColor].tint20,
        [`colorPalette${color2}BorderActive`]: statusSharedColors[sharedColor].tint30,
        [`colorPalette${color2}Border1`]: statusSharedColors[sharedColor].primary,
        [`colorPalette${color2}Border2`]: statusSharedColors[sharedColor].tint20
      };
      return Object.assign(acc, sharedColorTokens);
    }, {});
    statusColorPaletteTokens.colorPaletteRedForeground3 = statusSharedColors.red.tint30;
    statusColorPaletteTokens.colorPaletteRedBorder2 = statusSharedColors.red.tint30;
    statusColorPaletteTokens.colorPaletteGreenForeground3 = statusSharedColors.green.tint40;
    statusColorPaletteTokens.colorPaletteGreenBorder2 = statusSharedColors.green.tint40;
    statusColorPaletteTokens.colorPaletteDarkOrangeForeground3 = statusSharedColors.darkOrange.tint30;
    statusColorPaletteTokens.colorPaletteDarkOrangeBorder2 = statusSharedColors.darkOrange.tint30;
    statusColorPaletteTokens.colorPaletteRedForegroundInverted = statusSharedColors.red.primary;
    statusColorPaletteTokens.colorPaletteGreenForegroundInverted = statusSharedColors.green.primary;
    statusColorPaletteTokens.colorPaletteYellowForegroundInverted = statusSharedColors.yellow.shade30;
    const personaColorPaletteTokens = personaSharedColorNames.reduce((acc, sharedColor) => {
      const color2 = sharedColor.slice(0, 1).toUpperCase() + sharedColor.slice(1);
      const sharedColorTokens = {
        [`colorPalette${color2}Background2`]: personaSharedColors[sharedColor].shade30,
        [`colorPalette${color2}Foreground2`]: personaSharedColors[sharedColor].tint40,
        [`colorPalette${color2}BorderActive`]: personaSharedColors[sharedColor].tint30
      };
      return Object.assign(acc, sharedColorTokens);
    }, {});
    personaColorPaletteTokens.colorPaletteDarkRedBackground2 = personaSharedColors.darkRed.shade20;
    personaColorPaletteTokens.colorPalettePlumBackground2 = personaSharedColors.plum.shade20;
    const colorPaletteTokens = {
      ...statusColorPaletteTokens,
      ...personaColorPaletteTokens
    };
    const colorStatusTokens = Object.entries(statusColorMapping).reduce((acc, [statusColor, sharedColor]) => {
      const color2 = statusColor.slice(0, 1).toUpperCase() + statusColor.slice(1);
      const statusColorTokens = {
        [`colorStatus${color2}Background1`]: mappedStatusColors[sharedColor].shade40,
        [`colorStatus${color2}Background2`]: mappedStatusColors[sharedColor].shade30,
        [`colorStatus${color2}Background3`]: mappedStatusColors[sharedColor].primary,
        [`colorStatus${color2}Foreground1`]: mappedStatusColors[sharedColor].tint30,
        [`colorStatus${color2}Foreground2`]: mappedStatusColors[sharedColor].tint40,
        [`colorStatus${color2}Foreground3`]: mappedStatusColors[sharedColor].tint20,
        [`colorStatus${color2}BorderActive`]: mappedStatusColors[sharedColor].tint30,
        [`colorStatus${color2}ForegroundInverted`]: mappedStatusColors[sharedColor].shade10,
        [`colorStatus${color2}Border1`]: mappedStatusColors[sharedColor].primary,
        [`colorStatus${color2}Border2`]: mappedStatusColors[sharedColor].tint20
      };
      return Object.assign(acc, statusColorTokens);
    }, {});
    colorStatusTokens.colorStatusDangerForeground3 = mappedStatusColors[statusColorMapping.danger].tint30;
    colorStatusTokens.colorStatusDangerBorder2 = mappedStatusColors[statusColorMapping.danger].tint30;
    colorStatusTokens.colorStatusSuccessForeground3 = mappedStatusColors[statusColorMapping.success].tint40;
    colorStatusTokens.colorStatusSuccessBorder2 = mappedStatusColors[statusColorMapping.success].tint40;
    colorStatusTokens.colorStatusWarningForegroundInverted = mappedStatusColors[statusColorMapping.warning].shade20;
    const generateColorTokens = (brand) => ({
      colorNeutralForeground1: white,
      colorNeutralForeground1Hover: white,
      colorNeutralForeground1Pressed: white,
      colorNeutralForeground1Selected: white,
      colorNeutralForeground2: grey[84],
      colorNeutralForeground2Hover: white,
      colorNeutralForeground2Pressed: white,
      colorNeutralForeground2Selected: white,
      colorNeutralForeground2BrandHover: brand[100],
      colorNeutralForeground2BrandPressed: brand[90],
      colorNeutralForeground2BrandSelected: brand[100],
      colorNeutralForeground3: grey[68],
      colorNeutralForeground3Hover: grey[84],
      colorNeutralForeground3Pressed: grey[84],
      colorNeutralForeground3Selected: grey[84],
      colorNeutralForeground3BrandHover: brand[100],
      colorNeutralForeground3BrandPressed: brand[90],
      colorNeutralForeground3BrandSelected: brand[100],
      colorNeutralForeground4: grey[60],
      colorNeutralForegroundDisabled: grey[36],
      colorNeutralForegroundInvertedDisabled: whiteAlpha[40],
      colorBrandForegroundLink: brand[100],
      colorBrandForegroundLinkHover: brand[110],
      colorBrandForegroundLinkPressed: brand[90],
      colorBrandForegroundLinkSelected: brand[100],
      colorNeutralForeground2Link: grey[84],
      colorNeutralForeground2LinkHover: white,
      colorNeutralForeground2LinkPressed: white,
      colorNeutralForeground2LinkSelected: white,
      colorCompoundBrandForeground1: brand[100],
      colorCompoundBrandForeground1Hover: brand[110],
      colorCompoundBrandForeground1Pressed: brand[90],
      colorBrandForeground1: brand[100],
      colorBrandForeground2: brand[120],
      colorBrandForeground2Hover: brand[130],
      colorBrandForeground2Pressed: brand[160],
      colorNeutralForeground1Static: grey[14],
      colorNeutralForegroundStaticInverted: white,
      colorNeutralForegroundInverted: grey[14],
      colorNeutralForegroundInvertedHover: grey[14],
      colorNeutralForegroundInvertedPressed: grey[14],
      colorNeutralForegroundInvertedSelected: grey[14],
      colorNeutralForegroundInverted2: grey[14],
      colorNeutralForegroundOnBrand: white,
      colorNeutralForegroundInvertedLink: white,
      colorNeutralForegroundInvertedLinkHover: white,
      colorNeutralForegroundInvertedLinkPressed: white,
      colorNeutralForegroundInvertedLinkSelected: white,
      colorBrandForegroundInverted: brand[80],
      colorBrandForegroundInvertedHover: brand[70],
      colorBrandForegroundInvertedPressed: brand[60],
      colorBrandForegroundOnLight: brand[80],
      colorBrandForegroundOnLightHover: brand[70],
      colorBrandForegroundOnLightPressed: brand[50],
      colorBrandForegroundOnLightSelected: brand[60],
      colorNeutralBackground1: grey[16],
      colorNeutralBackground1Hover: grey[24],
      colorNeutralBackground1Pressed: grey[12],
      colorNeutralBackground1Selected: grey[22],
      colorNeutralBackground2: grey[14],
      colorNeutralBackground2Hover: grey[22],
      colorNeutralBackground2Pressed: grey[10],
      colorNeutralBackground2Selected: grey[20],
      colorNeutralBackground3: grey[12],
      colorNeutralBackground3Hover: grey[20],
      colorNeutralBackground3Pressed: grey[8],
      colorNeutralBackground3Selected: grey[18],
      colorNeutralBackground4: grey[8],
      colorNeutralBackground4Hover: grey[16],
      colorNeutralBackground4Pressed: grey[4],
      colorNeutralBackground4Selected: grey[14],
      colorNeutralBackground5: grey[4],
      colorNeutralBackground5Hover: grey[12],
      colorNeutralBackground5Pressed: black,
      colorNeutralBackground5Selected: grey[10],
      colorNeutralBackground6: grey[20],
      colorNeutralBackgroundInverted: white,
      colorNeutralBackgroundStatic: grey[24],
      colorNeutralBackgroundAlpha: grey10Alpha[50],
      colorNeutralBackgroundAlpha2: grey12Alpha[70],
      colorSubtleBackground: "transparent",
      colorSubtleBackgroundHover: grey[22],
      colorSubtleBackgroundPressed: grey[18],
      colorSubtleBackgroundSelected: grey[20],
      colorSubtleBackgroundLightAlphaHover: grey14Alpha[80],
      colorSubtleBackgroundLightAlphaPressed: grey14Alpha[50],
      colorSubtleBackgroundLightAlphaSelected: "transparent",
      colorSubtleBackgroundInverted: "transparent",
      colorSubtleBackgroundInvertedHover: blackAlpha[10],
      colorSubtleBackgroundInvertedPressed: blackAlpha[30],
      colorSubtleBackgroundInvertedSelected: blackAlpha[20],
      colorTransparentBackground: "transparent",
      colorTransparentBackgroundHover: "transparent",
      colorTransparentBackgroundPressed: "transparent",
      colorTransparentBackgroundSelected: "transparent",
      colorNeutralBackgroundDisabled: grey[8],
      colorNeutralBackgroundInvertedDisabled: whiteAlpha[10],
      colorNeutralStencil1: grey[34],
      colorNeutralStencil2: grey[20],
      colorNeutralStencil1Alpha: whiteAlpha[10],
      colorNeutralStencil2Alpha: whiteAlpha[5],
      colorBackgroundOverlay: blackAlpha[50],
      colorScrollbarOverlay: whiteAlpha[60],
      colorBrandBackground: brand[70],
      colorBrandBackgroundHover: brand[80],
      colorBrandBackgroundPressed: brand[40],
      colorBrandBackgroundSelected: brand[60],
      colorCompoundBrandBackground: brand[100],
      colorCompoundBrandBackgroundHover: brand[110],
      colorCompoundBrandBackgroundPressed: brand[90],
      colorBrandBackgroundStatic: brand[80],
      colorBrandBackground2: brand[20],
      colorBrandBackground2Hover: brand[40],
      colorBrandBackground2Pressed: brand[10],
      colorBrandBackgroundInverted: white,
      colorBrandBackgroundInvertedHover: brand[160],
      colorBrandBackgroundInvertedPressed: brand[140],
      colorBrandBackgroundInvertedSelected: brand[150],
      colorNeutralStrokeAccessible: grey[68],
      colorNeutralStrokeAccessibleHover: grey[74],
      colorNeutralStrokeAccessiblePressed: grey[70],
      colorNeutralStrokeAccessibleSelected: brand[100],
      colorNeutralStroke1: grey[40],
      colorNeutralStroke1Hover: grey[46],
      colorNeutralStroke1Pressed: grey[42],
      colorNeutralStroke1Selected: grey[44],
      colorNeutralStroke2: grey[32],
      colorNeutralStroke3: grey[24],
      colorNeutralStrokeSubtle: grey[4],
      colorNeutralStrokeOnBrand: grey[16],
      colorNeutralStrokeOnBrand2: white,
      colorNeutralStrokeOnBrand2Hover: white,
      colorNeutralStrokeOnBrand2Pressed: white,
      colorNeutralStrokeOnBrand2Selected: white,
      colorBrandStroke1: brand[100],
      colorBrandStroke2: brand[50],
      colorBrandStroke2Hover: brand[50],
      colorBrandStroke2Pressed: brand[30],
      colorBrandStroke2Contrast: brand[50],
      colorCompoundBrandStroke: brand[90],
      colorCompoundBrandStrokeHover: brand[100],
      colorCompoundBrandStrokePressed: brand[80],
      colorNeutralStrokeDisabled: grey[26],
      colorNeutralStrokeInvertedDisabled: whiteAlpha[40],
      colorTransparentStroke: "transparent",
      colorTransparentStrokeInteractive: "transparent",
      colorTransparentStrokeDisabled: "transparent",
      colorNeutralStrokeAlpha: whiteAlpha[10],
      colorNeutralStrokeAlpha2: whiteAlpha[20],
      colorStrokeFocus1: black,
      colorStrokeFocus2: white,
      colorNeutralShadowAmbient: "rgba(0,0,0,0.24)",
      colorNeutralShadowKey: "rgba(0,0,0,0.28)",
      colorNeutralShadowAmbientLighter: "rgba(0,0,0,0.12)",
      colorNeutralShadowKeyLighter: "rgba(0,0,0,0.14)",
      colorNeutralShadowAmbientDarker: "rgba(0,0,0,0.40)",
      colorNeutralShadowKeyDarker: "rgba(0,0,0,0.48)",
      colorBrandShadowAmbient: "rgba(0,0,0,0.30)",
      colorBrandShadowKey: "rgba(0,0,0,0.25)"
    });
    const createTeamsDarkTheme = (brand) => {
      const colorTokens = generateColorTokens(brand);
      return {
        ...borderRadius,
        ...fontSizes,
        ...lineHeights,
        ...fontFamilies,
        ...fontWeights,
        ...strokeWidths,
        ...horizontalSpacings,
        ...verticalSpacings,
        ...durations,
        ...curves,
        ...colorTokens,
        ...colorPaletteTokens,
        ...colorStatusTokens,
        ...createShadowTokens(colorTokens.colorNeutralShadowAmbient, colorTokens.colorNeutralShadowKey),
        ...createShadowTokens(colorTokens.colorBrandShadowAmbient, colorTokens.colorBrandShadowKey, "Brand")
      };
    };
    const teamsDarkTheme = createTeamsDarkTheme(brandTeams);
    const __GLOBAL__ = typeof window === "undefined" ? global : window;
    const __NAMESPACE_PREFIX__ = "@griffel/";
    function getGlobalVar(name2, defaultValue) {
      if (!__GLOBAL__[Symbol.for(__NAMESPACE_PREFIX__ + name2)]) {
        __GLOBAL__[Symbol.for(__NAMESPACE_PREFIX__ + name2)] = defaultValue;
      }
      return __GLOBAL__[Symbol.for(__NAMESPACE_PREFIX__ + name2)];
    }
    const DEFINITION_LOOKUP_TABLE = /* @__PURE__ */ getGlobalVar("DEFINITION_LOOKUP_TABLE", {});
    const SEQUENCE_HASH_LENGTH = 7;
    const SEQUENCE_PREFIX = "___";
    const SEQUENCE_SIZE = SEQUENCE_PREFIX.length + SEQUENCE_HASH_LENGTH;
    const LOOKUP_DEFINITIONS_INDEX = 0;
    const LOOKUP_DIR_INDEX = 1;
    function padEndHash(value) {
      const hashLength = value.length;
      if (hashLength === SEQUENCE_HASH_LENGTH) {
        return value;
      }
      for (let i2 = hashLength; i2 < SEQUENCE_HASH_LENGTH; i2++) {
        value += "0";
      }
      return value;
    }
    function hashSequence(classes, dir, sequenceIds = []) {
      {
        return SEQUENCE_PREFIX + padEndHash(murmur2$1(classes + dir));
      }
    }
    function reduceToClassName(classMap, dir) {
      let className = "";
      for (const propertyHash in classMap) {
        const classNameMapping = classMap[propertyHash];
        if (classNameMapping) {
          const hasRTLClassName = Array.isArray(classNameMapping);
          if (dir === "rtl") {
            className += (hasRTLClassName ? classNameMapping[1] : classNameMapping) + " ";
          } else {
            className += (hasRTLClassName ? classNameMapping[0] : classNameMapping) + " ";
          }
        }
      }
      return className.slice(0, -1);
    }
    function reduceToClassNameForSlots(classesMapBySlot, dir) {
      const classNamesForSlots = {};
      for (const slotName in classesMapBySlot) {
        const slotClasses = reduceToClassName(classesMapBySlot[slotName], dir);
        if (slotClasses === "") {
          classNamesForSlots[slotName] = "";
          continue;
        }
        const sequenceHash = hashSequence(slotClasses, dir);
        const resultSlotClasses = sequenceHash + " " + slotClasses;
        DEFINITION_LOOKUP_TABLE[sequenceHash] = [classesMapBySlot[slotName], dir];
        classNamesForSlots[slotName] = resultSlotClasses;
      }
      return classNamesForSlots;
    }
    const mergeClassesCachedResults = {};
    function mergeClasses() {
      let dir = null;
      let resultClassName = "";
      let sequenceMatch = "";
      const sequencesIds = new Array(arguments.length);
      for (let i2 = 0; i2 < arguments.length; i2++) {
        const className = arguments[i2];
        if (typeof className === "string" && className !== "") {
          const sequenceIndex = className.indexOf(SEQUENCE_PREFIX);
          if (sequenceIndex === -1) {
            resultClassName += className + " ";
          } else {
            const sequenceId = className.substr(sequenceIndex, SEQUENCE_SIZE);
            if (sequenceIndex > 0) {
              resultClassName += className.slice(0, sequenceIndex);
            }
            sequenceMatch += sequenceId;
            sequencesIds[i2] = sequenceId;
          }
        }
      }
      if (sequenceMatch === "") {
        return resultClassName.slice(0, -1);
      }
      const mergeClassesResult = mergeClassesCachedResults[sequenceMatch];
      if (mergeClassesResult !== void 0) {
        return resultClassName + mergeClassesResult;
      }
      const sequenceMappings = [];
      for (let i2 = 0; i2 < arguments.length; i2++) {
        const sequenceId = sequencesIds[i2];
        if (sequenceId) {
          const sequenceMapping = DEFINITION_LOOKUP_TABLE[sequenceId];
          if (sequenceMapping) {
            sequenceMappings.push(sequenceMapping[LOOKUP_DEFINITIONS_INDEX]);
            dir = sequenceMapping[LOOKUP_DIR_INDEX];
          }
        }
      }
      const resultDefinitions = Object.assign.apply(
        Object,
        // .assign() mutates the first object, we can't mutate mappings as it will produce invalid results later
        [{}].concat(sequenceMappings)
      );
      let atomicClassNames = reduceToClassName(resultDefinitions, dir);
      const newSequenceHash = hashSequence(atomicClassNames, dir, sequencesIds);
      atomicClassNames = newSequenceHash + " " + atomicClassNames;
      mergeClassesCachedResults[sequenceMatch] = atomicClassNames;
      DEFINITION_LOOKUP_TABLE[newSequenceHash] = [resultDefinitions, dir];
      return resultClassName + atomicClassNames;
    }
    const insertionFactory = () => {
      const insertionCache = {};
      return function insertStyles(renderer, cssRules2) {
        if (insertionCache[renderer.id] === void 0) {
          renderer.insertCSSRules(cssRules2);
          insertionCache[renderer.id] = true;
        }
      };
    };
    function __styles(classesMapBySlot, cssRules2, factory = insertionFactory) {
      const insertStyles = factory();
      let ltrClassNamesForSlots = null;
      let rtlClassNamesForSlots = null;
      function computeClasses(options) {
        const {
          dir,
          renderer
        } = options;
        const isLTR = dir === "ltr";
        if (isLTR) {
          if (ltrClassNamesForSlots === null) {
            ltrClassNamesForSlots = reduceToClassNameForSlots(classesMapBySlot, dir);
          }
        } else {
          if (rtlClassNamesForSlots === null) {
            rtlClassNamesForSlots = reduceToClassNameForSlots(classesMapBySlot, dir);
          }
        }
        insertStyles(renderer, cssRules2);
        const classNamesForSlots = isLTR ? ltrClassNamesForSlots : rtlClassNamesForSlots;
        return classNamesForSlots;
      }
      return computeClasses;
    }
    const fluentProviderClassNames = {
      root: "fui-FluentProvider"
    };
    const useStyles$h = /* @__PURE__ */ __styles({
      root: {
        sj55zd: "f19n0e5",
        De3pzq: "fxugw4r",
        fsow6f: ["f1o700av", "fes3tcz"],
        Bahqtrf: "fk6fouc",
        Be2twd7: "fkhj508",
        Bhrd7zp: "figsok6",
        Bg96gwp: "f1i3iumi"
      }
    }, {
      d: [".f19n0e5{color:var(--colorNeutralForeground1);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".f1o700av{text-align:left;}", ".fes3tcz{text-align:right;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}"]
    });
    const useFluentProviderStyles_unstable = (state) => {
      const renderer = useRenderer$1();
      const styles2 = useStyles$h({
        dir: state.dir,
        renderer
      });
      state.root.className = mergeClasses(fluentProviderClassNames.root, state.themeClassName, styles2.root, state.root.className);
      return state;
    };
    const useInsertionEffect$1 = React$1["useInsertionEffect"] ? React$1["useInsertionEffect"] : useIsomorphicLayoutEffect;
    const createStyleTag = (target, elementAttributes) => {
      if (!target) {
        return void 0;
      }
      const tag = target.createElement("style");
      Object.keys(elementAttributes).forEach((attrName) => {
        tag.setAttribute(attrName, elementAttributes[attrName]);
      });
      target.head.appendChild(tag);
      return tag;
    };
    const insertSheet = (tag, rule) => {
      const sheet = tag.sheet;
      if (sheet) {
        if (sheet.cssRules.length > 0) {
          sheet.deleteRule(0);
        }
        sheet.insertRule(rule, 0);
      }
    };
    const useFluentProviderThemeStyleTag = (options) => {
      const { targetDocument, theme, rendererAttributes } = options;
      const styleTag = reactExports.useRef();
      const styleTagId = useId(fluentProviderClassNames.root);
      const styleElementAttributes = rendererAttributes;
      const rule = reactExports.useMemo(() => createCSSRuleFromTheme(`.${styleTagId}`, theme), [
        theme,
        styleTagId
      ]);
      useHandleSSRStyleElements(targetDocument, styleTagId);
      useInsertionEffect$1(() => {
        const ssrStyleElement = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.getElementById(styleTagId);
        if (ssrStyleElement) {
          styleTag.current = ssrStyleElement;
        } else {
          styleTag.current = createStyleTag(targetDocument, {
            ...styleElementAttributes,
            id: styleTagId
          });
          if (styleTag.current) {
            insertSheet(styleTag.current, rule);
          }
        }
        return () => {
          var _styleTag_current;
          (_styleTag_current = styleTag.current) === null || _styleTag_current === void 0 ? void 0 : _styleTag_current.remove();
        };
      }, [
        styleTagId,
        targetDocument,
        rule,
        styleElementAttributes
      ]);
      return {
        styleTagId,
        rule
      };
    };
    function useHandleSSRStyleElements(targetDocument, styleTagId) {
      reactExports.useState(() => {
        if (!targetDocument) {
          return;
        }
        const themeStyleElement = targetDocument.getElementById(styleTagId);
        if (themeStyleElement) {
          targetDocument.head.append(themeStyleElement);
        }
      });
    }
    const EMPTY_OBJECT = {};
    const useFluentProvider_unstable = (props, ref) => {
      const parentContext = useFluent();
      const parentTheme = useTheme();
      const parentOverrides = useOverrides();
      const parentCustomStyleHooks = reactExports.useContext(CustomStyleHooksContext) || EMPTY_OBJECT;
      const {
        applyStylesToPortals = true,
        // eslint-disable-next-line @typescript-eslint/naming-convention
        customStyleHooks_unstable,
        dir = parentContext.dir,
        targetDocument = parentContext.targetDocument,
        theme,
        overrides_unstable: overrides = {}
      } = props;
      const mergedTheme = shallowMerge(parentTheme, theme);
      const mergedOverrides = shallowMerge(parentOverrides, overrides);
      const mergedCustomStyleHooks = shallowMerge(parentCustomStyleHooks, customStyleHooks_unstable);
      const renderer = useRenderer$1();
      var _renderer_styleElementAttributes;
      const { styleTagId, rule } = useFluentProviderThemeStyleTag({
        theme: mergedTheme,
        targetDocument,
        rendererAttributes: (_renderer_styleElementAttributes = renderer.styleElementAttributes) !== null && _renderer_styleElementAttributes !== void 0 ? _renderer_styleElementAttributes : {}
      });
      return {
        applyStylesToPortals,
        // eslint-disable-next-line @typescript-eslint/naming-convention
        customStyleHooks_unstable: mergedCustomStyleHooks,
        dir,
        targetDocument,
        theme: mergedTheme,
        // eslint-disable-next-line @typescript-eslint/naming-convention
        overrides_unstable: mergedOverrides,
        themeClassName: styleTagId,
        components: {
          root: "div"
        },
        root: always(getIntrinsicElementProps("div", {
          ...props,
          dir,
          // FIXME:
          // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
          // but since it would be a breaking change to fix it, we are casting ref to it's proper type
          ref: useMergedRefs(ref, useFocusVisible({
            targetDocument
          }))
        }), {
          elementType: "div"
        }),
        serverStyleProps: {
          cssRule: rule,
          attributes: {
            ...renderer.styleElementAttributes,
            id: styleTagId
          }
        }
      };
    };
    function shallowMerge(a2, b2) {
      if (a2 && b2) {
        return {
          ...a2,
          ...b2
        };
      }
      if (a2) {
        return a2;
      }
      return b2;
    }
    function useTheme() {
      return reactExports.useContext(ThemeContext);
    }
    function useFluentProviderContextValues_unstable(state) {
      const {
        applyStylesToPortals,
        // eslint-disable-next-line @typescript-eslint/naming-convention
        customStyleHooks_unstable,
        dir,
        root: root2,
        targetDocument,
        theme,
        themeClassName,
        // eslint-disable-next-line @typescript-eslint/naming-convention
        overrides_unstable
      } = state;
      const provider = reactExports.useMemo(() => ({
        dir,
        targetDocument
      }), [
        dir,
        targetDocument
      ]);
      const [tooltip] = reactExports.useState(() => ({}));
      const iconDirection = reactExports.useMemo(() => ({
        textDirection: dir
      }), [
        dir
      ]);
      return {
        // eslint-disable-next-line @typescript-eslint/naming-convention
        customStyleHooks_unstable,
        // eslint-disable-next-line @typescript-eslint/naming-convention
        overrides_unstable,
        provider,
        textDirection: dir,
        iconDirection,
        tooltip,
        theme,
        themeClassName: applyStylesToPortals ? root2.className : themeClassName
      };
    }
    const FluentProvider = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const state = useFluentProvider_unstable(props, ref);
      useFluentProviderStyles_unstable(state);
      const contextValues = useFluentProviderContextValues_unstable(state);
      return renderFluentProvider_unstable(state, contextValues);
    });
    FluentProvider.displayName = "FluentProvider";
    const createProvider = (Original) => {
      const Provider2 = (props) => {
        const valueRef = reactExports.useRef(props.value);
        const versionRef = reactExports.useRef(0);
        const contextValue = reactExports.useRef();
        if (!contextValue.current) {
          contextValue.current = {
            value: valueRef,
            version: versionRef,
            listeners: []
          };
        }
        useIsomorphicLayoutEffect(() => {
          valueRef.current = props.value;
          versionRef.current += 1;
          schedulerExports.unstable_runWithPriority(schedulerExports.unstable_NormalPriority, () => {
            contextValue.current.listeners.forEach((listener) => {
              listener([
                versionRef.current,
                props.value
              ]);
            });
          });
        }, [
          props.value
        ]);
        return reactExports.createElement(Original, {
          value: contextValue.current
        }, props.children);
      };
      return Provider2;
    };
    const createContext = (defaultValue) => {
      const context = reactExports.createContext({
        value: {
          current: defaultValue
        },
        version: {
          current: -1
        },
        listeners: []
      });
      context.Provider = createProvider(context.Provider);
      delete context.Consumer;
      return context;
    };
    const useContextSelector = (context, selector) => {
      const contextValue = reactExports.useContext(context);
      const { value: { current: value }, version: { current: version2 }, listeners } = contextValue;
      const selected = selector(value);
      const [state, dispatch] = reactExports.useReducer((prevState, payload) => {
        if (!payload) {
          return [
            value,
            selected
          ];
        }
        if (payload[0] <= version2) {
          if (objectIs(prevState[1], selected)) {
            return prevState;
          }
          return [
            value,
            selected
          ];
        }
        try {
          if (objectIs(prevState[0], payload[1])) {
            return prevState;
          }
          const nextSelected = selector(payload[1]);
          if (objectIs(prevState[1], nextSelected)) {
            return prevState;
          }
          return [
            payload[1],
            nextSelected
          ];
        } catch (e2) {
        }
        return [
          prevState[0],
          prevState[1]
        ];
      }, [
        value,
        selected
      ]);
      if (!objectIs(state[1], selected)) {
        dispatch(void 0);
      }
      useIsomorphicLayoutEffect(() => {
        listeners.push(dispatch);
        return () => {
          const index2 = listeners.indexOf(dispatch);
          listeners.splice(index2, 1);
        };
      }, [
        listeners
      ]);
      return state[1];
    };
    function is(x2, y2) {
      return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
    }
    const objectIs = (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore fallback to native if it exists (not in IE11)
      typeof Object.is === "function" ? Object.is : is
    );
    function useHasParentContext(context) {
      const contextValue = reactExports.useContext(context);
      if (contextValue.version) {
        return contextValue.version.current !== -1;
      }
      return false;
    }
    const Enter = "Enter";
    const Space = " ";
    const Tab = "Tab";
    const ArrowDown = "ArrowDown";
    const ArrowLeft = "ArrowLeft";
    const ArrowRight = "ArrowRight";
    const Escape = "Escape";
    function useARIAButtonProps(type, props) {
      const { disabled, disabledFocusable = false, ["aria-disabled"]: ariaDisabled, onClick, onKeyDown, onKeyUp, ...rest } = props !== null && props !== void 0 ? props : {};
      const normalizedARIADisabled = typeof ariaDisabled === "string" ? ariaDisabled === "true" : ariaDisabled;
      const isDisabled = disabled || disabledFocusable || normalizedARIADisabled;
      const handleClick = useEventCallback$1((ev) => {
        if (isDisabled) {
          ev.preventDefault();
          ev.stopPropagation();
        } else {
          onClick === null || onClick === void 0 ? void 0 : onClick(ev);
        }
      });
      const handleKeyDown = useEventCallback$1((ev) => {
        onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(ev);
        if (ev.isDefaultPrevented()) {
          return;
        }
        const key = ev.key;
        if (isDisabled && (key === Enter || key === Space)) {
          ev.preventDefault();
          ev.stopPropagation();
          return;
        }
        if (key === Space) {
          ev.preventDefault();
          return;
        } else if (key === Enter) {
          ev.preventDefault();
          ev.currentTarget.click();
        }
      });
      const handleKeyUp = useEventCallback$1((ev) => {
        onKeyUp === null || onKeyUp === void 0 ? void 0 : onKeyUp(ev);
        if (ev.isDefaultPrevented()) {
          return;
        }
        const key = ev.key;
        if (isDisabled && (key === Enter || key === Space)) {
          ev.preventDefault();
          ev.stopPropagation();
          return;
        }
        if (key === Space) {
          ev.preventDefault();
          ev.currentTarget.click();
        }
      });
      if (type === "button" || type === void 0) {
        return {
          ...rest,
          disabled: disabled && !disabledFocusable,
          "aria-disabled": disabledFocusable ? true : normalizedARIADisabled,
          // onclick should still use internal handler to ensure prevention if disabled
          // if disabledFocusable then there's no requirement for handlers as those events should not be propagated
          onClick: disabledFocusable ? void 0 : handleClick,
          onKeyUp: disabledFocusable ? void 0 : onKeyUp,
          onKeyDown: disabledFocusable ? void 0 : onKeyDown
        };
      } else {
        const resultProps = {
          role: "button",
          tabIndex: disabled && !disabledFocusable ? void 0 : 0,
          ...rest,
          // If it's not a <button> than listeners are required even with disabledFocusable
          // Since you cannot assure the default behavior of the element
          // E.g: <a> will redirect on click
          onClick: handleClick,
          onKeyUp: handleKeyUp,
          onKeyDown: handleKeyDown,
          "aria-disabled": disabled || disabledFocusable || normalizedARIADisabled
        };
        if (type === "a" && isDisabled) {
          resultProps.href = void 0;
        }
        return resultProps;
      }
    }
    const useARIAButtonShorthand = (value, options) => {
      const shorthand = resolveShorthand(value, options);
      var _shorthand_as;
      const shorthandARIAButton = useARIAButtonProps((_shorthand_as = shorthand === null || shorthand === void 0 ? void 0 : shorthand.as) !== null && _shorthand_as !== void 0 ? _shorthand_as : "button", shorthand);
      return shorthand && shorthandARIAButton;
    };
    const renderAvatar_unstable = (state) => {
      return /* @__PURE__ */ jsxs(state.root, {
        children: [
          state.initials && /* @__PURE__ */ jsx(state.initials, {}),
          state.icon && /* @__PURE__ */ jsx(state.icon, {}),
          state.image && /* @__PURE__ */ jsx(state.image, {}),
          state.badge && /* @__PURE__ */ jsx(state.badge, {}),
          state.activeAriaLabelElement
        ]
      });
    };
    const UNWANTED_ENCLOSURES_REGEX = /[\(\[\{][^\)\]\}]*[\)\]\}]/g;
    const UNWANTED_CHARS_REGEX = /[\0-\u001F\!-/:-@\[-`\{-\u00BF\u0250-\u036F\uD800-\uFFFF]/g;
    const PHONENUMBER_REGEX = /^\d+[\d\s]*(:?ext|x|)\s*\d+$/i;
    const MULTIPLE_WHITESPACES_REGEX = /\s+/g;
    const UNSUPPORTED_TEXT_REGEX = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uAC00-\uD7AF\uD7B0-\uD7FF\u3040-\u309F\u30A0-\u30FF\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF]|[\uD840-\uD869][\uDC00-\uDED6]/;
    function getInitialsLatin(displayName, isRtl, firstInitialOnly) {
      let initials = "";
      const splits = displayName.split(" ");
      if (splits.length !== 0) {
        initials += splits[0].charAt(0).toUpperCase();
      }
      if (!firstInitialOnly) {
        if (splits.length === 2) {
          initials += splits[1].charAt(0).toUpperCase();
        } else if (splits.length === 3) {
          initials += splits[2].charAt(0).toUpperCase();
        }
      }
      if (isRtl && initials.length > 1) {
        return initials.charAt(1) + initials.charAt(0);
      }
      return initials;
    }
    function cleanupDisplayName(displayName) {
      displayName = displayName.replace(UNWANTED_ENCLOSURES_REGEX, "");
      displayName = displayName.replace(UNWANTED_CHARS_REGEX, "");
      displayName = displayName.replace(MULTIPLE_WHITESPACES_REGEX, " ");
      displayName = displayName.trim();
      return displayName;
    }
    function getInitials(displayName, isRtl, options) {
      if (!displayName) {
        return "";
      }
      displayName = cleanupDisplayName(displayName);
      if (UNSUPPORTED_TEXT_REGEX.test(displayName) || !(options === null || options === void 0 ? void 0 : options.allowPhoneInitials) && PHONENUMBER_REGEX.test(displayName)) {
        return "";
      }
      return getInitialsLatin(displayName, isRtl, options === null || options === void 0 ? void 0 : options.firstInitialOnly);
    }
    const useBadge_unstable = (props, ref) => {
      const { shape = "circular", size = "medium", iconPosition = "before", appearance = "filled", color: color2 = "brand" } = props;
      const state = {
        shape,
        size,
        iconPosition,
        appearance,
        color: color2,
        components: {
          root: "div",
          icon: "span"
        },
        root: always(getIntrinsicElementProps("div", {
          // FIXME:
          // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
          // but since it would be a breaking change to fix it, we are casting ref to it's proper type
          ref,
          ...props
        }), {
          elementType: "div"
        }),
        icon: optional(props.icon, {
          elementType: "span"
        })
      };
      return state;
    };
    const renderBadge_unstable = (state) => {
      return /* @__PURE__ */ jsxs(state.root, {
        children: [
          state.iconPosition === "before" && state.icon && /* @__PURE__ */ jsx(state.icon, {}),
          state.root.children,
          state.iconPosition === "after" && state.icon && /* @__PURE__ */ jsx(state.icon, {})
        ]
      });
    };
    const presenceAwayFilled = {
      // FIXME not all presence icon sizes are available
      // https://github.com/microsoft/fluentui/issues/20650
      tiny: PresenceAway10Filled,
      "extra-small": PresenceAway10Filled,
      small: PresenceAway12Filled,
      medium: PresenceAway16Filled,
      large: PresenceAway20Filled,
      // FIXME not all presence icon sizes are available
      // https://github.com/microsoft/fluentui/issues/20650
      "extra-large": PresenceAway20Filled
    };
    const presenceAvailableRegular = {
      // FIXME not all presence icon sizes are available
      // https://github.com/microsoft/fluentui/issues/20650
      tiny: PresenceAvailable10Regular,
      "extra-small": PresenceAvailable10Regular,
      small: PresenceAvailable12Regular,
      medium: PresenceAvailable16Regular,
      large: PresenceAvailable20Regular,
      // FIXME not all presence icon sizes are available
      // https://github.com/microsoft/fluentui/issues/20650
      "extra-large": PresenceAvailable20Regular
    };
    const presenceAvailableFilled = {
      // FIXME not all presence icon sizes are available
      // https://github.com/microsoft/fluentui/issues/20650
      tiny: PresenceAvailable10Filled,
      "extra-small": PresenceAvailable10Filled,
      small: PresenceAvailable12Filled,
      medium: PresenceAvailable16Filled,
      large: PresenceAvailable20Filled,
      // FIXME not all presence icon sizes are available
      // https://github.com/microsoft/fluentui/issues/20650
      "extra-large": PresenceAvailable20Filled
    };
    const presenceBlockedRegular = {
      // FIXME not all presence icon sizes are available
      // https://github.com/microsoft/fluentui/issues/20650
      tiny: PresenceBlocked10Regular,
      "extra-small": PresenceBlocked10Regular,
      small: PresenceBlocked12Regular,
      medium: PresenceBlocked16Regular,
      large: PresenceBlocked20Regular,
      // FIXME not all presence icon sizes are available
      // https://github.com/microsoft/fluentui/issues/20650
      "extra-large": PresenceBlocked20Regular
    };
    const presenceBusyFilled = {
      // FIXME not all presence icon sizes are available
      // https://github.com/microsoft/fluentui/issues/20650
      tiny: PresenceBusy10Filled,
      "extra-small": PresenceBusy10Filled,
      small: PresenceBusy12Filled,
      medium: PresenceBusy16Filled,
      large: PresenceBusy20Filled,
      // FIXME not all presence icon sizes are available
      // https://github.com/microsoft/fluentui/issues/20650
      "extra-large": PresenceBusy20Filled
    };
    const presenceDndFilled = {
      // FIXME not all presence icon sizes are available
      // https://github.com/microsoft/fluentui/issues/20650
      tiny: PresenceDnd10Filled,
      "extra-small": PresenceDnd10Filled,
      small: PresenceDnd12Filled,
      medium: PresenceDnd16Filled,
      large: PresenceDnd20Filled,
      // FIXME not all presence icon sizes are available
      // https://github.com/microsoft/fluentui/issues/20650
      "extra-large": PresenceDnd20Filled
    };
    const presenceDndRegular = {
      // FIXME not all presence icon sizes are available
      // https://github.com/microsoft/fluentui/issues/20650
      tiny: PresenceDnd10Regular,
      "extra-small": PresenceDnd10Regular,
      small: PresenceDnd12Regular,
      medium: PresenceDnd16Regular,
      large: PresenceDnd20Regular,
      // FIXME not all presence icon sizes are available
      // https://github.com/microsoft/fluentui/issues/20650
      "extra-large": PresenceDnd20Regular
    };
    const presenceOofRegular = {
      // FIXME not all presence icon sizes are available
      // https://github.com/microsoft/fluentui/issues/20650
      tiny: PresenceOof10Regular,
      "extra-small": PresenceOof10Regular,
      small: PresenceOof12Regular,
      medium: PresenceOof16Regular,
      large: PresenceOof20Regular,
      // FIXME not all presence icon sizes are available
      // https://github.com/microsoft/fluentui/issues/20650
      "extra-large": PresenceOof20Regular
    };
    const presenceOfflineRegular = {
      // FIXME not all presence icon sizes are available
      // https://github.com/microsoft/fluentui/issues/20650
      tiny: PresenceOffline10Regular,
      "extra-small": PresenceOffline10Regular,
      small: PresenceOffline12Regular,
      medium: PresenceOffline16Regular,
      large: PresenceOffline20Regular,
      // FIXME not all presence icon sizes are available
      // https://github.com/microsoft/fluentui/issues/20650
      "extra-large": PresenceOffline20Regular
    };
    const presenceUnknownRegular = {
      // FIXME not all presence icon sizes are available
      // https://github.com/microsoft/fluentui/issues/20650
      tiny: PresenceUnknown10Regular,
      "extra-small": PresenceUnknown10Regular,
      small: PresenceUnknown12Regular,
      medium: PresenceUnknown16Regular,
      large: PresenceUnknown20Regular,
      // FIXME not all presence icon sizes are available
      // https://github.com/microsoft/fluentui/issues/20650
      "extra-large": PresenceUnknown20Regular
    };
    const iconMap = (status, outOfOffice, size) => {
      switch (status) {
        case "available":
          return outOfOffice ? presenceAvailableRegular[size] : presenceAvailableFilled[size];
        case "away":
          return outOfOffice ? presenceOofRegular[size] : presenceAwayFilled[size];
        case "blocked":
          return presenceBlockedRegular[size];
        case "busy":
          return outOfOffice ? presenceUnknownRegular[size] : presenceBusyFilled[size];
        case "do-not-disturb":
          return outOfOffice ? presenceDndRegular[size] : presenceDndFilled[size];
        case "offline":
          return outOfOffice ? presenceOofRegular[size] : presenceOfflineRegular[size];
        case "out-of-office":
          return presenceOofRegular[size];
        case "unknown":
          return presenceUnknownRegular[size];
      }
    };
    const DEFAULT_STRINGS$1 = {
      busy: "busy",
      "out-of-office": "out of office",
      away: "away",
      available: "available",
      offline: "offline",
      "do-not-disturb": "do not disturb",
      unknown: "unknown",
      blocked: "blocked"
    };
    const usePresenceBadge_unstable = (props, ref) => {
      const { size = "medium", status = "available", outOfOffice = false } = props;
      const statusText = DEFAULT_STRINGS$1[status];
      const oofText = props.outOfOffice && props.status !== "out-of-office" ? ` ${DEFAULT_STRINGS$1["out-of-office"]}` : "";
      const IconElement = iconMap(status, outOfOffice, size);
      const state = {
        ...useBadge_unstable({
          "aria-label": statusText + oofText,
          role: "img",
          ...props,
          size,
          icon: optional(props.icon, {
            defaultProps: {
              children: IconElement ? /* @__PURE__ */ reactExports.createElement(IconElement, null) : null
            },
            renderByDefault: true,
            elementType: "span"
          })
        }, ref),
        status,
        outOfOffice
      };
      return state;
    };
    const presenceBadgeClassNames = {
      root: "fui-PresenceBadge",
      icon: "fui-PresenceBadge__icon"
    };
    const getIsBusy = (status) => {
      if (status === "busy" || status === "do-not-disturb" || status === "blocked") {
        return true;
      }
      return false;
    };
    const useRootClassName$2 = /* @__PURE__ */ __resetStyles("r832ydo", null, [".r832ydo{display:inline-flex;box-sizing:border-box;align-items:center;justify-content:center;border-radius:var(--borderRadiusCircular);background-color:var(--colorNeutralBackground1);padding:1px;background-clip:content-box;}"]);
    const useIconClassName = /* @__PURE__ */ __resetStyles("r11ag4qr", null, [".r11ag4qr{display:flex;margin:-1px;}"]);
    const useStyles$g = /* @__PURE__ */ __styles$3({
      statusBusy: {
        sj55zd: "fvi85wt"
      },
      statusAway: {
        sj55zd: "f14k8a89"
      },
      statusAvailable: {
        sj55zd: "fqa5hgp"
      },
      statusOffline: {
        sj55zd: "f11d4kpn"
      },
      statusOutOfOffice: {
        sj55zd: "fdce8r3"
      },
      statusUnknown: {
        sj55zd: "f11d4kpn"
      },
      outOfOffice: {
        sj55zd: "fr0bkrk"
      },
      outOfOfficeAvailable: {
        sj55zd: "fqa5hgp"
      },
      outOfOfficeBusy: {
        sj55zd: "fvi85wt"
      },
      outOfOfficeUnknown: {
        sj55zd: "f11d4kpn"
      },
      tiny: {
        Bubjx69: "f9ikmtg",
        a9b677: "f16dn6v3",
        B2eet1l: "f1w2irj7",
        B5pe6w7: "fab5kbq",
        p4uzdd: "f1ms1d91"
      },
      large: {
        Bubjx69: "f9ikmtg",
        a9b677: "f64fuq3",
        B5pe6w7: "f1vfi1yj",
        p4uzdd: "f15s34gz"
      },
      extraLarge: {
        Bubjx69: "f9ikmtg",
        a9b677: "f1w9dchk",
        B5pe6w7: "f14efy9b",
        p4uzdd: "fhipgdu"
      }
    }, {
      d: [".fvi85wt{color:var(--colorPaletteRedBackground3);}", ".f14k8a89{color:var(--colorPaletteMarigoldBackground3);}", ".fqa5hgp{color:var(--colorPaletteLightGreenForeground3);}", ".f11d4kpn{color:var(--colorNeutralForeground3);}", ".fdce8r3{color:var(--colorPaletteBerryForeground3);}", ".fr0bkrk{color:var(--colorNeutralBackground1);}", ".f9ikmtg{aspect-ratio:1;}", ".f16dn6v3{width:6px;}", ".f1w2irj7{background-clip:unset;}", ".fab5kbq svg{width:6px!important;}", ".f1ms1d91 svg{height:6px!important;}", ".f64fuq3{width:20px;}", ".f1vfi1yj svg{width:20px!important;}", ".f15s34gz svg{height:20px!important;}", ".f1w9dchk{width:28px;}", ".f14efy9b svg{width:28px!important;}", ".fhipgdu svg{height:28px!important;}"]
    });
    const usePresenceBadgeStyles_unstable = (state) => {
      const rootClassName = useRootClassName$2();
      const iconClassName = useIconClassName();
      const styles2 = useStyles$g();
      const isBusy = getIsBusy(state.status);
      state.root.className = mergeClasses$2(presenceBadgeClassNames.root, rootClassName, isBusy && styles2.statusBusy, state.status === "away" && styles2.statusAway, state.status === "available" && styles2.statusAvailable, state.status === "offline" && styles2.statusOffline, state.status === "out-of-office" && styles2.statusOutOfOffice, state.status === "unknown" && styles2.statusUnknown, state.outOfOffice && styles2.outOfOffice, state.outOfOffice && state.status === "available" && styles2.outOfOfficeAvailable, state.outOfOffice && isBusy && styles2.outOfOfficeBusy, state.outOfOffice && (state.status === "out-of-office" || state.status === "away" || state.status === "offline") && styles2.statusOutOfOffice, state.outOfOffice && state.status === "unknown" && styles2.outOfOfficeUnknown, state.size === "tiny" && styles2.tiny, state.size === "large" && styles2.large, state.size === "extra-large" && styles2.extraLarge, state.root.className);
      if (state.icon) {
        state.icon.className = mergeClasses$2(presenceBadgeClassNames.icon, iconClassName, state.icon.className);
      }
      return state;
    };
    const PresenceBadge = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const state = usePresenceBadge_unstable(props, ref);
      usePresenceBadgeStyles_unstable(state);
      useCustomStyleHook("usePresenceBadgeStyles_unstable")(state);
      return renderBadge_unstable(state);
    });
    PresenceBadge.displayName = "PresenceBadge";
    const avatarContext = reactExports.createContext(void 0);
    const avatarContextDefaultValue = {};
    avatarContext.Provider;
    const useAvatarContext = () => {
      var _React_useContext;
      return (_React_useContext = reactExports.useContext(avatarContext)) !== null && _React_useContext !== void 0 ? _React_useContext : avatarContextDefaultValue;
    };
    const DEFAULT_STRINGS = {
      active: "active",
      inactive: "inactive"
    };
    const useAvatar_unstable = (props, ref) => {
      const { dir } = useFluent();
      const { shape: contextShape, size: contextSize } = useAvatarContext();
      const { name: name2, size = contextSize !== null && contextSize !== void 0 ? contextSize : 32, shape = contextShape !== null && contextShape !== void 0 ? contextShape : "circular", active = "unset", activeAppearance = "ring", idForColor } = props;
      let { color: color2 = "neutral" } = props;
      if (color2 === "colorful") {
        var _ref;
        color2 = avatarColors[getHashCode((_ref = idForColor !== null && idForColor !== void 0 ? idForColor : name2) !== null && _ref !== void 0 ? _ref : "") % avatarColors.length];
      }
      const baseId = useId("avatar-");
      const root2 = always(getIntrinsicElementProps(
        "span",
        {
          role: "img",
          id: baseId,
          // aria-label and/or aria-labelledby are resolved below
          ...props,
          ref
        },
        /* excludedPropNames: */
        [
          "name"
        ]
      ), {
        elementType: "span"
      });
      const [imageHidden, setImageHidden] = reactExports.useState(void 0);
      let image2 = optional(props.image, {
        defaultProps: {
          alt: "",
          role: "presentation",
          "aria-hidden": true,
          hidden: imageHidden
        },
        elementType: "img"
      });
      if (!(image2 === null || image2 === void 0 ? void 0 : image2.src)) {
        image2 = void 0;
      }
      if (image2) {
        image2.onError = mergeCallbacks(image2.onError, () => setImageHidden(true));
        image2.onLoad = mergeCallbacks(image2.onLoad, () => setImageHidden(void 0));
      }
      let initials = optional(props.initials, {
        renderByDefault: true,
        defaultProps: {
          children: getInitials(name2, dir === "rtl", {
            firstInitialOnly: size <= 16
          }),
          id: baseId + "__initials"
        },
        elementType: "span"
      });
      if (!(initials === null || initials === void 0 ? void 0 : initials.children)) {
        initials = void 0;
      }
      let icon = void 0;
      if (!initials && (!image2 || imageHidden)) {
        icon = optional(props.icon, {
          renderByDefault: true,
          defaultProps: {
            children: /* @__PURE__ */ reactExports.createElement(PersonRegular, null),
            "aria-hidden": true
          },
          elementType: "span"
        });
      }
      const badge = optional(props.badge, {
        defaultProps: {
          size: getBadgeSize(size),
          id: baseId + "__badge"
        },
        elementType: PresenceBadge
      });
      let activeAriaLabelElement;
      if (!root2["aria-label"] && !root2["aria-labelledby"]) {
        if (name2) {
          root2["aria-label"] = name2;
          if (badge) {
            root2["aria-labelledby"] = root2.id + " " + badge.id;
          }
        } else if (initials) {
          root2["aria-labelledby"] = initials.id + (badge ? " " + badge.id : "");
        }
        if (active === "active" || active === "inactive") {
          const activeText = DEFAULT_STRINGS[active];
          if (root2["aria-labelledby"]) {
            const activeId = baseId + "__active";
            root2["aria-labelledby"] += " " + activeId;
            activeAriaLabelElement = /* @__PURE__ */ reactExports.createElement("span", {
              hidden: true,
              id: activeId
            }, activeText);
          } else if (root2["aria-label"]) {
            root2["aria-label"] += " " + activeText;
          }
        }
      }
      return {
        size,
        shape,
        active,
        activeAppearance,
        activeAriaLabelElement,
        color: color2,
        components: {
          root: "span",
          initials: "span",
          icon: "span",
          image: "img",
          badge: PresenceBadge
        },
        root: root2,
        initials,
        icon,
        image: image2,
        badge
      };
    };
    const getBadgeSize = (size) => {
      if (size >= 96) {
        return "extra-large";
      } else if (size >= 64) {
        return "large";
      } else if (size >= 56) {
        return "medium";
      } else if (size >= 40) {
        return "small";
      } else if (size >= 28) {
        return "extra-small";
      } else {
        return "tiny";
      }
    };
    const avatarColors = [
      "dark-red",
      "cranberry",
      "red",
      "pumpkin",
      "peach",
      "marigold",
      "gold",
      "brass",
      "brown",
      "forest",
      "seafoam",
      "dark-green",
      "light-teal",
      "teal",
      "steel",
      "blue",
      "royal-blue",
      "cornflower",
      "navy",
      "lavender",
      "purple",
      "grape",
      "lilac",
      "pink",
      "magenta",
      "plum",
      "beige",
      "mink",
      "platinum",
      "anchor"
    ];
    const getHashCode = (str) => {
      let hashCode = 0;
      for (let len = str.length - 1; len >= 0; len--) {
        const ch2 = str.charCodeAt(len);
        const shift2 = len % 8;
        hashCode ^= (ch2 << shift2) + (ch2 >> 8 - shift2);
      }
      return hashCode;
    };
    const avatarClassNames = {
      root: "fui-Avatar",
      image: "fui-Avatar__image",
      initials: "fui-Avatar__initials",
      icon: "fui-Avatar__icon",
      badge: "fui-Avatar__badge"
    };
    const useRootClassName$1 = /* @__PURE__ */ __resetStyles("r81b29z", "r1aatmv", {
      r: [".r81b29z{display:inline-block;flex-shrink:0;position:relative;vertical-align:middle;border-radius:var(--borderRadiusCircular);font-family:var(--fontFamilyBase);font-weight:var(--fontWeightSemibold);font-size:var(--fontSizeBase300);width:32px;height:32px;}", ".r81b29z::before,.r81b29z::after{position:absolute;top:0;left:0;bottom:0;right:0;z-index:-1;margin:calc(-2 * var(--fui-Avatar-ringWidth, 0px));border-radius:inherit;transition-property:margin,opacity;transition-timing-function:var(--curveEasyEaseMax),var(--curveLinear);transition-duration:var(--durationUltraSlow),var(--durationSlower);}", ".r81b29z::before{border-style:solid;border-width:var(--fui-Avatar-ringWidth);}", ".r1aatmv{display:inline-block;flex-shrink:0;position:relative;vertical-align:middle;border-radius:var(--borderRadiusCircular);font-family:var(--fontFamilyBase);font-weight:var(--fontWeightSemibold);font-size:var(--fontSizeBase300);width:32px;height:32px;}", ".r1aatmv::before,.r1aatmv::after{position:absolute;top:0;right:0;bottom:0;left:0;z-index:-1;margin:calc(-2 * var(--fui-Avatar-ringWidth, 0px));border-radius:inherit;transition-property:margin,opacity;transition-timing-function:var(--curveEasyEaseMax),var(--curveLinear);transition-duration:var(--durationUltraSlow),var(--durationSlower);}", ".r1aatmv::before{border-style:solid;border-width:var(--fui-Avatar-ringWidth);}"],
      s: ["@media screen and (prefers-reduced-motion: reduce){.r81b29z::before,.r81b29z::after{transition-duration:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.r1aatmv::before,.r1aatmv::after{transition-duration:0.01ms;}}"]
    });
    const useImageClassName = /* @__PURE__ */ __resetStyles("r136dc0n", "rjly0nl", [".r136dc0n{position:absolute;top:0;left:0;width:100%;height:100%;border-radius:inherit;object-fit:cover;vertical-align:top;}", ".rjly0nl{position:absolute;top:0;right:0;width:100%;height:100%;border-radius:inherit;object-fit:cover;vertical-align:top;}"]);
    const useIconInitialsClassName = /* @__PURE__ */ __resetStyles("rip04v", "r31uzil", [".rip04v{position:absolute;box-sizing:border-box;top:0;left:0;width:100%;height:100%;line-height:1;border:var(--strokeWidthThin) solid var(--colorTransparentStroke);display:flex;align-items:center;justify-content:center;vertical-align:center;text-align:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;border-radius:inherit;}", ".r31uzil{position:absolute;box-sizing:border-box;top:0;right:0;width:100%;height:100%;line-height:1;border:var(--strokeWidthThin) solid var(--colorTransparentStroke);display:flex;align-items:center;justify-content:center;vertical-align:center;text-align:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;border-radius:inherit;}"]);
    const useStyles$f = /* @__PURE__ */ __styles$3({
      textCaption2Strong: {
        Be2twd7: "f13mqy1h"
      },
      textCaption1Strong: {
        Be2twd7: "fy9rknc"
      },
      textSubtitle2: {
        Be2twd7: "fod5ikn"
      },
      textSubtitle1: {
        Be2twd7: "f1pp30po"
      },
      textTitle3: {
        Be2twd7: "f1x0m3f5"
      },
      squareSmall: {
        Bbmb7ep: ["f1g3puop", "fi2rrw2"],
        Beyfa6y: ["fi2rrw2", "f1g3puop"],
        B7oj6ja: ["f1rstyi9", "f1s4nn1u"],
        Btl43ni: ["f1s4nn1u", "f1rstyi9"]
      },
      squareMedium: {
        Bbmb7ep: ["f1aa9q02", "f16jpd5f"],
        Beyfa6y: ["f16jpd5f", "f1aa9q02"],
        B7oj6ja: ["f1jar5jt", "fyu767a"],
        Btl43ni: ["fyu767a", "f1jar5jt"]
      },
      squareLarge: {
        Bbmb7ep: ["f1ldthgs", "frrelxk"],
        Beyfa6y: ["frrelxk", "f1ldthgs"],
        B7oj6ja: ["fobrfso", "ffisxpw"],
        Btl43ni: ["ffisxpw", "fobrfso"]
      },
      squareXLarge: {
        Bbmb7ep: ["fnivh3a", "fc7yr5o"],
        Beyfa6y: ["fc7yr5o", "fnivh3a"],
        B7oj6ja: ["f1el4m67", "f8yange"],
        Btl43ni: ["f8yange", "f1el4m67"]
      },
      activeOrInactive: {
        Bz10aip: "ftfx35i",
        Bmy1vo4: "fv0atk9",
        B3o57yi: "f1iry5bo",
        Bkqvd7p: "f15n41j8",
        Hwfdqs: "f1onx1g3"
      },
      ring: {
        Ftih45: "f1wl9k8s"
      },
      ringBadgeCutout: {
        f4a502: "fp2gujx"
      },
      ringThick: {
        of393c: "fq1w1vq"
      },
      ringThicker: {
        of393c: "fzg6ace"
      },
      ringThickest: {
        of393c: "f1nu8p71"
      },
      shadow: {
        Bsft5z2: "f13zj6fq"
      },
      shadow4: {
        Be6vj1x: "fcjn15l"
      },
      shadow8: {
        Be6vj1x: "f1tm8t9f"
      },
      shadow16: {
        Be6vj1x: "f1a1aohj"
      },
      shadow28: {
        Be6vj1x: "fond6v5"
      },
      inactive: {
        abs64n: "fp25eh",
        Bz10aip: "f1clczzi",
        Bkqvd7p: "f1l3s34x",
        Bucmhp4: "f1f5ar78",
        b2tv09: ["fqxtap0", "fhjukvy"],
        Bfgortx: "f1qj1nzo",
        Bnvr3x9: ["fhjukvy", "fqxtap0"],
        b6ubon: "fw457kn",
        Bqinb2h: "f1wmllxl"
      },
      badge: {
        qhf8xq: "f1euv43f",
        B5kzvoi: "f1yab3r1",
        j35jbq: ["f1e31b4d", "f1vgc2s3"]
      },
      badgeCutout: {
        btxmck: "f1eugkqs"
      },
      badgeAlign: {
        Dnlfbu: ["f1tlnv9o", "f1y9kyih"]
      },
      tiny: {
        Bdjeniz: "f1uwoubl",
        niu6jh: "fid048z"
      },
      "extra-small": {
        Bdjeniz: "f13ar0e0",
        niu6jh: "fid048z"
      },
      small: {
        Bdjeniz: "fwwuruf",
        niu6jh: "fid048z"
      },
      medium: {
        Bdjeniz: "f1af27q5",
        niu6jh: "fid048z"
      },
      large: {
        Bdjeniz: "f18yy57a",
        niu6jh: "f924bxt"
      },
      "extra-large": {
        Bdjeniz: "f2jg042",
        niu6jh: "f924bxt"
      },
      icon12: {
        Be2twd7: "f1ugzwwg"
      },
      icon16: {
        Be2twd7: "f4ybsrx"
      },
      icon20: {
        Be2twd7: "fe5j1ua"
      },
      icon24: {
        Be2twd7: "f1rt2boy"
      },
      icon28: {
        Be2twd7: "f24l1pt"
      },
      icon32: {
        Be2twd7: "ffl51b"
      },
      icon48: {
        Be2twd7: "f18m8u13"
      }
    }, {
      d: [".f13mqy1h{font-size:var(--fontSizeBase100);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".f1pp30po{font-size:var(--fontSizeBase500);}", ".f1x0m3f5{font-size:var(--fontSizeBase600);}", ".f1g3puop{border-bottom-right-radius:var(--borderRadiusSmall);}", ".fi2rrw2{border-bottom-left-radius:var(--borderRadiusSmall);}", ".f1rstyi9{border-top-right-radius:var(--borderRadiusSmall);}", ".f1s4nn1u{border-top-left-radius:var(--borderRadiusSmall);}", ".f1aa9q02{border-bottom-right-radius:var(--borderRadiusMedium);}", ".f16jpd5f{border-bottom-left-radius:var(--borderRadiusMedium);}", ".f1jar5jt{border-top-right-radius:var(--borderRadiusMedium);}", ".fyu767a{border-top-left-radius:var(--borderRadiusMedium);}", ".f1ldthgs{border-bottom-right-radius:var(--borderRadiusLarge);}", ".frrelxk{border-bottom-left-radius:var(--borderRadiusLarge);}", ".fobrfso{border-top-right-radius:var(--borderRadiusLarge);}", ".ffisxpw{border-top-left-radius:var(--borderRadiusLarge);}", ".fnivh3a{border-bottom-right-radius:var(--borderRadiusXLarge);}", ".fc7yr5o{border-bottom-left-radius:var(--borderRadiusXLarge);}", ".f1el4m67{border-top-right-radius:var(--borderRadiusXLarge);}", ".f8yange{border-top-left-radius:var(--borderRadiusXLarge);}", ".ftfx35i{transform:perspective(1px);}", ".fv0atk9{transition-property:transform,opacity;}", ".f1iry5bo{transition-duration:var(--durationUltraSlow),var(--durationFaster);}", ".f15n41j8{transition-timing-function:var(--curveEasyEaseMax),var(--curveLinear);}", '.f1wl9k8s::before{content:"";}', ".fp2gujx::before{-webkit-mask-image:radial-gradient(circle at bottom calc(var(--fui-Avatar-badgeRadius) + 2 * var(--fui-Avatar-ringWidth)) var(--fui-Avatar-badgeAlign) calc(var(--fui-Avatar-badgeRadius) + 2 * var(--fui-Avatar-ringWidth)), transparent calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) - 0.25px), white calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) + 0.25px));mask-image:radial-gradient(circle at bottom calc(var(--fui-Avatar-badgeRadius) + 2 * var(--fui-Avatar-ringWidth)) var(--fui-Avatar-badgeAlign) calc(var(--fui-Avatar-badgeRadius) + 2 * var(--fui-Avatar-ringWidth)), transparent calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) - 0.25px), white calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) + 0.25px));}", ".fq1w1vq{--fui-Avatar-ringWidth:var(--strokeWidthThick);}", ".fzg6ace{--fui-Avatar-ringWidth:var(--strokeWidthThicker);}", ".f1nu8p71{--fui-Avatar-ringWidth:var(--strokeWidthThickest);}", '.f13zj6fq::after{content:"";}', ".fcjn15l::after{box-shadow:var(--shadow4);}", ".f1tm8t9f::after{box-shadow:var(--shadow8);}", ".f1a1aohj::after{box-shadow:var(--shadow16);}", ".fond6v5::after{box-shadow:var(--shadow28);}", ".fp25eh{opacity:0.8;}", ".f1clczzi{transform:scale(0.875);}", ".f1l3s34x{transition-timing-function:var(--curveDecelerateMin),var(--curveLinear);}", ".f1f5ar78::before,.f1f5ar78::after{margin-top:0;}", ".fqxtap0::before,.fqxtap0::after{margin-right:0;}", ".fhjukvy::before,.fhjukvy::after{margin-left:0;}", ".f1qj1nzo::before,.f1qj1nzo::after{margin-bottom:0;}", ".fw457kn::before,.fw457kn::after{opacity:0;}", ".f1wmllxl::before,.f1wmllxl::after{transition-timing-function:var(--curveDecelerateMin),var(--curveLinear);}", ".f1euv43f{position:absolute;}", ".f1yab3r1{bottom:0;}", ".f1e31b4d{right:0;}", ".f1vgc2s3{left:0;}", ".f1eugkqs{-webkit-mask-image:radial-gradient(circle at bottom var(--fui-Avatar-badgeRadius) var(--fui-Avatar-badgeAlign) var(--fui-Avatar-badgeRadius), transparent calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) - 0.25px), white calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) + 0.25px));mask-image:radial-gradient(circle at bottom var(--fui-Avatar-badgeRadius) var(--fui-Avatar-badgeAlign) var(--fui-Avatar-badgeRadius), transparent calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) - 0.25px), white calc(var(--fui-Avatar-badgeRadius) + var(--fui-Avatar-badgeGap) + 0.25px));}", ".f1tlnv9o{--fui-Avatar-badgeAlign:right;}", ".f1y9kyih{--fui-Avatar-badgeAlign:left;}", ".f1uwoubl{--fui-Avatar-badgeRadius:3px;}", ".fid048z{--fui-Avatar-badgeGap:var(--strokeWidthThin);}", ".f13ar0e0{--fui-Avatar-badgeRadius:5px;}", ".fwwuruf{--fui-Avatar-badgeRadius:6px;}", ".f1af27q5{--fui-Avatar-badgeRadius:8px;}", ".f18yy57a{--fui-Avatar-badgeRadius:10px;}", ".f924bxt{--fui-Avatar-badgeGap:var(--strokeWidthThick);}", ".f2jg042{--fui-Avatar-badgeRadius:14px;}", ".f1ugzwwg{font-size:12px;}", ".f4ybsrx{font-size:16px;}", ".fe5j1ua{font-size:20px;}", ".f1rt2boy{font-size:24px;}", ".f24l1pt{font-size:28px;}", ".ffl51b{font-size:32px;}", ".f18m8u13{font-size:48px;}"],
      m: [["@media screen and (prefers-reduced-motion: reduce){.f1onx1g3{transition-duration:0.01ms;}}", {
        m: "screen and (prefers-reduced-motion: reduce)"
      }]]
    });
    const useSizeStyles = /* @__PURE__ */ __styles$3({
      "16": {
        a9b677: "fjw5fx7",
        Bqenvij: "fd461yt"
      },
      "20": {
        a9b677: "f64fuq3",
        Bqenvij: "fjamq6b"
      },
      "24": {
        a9b677: "fq4mcun",
        Bqenvij: "frvgh55"
      },
      "28": {
        a9b677: "f1w9dchk",
        Bqenvij: "fxldao9"
      },
      "32": {
        a9b677: "f1szoe96",
        Bqenvij: "f1d2rq10"
      },
      "36": {
        a9b677: "fpdz1er",
        Bqenvij: "f8ljn23"
      },
      "40": {
        a9b677: "feqmc2u",
        Bqenvij: "fbhnoac"
      },
      "48": {
        a9b677: "f124akge",
        Bqenvij: "ff2sm71"
      },
      "56": {
        a9b677: "f1u66zr1",
        Bqenvij: "fzki0ko"
      },
      "64": {
        a9b677: "fa9ln6p",
        Bqenvij: "f16k9i2m"
      },
      "72": {
        a9b677: "fhcae8x",
        Bqenvij: "f1shusfg"
      },
      "96": {
        a9b677: "f1kyr2gn",
        Bqenvij: "fypu0ge"
      },
      "120": {
        a9b677: "fwfqyga",
        Bqenvij: "fjr5b71"
      },
      "128": {
        a9b677: "f1iksgmy",
        Bqenvij: "fele2au"
      }
    }, {
      d: [".fjw5fx7{width:16px;}", ".fd461yt{height:16px;}", ".f64fuq3{width:20px;}", ".fjamq6b{height:20px;}", ".fq4mcun{width:24px;}", ".frvgh55{height:24px;}", ".f1w9dchk{width:28px;}", ".fxldao9{height:28px;}", ".f1szoe96{width:32px;}", ".f1d2rq10{height:32px;}", ".fpdz1er{width:36px;}", ".f8ljn23{height:36px;}", ".feqmc2u{width:40px;}", ".fbhnoac{height:40px;}", ".f124akge{width:48px;}", ".ff2sm71{height:48px;}", ".f1u66zr1{width:56px;}", ".fzki0ko{height:56px;}", ".fa9ln6p{width:64px;}", ".f16k9i2m{height:64px;}", ".fhcae8x{width:72px;}", ".f1shusfg{height:72px;}", ".f1kyr2gn{width:96px;}", ".fypu0ge{height:96px;}", ".fwfqyga{width:120px;}", ".fjr5b71{height:120px;}", ".f1iksgmy{width:128px;}", ".fele2au{height:128px;}"]
    });
    const useColorStyles = /* @__PURE__ */ __styles$3({
      neutral: {
        sj55zd: "f11d4kpn",
        De3pzq: "f18f03hv"
      },
      brand: {
        sj55zd: "fonrgv7",
        De3pzq: "f1blnnmj"
      },
      "dark-red": {
        sj55zd: "fqjd1y1",
        De3pzq: "f1vq2oo4"
      },
      cranberry: {
        sj55zd: "fg9gses",
        De3pzq: "f1lwxszt"
      },
      red: {
        sj55zd: "f23f7i0",
        De3pzq: "f1q9qhfq"
      },
      pumpkin: {
        sj55zd: "fjnan08",
        De3pzq: "fz91bi3"
      },
      peach: {
        sj55zd: "fknu15p",
        De3pzq: "f1b9nr51"
      },
      marigold: {
        sj55zd: "f9603vw",
        De3pzq: "f3z4w6d"
      },
      gold: {
        sj55zd: "fmq0uwp",
        De3pzq: "fg50kya"
      },
      brass: {
        sj55zd: "f28g5vo",
        De3pzq: "f4w2gd0"
      },
      brown: {
        sj55zd: "ftl572b",
        De3pzq: "f14wu1f4"
      },
      forest: {
        sj55zd: "f1gymlvd",
        De3pzq: "f19ut4y6"
      },
      seafoam: {
        sj55zd: "fnnb6wn",
        De3pzq: "f1n057jc"
      },
      "dark-green": {
        sj55zd: "ff58qw8",
        De3pzq: "f11t05wk"
      },
      "light-teal": {
        sj55zd: "f1up9qbj",
        De3pzq: "f42feg1"
      },
      teal: {
        sj55zd: "f135dsb4",
        De3pzq: "f6hvv1p"
      },
      steel: {
        sj55zd: "f151dlcp",
        De3pzq: "f1lnp8zf"
      },
      blue: {
        sj55zd: "f1rjv50u",
        De3pzq: "f1ggcpy6"
      },
      "royal-blue": {
        sj55zd: "f1emykk5",
        De3pzq: "f12rj61f"
      },
      cornflower: {
        sj55zd: "fqsigj7",
        De3pzq: "f8k7hur"
      },
      navy: {
        sj55zd: "f1nj97xi",
        De3pzq: "f19gw0ux"
      },
      lavender: {
        sj55zd: "fwctg0i",
        De3pzq: "ff379vm"
      },
      purple: {
        sj55zd: "fjrsgpu",
        De3pzq: "f1mzf1e1"
      },
      grape: {
        sj55zd: "f1fiiydq",
        De3pzq: "f1o4k8oy"
      },
      lilac: {
        sj55zd: "f1res9jt",
        De3pzq: "f1x6mz1o"
      },
      pink: {
        sj55zd: "fv3fbbi",
        De3pzq: "fydlv6t"
      },
      magenta: {
        sj55zd: "f1f1fwnz",
        De3pzq: "f4xb6j5"
      },
      plum: {
        sj55zd: "f8ptl6j",
        De3pzq: "fqo8e26"
      },
      beige: {
        sj55zd: "f1ntv3ld",
        De3pzq: "f101elhj"
      },
      mink: {
        sj55zd: "f1fscmp",
        De3pzq: "f13g8o5c"
      },
      platinum: {
        sj55zd: "f1dr00v2",
        De3pzq: "fkh7blw"
      },
      anchor: {
        sj55zd: "f1f3ti53",
        De3pzq: "fu4yj0j"
      }
    }, {
      d: [".f11d4kpn{color:var(--colorNeutralForeground3);}", ".f18f03hv{background-color:var(--colorNeutralBackground6);}", ".fonrgv7{color:var(--colorNeutralForegroundStaticInverted);}", ".f1blnnmj{background-color:var(--colorBrandBackgroundStatic);}", ".fqjd1y1{color:var(--colorPaletteDarkRedForeground2);}", ".f1vq2oo4{background-color:var(--colorPaletteDarkRedBackground2);}", ".fg9gses{color:var(--colorPaletteCranberryForeground2);}", ".f1lwxszt{background-color:var(--colorPaletteCranberryBackground2);}", ".f23f7i0{color:var(--colorPaletteRedForeground2);}", ".f1q9qhfq{background-color:var(--colorPaletteRedBackground2);}", ".fjnan08{color:var(--colorPalettePumpkinForeground2);}", ".fz91bi3{background-color:var(--colorPalettePumpkinBackground2);}", ".fknu15p{color:var(--colorPalettePeachForeground2);}", ".f1b9nr51{background-color:var(--colorPalettePeachBackground2);}", ".f9603vw{color:var(--colorPaletteMarigoldForeground2);}", ".f3z4w6d{background-color:var(--colorPaletteMarigoldBackground2);}", ".fmq0uwp{color:var(--colorPaletteGoldForeground2);}", ".fg50kya{background-color:var(--colorPaletteGoldBackground2);}", ".f28g5vo{color:var(--colorPaletteBrassForeground2);}", ".f4w2gd0{background-color:var(--colorPaletteBrassBackground2);}", ".ftl572b{color:var(--colorPaletteBrownForeground2);}", ".f14wu1f4{background-color:var(--colorPaletteBrownBackground2);}", ".f1gymlvd{color:var(--colorPaletteForestForeground2);}", ".f19ut4y6{background-color:var(--colorPaletteForestBackground2);}", ".fnnb6wn{color:var(--colorPaletteSeafoamForeground2);}", ".f1n057jc{background-color:var(--colorPaletteSeafoamBackground2);}", ".ff58qw8{color:var(--colorPaletteDarkGreenForeground2);}", ".f11t05wk{background-color:var(--colorPaletteDarkGreenBackground2);}", ".f1up9qbj{color:var(--colorPaletteLightTealForeground2);}", ".f42feg1{background-color:var(--colorPaletteLightTealBackground2);}", ".f135dsb4{color:var(--colorPaletteTealForeground2);}", ".f6hvv1p{background-color:var(--colorPaletteTealBackground2);}", ".f151dlcp{color:var(--colorPaletteSteelForeground2);}", ".f1lnp8zf{background-color:var(--colorPaletteSteelBackground2);}", ".f1rjv50u{color:var(--colorPaletteBlueForeground2);}", ".f1ggcpy6{background-color:var(--colorPaletteBlueBackground2);}", ".f1emykk5{color:var(--colorPaletteRoyalBlueForeground2);}", ".f12rj61f{background-color:var(--colorPaletteRoyalBlueBackground2);}", ".fqsigj7{color:var(--colorPaletteCornflowerForeground2);}", ".f8k7hur{background-color:var(--colorPaletteCornflowerBackground2);}", ".f1nj97xi{color:var(--colorPaletteNavyForeground2);}", ".f19gw0ux{background-color:var(--colorPaletteNavyBackground2);}", ".fwctg0i{color:var(--colorPaletteLavenderForeground2);}", ".ff379vm{background-color:var(--colorPaletteLavenderBackground2);}", ".fjrsgpu{color:var(--colorPalettePurpleForeground2);}", ".f1mzf1e1{background-color:var(--colorPalettePurpleBackground2);}", ".f1fiiydq{color:var(--colorPaletteGrapeForeground2);}", ".f1o4k8oy{background-color:var(--colorPaletteGrapeBackground2);}", ".f1res9jt{color:var(--colorPaletteLilacForeground2);}", ".f1x6mz1o{background-color:var(--colorPaletteLilacBackground2);}", ".fv3fbbi{color:var(--colorPalettePinkForeground2);}", ".fydlv6t{background-color:var(--colorPalettePinkBackground2);}", ".f1f1fwnz{color:var(--colorPaletteMagentaForeground2);}", ".f4xb6j5{background-color:var(--colorPaletteMagentaBackground2);}", ".f8ptl6j{color:var(--colorPalettePlumForeground2);}", ".fqo8e26{background-color:var(--colorPalettePlumBackground2);}", ".f1ntv3ld{color:var(--colorPaletteBeigeForeground2);}", ".f101elhj{background-color:var(--colorPaletteBeigeBackground2);}", ".f1fscmp{color:var(--colorPaletteMinkForeground2);}", ".f13g8o5c{background-color:var(--colorPaletteMinkBackground2);}", ".f1dr00v2{color:var(--colorPalettePlatinumForeground2);}", ".fkh7blw{background-color:var(--colorPalettePlatinumBackground2);}", ".f1f3ti53{color:var(--colorPaletteAnchorForeground2);}", ".fu4yj0j{background-color:var(--colorPaletteAnchorBackground2);}"]
    });
    const useRingColorStyles = /* @__PURE__ */ __styles$3({
      neutral: {
        Bic5iru: "f1uuiafn"
      },
      brand: {
        Bic5iru: "f1uuiafn"
      },
      "dark-red": {
        Bic5iru: "f1t2x9on"
      },
      cranberry: {
        Bic5iru: "f1pvshc9"
      },
      red: {
        Bic5iru: "f1ectbk9"
      },
      pumpkin: {
        Bic5iru: "fvzpl0b"
      },
      peach: {
        Bic5iru: "fwj2kd7"
      },
      marigold: {
        Bic5iru: "fr120vy"
      },
      gold: {
        Bic5iru: "f8xmmar"
      },
      brass: {
        Bic5iru: "f1hbety2"
      },
      brown: {
        Bic5iru: "f1vg3s4g"
      },
      forest: {
        Bic5iru: "f1m3olm5"
      },
      seafoam: {
        Bic5iru: "f17xiqtr"
      },
      "dark-green": {
        Bic5iru: "fx32vyh"
      },
      "light-teal": {
        Bic5iru: "f1mkihwv"
      },
      teal: {
        Bic5iru: "fecnooh"
      },
      steel: {
        Bic5iru: "f15hfgzm"
      },
      blue: {
        Bic5iru: "fqproka"
      },
      "royal-blue": {
        Bic5iru: "f17v2w59"
      },
      cornflower: {
        Bic5iru: "fp0q1mo"
      },
      navy: {
        Bic5iru: "f1nlym55"
      },
      lavender: {
        Bic5iru: "f62vk8h"
      },
      purple: {
        Bic5iru: "f15zl69q"
      },
      grape: {
        Bic5iru: "f53w4j7"
      },
      lilac: {
        Bic5iru: "fu2771t"
      },
      pink: {
        Bic5iru: "fzflscs"
      },
      magenta: {
        Bic5iru: "fb6rmqc"
      },
      plum: {
        Bic5iru: "f1a4gm5b"
      },
      beige: {
        Bic5iru: "f1qpf9z1"
      },
      mink: {
        Bic5iru: "f1l7or83"
      },
      platinum: {
        Bic5iru: "fzrj0iu"
      },
      anchor: {
        Bic5iru: "f8oz6wf"
      }
    }, {
      d: [".f1uuiafn::before{color:var(--colorBrandStroke1);}", ".f1t2x9on::before{color:var(--colorPaletteDarkRedBorderActive);}", ".f1pvshc9::before{color:var(--colorPaletteCranberryBorderActive);}", ".f1ectbk9::before{color:var(--colorPaletteRedBorderActive);}", ".fvzpl0b::before{color:var(--colorPalettePumpkinBorderActive);}", ".fwj2kd7::before{color:var(--colorPalettePeachBorderActive);}", ".fr120vy::before{color:var(--colorPaletteMarigoldBorderActive);}", ".f8xmmar::before{color:var(--colorPaletteGoldBorderActive);}", ".f1hbety2::before{color:var(--colorPaletteBrassBorderActive);}", ".f1vg3s4g::before{color:var(--colorPaletteBrownBorderActive);}", ".f1m3olm5::before{color:var(--colorPaletteForestBorderActive);}", ".f17xiqtr::before{color:var(--colorPaletteSeafoamBorderActive);}", ".fx32vyh::before{color:var(--colorPaletteDarkGreenBorderActive);}", ".f1mkihwv::before{color:var(--colorPaletteLightTealBorderActive);}", ".fecnooh::before{color:var(--colorPaletteTealBorderActive);}", ".f15hfgzm::before{color:var(--colorPaletteSteelBorderActive);}", ".fqproka::before{color:var(--colorPaletteBlueBorderActive);}", ".f17v2w59::before{color:var(--colorPaletteRoyalBlueBorderActive);}", ".fp0q1mo::before{color:var(--colorPaletteCornflowerBorderActive);}", ".f1nlym55::before{color:var(--colorPaletteNavyBorderActive);}", ".f62vk8h::before{color:var(--colorPaletteLavenderBorderActive);}", ".f15zl69q::before{color:var(--colorPalettePurpleBorderActive);}", ".f53w4j7::before{color:var(--colorPaletteGrapeBorderActive);}", ".fu2771t::before{color:var(--colorPaletteLilacBorderActive);}", ".fzflscs::before{color:var(--colorPalettePinkBorderActive);}", ".fb6rmqc::before{color:var(--colorPaletteMagentaBorderActive);}", ".f1a4gm5b::before{color:var(--colorPalettePlumBorderActive);}", ".f1qpf9z1::before{color:var(--colorPaletteBeigeBorderActive);}", ".f1l7or83::before{color:var(--colorPaletteMinkBorderActive);}", ".fzrj0iu::before{color:var(--colorPalettePlatinumBorderActive);}", ".f8oz6wf::before{color:var(--colorPaletteAnchorBorderActive);}"]
    });
    const useAvatarStyles_unstable = (state) => {
      const {
        size,
        shape,
        active,
        activeAppearance,
        color: color2
      } = state;
      const rootClassName = useRootClassName$1();
      const imageClassName = useImageClassName();
      const iconInitialsClassName = useIconInitialsClassName();
      const styles2 = useStyles$f();
      const sizeStyles = useSizeStyles();
      const colorStyles = useColorStyles();
      const ringColorStyles = useRingColorStyles();
      const rootClasses = [rootClassName, size !== 32 && sizeStyles[size]];
      if (state.badge) {
        rootClasses.push(styles2.badgeAlign, styles2[state.badge.size || "medium"]);
      }
      if (size <= 24) {
        rootClasses.push(styles2.textCaption2Strong);
      } else if (size <= 28) {
        rootClasses.push(styles2.textCaption1Strong);
      } else if (size <= 40)
        ;
      else if (size <= 56) {
        rootClasses.push(styles2.textSubtitle2);
      } else if (size <= 96) {
        rootClasses.push(styles2.textSubtitle1);
      } else {
        rootClasses.push(styles2.textTitle3);
      }
      if (shape === "square") {
        if (size <= 24) {
          rootClasses.push(styles2.squareSmall);
        } else if (size <= 48) {
          rootClasses.push(styles2.squareMedium);
        } else if (size <= 72) {
          rootClasses.push(styles2.squareLarge);
        } else {
          rootClasses.push(styles2.squareXLarge);
        }
      }
      if (active === "active" || active === "inactive") {
        rootClasses.push(styles2.activeOrInactive);
        if (activeAppearance === "ring" || activeAppearance === "ring-shadow") {
          rootClasses.push(styles2.ring, ringColorStyles[color2]);
          if (state.badge) {
            rootClasses.push(styles2.ringBadgeCutout);
          }
          if (size <= 48) {
            rootClasses.push(styles2.ringThick);
          } else if (size <= 64) {
            rootClasses.push(styles2.ringThicker);
          } else {
            rootClasses.push(styles2.ringThickest);
          }
        }
        if (activeAppearance === "shadow" || activeAppearance === "ring-shadow") {
          rootClasses.push(styles2.shadow);
          if (size <= 28) {
            rootClasses.push(styles2.shadow4);
          } else if (size <= 48) {
            rootClasses.push(styles2.shadow8);
          } else if (size <= 64) {
            rootClasses.push(styles2.shadow16);
          } else {
            rootClasses.push(styles2.shadow28);
          }
        }
        if (active === "inactive") {
          rootClasses.push(styles2.inactive);
        }
      }
      state.root.className = mergeClasses$2(avatarClassNames.root, ...rootClasses, state.root.className);
      if (state.badge) {
        state.badge.className = mergeClasses$2(avatarClassNames.badge, styles2.badge, state.badge.className);
      }
      if (state.image) {
        state.image.className = mergeClasses$2(avatarClassNames.image, imageClassName, colorStyles[color2], state.badge && styles2.badgeCutout, state.image.className);
      }
      if (state.initials) {
        state.initials.className = mergeClasses$2(avatarClassNames.initials, iconInitialsClassName, colorStyles[color2], state.badge && styles2.badgeCutout, state.initials.className);
      }
      if (state.icon) {
        let iconSizeClass;
        if (size <= 16) {
          iconSizeClass = styles2.icon12;
        } else if (size <= 24) {
          iconSizeClass = styles2.icon16;
        } else if (size <= 40) {
          iconSizeClass = styles2.icon20;
        } else if (size <= 48) {
          iconSizeClass = styles2.icon24;
        } else if (size <= 56) {
          iconSizeClass = styles2.icon28;
        } else if (size <= 72) {
          iconSizeClass = styles2.icon32;
        } else {
          iconSizeClass = styles2.icon48;
        }
        state.icon.className = mergeClasses$2(avatarClassNames.icon, iconInitialsClassName, iconSizeClass, colorStyles[color2], state.badge && styles2.badgeCutout, state.icon.className);
      }
      return state;
    };
    const Avatar = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const state = useAvatar_unstable(props, ref);
      useAvatarStyles_unstable(state);
      useCustomStyleHook("useAvatarStyles_unstable")(state);
      return renderAvatar_unstable(state);
    });
    Avatar.displayName = "Avatar";
    function createVirtualElementFromClick(nativeEvent) {
      const left = nativeEvent.clientX;
      const top = nativeEvent.clientY;
      const right = left + 1;
      const bottom = top + 1;
      function getBoundingClientRect() {
        return {
          left,
          top,
          right,
          bottom,
          x: left,
          y: top,
          height: 1,
          width: 1
        };
      }
      return {
        getBoundingClientRect
      };
    }
    const DATA_POSITIONING_INTERSECTING = "data-popper-is-intersecting";
    const DATA_POSITIONING_ESCAPED = "data-popper-escaped";
    const DATA_POSITIONING_HIDDEN = "data-popper-reference-hidden";
    const DATA_POSITIONING_PLACEMENT = "data-popper-placement";
    function t$2(t2) {
      return t2.split("-")[1];
    }
    function e$2(t2) {
      return "y" === t2 ? "height" : "width";
    }
    function n$3(t2) {
      return t2.split("-")[0];
    }
    function o$1(t2) {
      return ["top", "bottom"].includes(n$3(t2)) ? "x" : "y";
    }
    function i$2(i2, r2, a2) {
      let { reference: l2, floating: s2 } = i2;
      const c2 = l2.x + l2.width / 2 - s2.width / 2, f2 = l2.y + l2.height / 2 - s2.height / 2, m2 = o$1(r2), u2 = e$2(m2), g2 = l2[u2] / 2 - s2[u2] / 2, d2 = "x" === m2;
      let p2;
      switch (n$3(r2)) {
        case "top":
          p2 = { x: c2, y: l2.y - s2.height };
          break;
        case "bottom":
          p2 = { x: c2, y: l2.y + l2.height };
          break;
        case "right":
          p2 = { x: l2.x + l2.width, y: f2 };
          break;
        case "left":
          p2 = { x: l2.x - s2.width, y: f2 };
          break;
        default:
          p2 = { x: l2.x, y: l2.y };
      }
      switch (t$2(r2)) {
        case "start":
          p2[m2] -= g2 * (a2 && d2 ? -1 : 1);
          break;
        case "end":
          p2[m2] += g2 * (a2 && d2 ? -1 : 1);
      }
      return p2;
    }
    const r$4 = async (t2, e2, n2) => {
      const { placement: o2 = "bottom", strategy: r2 = "absolute", middleware: a2 = [], platform: l2 } = n2, s2 = a2.filter(Boolean), c2 = await (null == l2.isRTL ? void 0 : l2.isRTL(e2));
      let f2 = await l2.getElementRects({ reference: t2, floating: e2, strategy: r2 }), { x: m2, y: u2 } = i$2(f2, o2, c2), g2 = o2, d2 = {}, p2 = 0;
      for (let n3 = 0; n3 < s2.length; n3++) {
        const { name: a3, fn: h2 } = s2[n3], { x: y2, y: x2, data: w2, reset: v2 } = await h2({ x: m2, y: u2, initialPlacement: o2, placement: g2, strategy: r2, middlewareData: d2, rects: f2, platform: l2, elements: { reference: t2, floating: e2 } });
        m2 = null != y2 ? y2 : m2, u2 = null != x2 ? x2 : u2, d2 = { ...d2, [a3]: { ...d2[a3], ...w2 } }, v2 && p2 <= 50 && (p2++, "object" == typeof v2 && (v2.placement && (g2 = v2.placement), v2.rects && (f2 = true === v2.rects ? await l2.getElementRects({ reference: t2, floating: e2, strategy: r2 }) : v2.rects), { x: m2, y: u2 } = i$2(f2, g2, c2)), n3 = -1);
      }
      return { x: m2, y: u2, placement: g2, strategy: r2, middlewareData: d2 };
    };
    function a$1(t2) {
      return "number" != typeof t2 ? function(t3) {
        return { top: 0, right: 0, bottom: 0, left: 0, ...t3 };
      }(t2) : { top: t2, right: t2, bottom: t2, left: t2 };
    }
    function l$4(t2) {
      return { ...t2, top: t2.y, left: t2.x, right: t2.x + t2.width, bottom: t2.y + t2.height };
    }
    async function s$2(t2, e2) {
      var n2;
      void 0 === e2 && (e2 = {});
      const { x: o2, y: i2, platform: r2, rects: s2, elements: c2, strategy: f2 } = t2, { boundary: m2 = "clippingAncestors", rootBoundary: u2 = "viewport", elementContext: g2 = "floating", altBoundary: d2 = false, padding: p2 = 0 } = e2, h2 = a$1(p2), y2 = c2[d2 ? "floating" === g2 ? "reference" : "floating" : g2], x2 = l$4(await r2.getClippingRect({ element: null == (n2 = await (null == r2.isElement ? void 0 : r2.isElement(y2))) || n2 ? y2 : y2.contextElement || await (null == r2.getDocumentElement ? void 0 : r2.getDocumentElement(c2.floating)), boundary: m2, rootBoundary: u2, strategy: f2 })), w2 = "floating" === g2 ? { ...s2.floating, x: o2, y: i2 } : s2.reference, v2 = await (null == r2.getOffsetParent ? void 0 : r2.getOffsetParent(c2.floating)), b2 = await (null == r2.isElement ? void 0 : r2.isElement(v2)) && await (null == r2.getScale ? void 0 : r2.getScale(v2)) || { x: 1, y: 1 }, A2 = l$4(r2.convertOffsetParentRelativeRectToViewportRelativeRect ? await r2.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: w2, offsetParent: v2, strategy: f2 }) : w2);
      return { top: (x2.top - A2.top + h2.top) / b2.y, bottom: (A2.bottom - x2.bottom + h2.bottom) / b2.y, left: (x2.left - A2.left + h2.left) / b2.x, right: (A2.right - x2.right + h2.right) / b2.x };
    }
    const c$4 = Math.min, f$2 = Math.max;
    function m$3(t2, e2, n2) {
      return f$2(t2, c$4(e2, n2));
    }
    const u$3 = (n2) => ({ name: "arrow", options: n2, async fn(i2) {
      const { element: r2, padding: l2 = 0 } = n2 || {}, { x: s2, y: c2, placement: f2, rects: u2, platform: g2, elements: d2 } = i2;
      if (null == r2)
        return {};
      const p2 = a$1(l2), h2 = { x: s2, y: c2 }, y2 = o$1(f2), x2 = e$2(y2), w2 = await g2.getDimensions(r2), v2 = "y" === y2, b2 = v2 ? "top" : "left", A2 = v2 ? "bottom" : "right", R2 = v2 ? "clientHeight" : "clientWidth", P2 = u2.reference[x2] + u2.reference[y2] - h2[y2] - u2.floating[x2], E2 = h2[y2] - u2.reference[y2], T2 = await (null == g2.getOffsetParent ? void 0 : g2.getOffsetParent(r2));
      let D2 = T2 ? T2[R2] : 0;
      D2 && await (null == g2.isElement ? void 0 : g2.isElement(T2)) || (D2 = d2.floating[R2] || u2.floating[x2]);
      const L2 = P2 / 2 - E2 / 2, k2 = p2[b2], O2 = D2 - w2[x2] - p2[A2], B2 = D2 / 2 - w2[x2] / 2 + L2, C2 = m$3(k2, B2, O2), H2 = null != t$2(f2) && B2 != C2 && u2.reference[x2] / 2 - (B2 < k2 ? p2[b2] : p2[A2]) - w2[x2] / 2 < 0;
      return { [y2]: h2[y2] - (H2 ? B2 < k2 ? k2 - B2 : O2 - B2 : 0), data: { [y2]: C2, centerOffset: B2 - C2 } };
    } }), g$2 = ["top", "right", "bottom", "left"];
    g$2.reduce((t2, e2) => t2.concat(e2, e2 + "-start", e2 + "-end"), []);
    const p$3 = { left: "right", right: "left", bottom: "top", top: "bottom" };
    function h$4(t2) {
      return t2.replace(/left|right|bottom|top/g, (t3) => p$3[t3]);
    }
    function y$1(n2, i2, r2) {
      void 0 === r2 && (r2 = false);
      const a2 = t$2(n2), l2 = o$1(n2), s2 = e$2(l2);
      let c2 = "x" === l2 ? a2 === (r2 ? "end" : "start") ? "right" : "left" : "start" === a2 ? "bottom" : "top";
      return i2.reference[s2] > i2.floating[s2] && (c2 = h$4(c2)), { main: c2, cross: h$4(c2) };
    }
    const x$2 = { start: "end", end: "start" };
    function w$1(t2) {
      return t2.replace(/start|end/g, (t3) => x$2[t3]);
    }
    const b$2 = function(e2) {
      return void 0 === e2 && (e2 = {}), { name: "flip", options: e2, async fn(o2) {
        var i2;
        const { placement: r2, middlewareData: a2, rects: l2, initialPlacement: c2, platform: f2, elements: m2 } = o2, { mainAxis: u2 = true, crossAxis: g2 = true, fallbackPlacements: d2, fallbackStrategy: p2 = "bestFit", fallbackAxisSideDirection: x2 = "none", flipAlignment: v2 = true, ...b2 } = e2, A2 = n$3(r2), R2 = n$3(c2) === c2, P2 = await (null == f2.isRTL ? void 0 : f2.isRTL(m2.floating)), E2 = d2 || (R2 || !v2 ? [h$4(c2)] : function(t2) {
          const e3 = h$4(t2);
          return [w$1(t2), e3, w$1(e3)];
        }(c2));
        d2 || "none" === x2 || E2.push(...function(e3, o3, i3, r3) {
          const a3 = t$2(e3);
          let l3 = function(t2, e4, n2) {
            const o4 = ["left", "right"], i4 = ["right", "left"], r4 = ["top", "bottom"], a4 = ["bottom", "top"];
            switch (t2) {
              case "top":
              case "bottom":
                return n2 ? e4 ? i4 : o4 : e4 ? o4 : i4;
              case "left":
              case "right":
                return e4 ? r4 : a4;
              default:
                return [];
            }
          }(n$3(e3), "start" === i3, r3);
          return a3 && (l3 = l3.map((t2) => t2 + "-" + a3), o3 && (l3 = l3.concat(l3.map(w$1)))), l3;
        }(c2, v2, x2, P2));
        const T2 = [c2, ...E2], D2 = await s$2(o2, b2), L2 = [];
        let k2 = (null == (i2 = a2.flip) ? void 0 : i2.overflows) || [];
        if (u2 && L2.push(D2[A2]), g2) {
          const { main: t2, cross: e3 } = y$1(r2, l2, P2);
          L2.push(D2[t2], D2[e3]);
        }
        if (k2 = [...k2, { placement: r2, overflows: L2 }], !L2.every((t2) => t2 <= 0)) {
          var O2, B2;
          const t2 = ((null == (O2 = a2.flip) ? void 0 : O2.index) || 0) + 1, e3 = T2[t2];
          if (e3)
            return { data: { index: t2, overflows: k2 }, reset: { placement: e3 } };
          let n2 = null == (B2 = k2.filter((t3) => t3.overflows[0] <= 0).sort((t3, e4) => t3.overflows[1] - e4.overflows[1])[0]) ? void 0 : B2.placement;
          if (!n2)
            switch (p2) {
              case "bestFit": {
                var C2;
                const t3 = null == (C2 = k2.map((t4) => [t4.placement, t4.overflows.filter((t5) => t5 > 0).reduce((t5, e4) => t5 + e4, 0)]).sort((t4, e4) => t4[1] - e4[1])[0]) ? void 0 : C2[0];
                t3 && (n2 = t3);
                break;
              }
              case "initialPlacement":
                n2 = c2;
            }
          if (r2 !== n2)
            return { reset: { placement: n2 } };
        }
        return {};
      } };
    };
    function A$1(t2, e2) {
      return { top: t2.top - e2.height, right: t2.right - e2.width, bottom: t2.bottom - e2.height, left: t2.left - e2.width };
    }
    function R$2(t2) {
      return g$2.some((e2) => t2[e2] >= 0);
    }
    const P = function(t2) {
      return void 0 === t2 && (t2 = {}), { name: "hide", options: t2, async fn(e2) {
        const { strategy: n2 = "referenceHidden", ...o2 } = t2, { rects: i2 } = e2;
        switch (n2) {
          case "referenceHidden": {
            const t3 = A$1(await s$2(e2, { ...o2, elementContext: "reference" }), i2.reference);
            return { data: { referenceHiddenOffsets: t3, referenceHidden: R$2(t3) } };
          }
          case "escaped": {
            const t3 = A$1(await s$2(e2, { ...o2, altBoundary: true }), i2.floating);
            return { data: { escapedOffsets: t3, escaped: R$2(t3) } };
          }
          default:
            return {};
        }
      } };
    };
    const D$1 = function(e2) {
      return void 0 === e2 && (e2 = 0), { name: "offset", options: e2, async fn(i2) {
        const { x: r2, y: a2 } = i2, l2 = await async function(e3, i3) {
          const { placement: r3, platform: a3, elements: l3 } = e3, s2 = await (null == a3.isRTL ? void 0 : a3.isRTL(l3.floating)), c2 = n$3(r3), f2 = t$2(r3), m2 = "x" === o$1(r3), u2 = ["left", "top"].includes(c2) ? -1 : 1, g2 = s2 && m2 ? -1 : 1, d2 = "function" == typeof i3 ? i3(e3) : i3;
          let { mainAxis: p2, crossAxis: h2, alignmentAxis: y2 } = "number" == typeof d2 ? { mainAxis: d2, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...d2 };
          return f2 && "number" == typeof y2 && (h2 = "end" === f2 ? -1 * y2 : y2), m2 ? { x: h2 * g2, y: p2 * u2 } : { x: p2 * u2, y: h2 * g2 };
        }(i2, e2);
        return { x: r2 + l2.x, y: a2 + l2.y, data: l2 };
      } };
    };
    function L$2(t2) {
      return "x" === t2 ? "y" : "x";
    }
    const k$2 = function(t2) {
      return void 0 === t2 && (t2 = {}), { name: "shift", options: t2, async fn(e2) {
        const { x: i2, y: r2, placement: a2 } = e2, { mainAxis: l2 = true, crossAxis: c2 = false, limiter: f2 = { fn: (t3) => {
          let { x: e3, y: n2 } = t3;
          return { x: e3, y: n2 };
        } }, ...u2 } = t2, g2 = { x: i2, y: r2 }, d2 = await s$2(e2, u2), p2 = o$1(n$3(a2)), h2 = L$2(p2);
        let y2 = g2[p2], x2 = g2[h2];
        if (l2) {
          const t3 = "y" === p2 ? "bottom" : "right";
          y2 = m$3(y2 + d2["y" === p2 ? "top" : "left"], y2, y2 - d2[t3]);
        }
        if (c2) {
          const t3 = "y" === h2 ? "bottom" : "right";
          x2 = m$3(x2 + d2["y" === h2 ? "top" : "left"], x2, x2 - d2[t3]);
        }
        const w2 = f2.fn({ ...e2, [p2]: y2, [h2]: x2 });
        return { ...w2, data: { x: w2.x - i2, y: w2.y - r2 } };
      } };
    }, O$1 = function(t2) {
      return void 0 === t2 && (t2 = {}), { options: t2, fn(e2) {
        const { x: i2, y: r2, placement: a2, rects: l2, middlewareData: s2 } = e2, { offset: c2 = 0, mainAxis: f2 = true, crossAxis: m2 = true } = t2, u2 = { x: i2, y: r2 }, g2 = o$1(a2), d2 = L$2(g2);
        let p2 = u2[g2], h2 = u2[d2];
        const y2 = "function" == typeof c2 ? c2(e2) : c2, x2 = "number" == typeof y2 ? { mainAxis: y2, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...y2 };
        if (f2) {
          const t3 = "y" === g2 ? "height" : "width", e3 = l2.reference[g2] - l2.floating[t3] + x2.mainAxis, n2 = l2.reference[g2] + l2.reference[t3] - x2.mainAxis;
          p2 < e3 ? p2 = e3 : p2 > n2 && (p2 = n2);
        }
        if (m2) {
          var w2, v2;
          const t3 = "y" === g2 ? "width" : "height", e3 = ["top", "left"].includes(n$3(a2)), o2 = l2.reference[d2] - l2.floating[t3] + (e3 && (null == (w2 = s2.offset) ? void 0 : w2[d2]) || 0) + (e3 ? 0 : x2.crossAxis), i3 = l2.reference[d2] + l2.reference[t3] + (e3 ? 0 : (null == (v2 = s2.offset) ? void 0 : v2[d2]) || 0) - (e3 ? x2.crossAxis : 0);
          h2 < o2 ? h2 = o2 : h2 > i3 && (h2 = i3);
        }
        return { [g2]: p2, [d2]: h2 };
      } };
    }, B = function(e2) {
      return void 0 === e2 && (e2 = {}), { name: "size", options: e2, async fn(i2) {
        const { placement: r2, rects: a2, platform: l2, elements: m2 } = i2, { apply: u2 = () => {
        }, ...g2 } = e2, d2 = await s$2(i2, g2), p2 = n$3(r2), h2 = t$2(r2), y2 = "x" === o$1(r2), { width: x2, height: w2 } = a2.floating;
        let v2, b2;
        "top" === p2 || "bottom" === p2 ? (v2 = p2, b2 = h2 === (await (null == l2.isRTL ? void 0 : l2.isRTL(m2.floating)) ? "start" : "end") ? "left" : "right") : (b2 = p2, v2 = "end" === h2 ? "top" : "bottom");
        const A2 = w2 - d2[v2], R2 = x2 - d2[b2];
        let P2 = A2, E2 = R2;
        if (y2 ? E2 = c$4(x2 - d2.right - d2.left, R2) : P2 = c$4(w2 - d2.bottom - d2.top, A2), !i2.middlewareData.shift && !h2) {
          const t2 = f$2(d2.left, 0), e3 = f$2(d2.right, 0), n2 = f$2(d2.top, 0), o2 = f$2(d2.bottom, 0);
          y2 ? E2 = x2 - 2 * (0 !== t2 || 0 !== e3 ? t2 + e3 : f$2(d2.left, d2.right)) : P2 = w2 - 2 * (0 !== n2 || 0 !== o2 ? n2 + o2 : f$2(d2.top, d2.bottom));
        }
        await u2({ ...i2, availableWidth: E2, availableHeight: P2 });
        const T2 = await l2.getDimensions(m2.floating);
        return x2 !== T2.width || w2 !== T2.height ? { reset: { rects: true } } : {};
      } };
    };
    function n$2(t2) {
      var e2;
      return (null == (e2 = t2.ownerDocument) ? void 0 : e2.defaultView) || window;
    }
    function o(t2) {
      return n$2(t2).getComputedStyle(t2);
    }
    function i$1(t2) {
      return t2 instanceof n$2(t2).Node;
    }
    function r$3(t2) {
      return i$1(t2) ? (t2.nodeName || "").toLowerCase() : "";
    }
    let l$3;
    function c$3() {
      if (l$3)
        return l$3;
      const t2 = navigator.userAgentData;
      return t2 && Array.isArray(t2.brands) ? (l$3 = t2.brands.map((t3) => t3.brand + "/" + t3.version).join(" "), l$3) : navigator.userAgent;
    }
    function s$1(t2) {
      return t2 instanceof n$2(t2).HTMLElement;
    }
    function f$1(t2) {
      return t2 instanceof n$2(t2).Element;
    }
    function u$2(t2) {
      if ("undefined" == typeof ShadowRoot)
        return false;
      return t2 instanceof n$2(t2).ShadowRoot || t2 instanceof ShadowRoot;
    }
    function a(t2) {
      const { overflow: e2, overflowX: n2, overflowY: i2, display: r2 } = o(t2);
      return /auto|scroll|overlay|hidden|clip/.test(e2 + i2 + n2) && !["inline", "contents"].includes(r2);
    }
    function d$1(t2) {
      return ["table", "td", "th"].includes(r$3(t2));
    }
    function h$3(t2) {
      const e2 = /firefox/i.test(c$3()), n2 = o(t2), i2 = n2.backdropFilter || n2.WebkitBackdropFilter;
      return "none" !== n2.transform || "none" !== n2.perspective || !!i2 && "none" !== i2 || e2 && "filter" === n2.willChange || e2 && !!n2.filter && "none" !== n2.filter || ["transform", "perspective"].some((t3) => n2.willChange.includes(t3)) || ["paint", "layout", "strict", "content"].some((t3) => {
        const e3 = n2.contain;
        return null != e3 && e3.includes(t3);
      });
    }
    function p$2() {
      return /^((?!chrome|android).)*safari/i.test(c$3());
    }
    function g$1(t2) {
      return ["html", "body", "#document"].includes(r$3(t2));
    }
    const m$2 = Math.min, y = Math.max, x$1 = Math.round;
    function w(t2) {
      const e2 = o(t2);
      let n2 = parseFloat(e2.width), i2 = parseFloat(e2.height);
      const r2 = s$1(t2), l2 = r2 ? t2.offsetWidth : n2, c2 = r2 ? t2.offsetHeight : i2, f2 = x$1(n2) !== l2 || x$1(i2) !== c2;
      return f2 && (n2 = l2, i2 = c2), { width: n2, height: i2, fallback: f2 };
    }
    function v$1(t2) {
      return f$1(t2) ? t2 : t2.contextElement;
    }
    const b$1 = { x: 1, y: 1 };
    function L$1(t2) {
      const e2 = v$1(t2);
      if (!s$1(e2))
        return b$1;
      const n2 = e2.getBoundingClientRect(), { width: o2, height: i2, fallback: r2 } = w(e2);
      let l2 = (r2 ? x$1(n2.width) : n2.width) / o2, c2 = (r2 ? x$1(n2.height) : n2.height) / i2;
      return l2 && Number.isFinite(l2) || (l2 = 1), c2 && Number.isFinite(c2) || (c2 = 1), { x: l2, y: c2 };
    }
    function E(e2, o2, i2, r2) {
      var l2, c2;
      void 0 === o2 && (o2 = false), void 0 === i2 && (i2 = false);
      const s2 = e2.getBoundingClientRect(), u2 = v$1(e2);
      let a2 = b$1;
      o2 && (r2 ? f$1(r2) && (a2 = L$1(r2)) : a2 = L$1(e2));
      const d2 = u2 ? n$2(u2) : window, h2 = p$2() && i2;
      let g2 = (s2.left + (h2 && (null == (l2 = d2.visualViewport) ? void 0 : l2.offsetLeft) || 0)) / a2.x, m2 = (s2.top + (h2 && (null == (c2 = d2.visualViewport) ? void 0 : c2.offsetTop) || 0)) / a2.y, y2 = s2.width / a2.x, x2 = s2.height / a2.y;
      if (u2) {
        const t2 = n$2(u2), e3 = r2 && f$1(r2) ? n$2(r2) : r2;
        let o3 = t2.frameElement;
        for (; o3 && r2 && e3 !== t2; ) {
          const t3 = L$1(o3), e4 = o3.getBoundingClientRect(), i3 = getComputedStyle(o3);
          e4.x += (o3.clientLeft + parseFloat(i3.paddingLeft)) * t3.x, e4.y += (o3.clientTop + parseFloat(i3.paddingTop)) * t3.y, g2 *= t3.x, m2 *= t3.y, y2 *= t3.x, x2 *= t3.y, g2 += e4.x, m2 += e4.y, o3 = n$2(o3).frameElement;
        }
      }
      return l$4({ width: y2, height: x2, x: g2, y: m2 });
    }
    function T(t2) {
      return ((i$1(t2) ? t2.ownerDocument : t2.document) || window.document).documentElement;
    }
    function R$1(t2) {
      return f$1(t2) ? { scrollLeft: t2.scrollLeft, scrollTop: t2.scrollTop } : { scrollLeft: t2.pageXOffset, scrollTop: t2.pageYOffset };
    }
    function C$1(t2) {
      return E(T(t2)).left + R$1(t2).scrollLeft;
    }
    function F(t2) {
      if ("html" === r$3(t2))
        return t2;
      const e2 = t2.assignedSlot || t2.parentNode || u$2(t2) && t2.host || T(t2);
      return u$2(e2) ? e2.host : e2;
    }
    function W(t2) {
      const e2 = F(t2);
      return g$1(e2) ? e2.ownerDocument.body : s$1(e2) && a(e2) ? e2 : W(e2);
    }
    function D(t2, e2) {
      var o2;
      void 0 === e2 && (e2 = []);
      const i2 = W(t2), r2 = i2 === (null == (o2 = t2.ownerDocument) ? void 0 : o2.body), l2 = n$2(i2);
      return r2 ? e2.concat(l2, l2.visualViewport || [], a(i2) ? i2 : []) : e2.concat(i2, D(i2));
    }
    function S(e2, i2, r2) {
      let l2;
      if ("viewport" === i2)
        l2 = function(t2, e3) {
          const o2 = n$2(t2), i3 = T(t2), r3 = o2.visualViewport;
          let l3 = i3.clientWidth, c3 = i3.clientHeight, s2 = 0, f2 = 0;
          if (r3) {
            l3 = r3.width, c3 = r3.height;
            const t3 = p$2();
            (!t3 || t3 && "fixed" === e3) && (s2 = r3.offsetLeft, f2 = r3.offsetTop);
          }
          return { width: l3, height: c3, x: s2, y: f2 };
        }(e2, r2);
      else if ("document" === i2)
        l2 = function(t2) {
          const e3 = T(t2), n2 = R$1(t2), i3 = t2.ownerDocument.body, r3 = y(e3.scrollWidth, e3.clientWidth, i3.scrollWidth, i3.clientWidth), l3 = y(e3.scrollHeight, e3.clientHeight, i3.scrollHeight, i3.clientHeight);
          let c3 = -n2.scrollLeft + C$1(t2);
          const s2 = -n2.scrollTop;
          return "rtl" === o(i3).direction && (c3 += y(e3.clientWidth, i3.clientWidth) - r3), { width: r3, height: l3, x: c3, y: s2 };
        }(T(e2));
      else if (f$1(i2))
        l2 = function(t2, e3) {
          const n2 = E(t2, true, "fixed" === e3), o2 = n2.top + t2.clientTop, i3 = n2.left + t2.clientLeft, r3 = s$1(t2) ? L$1(t2) : { x: 1, y: 1 };
          return { width: t2.clientWidth * r3.x, height: t2.clientHeight * r3.y, x: i3 * r3.x, y: o2 * r3.y };
        }(i2, r2);
      else {
        const t2 = { ...i2 };
        if (p$2()) {
          var c2, u2;
          const o2 = n$2(e2);
          t2.x -= (null == (c2 = o2.visualViewport) ? void 0 : c2.offsetLeft) || 0, t2.y -= (null == (u2 = o2.visualViewport) ? void 0 : u2.offsetTop) || 0;
        }
        l2 = t2;
      }
      return l$4(l2);
    }
    function A(t2, e2) {
      return s$1(t2) && "fixed" !== o(t2).position ? e2 ? e2(t2) : t2.offsetParent : null;
    }
    function H(t2, e2) {
      const i2 = n$2(t2);
      if (!s$1(t2))
        return i2;
      let l2 = A(t2, e2);
      for (; l2 && d$1(l2) && "static" === o(l2).position; )
        l2 = A(l2, e2);
      return l2 && ("html" === r$3(l2) || "body" === r$3(l2) && "static" === o(l2).position && !h$3(l2)) ? i2 : l2 || function(t3) {
        let e3 = F(t3);
        for (; s$1(e3) && !g$1(e3); ) {
          if (h$3(e3))
            return e3;
          e3 = F(e3);
        }
        return null;
      }(t2) || i2;
    }
    function V(t2, e2, n2) {
      const o2 = s$1(e2), i2 = T(e2), l2 = E(t2, true, "fixed" === n2, e2);
      let c2 = { scrollLeft: 0, scrollTop: 0 };
      const f2 = { x: 0, y: 0 };
      if (o2 || !o2 && "fixed" !== n2)
        if (("body" !== r$3(e2) || a(i2)) && (c2 = R$1(e2)), s$1(e2)) {
          const t3 = E(e2, true);
          f2.x = t3.x + e2.clientLeft, f2.y = t3.y + e2.clientTop;
        } else
          i2 && (f2.x = C$1(i2));
      return { x: l2.left + c2.scrollLeft - f2.x, y: l2.top + c2.scrollTop - f2.y, width: l2.width, height: l2.height };
    }
    const O = { getClippingRect: function(t2) {
      let { element: e2, boundary: n2, rootBoundary: i2, strategy: l2 } = t2;
      const c2 = "clippingAncestors" === n2 ? function(t3, e3) {
        const n3 = e3.get(t3);
        if (n3)
          return n3;
        let i3 = D(t3).filter((t4) => f$1(t4) && "body" !== r$3(t4)), l3 = null;
        const c3 = "fixed" === o(t3).position;
        let s3 = c3 ? F(t3) : t3;
        for (; f$1(s3) && !g$1(s3); ) {
          const t4 = o(s3), e4 = h$3(s3);
          "fixed" === t4.position ? l3 = null : (c3 ? e4 || l3 : e4 || "static" !== t4.position || !l3 || !["absolute", "fixed"].includes(l3.position)) ? l3 = t4 : i3 = i3.filter((t5) => t5 !== s3), s3 = F(s3);
        }
        return e3.set(t3, i3), i3;
      }(e2, this._c) : [].concat(n2), s2 = [...c2, i2], u2 = s2[0], a2 = s2.reduce((t3, n3) => {
        const o2 = S(e2, n3, l2);
        return t3.top = y(o2.top, t3.top), t3.right = m$2(o2.right, t3.right), t3.bottom = m$2(o2.bottom, t3.bottom), t3.left = y(o2.left, t3.left), t3;
      }, S(e2, u2, l2));
      return { width: a2.right - a2.left, height: a2.bottom - a2.top, x: a2.left, y: a2.top };
    }, convertOffsetParentRelativeRectToViewportRelativeRect: function(t2) {
      let { rect: e2, offsetParent: n2, strategy: o2 } = t2;
      const i2 = s$1(n2), l2 = T(n2);
      if (n2 === l2)
        return e2;
      let c2 = { scrollLeft: 0, scrollTop: 0 }, f2 = { x: 1, y: 1 };
      const u2 = { x: 0, y: 0 };
      if ((i2 || !i2 && "fixed" !== o2) && (("body" !== r$3(n2) || a(l2)) && (c2 = R$1(n2)), s$1(n2))) {
        const t3 = E(n2);
        f2 = L$1(n2), u2.x = t3.x + n2.clientLeft, u2.y = t3.y + n2.clientTop;
      }
      return { width: e2.width * f2.x, height: e2.height * f2.y, x: e2.x * f2.x - c2.scrollLeft * f2.x + u2.x, y: e2.y * f2.y - c2.scrollTop * f2.y + u2.y };
    }, isElement: f$1, getDimensions: function(t2) {
      return w(t2);
    }, getOffsetParent: H, getDocumentElement: T, getScale: L$1, async getElementRects(t2) {
      let { reference: e2, floating: n2, strategy: o2 } = t2;
      const i2 = this.getOffsetParent || H, r2 = this.getDimensions;
      return { reference: V(e2, await i2(n2), o2), floating: { x: 0, y: 0, ...await r2(n2) } };
    }, getClientRects: (t2) => Array.from(t2.getClientRects()), isRTL: (t2) => "rtl" === o(t2).direction };
    const z = (t2, n2, o2) => {
      const i2 = /* @__PURE__ */ new Map(), r2 = { platform: O, ...o2 }, l2 = { ...r2.platform, _c: i2 };
      return r$4(t2, n2, { ...r2, platform: l2 });
    };
    function parseFloatingUIPlacement(placement) {
      const tokens2 = placement.split("-");
      return {
        side: tokens2[0],
        alignment: tokens2[1]
      };
    }
    const getParentNode = (node2) => {
      if (node2.nodeName === "HTML") {
        return node2;
      }
      return node2.parentNode || node2.host;
    };
    const getStyleComputedProperty = (node2) => {
      var _node_ownerDocument;
      if (node2.nodeType !== 1) {
        return {};
      }
      const window2 = (_node_ownerDocument = node2.ownerDocument) === null || _node_ownerDocument === void 0 ? void 0 : _node_ownerDocument.defaultView;
      return window2.getComputedStyle(node2, null);
    };
    const getScrollParent = (node2) => {
      const parentNode = node2 && getParentNode(node2);
      if (!parentNode)
        return document.body;
      switch (parentNode.nodeName) {
        case "HTML":
        case "BODY":
          return parentNode.ownerDocument.body;
        case "#document":
          return parentNode.body;
      }
      const { overflow: overflow2, overflowX, overflowY } = getStyleComputedProperty(parentNode);
      if (/(auto|scroll|overlay)/.test(overflow2 + overflowY + overflowX)) {
        return parentNode;
      }
      return getScrollParent(parentNode);
    };
    const hasScrollParent = (node2) => {
      var _scrollParentElement_ownerDocument;
      const scrollParentElement = getScrollParent(node2);
      return scrollParentElement ? scrollParentElement !== ((_scrollParentElement_ownerDocument = scrollParentElement.ownerDocument) === null || _scrollParentElement_ownerDocument === void 0 ? void 0 : _scrollParentElement_ownerDocument.body) : false;
    };
    function getBoundary(element2, boundary) {
      if (boundary === "window") {
        return element2 === null || element2 === void 0 ? void 0 : element2.ownerDocument.documentElement;
      }
      if (boundary === "clippingParents") {
        return "clippingAncestors";
      }
      if (boundary === "scrollParent") {
        let boundariesNode = getScrollParent(element2);
        if (boundariesNode.nodeName === "BODY") {
          boundariesNode = element2 === null || element2 === void 0 ? void 0 : element2.ownerDocument.documentElement;
        }
        return boundariesNode;
      }
      return boundary;
    }
    function mergeArrowOffset(userOffset, arrowHeight2) {
      if (typeof userOffset === "number") {
        return addArrowOffset(userOffset, arrowHeight2);
      }
      if (typeof userOffset === "object" && userOffset !== null) {
        return addArrowOffset(userOffset, arrowHeight2);
      }
      if (typeof userOffset === "function") {
        return (offsetParams) => {
          const offset2 = userOffset(offsetParams);
          return addArrowOffset(offset2, arrowHeight2);
        };
      }
      return {
        mainAxis: arrowHeight2
      };
    }
    const addArrowOffset = (offset2, arrowHeight2) => {
      if (typeof offset2 === "number") {
        return {
          mainAxis: offset2 + arrowHeight2
        };
      }
      var _offset_mainAxis;
      return {
        ...offset2,
        mainAxis: ((_offset_mainAxis = offset2.mainAxis) !== null && _offset_mainAxis !== void 0 ? _offset_mainAxis : 0) + arrowHeight2
      };
    };
    function toFloatingUIPadding(padding2, isRtl) {
      if (typeof padding2 === "number") {
        return padding2;
      }
      const { start, end, ...verticalPadding } = padding2;
      const paddingObject = verticalPadding;
      const left = isRtl ? "end" : "start";
      const right = isRtl ? "start" : "end";
      if (padding2[left]) {
        paddingObject.left = padding2[left];
      }
      if (padding2[right]) {
        paddingObject.right = padding2[right];
      }
      return paddingObject;
    }
    const getPositionMap$1 = (rtl) => ({
      above: "top",
      below: "bottom",
      before: rtl ? "right" : "left",
      after: rtl ? "left" : "right"
    });
    const getAlignmentMap$1 = () => ({
      start: "start",
      end: "end",
      top: "start",
      bottom: "end",
      center: void 0
    });
    const shouldAlignToCenter = (p2, a2) => {
      const positionedVertically = p2 === "above" || p2 === "below";
      const alignedVertically = a2 === "top" || a2 === "bottom";
      return positionedVertically && alignedVertically || !positionedVertically && !alignedVertically;
    };
    const toFloatingUIPlacement = (align, position2, rtl) => {
      const alignment = shouldAlignToCenter(position2, align) ? "center" : align;
      const computedPosition = position2 && getPositionMap$1(rtl)[position2];
      const computedAlignment = alignment && getAlignmentMap$1()[alignment];
      if (computedPosition && computedAlignment) {
        return `${computedPosition}-${computedAlignment}`;
      }
      return computedPosition;
    };
    const getPositionMap = () => ({
      top: "above",
      bottom: "below",
      right: "after",
      left: "before"
    });
    const getAlignmentMap = (position2) => {
      if (position2 === "above" || position2 === "below") {
        return {
          start: "start",
          end: "end"
        };
      }
      return {
        start: "top",
        end: "bottom"
      };
    };
    const fromFloatingUIPlacement = (placement) => {
      const { side, alignment: floatingUIAlignment } = parseFloatingUIPlacement(placement);
      const position2 = getPositionMap()[side];
      const alignment = floatingUIAlignment && getAlignmentMap(position2)[floatingUIAlignment];
      return {
        position: position2,
        alignment
      };
    };
    const shorthandLookup = {
      above: {
        position: "above",
        align: "center"
      },
      "above-start": {
        position: "above",
        align: "start"
      },
      "above-end": {
        position: "above",
        align: "end"
      },
      below: {
        position: "below",
        align: "center"
      },
      "below-start": {
        position: "below",
        align: "start"
      },
      "below-end": {
        position: "below",
        align: "end"
      },
      before: {
        position: "before",
        align: "center"
      },
      "before-top": {
        position: "before",
        align: "top"
      },
      "before-bottom": {
        position: "before",
        align: "bottom"
      },
      after: {
        position: "after",
        align: "center"
      },
      "after-top": {
        position: "after",
        align: "top"
      },
      "after-bottom": {
        position: "after",
        align: "bottom"
      }
    };
    function resolvePositioningShorthand(shorthand) {
      if (shorthand === void 0 || shorthand === null) {
        return {};
      }
      if (typeof shorthand === "string") {
        return shorthandLookup[shorthand];
      }
      return shorthand;
    }
    function useCallbackRef(initialValue, callback, skipInitialResolve) {
      const isFirst = reactExports.useRef(true);
      const [ref] = reactExports.useState(() => ({
        // value
        value: initialValue,
        // last callback
        callback,
        // "memoized" public interface
        facade: {
          get current() {
            return ref.value;
          },
          set current(value) {
            const last = ref.value;
            if (last !== value) {
              ref.value = value;
              if (skipInitialResolve && isFirst.current) {
                return;
              }
              ref.callback(value, last);
            }
          }
        }
      }));
      useIsomorphicLayoutEffect(() => {
        isFirst.current = false;
      }, []);
      ref.callback = callback;
      return ref.facade;
    }
    function debounce(fn) {
      let pending;
      return () => {
        if (!pending) {
          pending = new Promise((resolve) => {
            Promise.resolve().then(() => {
              pending = void 0;
              resolve(fn());
            });
          });
        }
        return pending;
      };
    }
    function writeArrowUpdates(options) {
      const { arrow, middlewareData } = options;
      if (!middlewareData.arrow || !arrow) {
        return;
      }
      const { x: arrowX, y: arrowY } = middlewareData.arrow;
      Object.assign(arrow.style, {
        left: `${arrowX}px`,
        top: `${arrowY}px`
      });
    }
    function writeContainerUpdates(options) {
      var _middlewareData_hide, _middlewareData_hide1, _container_ownerDocument_defaultView;
      const { container, placement, middlewareData, strategy, lowPPI, coordinates, useTransform = true } = options;
      if (!container) {
        return;
      }
      container.setAttribute(DATA_POSITIONING_PLACEMENT, placement);
      container.removeAttribute(DATA_POSITIONING_INTERSECTING);
      if (middlewareData.intersectionObserver.intersecting) {
        container.setAttribute(DATA_POSITIONING_INTERSECTING, "");
      }
      container.removeAttribute(DATA_POSITIONING_ESCAPED);
      if ((_middlewareData_hide = middlewareData.hide) === null || _middlewareData_hide === void 0 ? void 0 : _middlewareData_hide.escaped) {
        container.setAttribute(DATA_POSITIONING_ESCAPED, "");
      }
      container.removeAttribute(DATA_POSITIONING_HIDDEN);
      if ((_middlewareData_hide1 = middlewareData.hide) === null || _middlewareData_hide1 === void 0 ? void 0 : _middlewareData_hide1.referenceHidden) {
        container.setAttribute(DATA_POSITIONING_HIDDEN, "");
      }
      const devicePixelRatio = ((_container_ownerDocument_defaultView = container.ownerDocument.defaultView) === null || _container_ownerDocument_defaultView === void 0 ? void 0 : _container_ownerDocument_defaultView.devicePixelRatio) || 1;
      const x2 = Math.round(coordinates.x * devicePixelRatio) / devicePixelRatio;
      const y2 = Math.round(coordinates.y * devicePixelRatio) / devicePixelRatio;
      Object.assign(container.style, {
        position: strategy
      });
      if (useTransform) {
        Object.assign(container.style, {
          transform: lowPPI ? `translate(${x2}px, ${y2}px)` : `translate3d(${x2}px, ${y2}px, 0)`
        });
        return;
      }
      Object.assign(container.style, {
        left: `${x2}px`,
        top: `${y2}px`
      });
    }
    const normalizeAutoSize = (autoSize) => {
      switch (autoSize) {
        case "always":
        case true:
          return {
            applyMaxWidth: true,
            applyMaxHeight: true
          };
        case "width-always":
        case "width":
          return {
            applyMaxWidth: true,
            applyMaxHeight: false
          };
        case "height-always":
        case "height":
          return {
            applyMaxWidth: false,
            applyMaxHeight: true
          };
        default:
          return false;
      }
    };
    function coverTarget() {
      return {
        name: "coverTarget",
        fn: (middlewareArguments) => {
          const { placement, rects, x: x2, y: y2 } = middlewareArguments;
          const basePlacement = parseFloatingUIPlacement(placement).side;
          const newCoords = {
            x: x2,
            y: y2
          };
          switch (basePlacement) {
            case "bottom":
              newCoords.y -= rects.reference.height;
              break;
            case "top":
              newCoords.y += rects.reference.height;
              break;
            case "left":
              newCoords.x += rects.reference.width;
              break;
            case "right":
              newCoords.x -= rects.reference.width;
              break;
          }
          return newCoords;
        }
      };
    }
    function flip(options) {
      const { hasScrollableElement, flipBoundary, container, fallbackPositions = [], isRtl } = options;
      const fallbackPlacements = fallbackPositions.reduce((acc, shorthand) => {
        const { position: position2, align } = resolvePositioningShorthand(shorthand);
        const placement = toFloatingUIPlacement(align, position2, isRtl);
        if (placement) {
          acc.push(placement);
        }
        return acc;
      }, []);
      return b$2({
        ...hasScrollableElement && {
          boundary: "clippingAncestors"
        },
        ...flipBoundary && {
          altBoundary: true,
          boundary: getBoundary(container, flipBoundary)
        },
        fallbackStrategy: "bestFit",
        ...fallbackPlacements.length && {
          fallbackPlacements
        }
      });
    }
    function intersecting() {
      return {
        name: "intersectionObserver",
        fn: async (middlewareArguments) => {
          const floatingRect = middlewareArguments.rects.floating;
          const altOverflow = await s$2(middlewareArguments, {
            altBoundary: true
          });
          const isIntersectingTop = altOverflow.top < floatingRect.height && altOverflow.top > 0;
          const isIntersectingBottom = altOverflow.bottom < floatingRect.height && altOverflow.bottom > 0;
          const isIntersecting = isIntersectingTop || isIntersectingBottom;
          return {
            data: {
              intersecting: isIntersecting
            }
          };
        }
      };
    }
    const resetMaxSize = (autoSize) => ({
      name: "resetMaxSize",
      fn({ middlewareData, elements }) {
        var _middlewareData_resetMaxSize;
        if ((_middlewareData_resetMaxSize = middlewareData.resetMaxSize) === null || _middlewareData_resetMaxSize === void 0 ? void 0 : _middlewareData_resetMaxSize.maxSizeAlreadyReset) {
          return {};
        }
        const { applyMaxWidth, applyMaxHeight } = autoSize;
        if (applyMaxWidth) {
          elements.floating.style.removeProperty("box-sizing");
          elements.floating.style.removeProperty("max-width");
          elements.floating.style.removeProperty("width");
        }
        if (applyMaxHeight) {
          elements.floating.style.removeProperty("box-sizing");
          elements.floating.style.removeProperty("max-height");
          elements.floating.style.removeProperty("height");
        }
        return {
          data: {
            maxSizeAlreadyReset: true
          },
          reset: {
            rects: true
          }
        };
      }
    });
    function maxSize(autoSize, options) {
      const { container, overflowBoundary } = options;
      return B({
        ...overflowBoundary && {
          altBoundary: true,
          boundary: getBoundary(container, overflowBoundary)
        },
        apply({ availableHeight, availableWidth, elements, rects }) {
          const applyMaxSizeStyles = (apply, dimension, availableSize) => {
            if (!apply) {
              return;
            }
            elements.floating.style.setProperty("box-sizing", "border-box");
            elements.floating.style.setProperty(`max-${dimension}`, `${availableSize}px`);
            if (rects.floating[dimension] > availableSize) {
              elements.floating.style.setProperty(dimension, `${availableSize}px`);
              const axis = dimension === "width" ? "x" : "y";
              if (!elements.floating.style.getPropertyValue(`overflow-${axis}`)) {
                elements.floating.style.setProperty(`overflow-${axis}`, "auto");
              }
            }
          };
          const { applyMaxWidth, applyMaxHeight } = autoSize;
          applyMaxSizeStyles(applyMaxWidth, "width", availableWidth);
          applyMaxSizeStyles(applyMaxHeight, "height", availableHeight);
        }
      });
    }
    function getFloatingUIOffset(rawOffset) {
      if (!rawOffset) {
        return rawOffset;
      }
      if (typeof rawOffset === "number" || typeof rawOffset === "object") {
        return rawOffset;
      }
      return ({ rects: { floating, reference }, placement }) => {
        const { position: position2, alignment } = fromFloatingUIPlacement(placement);
        return rawOffset({
          positionedRect: floating,
          targetRect: reference,
          position: position2,
          alignment
        });
      };
    }
    function offset$1(offsetValue) {
      const floatingUIOffset = getFloatingUIOffset(offsetValue);
      return D$1(floatingUIOffset);
    }
    function shift(options) {
      const { hasScrollableElement, disableTether, overflowBoundary, container, overflowBoundaryPadding, isRtl } = options;
      return k$2({
        ...hasScrollableElement && {
          boundary: "clippingAncestors"
        },
        ...disableTether && {
          crossAxis: disableTether === "all",
          limiter: O$1({
            crossAxis: disableTether !== "all",
            mainAxis: false
          })
        },
        ...overflowBoundaryPadding && {
          padding: toFloatingUIPadding(overflowBoundaryPadding, isRtl)
        },
        ...overflowBoundary && {
          altBoundary: true,
          boundary: getBoundary(container, overflowBoundary)
        }
      });
    }
    const matchTargetSizeCssVar = "--fui-match-target-size";
    function matchTargetSize() {
      return {
        name: "matchTargetSize",
        fn: async (middlewareArguments) => {
          const { rects: { reference: referenceRect, floating: floatingRect }, elements: { floating: floatingElement }, middlewareData: { matchTargetSize: { matchTargetSizeAttempt = false } = {} } } = middlewareArguments;
          if (referenceRect.width === floatingRect.width || matchTargetSizeAttempt) {
            return {};
          }
          const { width } = referenceRect;
          floatingElement.style.setProperty(matchTargetSizeCssVar, `${width}px`);
          if (!floatingElement.style.width) {
            floatingElement.style.width = `var(${matchTargetSizeCssVar})`;
          }
          return {
            data: {
              matchTargetSizeAttempt: true
            },
            reset: {
              rects: true
            }
          };
        }
      };
    }
    function listScrollParents(node2) {
      const scrollParents = [];
      let cur = node2;
      while (cur) {
        const scrollParent = getScrollParent(cur);
        if (node2.ownerDocument.body === scrollParent) {
          scrollParents.push(scrollParent);
          break;
        }
        scrollParents.push(scrollParent);
        cur = scrollParent;
      }
      return scrollParents;
    }
    function createPositionManager(options) {
      const { container, target, arrow, strategy, middleware: middleware2, placement, useTransform = true } = options;
      let isDestroyed = false;
      if (!target || !container) {
        return {
          updatePosition: () => void 0,
          dispose: () => void 0
        };
      }
      let isFirstUpdate = true;
      const scrollParents = /* @__PURE__ */ new Set();
      const targetWindow = container.ownerDocument.defaultView;
      Object.assign(container.style, {
        position: "fixed",
        left: 0,
        top: 0,
        margin: 0
      });
      const forceUpdate = () => {
        if (isDestroyed) {
          return;
        }
        if (isFirstUpdate) {
          listScrollParents(container).forEach((scrollParent) => scrollParents.add(scrollParent));
          if (isHTMLElement$1(target)) {
            listScrollParents(target).forEach((scrollParent) => scrollParents.add(scrollParent));
          }
          scrollParents.forEach((scrollParent) => {
            scrollParent.addEventListener("scroll", updatePosition, {
              passive: true
            });
          });
          isFirstUpdate = false;
        }
        Object.assign(container.style, {
          position: strategy
        });
        z(target, container, {
          placement,
          middleware: middleware2,
          strategy
        }).then(({ x: x2, y: y2, middlewareData, placement: computedPlacement }) => {
          if (isDestroyed) {
            return;
          }
          writeArrowUpdates({
            arrow,
            middlewareData
          });
          writeContainerUpdates({
            container,
            middlewareData,
            placement: computedPlacement,
            coordinates: {
              x: x2,
              y: y2
            },
            lowPPI: ((targetWindow === null || targetWindow === void 0 ? void 0 : targetWindow.devicePixelRatio) || 1) <= 1,
            strategy,
            useTransform
          });
        }).catch((err) => {
        });
      };
      const updatePosition = debounce(() => forceUpdate());
      const dispose = () => {
        isDestroyed = true;
        if (targetWindow) {
          targetWindow.removeEventListener("scroll", updatePosition);
          targetWindow.removeEventListener("resize", updatePosition);
        }
        scrollParents.forEach((scrollParent) => {
          scrollParent.removeEventListener("scroll", updatePosition);
        });
        scrollParents.clear();
      };
      if (targetWindow) {
        targetWindow.addEventListener("scroll", updatePosition, {
          passive: true
        });
        targetWindow.addEventListener("resize", updatePosition);
      }
      updatePosition();
      return {
        updatePosition,
        dispose
      };
    }
    function usePositioning(options) {
      const managerRef = reactExports.useRef(null);
      const targetRef = reactExports.useRef(null);
      const overrideTargetRef = reactExports.useRef(null);
      const containerRef = reactExports.useRef(null);
      const arrowRef = reactExports.useRef(null);
      const { enabled = true } = options;
      const resolvePositioningOptions = usePositioningOptions(options);
      const updatePositionManager = reactExports.useCallback(() => {
        if (managerRef.current) {
          managerRef.current.dispose();
        }
        managerRef.current = null;
        var _overrideTargetRef_current;
        const target = (_overrideTargetRef_current = overrideTargetRef.current) !== null && _overrideTargetRef_current !== void 0 ? _overrideTargetRef_current : targetRef.current;
        if (enabled && canUseDOM() && target && containerRef.current) {
          managerRef.current = createPositionManager({
            container: containerRef.current,
            target,
            arrow: arrowRef.current,
            ...resolvePositioningOptions(containerRef.current, arrowRef.current)
          });
        }
      }, [
        enabled,
        resolvePositioningOptions
      ]);
      const setOverrideTarget = useEventCallback$1((target) => {
        overrideTargetRef.current = target;
        updatePositionManager();
      });
      reactExports.useImperativeHandle(options.positioningRef, () => ({
        updatePosition: () => {
          var _managerRef_current;
          return (_managerRef_current = managerRef.current) === null || _managerRef_current === void 0 ? void 0 : _managerRef_current.updatePosition();
        },
        setTarget: (target) => {
          if (options.target && false) {
            const err = new Error();
            console.warn("Imperative setTarget should not be used at the same time as target option");
            console.warn(err.stack);
          }
          setOverrideTarget(target);
        }
      }), [
        options.target,
        setOverrideTarget
      ]);
      useIsomorphicLayoutEffect(() => {
        var _options_target;
        setOverrideTarget((_options_target = options.target) !== null && _options_target !== void 0 ? _options_target : null);
      }, [
        options.target,
        setOverrideTarget
      ]);
      useIsomorphicLayoutEffect(() => {
        updatePositionManager();
      }, [
        updatePositionManager
      ]);
      const setTarget = useCallbackRef(null, (target) => {
        if (targetRef.current !== target) {
          targetRef.current = target;
          updatePositionManager();
        }
      });
      const setContainer = useCallbackRef(null, (container) => {
        if (containerRef.current !== container) {
          containerRef.current = container;
          updatePositionManager();
        }
      });
      const setArrow = useCallbackRef(null, (arrow) => {
        if (arrowRef.current !== arrow) {
          arrowRef.current = arrow;
          updatePositionManager();
        }
      });
      return {
        targetRef: setTarget,
        containerRef: setContainer,
        arrowRef: setArrow
      };
    }
    function usePositioningOptions(options) {
      const {
        align,
        arrowPadding,
        autoSize: rawAutoSize,
        coverTarget: coverTarget$1,
        flipBoundary,
        offset: offset2,
        overflowBoundary,
        pinned,
        position: position2,
        unstable_disableTether: disableTether,
        // eslint-disable-next-line deprecation/deprecation
        positionFixed,
        strategy,
        overflowBoundaryPadding,
        fallbackPositions,
        useTransform,
        matchTargetSize: matchTargetSize$1
      } = options;
      const { dir, targetDocument } = useFluent();
      const isRtl = dir === "rtl";
      const positionStrategy = (strategy !== null && strategy !== void 0 ? strategy : positionFixed) ? "fixed" : "absolute";
      const autoSize = normalizeAutoSize(rawAutoSize);
      return reactExports.useCallback(
        (container, arrow) => {
          const hasScrollableElement = hasScrollParent(container);
          const middleware2 = [
            autoSize && resetMaxSize(autoSize),
            matchTargetSize$1 && matchTargetSize(),
            offset2 && offset$1(offset2),
            coverTarget$1 && coverTarget(),
            !pinned && flip({
              container,
              flipBoundary,
              hasScrollableElement,
              isRtl,
              fallbackPositions
            }),
            shift({
              container,
              hasScrollableElement,
              overflowBoundary,
              disableTether,
              overflowBoundaryPadding,
              isRtl
            }),
            autoSize && maxSize(autoSize, {
              container,
              overflowBoundary
            }),
            intersecting(),
            arrow && u$3({
              element: arrow,
              padding: arrowPadding
            }),
            P({
              strategy: "referenceHidden"
            }),
            P({
              strategy: "escaped"
            }),
            false
          ].filter(Boolean);
          const placement = toFloatingUIPlacement(align, position2, isRtl);
          return {
            placement,
            middleware: middleware2,
            strategy: positionStrategy,
            useTransform
          };
        },
        // Options is missing here, but it's not required
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [
          align,
          arrowPadding,
          autoSize,
          coverTarget$1,
          disableTether,
          flipBoundary,
          isRtl,
          offset2,
          overflowBoundary,
          pinned,
          position2,
          positionStrategy,
          overflowBoundaryPadding,
          fallbackPositions,
          useTransform,
          matchTargetSize$1,
          targetDocument
        ]
      );
    }
    const usePositioningMouseTarget = (initialState) => {
      const [virtualElement, setVirtualElement] = reactExports.useState(initialState);
      const setVirtualMouseTarget = (event) => {
        if (event === void 0 || event === null) {
          setVirtualElement(void 0);
          return;
        }
        let mouseevent;
        if (!(event instanceof MouseEvent)) {
          mouseevent = event.nativeEvent;
        } else {
          mouseevent = event;
        }
        if (!(mouseevent instanceof MouseEvent) && false) {
          console.error("usePositioningMouseTarget should only be used with MouseEvent");
        }
        const contextTarget = createVirtualElementFromClick(mouseevent);
        setVirtualElement(contextTarget);
      };
      return [
        virtualElement,
        setVirtualMouseTarget
      ];
    };
    const PopoverContext = createContext(void 0);
    const popoverContextDefaultValue = {
      open: false,
      setOpen: () => null,
      toggleOpen: () => null,
      triggerRef: {
        current: null
      },
      contentRef: {
        current: null
      },
      arrowRef: {
        current: null
      },
      openOnContext: false,
      openOnHover: false,
      size: "medium",
      trapFocus: false,
      inline: false
    };
    PopoverContext.Provider;
    const usePopoverContext_unstable = (selector) => useContextSelector(PopoverContext, (ctx = popoverContextDefaultValue) => selector(ctx));
    const usePopoverSurface_unstable = (props, ref) => {
      const contentRef = usePopoverContext_unstable((context) => context.contentRef);
      const openOnHover = usePopoverContext_unstable((context) => context.openOnHover);
      const setOpen = usePopoverContext_unstable((context) => context.setOpen);
      const mountNode = usePopoverContext_unstable((context) => context.mountNode);
      const arrowRef = usePopoverContext_unstable((context) => context.arrowRef);
      const size = usePopoverContext_unstable((context) => context.size);
      const withArrow = usePopoverContext_unstable((context) => context.withArrow);
      const appearance = usePopoverContext_unstable((context) => context.appearance);
      const trapFocus = usePopoverContext_unstable((context) => context.trapFocus);
      const inertTrapFocus = usePopoverContext_unstable((context) => context.inertTrapFocus);
      const inline = usePopoverContext_unstable((context) => context.inline);
      const { modalAttributes } = useModalAttributes({
        trapFocus,
        legacyTrapFocus: !inertTrapFocus,
        alwaysFocusable: !trapFocus
      });
      const state = {
        inline,
        appearance,
        withArrow,
        size,
        arrowRef,
        mountNode,
        components: {
          root: "div"
        },
        root: always(getIntrinsicElementProps("div", {
          // FIXME:
          // `contentRef` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
          // but since it would be a breaking change to fix it, we are casting ref to it's proper type
          ref: useMergedRefs(ref, contentRef),
          role: trapFocus ? "dialog" : "group",
          "aria-modal": trapFocus ? true : void 0,
          ...modalAttributes,
          ...props
        }), {
          elementType: "div"
        })
      };
      const { onMouseEnter: onMouseEnterOriginal, onMouseLeave: onMouseLeaveOriginal, onKeyDown: onKeyDownOriginal } = state.root;
      state.root.onMouseEnter = (e2) => {
        if (openOnHover) {
          setOpen(e2, true);
        }
        onMouseEnterOriginal === null || onMouseEnterOriginal === void 0 ? void 0 : onMouseEnterOriginal(e2);
      };
      state.root.onMouseLeave = (e2) => {
        if (openOnHover) {
          setOpen(e2, false);
        }
        onMouseLeaveOriginal === null || onMouseLeaveOriginal === void 0 ? void 0 : onMouseLeaveOriginal(e2);
      };
      state.root.onKeyDown = (e2) => {
        var _contentRef_current;
        if (e2.key === "Escape" && ((_contentRef_current = contentRef.current) === null || _contentRef_current === void 0 ? void 0 : _contentRef_current.contains(e2.target))) {
          e2.preventDefault();
          setOpen(e2, false);
        }
        onKeyDownOriginal === null || onKeyDownOriginal === void 0 ? void 0 : onKeyDownOriginal(e2);
      };
      return state;
    };
    function toMountNodeProps(mountNode) {
      if (isHTMLElement$1(mountNode)) {
        return {
          element: mountNode
        };
      }
      if (typeof mountNode === "object") {
        if (mountNode === null) {
          return {
            element: null
          };
        }
        return mountNode;
      }
      return {};
    }
    var getCurrentOwner = () => reactExports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner.current;
    var useIsStrictMode = () => {
      {
        return false;
      }
    };
    var effectSet = /* @__PURE__ */ new WeakSet();
    function useStrictEffect(effect, deps) {
      const currentOwner = getCurrentOwner();
      reactExports.useEffect(() => {
        if (!effectSet.has(currentOwner)) {
          effectSet.add(currentOwner);
          effect();
          return;
        }
        const dispose = effect();
        return dispose;
      }, deps);
    }
    var memoSet = /* @__PURE__ */ new WeakSet();
    function useStrictMemo(factory, deps) {
      return reactExports.useMemo(() => {
        const currentOwner = getCurrentOwner();
        if (!memoSet.has(currentOwner)) {
          memoSet.add(currentOwner);
          return null;
        }
        return factory();
      }, deps);
    }
    function useDisposable(factory, deps) {
      var _a2;
      const isStrictMode = useIsStrictMode() && false;
      const useMemo4 = isStrictMode ? useStrictMemo : reactExports.useMemo;
      const useEffect3 = isStrictMode ? useStrictEffect : reactExports.useEffect;
      const [disposable, dispose] = (_a2 = useMemo4(() => factory(), deps)) != null ? _a2 : [
        null,
        () => null
      ];
      useEffect3(() => {
        return dispose;
      }, deps);
      return disposable;
    }
    const usePortalMountNodeStylesStyles = /* @__PURE__ */ __styles$3({
      root: {
        qhf8xq: "f1euv43f",
        Bhzewxz: "f15twtuk",
        oyh7mz: ["f1vgc2s3", "f1e31b4d"],
        j35jbq: ["f1e31b4d", "f1vgc2s3"],
        Bj3rh1h: "f494woh"
      }
    }, {
      d: [".f1euv43f{position:absolute;}", ".f15twtuk{top:0;}", ".f1vgc2s3{left:0;}", ".f1e31b4d{right:0;}", ".f494woh{z-index:1000000;}"]
    });
    const useInsertionEffect = React$1["useInsertionEffect"];
    const usePortalMountNode = (options) => {
      const { targetDocument, dir } = useFluent();
      const mountNode = usePortalMountNode$1();
      const focusVisibleRef = useFocusVisible();
      const classes = usePortalMountNodeStylesStyles();
      const themeClassName = useThemeClassName();
      const className = mergeClasses$2(themeClassName, classes.root, options.className);
      const targetNode = mountNode !== null && mountNode !== void 0 ? mountNode : targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.body;
      const element2 = useDisposable(() => {
        if (targetNode === void 0 || options.disabled) {
          return [
            null,
            () => null
          ];
        }
        const newElement = targetNode.ownerDocument.createElement("div");
        targetNode.appendChild(newElement);
        return [
          newElement,
          () => newElement.remove()
        ];
      }, [
        targetNode
      ]);
      if (useInsertionEffect) {
        useInsertionEffect(() => {
          if (!element2) {
            return;
          }
          const classesToApply = className.split(" ").filter(Boolean);
          element2.classList.add(...classesToApply);
          element2.setAttribute("dir", dir);
          focusVisibleRef.current = element2;
          return () => {
            element2.classList.remove(...classesToApply);
            element2.removeAttribute("dir");
          };
        }, [
          className,
          dir,
          element2,
          focusVisibleRef
        ]);
      } else {
        reactExports.useMemo(() => {
          if (!element2) {
            return;
          }
          element2.className = className;
          element2.setAttribute("dir", dir);
          focusVisibleRef.current = element2;
        }, [
          className,
          dir,
          element2,
          focusVisibleRef
        ]);
      }
      return element2;
    };
    const usePortal_unstable = (props) => {
      const { element: element2, className } = toMountNodeProps(props.mountNode);
      const virtualParentRootRef = reactExports.useRef(null);
      const fallbackElement = usePortalMountNode({
        disabled: !!element2,
        className
      });
      const mountNode = element2 !== null && element2 !== void 0 ? element2 : fallbackElement;
      const state = {
        children: props.children,
        mountNode,
        virtualParentRootRef
      };
      reactExports.useEffect(() => {
        if (!mountNode) {
          return;
        }
        const virtualParent = virtualParentRootRef.current;
        const isVirtualParentInsideChild = mountNode.contains(virtualParent);
        if (virtualParent && !isVirtualParentInsideChild) {
          setVirtualParent(mountNode, virtualParent);
          return () => {
            setVirtualParent(mountNode, void 0);
          };
        }
      }, [
        virtualParentRootRef,
        mountNode
      ]);
      return state;
    };
    const renderPortal_unstable = (state) => {
      return /* @__PURE__ */ reactExports.createElement("span", {
        hidden: true,
        ref: state.virtualParentRootRef
      }, state.mountNode && /* @__PURE__ */ reactDomExports.createPortal(state.children, state.mountNode));
    };
    const Portal = (props) => {
      const state = usePortal_unstable(props);
      return renderPortal_unstable(state);
    };
    Portal.displayName = "Portal";
    const renderPopoverSurface_unstable = (state) => {
      const surface = /* @__PURE__ */ jsxs(state.root, {
        children: [
          state.withArrow && /* @__PURE__ */ jsx("div", {
            ref: state.arrowRef,
            className: state.arrowClassName
          }),
          state.root.children
        ]
      });
      if (state.inline) {
        return surface;
      }
      return /* @__PURE__ */ jsx(Portal, {
        mountNode: state.mountNode,
        children: surface
      });
    };
    const popoverSurfaceClassNames = {
      root: "fui-PopoverSurface"
    };
    const arrowHeights = {
      small: 6,
      medium: 8,
      large: 8
    };
    const useStyles$e = /* @__PURE__ */ __styles$3({
      root: {
        sj55zd: "f19n0e5",
        De3pzq: "fxugw4r",
        E5pizo: "f1hg901r",
        Bbmb7ep: ["f1aa9q02", "f16jpd5f"],
        Beyfa6y: ["f16jpd5f", "f1aa9q02"],
        B7oj6ja: ["f1jar5jt", "fyu767a"],
        Btl43ni: ["fyu767a", "f1jar5jt"],
        B4j52fo: "f5ogflp",
        Bekrc4i: ["f1hqa2wf", "finvdd3"],
        Bn0qgzm: "f1f09k3d",
        ibv6hh: ["finvdd3", "f1hqa2wf"],
        icvyot: "fzkkow9",
        vrafjx: ["fcdblym", "fjik90z"],
        oivjwe: "fg706s2",
        wvpqe5: ["fjik90z", "fcdblym"],
        g2u3we: "fghlq4f",
        h3c5rm: ["f1gn591s", "fjscplz"],
        B9xav0g: "fb073pr",
        zhjwy3: ["fjscplz", "f1gn591s"],
        Bahqtrf: "fk6fouc",
        Be2twd7: "fkhj508",
        Bhrd7zp: "figsok6",
        Bg96gwp: "f1i3iumi",
        B93otf3: "f18k4bn6",
        vin17d: "fo1kyvf",
        Ezkn3b: "fetxo7e",
        ex8oj8: "fmm77a6",
        Bksk4gw: "f12t24nk",
        Bc5phfd: "f1babd7",
        cbiifc: "f1jgo889",
        fyiq5g: "f1ij1pew",
        Bqc19t1: "f1gu8pa9",
        Eet2gb: "fhfnl4n",
        Bhl7k63: "fk8tkmz",
        Bv12yb3: "f3n0535",
        z0t1cu: "fi19xcv",
        Bks05zx: "f1mzajhk",
        Bvtglag: "fjp4h9y"
      },
      inline: {
        Bj3rh1h: "f19g0ac"
      },
      inverted: {
        De3pzq: "fg3r6xk",
        sj55zd: "fonrgv7"
      },
      brand: {
        De3pzq: "ffp7eso",
        sj55zd: "f1phragk"
      },
      smallPadding: {
        z8tnut: "f1kcqot9",
        z189sj: ["f11qrl6u", "fjlbh76"],
        Byoj8tv: "fpe6lb7",
        uwmqm3: ["fjlbh76", "f11qrl6u"]
      },
      mediumPadding: {
        z8tnut: "fqag9an",
        z189sj: ["f1gbmcue", "f1rh9g5y"],
        Byoj8tv: "fp67ikv",
        uwmqm3: ["f1rh9g5y", "f1gbmcue"]
      },
      largePadding: {
        z8tnut: "fc7z3ec",
        z189sj: ["fat0sn4", "fekwl8i"],
        Byoj8tv: "fe2my4m",
        uwmqm3: ["fekwl8i", "fat0sn4"]
      },
      smallArrow: {
        a9b677: "f1ekdpwm",
        Bqenvij: "f83vc9z"
      },
      mediumLargeArrow: {
        a9b677: "f1kmc0fn",
        Bqenvij: "fb6lvc5"
      },
      arrow: {
        qhf8xq: "f1euv43f",
        De3pzq: "f1u2r49w",
        Bcdw1i0: "fd7fpy0",
        Bj3rh1h: "f1bsuimh",
        Ftih45: "f1wl9k8s",
        B1puzpu: "f1wkw4r9",
        Brfgrao: "f1j7ml58",
        Bcvre1j: "fyl8oag",
        Ccq8qp: "frdoeuz",
        Baz25je: "fb81m9q",
        cmx5o7: "f1ljr5q2",
        B4f6apu: "fyfemzf",
        m598lv: "focyt6c",
        Bk5zm6e: "fnhxbxj",
        y0oebl: "fdw6hkg",
        qa3bma: "f11yjt3y",
        Bqjgrrk: "f1172wan",
        Budzafs: ["f9e5op9", "f112wvtl"],
        Hv9wc6: ["ftj5xct", "fyavhwi"],
        hl6cv3: "f1773hnp",
        Bh2vraf: "f1n8855c",
        yayu3t: "f1v7783n",
        wedwtw: "fsw6im5",
        rhl9o9: "fh2hsk5",
        Bu8t5uz: "f159pzir",
        B6q6orb: "f11yvu4",
        Bwwlvwl: "fm1ycve"
      }
    }, {
      d: [".f19n0e5{color:var(--colorNeutralForeground1);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".f1hg901r{box-shadow:var(--shadow16);}", ".f1aa9q02{border-bottom-right-radius:var(--borderRadiusMedium);}", ".f16jpd5f{border-bottom-left-radius:var(--borderRadiusMedium);}", ".f1jar5jt{border-top-right-radius:var(--borderRadiusMedium);}", ".fyu767a{border-top-left-radius:var(--borderRadiusMedium);}", ".f5ogflp{border-top-width:1px;}", ".f1hqa2wf{border-right-width:1px;}", ".finvdd3{border-left-width:1px;}", ".f1f09k3d{border-bottom-width:1px;}", ".fzkkow9{border-top-style:solid;}", ".fcdblym{border-right-style:solid;}", ".fjik90z{border-left-style:solid;}", ".fg706s2{border-bottom-style:solid;}", ".fghlq4f{border-top-color:var(--colorTransparentStroke);}", ".f1gn591s{border-right-color:var(--colorTransparentStroke);}", ".fjscplz{border-left-color:var(--colorTransparentStroke);}", ".fb073pr{border-bottom-color:var(--colorTransparentStroke);}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".f18k4bn6{animation-composition:accumulate;}", ".fo1kyvf{animation-duration:var(--durationSlower);}", ".fetxo7e{animation-timing-function:var(--curveDecelerateMid);}", ".fmm77a6{--slide-distance-x:0px;}", ".f12t24nk{--slide-distance-y:10px;}", ".f1babd7[data-popper-placement^=right]{--slide-distance-x:-10px;}", ".f1jgo889[data-popper-placement^=right]{--slide-distance-y:0px;}", ".f1ij1pew[data-popper-placement^=bottom]{--slide-distance-x:0px;}", ".f1gu8pa9[data-popper-placement^=bottom]{--slide-distance-y:-10px;}", ".fhfnl4n[data-popper-placement^=left]{--slide-distance-x:10px;}", ".fk8tkmz[data-popper-placement^=left]{--slide-distance-y:0px;}", ".f3n0535{animation-name:f5j8bii,fld5wjx;}", ".f19g0ac{z-index:1;}", ".fg3r6xk{background-color:var(--colorNeutralBackgroundStatic);}", ".fonrgv7{color:var(--colorNeutralForegroundStaticInverted);}", ".ffp7eso{background-color:var(--colorBrandBackground);}", ".f1phragk{color:var(--colorNeutralForegroundOnBrand);}", ".f1kcqot9{padding-top:12px;}", ".f11qrl6u{padding-right:12px;}", ".fjlbh76{padding-left:12px;}", ".fpe6lb7{padding-bottom:12px;}", ".fqag9an{padding-top:16px;}", ".f1gbmcue{padding-right:16px;}", ".f1rh9g5y{padding-left:16px;}", ".fp67ikv{padding-bottom:16px;}", ".fc7z3ec{padding-top:20px;}", ".fat0sn4{padding-right:20px;}", ".fekwl8i{padding-left:20px;}", ".fe2my4m{padding-bottom:20px;}", ".f1ekdpwm{width:8.484px;}", ".f83vc9z{height:8.484px;}", ".f1kmc0fn{width:11.312px;}", ".fb6lvc5{height:11.312px;}", ".f1euv43f{position:absolute;}", ".f1u2r49w{background-color:inherit;}", ".fd7fpy0{visibility:hidden;}", ".f1bsuimh{z-index:-1;}", '.f1wl9k8s::before{content:"";}', ".f1wkw4r9::before{visibility:visible;}", ".f1j7ml58::before{position:absolute;}", ".fyl8oag::before{box-sizing:border-box;}", ".frdoeuz::before{width:inherit;}", ".fb81m9q::before{height:inherit;}", ".f1ljr5q2::before{background-color:inherit;}", ".fyfemzf::before{border-right-width:1px;}", ".focyt6c::before{border-right-style:solid;}", ".fnhxbxj::before{border-right-color:var(--colorTransparentStroke);}", ".fdw6hkg::before{border-bottom-width:1px;}", ".f11yjt3y::before{border-bottom-style:solid;}", ".f1172wan::before{border-bottom-color:var(--colorTransparentStroke);}", ".f9e5op9::before{border-bottom-right-radius:var(--borderRadiusSmall);}", ".f112wvtl::before{border-bottom-left-radius:var(--borderRadiusSmall);}", ".ftj5xct::before{transform:rotate(var(--angle)) translate(0, 50%) rotate(45deg);}", ".fyavhwi::before{transform:rotate(var(--angle)) translate(0, 50%) rotate(-45deg);}", '[data-popper-placement^="top"] .f1773hnp{bottom:-1px;}', '[data-popper-placement^="top"] .f1n8855c{--angle:0;}', '[data-popper-placement^="right"] .f1v7783n{left:-1px;}', '[data-popper-placement^="right"] .fsw6im5{--angle:90deg;}', '[data-popper-placement^="bottom"] .fh2hsk5{top:-1px;}', '[data-popper-placement^="bottom"] .f159pzir{--angle:180deg;}', '[data-popper-placement^="left"] .f11yvu4{right:-1px;}', '[data-popper-placement^="left"] .fm1ycve{--angle:270deg;}'],
      k: ["@keyframes f5j8bii{from{opacity:0;}to{opacity:1;}}", "@keyframes fld5wjx{from{transform:translate(var(--slide-distance-x), var(--slide-distance-y));}}"],
      m: [["@media (prefers-reduced-motion){.fi19xcv[data-popper-placement]{animation-duration:1ms;}}", {
        m: "(prefers-reduced-motion)"
      }], ["@media (prefers-reduced-motion){.f1mzajhk[data-popper-placement]{animation-name:f5j8bii;}}", {
        m: "(prefers-reduced-motion)"
      }]],
      t: ["@supports not (animation-composition: accumulate){.fjp4h9y[data-popper-placement]{animation-name:f5j8bii;}}"]
    });
    const usePopoverSurfaceStyles_unstable = (state) => {
      const styles2 = useStyles$e();
      state.root.className = mergeClasses$2(popoverSurfaceClassNames.root, styles2.root, state.inline && styles2.inline, state.size === "small" && styles2.smallPadding, state.size === "medium" && styles2.mediumPadding, state.size === "large" && styles2.largePadding, state.appearance === "inverted" && styles2.inverted, state.appearance === "brand" && styles2.brand, state.root.className);
      state.arrowClassName = mergeClasses$2(styles2.arrow, state.size === "small" ? styles2.smallArrow : styles2.mediumLargeArrow);
      return state;
    };
    const PopoverSurface = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const state = usePopoverSurface_unstable(props, ref);
      usePopoverSurfaceStyles_unstable(state);
      useCustomStyleHook("usePopoverSurfaceStyles_unstable")(state);
      return renderPopoverSurface_unstable(state);
    });
    PopoverSurface.displayName = "PopoverSurface";
    const popoverSurfaceBorderRadius = 4;
    const usePopover_unstable = (props) => {
      const [contextTarget, setContextTarget] = usePositioningMouseTarget();
      const initialState = {
        size: "medium",
        contextTarget,
        setContextTarget,
        ...props
      };
      const children = reactExports.Children.toArray(props.children);
      let popoverTrigger = void 0;
      let popoverSurface = void 0;
      if (children.length === 2) {
        popoverTrigger = children[0];
        popoverSurface = children[1];
      } else if (children.length === 1) {
        popoverSurface = children[0];
      }
      const [open, setOpenState] = useOpenState(initialState);
      const setOpenTimeoutRef = reactExports.useRef(0);
      const setOpen = useEventCallback$1((e2, shouldOpen) => {
        clearTimeout(setOpenTimeoutRef.current);
        if (!(e2 instanceof Event) && e2.persist) {
          e2.persist();
        }
        if (e2.type === "mouseleave") {
          var _props_mouseLeaveDelay;
          setOpenTimeoutRef.current = setTimeout(() => {
            setOpenState(e2, shouldOpen);
          }, (_props_mouseLeaveDelay = props.mouseLeaveDelay) !== null && _props_mouseLeaveDelay !== void 0 ? _props_mouseLeaveDelay : 500);
        } else {
          setOpenState(e2, shouldOpen);
        }
      });
      reactExports.useEffect(() => {
        return () => {
          clearTimeout(setOpenTimeoutRef.current);
        };
      }, []);
      const toggleOpen = reactExports.useCallback((e2) => {
        setOpen(e2, !open);
      }, [
        setOpen,
        open
      ]);
      const positioningRefs = usePopoverRefs(initialState);
      const { targetDocument } = useFluent();
      var _props_closeOnIframeFocus;
      useOnClickOutside({
        contains: elementContains,
        element: targetDocument,
        callback: (ev) => setOpen(ev, false),
        refs: [
          positioningRefs.triggerRef,
          positioningRefs.contentRef
        ],
        disabled: !open,
        disabledFocusOnIframe: !((_props_closeOnIframeFocus = props.closeOnIframeFocus) !== null && _props_closeOnIframeFocus !== void 0 ? _props_closeOnIframeFocus : true)
      });
      const closeOnScroll = initialState.openOnContext || initialState.closeOnScroll;
      useOnScrollOutside({
        contains: elementContains,
        element: targetDocument,
        callback: (ev) => setOpen(ev, false),
        refs: [
          positioningRefs.triggerRef,
          positioningRefs.contentRef
        ],
        disabled: !open || !closeOnScroll
      });
      const { findFirstFocusable } = useFocusFinders();
      reactExports.useEffect(() => {
        if (props.unstable_disableAutoFocus) {
          return;
        }
        if (open && positioningRefs.contentRef.current) {
          var _positioningRefs_contentRef_current_getAttribute;
          const containerTabIndex = (_positioningRefs_contentRef_current_getAttribute = positioningRefs.contentRef.current.getAttribute("tabIndex")) !== null && _positioningRefs_contentRef_current_getAttribute !== void 0 ? _positioningRefs_contentRef_current_getAttribute : void 0;
          const firstFocusable = isNaN(containerTabIndex) ? findFirstFocusable(positioningRefs.contentRef.current) : positioningRefs.contentRef.current;
          firstFocusable === null || firstFocusable === void 0 ? void 0 : firstFocusable.focus();
        }
      }, [
        findFirstFocusable,
        open,
        positioningRefs.contentRef,
        props.unstable_disableAutoFocus
      ]);
      var _props_inertTrapFocus, _props_inline;
      return {
        ...initialState,
        ...positioningRefs,
        // eslint-disable-next-line deprecation/deprecation
        inertTrapFocus: (_props_inertTrapFocus = props.inertTrapFocus) !== null && _props_inertTrapFocus !== void 0 ? _props_inertTrapFocus : props.legacyTrapFocus === void 0 ? false : !props.legacyTrapFocus,
        popoverTrigger,
        popoverSurface,
        open,
        setOpen,
        toggleOpen,
        setContextTarget,
        contextTarget,
        inline: (_props_inline = props.inline) !== null && _props_inline !== void 0 ? _props_inline : false
      };
    };
    function useOpenState(state) {
      const onOpenChange = useEventCallback$1((e2, data) => {
        var _state_onOpenChange;
        return (_state_onOpenChange = state.onOpenChange) === null || _state_onOpenChange === void 0 ? void 0 : _state_onOpenChange.call(state, e2, data);
      });
      const [open, setOpenState] = useControllableState({
        state: state.open,
        defaultState: state.defaultOpen,
        initialState: false
      });
      state.open = open !== void 0 ? open : state.open;
      const setContextTarget = state.setContextTarget;
      const setOpen = reactExports.useCallback((e2, shouldOpen) => {
        if (shouldOpen && e2.type === "contextmenu") {
          setContextTarget(e2);
        }
        if (!shouldOpen) {
          setContextTarget(void 0);
        }
        setOpenState(shouldOpen);
        onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(e2, {
          open: shouldOpen
        });
      }, [
        setOpenState,
        onOpenChange,
        setContextTarget
      ]);
      return [
        open,
        setOpen
      ];
    }
    function usePopoverRefs(state) {
      const positioningOptions = {
        position: "above",
        align: "center",
        arrowPadding: 2 * popoverSurfaceBorderRadius,
        target: state.openOnContext ? state.contextTarget : void 0,
        ...resolvePositioningShorthand(state.positioning)
      };
      if (positioningOptions.coverTarget) {
        state.withArrow = false;
      }
      if (state.withArrow) {
        positioningOptions.offset = mergeArrowOffset(positioningOptions.offset, arrowHeights[state.size]);
      }
      const { targetRef: triggerRef, containerRef: contentRef, arrowRef } = usePositioning(positioningOptions);
      return {
        triggerRef,
        contentRef,
        arrowRef
      };
    }
    const renderPopover_unstable = (state) => {
      const { appearance, arrowRef, contentRef, inline, mountNode, open, openOnContext, openOnHover, setOpen, size, toggleOpen, trapFocus, triggerRef, withArrow, inertTrapFocus } = state;
      return /* @__PURE__ */ reactExports.createElement(PopoverContext.Provider, {
        value: {
          appearance,
          arrowRef,
          contentRef,
          inline,
          mountNode,
          open,
          openOnContext,
          openOnHover,
          setOpen,
          toggleOpen,
          triggerRef,
          size,
          trapFocus,
          inertTrapFocus,
          withArrow
        }
      }, state.popoverTrigger, state.open && state.popoverSurface);
    };
    const Popover = (props) => {
      const state = usePopover_unstable(props);
      return renderPopover_unstable(state);
    };
    Popover.displayName = "Popover";
    const usePopoverTrigger_unstable = (props) => {
      const { children, disableButtonEnhancement = false } = props;
      const child = getTriggerChild(children);
      const open = usePopoverContext_unstable((context) => context.open);
      const setOpen = usePopoverContext_unstable((context) => context.setOpen);
      const toggleOpen = usePopoverContext_unstable((context) => context.toggleOpen);
      const triggerRef = usePopoverContext_unstable((context) => context.triggerRef);
      const openOnHover = usePopoverContext_unstable((context) => context.openOnHover);
      const openOnContext = usePopoverContext_unstable((context) => context.openOnContext);
      const { triggerAttributes } = useModalAttributes();
      const onContextMenu = (e2) => {
        if (openOnContext) {
          e2.preventDefault();
          setOpen(e2, true);
        }
      };
      const onClick = (e2) => {
        if (!openOnContext) {
          toggleOpen(e2);
        }
      };
      const onKeyDown = (e2) => {
        if (e2.key === Escape && open && !e2.isDefaultPrevented()) {
          setOpen(e2, false);
          e2.preventDefault();
        }
      };
      const onMouseEnter = (e2) => {
        if (openOnHover) {
          setOpen(e2, true);
        }
      };
      const onMouseLeave = (e2) => {
        if (openOnHover) {
          setOpen(e2, false);
        }
      };
      const contextMenuProps = {
        ...triggerAttributes,
        "aria-expanded": `${open}`,
        ...child === null || child === void 0 ? void 0 : child.props,
        onMouseEnter: useEventCallback$1(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onMouseEnter, onMouseEnter)),
        onMouseLeave: useEventCallback$1(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onMouseLeave, onMouseLeave)),
        onContextMenu: useEventCallback$1(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onContextMenu, onContextMenu)),
        ref: useMergedRefs(triggerRef, child === null || child === void 0 ? void 0 : child.ref)
      };
      const triggerChildProps = {
        ...contextMenuProps,
        onClick: useEventCallback$1(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onClick, onClick)),
        onKeyDown: useEventCallback$1(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onKeyDown, onKeyDown))
      };
      const ariaButtonTriggerChildProps = useARIAButtonProps((child === null || child === void 0 ? void 0 : child.type) === "button" || (child === null || child === void 0 ? void 0 : child.type) === "a" ? child.type : "div", triggerChildProps);
      return {
        children: applyTriggerPropsToChildren(props.children, useARIAButtonProps((child === null || child === void 0 ? void 0 : child.type) === "button" || (child === null || child === void 0 ? void 0 : child.type) === "a" ? child.type : "div", openOnContext ? contextMenuProps : disableButtonEnhancement ? triggerChildProps : ariaButtonTriggerChildProps))
      };
    };
    const renderPopoverTrigger_unstable = (state) => {
      return state.children;
    };
    const PopoverTrigger = (props) => {
      const state = usePopoverTrigger_unstable(props);
      return renderPopoverTrigger_unstable(state);
    };
    PopoverTrigger.displayName = "PopoverTrigger";
    PopoverTrigger.isFluentTriggerComponent = true;
    const arrowHeight = 6;
    const tooltipBorderRadius = 4;
    const useTooltip_unstable = (props) => {
      var _child_props, _child_props1, _child_props2, _child_props3;
      const context = useTooltipVisibility();
      const isServerSideRender = useIsSSR();
      const { targetDocument } = useFluent();
      const [setDelayTimeout, clearDelayTimeout] = useTimeout();
      const { appearance = "normal", children, content: content2, withArrow = false, positioning = "above", onVisibleChange, relationship, showDelay = 250, hideDelay = 250, mountNode } = props;
      const [visible, setVisibleInternal] = useControllableState({
        state: props.visible,
        initialState: false
      });
      const setVisible = reactExports.useCallback((ev, data) => {
        clearDelayTimeout();
        setVisibleInternal((oldVisible) => {
          if (data.visible !== oldVisible) {
            onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(ev, data);
          }
          return data.visible;
        });
      }, [
        clearDelayTimeout,
        setVisibleInternal,
        onVisibleChange
      ]);
      const state = {
        withArrow,
        positioning,
        showDelay,
        hideDelay,
        relationship,
        visible,
        shouldRenderTooltip: visible,
        appearance,
        mountNode,
        // Slots
        components: {
          content: "div"
        },
        content: always(content2, {
          defaultProps: {
            role: "tooltip"
          },
          elementType: "div"
        })
      };
      state.content.id = useId("tooltip-", state.content.id);
      const positioningOptions = {
        enabled: state.visible,
        arrowPadding: 2 * tooltipBorderRadius,
        position: "above",
        align: "center",
        offset: 4,
        ...resolvePositioningShorthand(state.positioning)
      };
      if (state.withArrow) {
        positioningOptions.offset = mergeArrowOffset(positioningOptions.offset, arrowHeight);
      }
      const { targetRef, containerRef, arrowRef } = usePositioning(positioningOptions);
      state.content.ref = useMergedRefs(state.content.ref, containerRef);
      state.arrowRef = arrowRef;
      useIsomorphicLayoutEffect(() => {
        if (visible) {
          var _context_visibleTooltip;
          const thisTooltip = {
            hide: (ev) => setVisible(void 0, {
              visible: false,
              documentKeyboardEvent: ev
            })
          };
          (_context_visibleTooltip = context.visibleTooltip) === null || _context_visibleTooltip === void 0 ? void 0 : _context_visibleTooltip.hide();
          context.visibleTooltip = thisTooltip;
          const onDocumentKeyDown = (ev) => {
            if (ev.key === Escape && !ev.defaultPrevented) {
              thisTooltip.hide(ev);
              ev.preventDefault();
            }
          };
          targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.addEventListener("keydown", onDocumentKeyDown, {
            // As this event is added at targeted document,
            // we need to capture the event to be sure keydown handling from tooltip happens first
            capture: true
          });
          return () => {
            if (context.visibleTooltip === thisTooltip) {
              context.visibleTooltip = void 0;
            }
            targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.removeEventListener("keydown", onDocumentKeyDown, {
              capture: true
            });
          };
        }
      }, [
        context,
        targetDocument,
        visible,
        setVisible
      ]);
      const ignoreNextFocusEventRef = reactExports.useRef(false);
      const onEnterTrigger = reactExports.useCallback((ev) => {
        if (ev.type === "focus" && ignoreNextFocusEventRef.current) {
          ignoreNextFocusEventRef.current = false;
          return;
        }
        const delay = context.visibleTooltip ? 0 : state.showDelay;
        setDelayTimeout(() => {
          setVisible(ev, {
            visible: true
          });
        }, delay);
        ev.persist();
      }, [
        setDelayTimeout,
        setVisible,
        state.showDelay,
        context
      ]);
      const [keyborgListenerCallbackRef] = reactExports.useState(() => {
        const onKeyborgFocusIn = (ev) => {
          var _ev_details;
          if ((_ev_details = ev.details) === null || _ev_details === void 0 ? void 0 : _ev_details.isFocusedProgrammatically) {
            ignoreNextFocusEventRef.current = true;
          }
        };
        let current = null;
        return (element2) => {
          current === null || current === void 0 ? void 0 : current.removeEventListener(KEYBORG_FOCUSIN, onKeyborgFocusIn);
          element2 === null || element2 === void 0 ? void 0 : element2.addEventListener(KEYBORG_FOCUSIN, onKeyborgFocusIn);
          current = element2;
        };
      });
      const onLeaveTrigger = reactExports.useCallback((ev) => {
        let delay = state.hideDelay;
        if (ev.type === "blur") {
          delay = 0;
          ignoreNextFocusEventRef.current = (targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement) === ev.target;
        }
        setDelayTimeout(() => {
          setVisible(ev, {
            visible: false
          });
        }, delay);
        ev.persist();
      }, [
        setDelayTimeout,
        setVisible,
        state.hideDelay,
        targetDocument
      ]);
      state.content.onPointerEnter = mergeCallbacks(state.content.onPointerEnter, clearDelayTimeout);
      state.content.onPointerLeave = mergeCallbacks(state.content.onPointerLeave, onLeaveTrigger);
      state.content.onFocus = mergeCallbacks(state.content.onFocus, clearDelayTimeout);
      state.content.onBlur = mergeCallbacks(state.content.onBlur, onLeaveTrigger);
      const child = getTriggerChild(children);
      const triggerAriaProps = {};
      if (relationship === "label") {
        if (typeof state.content.children === "string") {
          triggerAriaProps["aria-label"] = state.content.children;
        } else {
          triggerAriaProps["aria-labelledby"] = state.content.id;
          state.shouldRenderTooltip = true;
        }
      } else if (relationship === "description") {
        triggerAriaProps["aria-describedby"] = state.content.id;
        state.shouldRenderTooltip = true;
      }
      if (isServerSideRender) {
        state.shouldRenderTooltip = false;
      }
      state.children = applyTriggerPropsToChildren(children, {
        ...triggerAriaProps,
        ...child === null || child === void 0 ? void 0 : child.props,
        ref: useMergedRefs(
          child === null || child === void 0 ? void 0 : child.ref,
          keyborgListenerCallbackRef,
          // If the target prop is not provided, attach targetRef to the trigger element's ref prop
          positioningOptions.target === void 0 ? targetRef : void 0
        ),
        onPointerEnter: useEventCallback$1(mergeCallbacks(child === null || child === void 0 ? void 0 : (_child_props = child.props) === null || _child_props === void 0 ? void 0 : _child_props.onPointerEnter, onEnterTrigger)),
        onPointerLeave: useEventCallback$1(mergeCallbacks(child === null || child === void 0 ? void 0 : (_child_props1 = child.props) === null || _child_props1 === void 0 ? void 0 : _child_props1.onPointerLeave, onLeaveTrigger)),
        onFocus: useEventCallback$1(mergeCallbacks(child === null || child === void 0 ? void 0 : (_child_props2 = child.props) === null || _child_props2 === void 0 ? void 0 : _child_props2.onFocus, onEnterTrigger)),
        onBlur: useEventCallback$1(mergeCallbacks(child === null || child === void 0 ? void 0 : (_child_props3 = child.props) === null || _child_props3 === void 0 ? void 0 : _child_props3.onBlur, onLeaveTrigger))
      });
      return state;
    };
    const renderTooltip_unstable = (state) => {
      return /* @__PURE__ */ jsxs(reactExports.Fragment, {
        children: [
          state.children,
          state.shouldRenderTooltip && /* @__PURE__ */ jsx(Portal, {
            mountNode: state.mountNode,
            children: /* @__PURE__ */ jsxs(state.content, {
              children: [
                state.withArrow && /* @__PURE__ */ jsx("div", {
                  ref: state.arrowRef,
                  className: state.arrowClassName
                }),
                state.content.children
              ]
            })
          })
        ]
      });
    };
    const tooltipClassNames = {
      content: "fui-Tooltip__content"
    };
    const useStyles$d = /* @__PURE__ */ __styles$3({
      root: {
        mc9l5x: "fjseox",
        B7ck84d: "f1ewtqcl",
        B2u0y6b: "f132xexn",
        Bceei9c: "f158kwzp",
        Bahqtrf: "fk6fouc",
        Be2twd7: "fy9rknc",
        Bg96gwp: "fwrc4pm",
        Btd35i7: "fokg9q4",
        Bbmb7ep: ["f1aa9q02", "f16jpd5f"],
        Beyfa6y: ["f16jpd5f", "f1aa9q02"],
        B7oj6ja: ["f1jar5jt", "fyu767a"],
        Btl43ni: ["fyu767a", "f1jar5jt"],
        B4j52fo: "f5ogflp",
        Bekrc4i: ["f1hqa2wf", "finvdd3"],
        Bn0qgzm: "f1f09k3d",
        ibv6hh: ["finvdd3", "f1hqa2wf"],
        icvyot: "fzkkow9",
        vrafjx: ["fcdblym", "fjik90z"],
        oivjwe: "fg706s2",
        wvpqe5: ["fjik90z", "fcdblym"],
        g2u3we: "fghlq4f",
        h3c5rm: ["f1gn591s", "fjscplz"],
        B9xav0g: "fb073pr",
        zhjwy3: ["fjscplz", "f1gn591s"],
        z8tnut: "f10ra9hq",
        z189sj: ["fd9xhir", "f1jlaasf"],
        Byoj8tv: "f1d7kygh",
        uwmqm3: ["f1jlaasf", "fd9xhir"],
        De3pzq: "fxugw4r",
        sj55zd: "f19n0e5",
        Bhu2qc9: "fxeb0a7"
      },
      visible: {
        mc9l5x: "ftgm304"
      },
      inverted: {
        De3pzq: "fg3r6xk",
        sj55zd: "fonrgv7"
      },
      arrow: {
        qhf8xq: "f1euv43f",
        De3pzq: "f1u2r49w",
        Bcdw1i0: "fd7fpy0",
        Bj3rh1h: "f1bsuimh",
        a9b677: "f1ekdpwm",
        Bqenvij: "f83vc9z",
        Ftih45: "f1wl9k8s",
        B1puzpu: "f1wkw4r9",
        Brfgrao: "f1j7ml58",
        Bcvre1j: "fyl8oag",
        Ccq8qp: "frdoeuz",
        Baz25je: "fb81m9q",
        cmx5o7: "f1ljr5q2",
        B4f6apu: "fyfemzf",
        m598lv: "focyt6c",
        Bk5zm6e: "fnhxbxj",
        y0oebl: "fdw6hkg",
        qa3bma: "f11yjt3y",
        Bqjgrrk: "f1172wan",
        Budzafs: ["f9e5op9", "f112wvtl"],
        Hv9wc6: ["ftj5xct", "fyavhwi"],
        hl6cv3: "f1773hnp",
        Bh2vraf: "f1n8855c",
        yayu3t: "f1v7783n",
        wedwtw: "fsw6im5",
        rhl9o9: "fh2hsk5",
        Bu8t5uz: "f159pzir",
        B6q6orb: "f11yvu4",
        Bwwlvwl: "fm1ycve"
      }
    }, {
      d: [".fjseox{display:none;}", ".f1ewtqcl{box-sizing:border-box;}", ".f132xexn{max-width:240px;}", ".f158kwzp{cursor:default;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".fokg9q4{overflow-wrap:break-word;}", ".f1aa9q02{border-bottom-right-radius:var(--borderRadiusMedium);}", ".f16jpd5f{border-bottom-left-radius:var(--borderRadiusMedium);}", ".f1jar5jt{border-top-right-radius:var(--borderRadiusMedium);}", ".fyu767a{border-top-left-radius:var(--borderRadiusMedium);}", ".f5ogflp{border-top-width:1px;}", ".f1hqa2wf{border-right-width:1px;}", ".finvdd3{border-left-width:1px;}", ".f1f09k3d{border-bottom-width:1px;}", ".fzkkow9{border-top-style:solid;}", ".fcdblym{border-right-style:solid;}", ".fjik90z{border-left-style:solid;}", ".fg706s2{border-bottom-style:solid;}", ".fghlq4f{border-top-color:var(--colorTransparentStroke);}", ".f1gn591s{border-right-color:var(--colorTransparentStroke);}", ".fjscplz{border-left-color:var(--colorTransparentStroke);}", ".fb073pr{border-bottom-color:var(--colorTransparentStroke);}", ".f10ra9hq{padding-top:4px;}", ".fd9xhir{padding-right:11px;}", ".f1jlaasf{padding-left:11px;}", ".f1d7kygh{padding-bottom:6px;}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".fxeb0a7{filter:drop-shadow(0 0 2px var(--colorNeutralShadowAmbient)) drop-shadow(0 4px 8px var(--colorNeutralShadowKey));}", ".ftgm304{display:block;}", ".fg3r6xk{background-color:var(--colorNeutralBackgroundStatic);}", ".fonrgv7{color:var(--colorNeutralForegroundStaticInverted);}", ".f1euv43f{position:absolute;}", ".f1u2r49w{background-color:inherit;}", ".fd7fpy0{visibility:hidden;}", ".f1bsuimh{z-index:-1;}", ".f1ekdpwm{width:8.484px;}", ".f83vc9z{height:8.484px;}", '.f1wl9k8s::before{content:"";}', ".f1wkw4r9::before{visibility:visible;}", ".f1j7ml58::before{position:absolute;}", ".fyl8oag::before{box-sizing:border-box;}", ".frdoeuz::before{width:inherit;}", ".fb81m9q::before{height:inherit;}", ".f1ljr5q2::before{background-color:inherit;}", ".fyfemzf::before{border-right-width:1px;}", ".focyt6c::before{border-right-style:solid;}", ".fnhxbxj::before{border-right-color:var(--colorTransparentStroke);}", ".fdw6hkg::before{border-bottom-width:1px;}", ".f11yjt3y::before{border-bottom-style:solid;}", ".f1172wan::before{border-bottom-color:var(--colorTransparentStroke);}", ".f9e5op9::before{border-bottom-right-radius:var(--borderRadiusSmall);}", ".f112wvtl::before{border-bottom-left-radius:var(--borderRadiusSmall);}", ".ftj5xct::before{transform:rotate(var(--angle)) translate(0, 50%) rotate(45deg);}", ".fyavhwi::before{transform:rotate(var(--angle)) translate(0, 50%) rotate(-45deg);}", '[data-popper-placement^="top"] .f1773hnp{bottom:-1px;}', '[data-popper-placement^="top"] .f1n8855c{--angle:0;}', '[data-popper-placement^="right"] .f1v7783n{left:-1px;}', '[data-popper-placement^="right"] .fsw6im5{--angle:90deg;}', '[data-popper-placement^="bottom"] .fh2hsk5{top:-1px;}', '[data-popper-placement^="bottom"] .f159pzir{--angle:180deg;}', '[data-popper-placement^="left"] .f11yvu4{right:-1px;}', '[data-popper-placement^="left"] .fm1ycve{--angle:270deg;}']
    });
    const useTooltipStyles_unstable = (state) => {
      const styles2 = useStyles$d();
      state.content.className = mergeClasses$2(tooltipClassNames.content, styles2.root, state.appearance === "inverted" && styles2.inverted, state.visible && styles2.visible, state.content.className);
      state.arrowClassName = styles2.arrow;
      return state;
    };
    const Tooltip = (props) => {
      const state = useTooltip_unstable(props);
      useTooltipStyles_unstable(state);
      useCustomStyleHook("useTooltipStyles_unstable")(state);
      return renderTooltip_unstable(state);
    };
    Tooltip.displayName = "Tooltip";
    Tooltip.isFluentTriggerComponent = true;
    const renderButton_unstable = (state) => {
      const { iconOnly, iconPosition } = state;
      return /* @__PURE__ */ jsxs(state.root, {
        children: [
          iconPosition !== "after" && state.icon && /* @__PURE__ */ jsx(state.icon, {}),
          !iconOnly && state.root.children,
          iconPosition === "after" && state.icon && /* @__PURE__ */ jsx(state.icon, {})
        ]
      });
    };
    const buttonContext = reactExports.createContext(void 0);
    const buttonContextDefaultValue = {};
    buttonContext.Provider;
    const useButtonContext = () => {
      var _React_useContext;
      return (_React_useContext = reactExports.useContext(buttonContext)) !== null && _React_useContext !== void 0 ? _React_useContext : buttonContextDefaultValue;
    };
    const useButton_unstable = (props, ref) => {
      const { size: contextSize } = useButtonContext();
      const { appearance = "secondary", as: as2 = "button", disabled = false, disabledFocusable = false, icon, iconPosition = "before", shape = "rounded", size = contextSize !== null && contextSize !== void 0 ? contextSize : "medium" } = props;
      const iconShorthand = optional(icon, {
        elementType: "span"
      });
      return {
        // Props passed at the top-level
        appearance,
        disabled,
        disabledFocusable,
        iconPosition,
        shape,
        size,
        iconOnly: Boolean((iconShorthand === null || iconShorthand === void 0 ? void 0 : iconShorthand.children) && !props.children),
        components: {
          root: "button",
          icon: "span"
        },
        root: always(getIntrinsicElementProps(as2, useARIAButtonShorthand(props, {
          required: true,
          defaultProps: {
            ref,
            type: "button"
          }
        })), {
          elementType: "button"
        }),
        icon: iconShorthand
      };
    };
    const buttonClassNames = {
      root: "fui-Button",
      icon: "fui-Button__icon"
    };
    const useRootBaseClassName$1 = /* @__PURE__ */ __resetStyles("r1alrhcs", null, {
      r: [".r1alrhcs{align-items:center;box-sizing:border-box;display:inline-flex;justify-content:center;text-decoration-line:none;vertical-align:middle;margin:0;overflow:hidden;background-color:var(--colorNeutralBackground1);color:var(--colorNeutralForeground1);border:var(--strokeWidthThin) solid var(--colorNeutralStroke1);font-family:var(--fontFamilyBase);outline-style:none;padding:5px var(--spacingHorizontalM);min-width:96px;border-radius:var(--borderRadiusMedium);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightSemibold);line-height:var(--lineHeightBase300);transition-duration:var(--durationFaster);transition-property:background,border,color;transition-timing-function:var(--curveEasyEase);}", ".r1alrhcs:hover{background-color:var(--colorNeutralBackground1Hover);border-color:var(--colorNeutralStroke1Hover);color:var(--colorNeutralForeground1Hover);cursor:pointer;}", ".r1alrhcs:hover:active{background-color:var(--colorNeutralBackground1Pressed);border-color:var(--colorNeutralStroke1Pressed);color:var(--colorNeutralForeground1Pressed);outline-style:none;}", ".r1alrhcs[data-fui-focus-visible]{border-color:var(--colorStrokeFocus2);border-radius:var(--borderRadiusMedium);border-width:1px;outline:var(--strokeWidthThick) solid var(--colorTransparentStroke);box-shadow:0 0 0 var(--strokeWidthThin) var(--colorStrokeFocus2) inset;z-index:1;}"],
      s: ["@media screen and (prefers-reduced-motion: reduce){.r1alrhcs{transition-duration:0.01ms;}}", "@media (forced-colors: active){.r1alrhcs:focus{border-color:ButtonText;}.r1alrhcs:hover{background-color:HighlightText;border-color:Highlight;color:Highlight;forced-color-adjust:none;}.r1alrhcs:hover:active{background-color:HighlightText;border-color:Highlight;color:Highlight;forced-color-adjust:none;}}", "@supports (-moz-appearance:button){.r1alrhcs[data-fui-focus-visible]{box-shadow:0 0 0 calc(var(--strokeWidthThin) + 0.25px) var(--colorStrokeFocus2) inset;}}"]
    });
    const useIconBaseClassName = /* @__PURE__ */ __resetStyles("rywnvv2", null, [".rywnvv2{align-items:center;display:inline-flex;justify-content:center;font-size:20px;height:20px;width:20px;--fui-Button__icon--spacing:var(--spacingHorizontalSNudge);}"]);
    const useRootStyles$5 = /* @__PURE__ */ __styles$3({
      outline: {
        De3pzq: "f1c21dwh",
        Jwef8y: "fjxutwb",
        iro3zm: "fwiml72"
      },
      primary: {
        De3pzq: "ffp7eso",
        g2u3we: "f1p3nwhy",
        h3c5rm: ["f11589ue", "f1pdflbu"],
        B9xav0g: "f1q5o8ev",
        zhjwy3: ["f1pdflbu", "f11589ue"],
        sj55zd: "f1phragk",
        Jwef8y: "f15wkkf3",
        Bgoe8wy: "f1s2uweq",
        Bwzppfd: ["fr80ssc", "fecsdlb"],
        oetu4i: "f1ukrpxl",
        gg5e9n: ["fecsdlb", "fr80ssc"],
        Bi91k9c: "f1rq72xc",
        iro3zm: "fnp9lpt",
        b661bw: "f1h0usnq",
        Bk6r4ia: ["fs4ktlq", "fx2bmrt"],
        B9zn80p: "f16h9ulv",
        Bpld233: ["fx2bmrt", "fs4ktlq"],
        B2d53fq: "f1d6v5y2",
        Bsw6fvg: "f1rirnrt",
        Bjwas2f: "f1uu00uk",
        Bn1d65q: ["fkvaka8", "f9a0qzu"],
        Bxeuatn: "f1ux7til",
        n51gp8: ["f9a0qzu", "fkvaka8"],
        Bbusuzp: "f1lkg8j3",
        ycbfsm: "fkc42ay",
        Bqrx1nm: "fq7113v",
        pgvf35: "ff1wgvm",
        Bh7lczh: ["fiob0tu", "f1x4h75k"],
        dpv3f4: "f1j6scgf",
        Bpnjhaq: ["f1x4h75k", "fiob0tu"],
        ze5xyy: "f4xjyn1",
        g2kj27: "fbgcvur",
        Bf756sw: "f1ks1yx8",
        Bow2dr7: ["f1o6qegi", "fmxjhhp"],
        Bvhedfk: "fcnxywj",
        Gye4lf: ["fmxjhhp", "f1o6qegi"],
        pc6evw: "f9ddjv3"
      },
      secondary: {},
      subtle: {
        De3pzq: "fhovq9v",
        g2u3we: "f1p3nwhy",
        h3c5rm: ["f11589ue", "f1pdflbu"],
        B9xav0g: "f1q5o8ev",
        zhjwy3: ["f1pdflbu", "f11589ue"],
        sj55zd: "fkfq4zb",
        Jwef8y: "f1t94bn6",
        Bgoe8wy: "f1s2uweq",
        Bwzppfd: ["fr80ssc", "fecsdlb"],
        oetu4i: "f1ukrpxl",
        gg5e9n: ["fecsdlb", "fr80ssc"],
        Bi91k9c: "fnwyq0v",
        Bk3fhr4: "ft1hn21",
        Bmfj8id: "fuxngvv",
        Bbdnnc7: "fy5bs14",
        iro3zm: "fsv2rcd",
        b661bw: "f1h0usnq",
        Bk6r4ia: ["fs4ktlq", "fx2bmrt"],
        B9zn80p: "f16h9ulv",
        Bpld233: ["fx2bmrt", "fs4ktlq"],
        B2d53fq: "f1omzyqd",
        em6i61: "f1dfjoow",
        vm6p8p: "f1j98vj9",
        x3br3k: "fj8yq94",
        ze5xyy: "f4xjyn1",
        Bx3q9su: "f1et0tmh",
        pc6evw: "f9ddjv3",
        xd2cci: "f1wi8ngl"
      },
      transparent: {
        De3pzq: "f1c21dwh",
        g2u3we: "f1p3nwhy",
        h3c5rm: ["f11589ue", "f1pdflbu"],
        B9xav0g: "f1q5o8ev",
        zhjwy3: ["f1pdflbu", "f11589ue"],
        sj55zd: "fkfq4zb",
        Jwef8y: "fjxutwb",
        Bgoe8wy: "f1s2uweq",
        Bwzppfd: ["fr80ssc", "fecsdlb"],
        oetu4i: "f1ukrpxl",
        gg5e9n: ["fecsdlb", "fr80ssc"],
        Bi91k9c: "f139oj5f",
        Bk3fhr4: "ft1hn21",
        Bmfj8id: "fuxngvv",
        iro3zm: "fwiml72",
        b661bw: "f1h0usnq",
        Bk6r4ia: ["fs4ktlq", "fx2bmrt"],
        B9zn80p: "f16h9ulv",
        Bpld233: ["fx2bmrt", "fs4ktlq"],
        B2d53fq: "f1fg1p5m",
        em6i61: "f1dfjoow",
        vm6p8p: "f1j98vj9",
        Bqrx1nm: "f1tme0vf",
        ze5xyy: "f4xjyn1",
        g2kj27: "f18onu3q",
        pc6evw: "f9ddjv3"
      },
      circular: {
        Bbmb7ep: ["f8fbkgy", "f1nfllo7"],
        Beyfa6y: ["f1nfllo7", "f8fbkgy"],
        B7oj6ja: ["f1djnp8u", "f1s8kh49"],
        Btl43ni: ["f1s8kh49", "f1djnp8u"]
      },
      rounded: {},
      square: {
        Bbmb7ep: ["fzi6hpg", "fyowgf4"],
        Beyfa6y: ["fyowgf4", "fzi6hpg"],
        B7oj6ja: ["f3fg2lr", "f13av6d4"],
        Btl43ni: ["f13av6d4", "f3fg2lr"]
      },
      small: {
        Bf4jedk: "fh7ncta",
        z8tnut: "f1khb0e9",
        z189sj: ["f1vdfbxk", "f1f5gg8d"],
        Byoj8tv: "f1jnq6q7",
        uwmqm3: ["f1f5gg8d", "f1vdfbxk"],
        Bbmb7ep: ["f1aa9q02", "f16jpd5f"],
        Beyfa6y: ["f16jpd5f", "f1aa9q02"],
        B7oj6ja: ["f1jar5jt", "fyu767a"],
        Btl43ni: ["fyu767a", "f1jar5jt"],
        Be2twd7: "fy9rknc",
        Bhrd7zp: "figsok6",
        Bg96gwp: "fwrc4pm"
      },
      smallWithIcon: {
        Byoj8tv: "f1brlhvm",
        z8tnut: "f1sl3k7w"
      },
      medium: {},
      large: {
        Bf4jedk: "f14es27b",
        z8tnut: "fp9bwmr",
        z189sj: ["fjodcmx", "fhx4nu"],
        Byoj8tv: "f150uoa4",
        uwmqm3: ["fhx4nu", "fjodcmx"],
        Bbmb7ep: ["f1aa9q02", "f16jpd5f"],
        Beyfa6y: ["f16jpd5f", "f1aa9q02"],
        B7oj6ja: ["f1jar5jt", "fyu767a"],
        Btl43ni: ["fyu767a", "f1jar5jt"],
        Be2twd7: "fod5ikn",
        Bhrd7zp: "fl43uef",
        Bg96gwp: "faaz57k"
      },
      largeWithIcon: {
        Byoj8tv: "fy7v416",
        z8tnut: "f1a1bwwz"
      }
    }, {
      d: [".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".ffp7eso{background-color:var(--colorBrandBackground);}", ".f1p3nwhy{border-top-color:transparent;}", ".f11589ue{border-right-color:transparent;}", ".f1pdflbu{border-left-color:transparent;}", ".f1q5o8ev{border-bottom-color:transparent;}", ".f1phragk{color:var(--colorNeutralForegroundOnBrand);}", ".fhovq9v{background-color:var(--colorSubtleBackground);}", ".fkfq4zb{color:var(--colorNeutralForeground2);}", ".f8fbkgy{border-bottom-right-radius:var(--borderRadiusCircular);}", ".f1nfllo7{border-bottom-left-radius:var(--borderRadiusCircular);}", ".f1djnp8u{border-top-right-radius:var(--borderRadiusCircular);}", ".f1s8kh49{border-top-left-radius:var(--borderRadiusCircular);}", ".fzi6hpg{border-bottom-right-radius:var(--borderRadiusNone);}", ".fyowgf4{border-bottom-left-radius:var(--borderRadiusNone);}", ".f3fg2lr{border-top-right-radius:var(--borderRadiusNone);}", ".f13av6d4{border-top-left-radius:var(--borderRadiusNone);}", ".fh7ncta{min-width:64px;}", ".f1khb0e9{padding-top:3px;}", ".f1vdfbxk{padding-right:var(--spacingHorizontalS);}", ".f1f5gg8d{padding-left:var(--spacingHorizontalS);}", ".f1jnq6q7{padding-bottom:3px;}", ".f1aa9q02{border-bottom-right-radius:var(--borderRadiusMedium);}", ".f16jpd5f{border-bottom-left-radius:var(--borderRadiusMedium);}", ".f1jar5jt{border-top-right-radius:var(--borderRadiusMedium);}", ".fyu767a{border-top-left-radius:var(--borderRadiusMedium);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".f1brlhvm{padding-bottom:1px;}", ".f1sl3k7w{padding-top:1px;}", ".f14es27b{min-width:96px;}", ".fp9bwmr{padding-top:8px;}", ".fjodcmx{padding-right:var(--spacingHorizontalL);}", ".fhx4nu{padding-left:var(--spacingHorizontalL);}", ".f150uoa4{padding-bottom:8px;}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".fy7v416{padding-bottom:7px;}", ".f1a1bwwz{padding-top:7px;}"],
      h: [".fjxutwb:hover{background-color:var(--colorTransparentBackgroundHover);}", ".fwiml72:hover:active{background-color:var(--colorTransparentBackgroundPressed);}", ".f15wkkf3:hover{background-color:var(--colorBrandBackgroundHover);}", ".f1s2uweq:hover{border-top-color:transparent;}", ".fr80ssc:hover{border-right-color:transparent;}", ".fecsdlb:hover{border-left-color:transparent;}", ".f1ukrpxl:hover{border-bottom-color:transparent;}", ".f1rq72xc:hover{color:var(--colorNeutralForegroundOnBrand);}", ".fnp9lpt:hover:active{background-color:var(--colorBrandBackgroundPressed);}", ".f1h0usnq:hover:active{border-top-color:transparent;}", ".fs4ktlq:hover:active{border-right-color:transparent;}", ".fx2bmrt:hover:active{border-left-color:transparent;}", ".f16h9ulv:hover:active{border-bottom-color:transparent;}", ".f1d6v5y2:hover:active{color:var(--colorNeutralForegroundOnBrand);}", ".f1t94bn6:hover{background-color:var(--colorSubtleBackgroundHover);}", ".fnwyq0v:hover{color:var(--colorNeutralForeground2Hover);}", ".ft1hn21:hover .fui-Icon-filled{display:inline;}", ".fuxngvv:hover .fui-Icon-regular{display:none;}", ".fy5bs14:hover .fui-Button__icon{color:var(--colorNeutralForeground2BrandHover);}", ".fsv2rcd:hover:active{background-color:var(--colorSubtleBackgroundPressed);}", ".f1omzyqd:hover:active{color:var(--colorNeutralForeground2Pressed);}", ".f1dfjoow:hover:active .fui-Icon-filled{display:inline;}", ".f1j98vj9:hover:active .fui-Icon-regular{display:none;}", ".fj8yq94:hover:active .fui-Button__icon{color:var(--colorNeutralForeground2BrandPressed);}", ".f139oj5f:hover{color:var(--colorNeutralForeground2BrandHover);}", ".f1fg1p5m:hover:active{color:var(--colorNeutralForeground2BrandPressed);}"],
      m: [["@media (forced-colors: active){.f1rirnrt{background-color:Highlight;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.f1uu00uk{border-top-color:HighlightText;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.f9a0qzu{border-left-color:HighlightText;}.fkvaka8{border-right-color:HighlightText;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.f1ux7til{border-bottom-color:HighlightText;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.f1lkg8j3{color:HighlightText;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.fkc42ay{forced-color-adjust:none;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.fq7113v:hover{background-color:HighlightText;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.ff1wgvm:hover{border-top-color:Highlight;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.f1x4h75k:hover{border-left-color:Highlight;}.fiob0tu:hover{border-right-color:Highlight;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.f1j6scgf:hover{border-bottom-color:Highlight;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.f4xjyn1:hover{color:Highlight;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.fbgcvur:hover:active{background-color:HighlightText;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.f1ks1yx8:hover:active{border-top-color:Highlight;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.f1o6qegi:hover:active{border-right-color:Highlight;}.fmxjhhp:hover:active{border-left-color:Highlight;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.fcnxywj:hover:active{border-bottom-color:Highlight;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.f9ddjv3:hover:active{color:Highlight;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.f1et0tmh:hover .fui-Button__icon{color:Highlight;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.f1wi8ngl:hover:active .fui-Button__icon{color:Highlight;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.f1tme0vf:hover{background-color:var(--colorTransparentBackground);}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.f18onu3q:hover:active{background-color:var(--colorTransparentBackground);}}", {
        m: "(forced-colors: active)"
      }]]
    });
    const useRootDisabledStyles = /* @__PURE__ */ __styles$3({
      base: {
        De3pzq: "f1bg9a2p",
        g2u3we: "f1jj8ep1",
        h3c5rm: ["f15xbau", "fy0fskl"],
        B9xav0g: "f4ikngz",
        zhjwy3: ["fy0fskl", "f15xbau"],
        sj55zd: "f1s2aq7o",
        Bceei9c: "fdrzuqr",
        Bfinmwp: "f15x8b5r",
        Jwef8y: "f1falr9n",
        Bgoe8wy: "f12mpcsy",
        Bwzppfd: ["f1gwvigk", "f18rmfxp"],
        oetu4i: "f1jnshp0",
        gg5e9n: ["f18rmfxp", "f1gwvigk"],
        Bi91k9c: "fvgxktp",
        eoavqd: "fphbwmw",
        Bk3fhr4: "f19vpps7",
        Bmfj8id: "fv5swzo",
        Bbdnnc7: "f1al02dq",
        iro3zm: "f1t6o4dc",
        b661bw: "f10ztigi",
        Bk6r4ia: ["f1ft5sdu", "f1gzf82w"],
        B9zn80p: "f12zbtn2",
        Bpld233: ["f1gzf82w", "f1ft5sdu"],
        B2d53fq: "fcvwxyo",
        c3iz72: "f8w4c43",
        em6i61: "f1ol4fw6",
        vm6p8p: "f1q1lw4e",
        x3br3k: "f1dwjv2g"
      },
      highContrast: {
        Bsw6fvg: "f4lkoma",
        Bjwas2f: "fg455y9",
        Bn1d65q: ["f1rvyvqg", "f14g86mu"],
        Bxeuatn: "f1cwzwz",
        n51gp8: ["f14g86mu", "f1rvyvqg"],
        Bbusuzp: "f1dcs8yz",
        G867l3: "fjwq6ea",
        gdbnj: ["f1lr3nhc", "f1mbxvi6"],
        mxns5l: "fn5gmvv",
        o3nasb: ["f1mbxvi6", "f1lr3nhc"],
        Bqrx1nm: "f1vmkb5g",
        pgvf35: "f53ppgq",
        Bh7lczh: ["f1663y11", "f80fkiy"],
        dpv3f4: "f18v5270",
        Bpnjhaq: ["f80fkiy", "f1663y11"],
        ze5xyy: "f1kc2mi9",
        g2kj27: "f1y0svfh",
        Bf756sw: "fihuait",
        Bow2dr7: ["fnxhupq", "fyd6l6x"],
        Bvhedfk: "fx507ft",
        Gye4lf: ["fyd6l6x", "fnxhupq"],
        pc6evw: "fb3rf2x"
      },
      outline: {
        De3pzq: "f1c21dwh",
        Jwef8y: "f9ql6rf",
        iro3zm: "f3h1zc4"
      },
      primary: {
        g2u3we: "f1p3nwhy",
        h3c5rm: ["f11589ue", "f1pdflbu"],
        B9xav0g: "f1q5o8ev",
        zhjwy3: ["f1pdflbu", "f11589ue"],
        Bgoe8wy: "f1s2uweq",
        Bwzppfd: ["fr80ssc", "fecsdlb"],
        oetu4i: "f1ukrpxl",
        gg5e9n: ["fecsdlb", "fr80ssc"],
        b661bw: "f1h0usnq",
        Bk6r4ia: ["fs4ktlq", "fx2bmrt"],
        B9zn80p: "f16h9ulv",
        Bpld233: ["fx2bmrt", "fs4ktlq"]
      },
      secondary: {},
      subtle: {
        De3pzq: "f1c21dwh",
        g2u3we: "f1p3nwhy",
        h3c5rm: ["f11589ue", "f1pdflbu"],
        B9xav0g: "f1q5o8ev",
        zhjwy3: ["f1pdflbu", "f11589ue"],
        Jwef8y: "f9ql6rf",
        Bgoe8wy: "f1s2uweq",
        Bwzppfd: ["fr80ssc", "fecsdlb"],
        oetu4i: "f1ukrpxl",
        gg5e9n: ["fecsdlb", "fr80ssc"],
        iro3zm: "f3h1zc4",
        b661bw: "f1h0usnq",
        Bk6r4ia: ["fs4ktlq", "fx2bmrt"],
        B9zn80p: "f16h9ulv",
        Bpld233: ["fx2bmrt", "fs4ktlq"]
      },
      transparent: {
        De3pzq: "f1c21dwh",
        g2u3we: "f1p3nwhy",
        h3c5rm: ["f11589ue", "f1pdflbu"],
        B9xav0g: "f1q5o8ev",
        zhjwy3: ["f1pdflbu", "f11589ue"],
        Jwef8y: "f9ql6rf",
        Bgoe8wy: "f1s2uweq",
        Bwzppfd: ["fr80ssc", "fecsdlb"],
        oetu4i: "f1ukrpxl",
        gg5e9n: ["fecsdlb", "fr80ssc"],
        iro3zm: "f3h1zc4",
        b661bw: "f1h0usnq",
        Bk6r4ia: ["fs4ktlq", "fx2bmrt"],
        B9zn80p: "f16h9ulv",
        Bpld233: ["fx2bmrt", "fs4ktlq"]
      }
    }, {
      d: [".f1bg9a2p{background-color:var(--colorNeutralBackgroundDisabled);}", ".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fdrzuqr{cursor:not-allowed;}", ".f15x8b5r .fui-Button__icon{color:var(--colorNeutralForegroundDisabled);}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".f1p3nwhy{border-top-color:transparent;}", ".f11589ue{border-right-color:transparent;}", ".f1pdflbu{border-left-color:transparent;}", ".f1q5o8ev{border-bottom-color:transparent;}"],
      h: [".f1falr9n:hover{background-color:var(--colorNeutralBackgroundDisabled);}", ".f12mpcsy:hover{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f1gwvigk:hover{border-right-color:var(--colorNeutralStrokeDisabled);}", ".f18rmfxp:hover{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f1jnshp0:hover{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".fvgxktp:hover{color:var(--colorNeutralForegroundDisabled);}", ".fphbwmw:hover{cursor:not-allowed;}", ".f19vpps7:hover .fui-Icon-filled{display:none;}", ".fv5swzo:hover .fui-Icon-regular{display:inline;}", ".f1al02dq:hover .fui-Button__icon{color:var(--colorNeutralForegroundDisabled);}", ".f1t6o4dc:hover:active{background-color:var(--colorNeutralBackgroundDisabled);}", ".f10ztigi:hover:active{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f1ft5sdu:hover:active{border-right-color:var(--colorNeutralStrokeDisabled);}", ".f1gzf82w:hover:active{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f12zbtn2:hover:active{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".fcvwxyo:hover:active{color:var(--colorNeutralForegroundDisabled);}", ".f8w4c43:hover:active{cursor:not-allowed;}", ".f1ol4fw6:hover:active .fui-Icon-filled{display:none;}", ".f1q1lw4e:hover:active .fui-Icon-regular{display:inline;}", ".f1dwjv2g:hover:active .fui-Button__icon{color:var(--colorNeutralForegroundDisabled);}", ".f9ql6rf:hover{background-color:var(--colorTransparentBackground);}", ".f3h1zc4:hover:active{background-color:var(--colorTransparentBackground);}", ".f1s2uweq:hover{border-top-color:transparent;}", ".fr80ssc:hover{border-right-color:transparent;}", ".fecsdlb:hover{border-left-color:transparent;}", ".f1ukrpxl:hover{border-bottom-color:transparent;}", ".f1h0usnq:hover:active{border-top-color:transparent;}", ".fs4ktlq:hover:active{border-right-color:transparent;}", ".fx2bmrt:hover:active{border-left-color:transparent;}", ".f16h9ulv:hover:active{border-bottom-color:transparent;}"],
      m: [["@media (forced-colors: active){.f4lkoma{background-color:ButtonFace;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.fg455y9{border-top-color:GrayText;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.f14g86mu{border-left-color:GrayText;}.f1rvyvqg{border-right-color:GrayText;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.f1cwzwz{border-bottom-color:GrayText;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.f1dcs8yz{color:GrayText;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.fjwq6ea:focus{border-top-color:GrayText;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.f1lr3nhc:focus{border-right-color:GrayText;}.f1mbxvi6:focus{border-left-color:GrayText;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.fn5gmvv:focus{border-bottom-color:GrayText;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.f1vmkb5g:hover{background-color:ButtonFace;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.f53ppgq:hover{border-top-color:GrayText;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.f1663y11:hover{border-right-color:GrayText;}.f80fkiy:hover{border-left-color:GrayText;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.f18v5270:hover{border-bottom-color:GrayText;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.f1kc2mi9:hover{color:GrayText;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.f1y0svfh:hover:active{background-color:ButtonFace;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.fihuait:hover:active{border-top-color:GrayText;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.fnxhupq:hover:active{border-right-color:GrayText;}.fyd6l6x:hover:active{border-left-color:GrayText;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.fx507ft:hover:active{border-bottom-color:GrayText;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.fb3rf2x:hover:active{color:GrayText;}}", {
        m: "(forced-colors: active)"
      }]]
    });
    const useRootFocusStyles = /* @__PURE__ */ __styles$3({
      circular: {
        kdpuga: ["fanj13w", "f1gou5sz"],
        Bw81rd7: ["f1gou5sz", "fanj13w"],
        B6xbmo0: ["fulf6x3", "foeb2x"],
        dm238s: ["foeb2x", "fulf6x3"]
      },
      rounded: {},
      square: {
        kdpuga: ["f1ndz5i7", "f1co4qro"],
        Bw81rd7: ["f1co4qro", "f1ndz5i7"],
        B6xbmo0: ["f146y5a9", "f1k2ftg"],
        dm238s: ["f1k2ftg", "f146y5a9"]
      },
      primary: {
        B8q5s1w: "f17t0x8g",
        Bci5o5g: ["f194v5ow", "fk7jm04"],
        n8qw10: "f1qgg65p",
        Bdrgwmp: ["fk7jm04", "f194v5ow"],
        j6ew2k: ["fhgccpy", "fjo7pq6"],
        he4mth: "f32wu9k",
        Byr4aka: "fu5nqqq",
        lks7q5: ["f13prjl2", "f1nl83rv"],
        Bnan3qt: "f1czftr5",
        k1dn9: ["f1nl83rv", "f13prjl2"],
        Boium3a: ["f12k37oa", "fdnykm2"],
        tm8e47: "fr96u23"
      },
      small: {
        kdpuga: ["fg3gtdo", "fwii5mg"],
        Bw81rd7: ["fwii5mg", "fg3gtdo"],
        B6xbmo0: ["f1palphq", "f12nxie7"],
        dm238s: ["f12nxie7", "f1palphq"]
      },
      medium: {},
      large: {
        kdpuga: ["ft3lys4", "f1la4x2g"],
        Bw81rd7: ["f1la4x2g", "ft3lys4"],
        B6xbmo0: ["f156y0zm", "fakimq4"],
        dm238s: ["fakimq4", "f156y0zm"]
      }
    }, {
      d: [".fanj13w[data-fui-focus-visible]{border-bottom-right-radius:var(--borderRadiusCircular);}", ".f1gou5sz[data-fui-focus-visible]{border-bottom-left-radius:var(--borderRadiusCircular);}", ".fulf6x3[data-fui-focus-visible]{border-top-right-radius:var(--borderRadiusCircular);}", ".foeb2x[data-fui-focus-visible]{border-top-left-radius:var(--borderRadiusCircular);}", ".f1ndz5i7[data-fui-focus-visible]{border-bottom-right-radius:var(--borderRadiusNone);}", ".f1co4qro[data-fui-focus-visible]{border-bottom-left-radius:var(--borderRadiusNone);}", ".f146y5a9[data-fui-focus-visible]{border-top-right-radius:var(--borderRadiusNone);}", ".f1k2ftg[data-fui-focus-visible]{border-top-left-radius:var(--borderRadiusNone);}", ".f17t0x8g[data-fui-focus-visible]{border-top-color:var(--colorStrokeFocus2);}", ".f194v5ow[data-fui-focus-visible]{border-right-color:var(--colorStrokeFocus2);}", ".fk7jm04[data-fui-focus-visible]{border-left-color:var(--colorStrokeFocus2);}", ".f1qgg65p[data-fui-focus-visible]{border-bottom-color:var(--colorStrokeFocus2);}", ".fhgccpy[data-fui-focus-visible]{box-shadow:var(--shadow2),0 0 0 var(--strokeWidthThin) var(--colorStrokeFocus2) inset,0 0 0 var(--strokeWidthThick) var(--colorNeutralForegroundOnBrand) inset;}", ".fjo7pq6[data-fui-focus-visible]{box-shadow:var(--shadow2),0 0 0 var(--strokeWidthThin) var(--colorStrokeFocus2) inset,0 0 0 var(--strokeWidthThick) var(--colorNeutralForegroundOnBrand) inset;}", ".f32wu9k[data-fui-focus-visible]:hover{box-shadow:var(--shadow2),0 0 0 var(--strokeWidthThin) var(--colorStrokeFocus2) inset;}", ".fu5nqqq[data-fui-focus-visible]:hover{border-top-color:var(--colorStrokeFocus2);}", ".f13prjl2[data-fui-focus-visible]:hover{border-right-color:var(--colorStrokeFocus2);}", ".f1nl83rv[data-fui-focus-visible]:hover{border-left-color:var(--colorStrokeFocus2);}", ".f1czftr5[data-fui-focus-visible]:hover{border-bottom-color:var(--colorStrokeFocus2);}", ".fg3gtdo[data-fui-focus-visible]{border-bottom-right-radius:var(--borderRadiusSmall);}", ".fwii5mg[data-fui-focus-visible]{border-bottom-left-radius:var(--borderRadiusSmall);}", ".f1palphq[data-fui-focus-visible]{border-top-right-radius:var(--borderRadiusSmall);}", ".f12nxie7[data-fui-focus-visible]{border-top-left-radius:var(--borderRadiusSmall);}", ".ft3lys4[data-fui-focus-visible]{border-bottom-right-radius:var(--borderRadiusLarge);}", ".f1la4x2g[data-fui-focus-visible]{border-bottom-left-radius:var(--borderRadiusLarge);}", ".f156y0zm[data-fui-focus-visible]{border-top-right-radius:var(--borderRadiusLarge);}", ".fakimq4[data-fui-focus-visible]{border-top-left-radius:var(--borderRadiusLarge);}"],
      t: ["@supports (-moz-appearance:button){.f12k37oa[data-fui-focus-visible]{box-shadow:var(--shadow2),0 0 0 calc(var(--strokeWidthThin) + 0.25px) var(--colorStrokeFocus2) inset,0 0 0 var(--strokeWidthThick) var(--colorNeutralForegroundOnBrand) inset;}.fdnykm2[data-fui-focus-visible]{box-shadow:var(--shadow2),0 0 0 calc(var(--strokeWidthThin) + 0.25px) var(--colorStrokeFocus2) inset,0 0 0 var(--strokeWidthThick) var(--colorNeutralForegroundOnBrand) inset;}}", "@supports (-moz-appearance:button){.fr96u23[data-fui-focus-visible]:hover{box-shadow:var(--shadow2),0 0 0 calc(var(--strokeWidthThin) + 0.25px) var(--colorStrokeFocus2) inset;}}"]
    });
    const useRootIconOnlyStyles = /* @__PURE__ */ __styles$3({
      small: {
        z8tnut: "f1sl3k7w",
        z189sj: ["f136y8j8", "f10xn8zz"],
        Byoj8tv: "f1brlhvm",
        uwmqm3: ["f10xn8zz", "f136y8j8"],
        Bf4jedk: "f17fgpbq",
        B2u0y6b: "f1jt17bm"
      },
      medium: {
        z8tnut: "f1sbtcvk",
        z189sj: ["fwiuce9", "f15vdbe4"],
        Byoj8tv: "fdghr9",
        uwmqm3: ["f15vdbe4", "fwiuce9"],
        Bf4jedk: "fwbmr0d",
        B2u0y6b: "f44c6la"
      },
      large: {
        z8tnut: "f1a1bwwz",
        z189sj: ["f18k1jr3", "f1rtp3s9"],
        Byoj8tv: "fy7v416",
        uwmqm3: ["f1rtp3s9", "f18k1jr3"],
        Bf4jedk: "f12clzc2",
        B2u0y6b: "fjy1crr"
      }
    }, {
      d: [".f1sl3k7w{padding-top:1px;}", ".f136y8j8{padding-right:1px;}", ".f10xn8zz{padding-left:1px;}", ".f1brlhvm{padding-bottom:1px;}", ".f17fgpbq{min-width:24px;}", ".f1jt17bm{max-width:24px;}", ".f1sbtcvk{padding-top:5px;}", ".fwiuce9{padding-right:5px;}", ".f15vdbe4{padding-left:5px;}", ".fdghr9{padding-bottom:5px;}", ".fwbmr0d{min-width:32px;}", ".f44c6la{max-width:32px;}", ".f1a1bwwz{padding-top:7px;}", ".f18k1jr3{padding-right:7px;}", ".f1rtp3s9{padding-left:7px;}", ".fy7v416{padding-bottom:7px;}", ".f12clzc2{min-width:40px;}", ".fjy1crr{max-width:40px;}"]
    });
    const useIconStyles = /* @__PURE__ */ __styles$3({
      small: {
        Be2twd7: "fe5j1ua",
        Bqenvij: "fjamq6b",
        a9b677: "f64fuq3",
        Bqrlyyl: "fbaiahx"
      },
      medium: {},
      large: {
        Be2twd7: "f1rt2boy",
        Bqenvij: "frvgh55",
        a9b677: "fq4mcun",
        Bqrlyyl: "f1exjqw5"
      },
      before: {
        t21cq0: ["f1nizpg2", "f1a695kz"]
      },
      after: {
        Frg6f3: ["f1a695kz", "f1nizpg2"]
      }
    }, {
      d: [".fe5j1ua{font-size:20px;}", ".fjamq6b{height:20px;}", ".f64fuq3{width:20px;}", ".fbaiahx{--fui-Button__icon--spacing:var(--spacingHorizontalXS);}", ".f1rt2boy{font-size:24px;}", ".frvgh55{height:24px;}", ".fq4mcun{width:24px;}", ".f1exjqw5{--fui-Button__icon--spacing:var(--spacingHorizontalSNudge);}", ".f1nizpg2{margin-right:var(--fui-Button__icon--spacing);}", ".f1a695kz{margin-left:var(--fui-Button__icon--spacing);}"]
    });
    const useButtonStyles_unstable = (state) => {
      const rootBaseClassName = useRootBaseClassName$1();
      const iconBaseClassName = useIconBaseClassName();
      const rootStyles = useRootStyles$5();
      const rootDisabledStyles = useRootDisabledStyles();
      const rootFocusStyles = useRootFocusStyles();
      const rootIconOnlyStyles = useRootIconOnlyStyles();
      const iconStyles = useIconStyles();
      const {
        appearance,
        disabled,
        disabledFocusable,
        icon,
        iconOnly,
        iconPosition,
        shape,
        size
      } = state;
      state.root.className = mergeClasses$2(
        buttonClassNames.root,
        rootBaseClassName,
        appearance && rootStyles[appearance],
        rootStyles[size],
        icon && size === "small" && rootStyles.smallWithIcon,
        icon && size === "large" && rootStyles.largeWithIcon,
        rootStyles[shape],
        // Disabled styles
        (disabled || disabledFocusable) && rootDisabledStyles.base,
        (disabled || disabledFocusable) && rootDisabledStyles.highContrast,
        appearance && (disabled || disabledFocusable) && rootDisabledStyles[appearance],
        // Focus styles
        appearance === "primary" && rootFocusStyles.primary,
        rootFocusStyles[size],
        rootFocusStyles[shape],
        // Icon-only styles
        iconOnly && rootIconOnlyStyles[size],
        // User provided class name
        state.root.className
      );
      if (state.icon) {
        state.icon.className = mergeClasses$2(buttonClassNames.icon, iconBaseClassName, !!state.root.children && iconStyles[iconPosition], iconStyles[size], state.icon.className);
      }
      return state;
    };
    const Button = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const state = useButton_unstable(props, ref);
      useButtonStyles_unstable(state);
      useCustomStyleHook("useButtonStyles_unstable")(state);
      return renderButton_unstable(state);
    });
    Button.displayName = "Button";
    const FieldContext = reactExports.createContext(void 0);
    const FieldContextProvider = FieldContext.Provider;
    const useFieldContext_unstable = () => reactExports.useContext(FieldContext);
    const useFieldContextValues_unstable = (state) => {
      var _state_label, _state_label1, _state_validationMessage, _state_hint;
      const { generatedControlId, orientation, required, size, validationState } = state;
      const labelFor = (_state_label = state.label) === null || _state_label === void 0 ? void 0 : _state_label.htmlFor;
      const labelId = (_state_label1 = state.label) === null || _state_label1 === void 0 ? void 0 : _state_label1.id;
      const validationMessageId = (_state_validationMessage = state.validationMessage) === null || _state_validationMessage === void 0 ? void 0 : _state_validationMessage.id;
      const hintId = (_state_hint = state.hint) === null || _state_hint === void 0 ? void 0 : _state_hint.id;
      const field = reactExports.useMemo(() => ({
        generatedControlId,
        hintId,
        labelFor,
        labelId,
        orientation,
        required,
        size,
        validationMessageId,
        validationState
      }), [
        generatedControlId,
        hintId,
        labelFor,
        labelId,
        orientation,
        required,
        size,
        validationMessageId,
        validationState
      ]);
      return {
        field
      };
    };
    function useFieldControlProps_unstable(props, options) {
      return getFieldControlProps(useFieldContext_unstable(), props, options);
    }
    function getFieldControlProps(context, props, options) {
      if (!context) {
        return props;
      }
      props = {
        ...props
      };
      const { generatedControlId, hintId, labelFor, labelId, required, validationMessageId, validationState } = context;
      if (generatedControlId) {
        var _props;
        var _id;
        (_id = (_props = props).id) !== null && _id !== void 0 ? _id : _props.id = generatedControlId;
      }
      if (labelId && (!(options === null || options === void 0 ? void 0 : options.supportsLabelFor) || labelFor !== props.id)) {
        var _props1, _arialabelledby;
        var _2;
        (_2 = (_props1 = props)[_arialabelledby = "aria-labelledby"]) !== null && _2 !== void 0 ? _2 : _props1[_arialabelledby] = labelId;
      }
      if (validationMessageId || hintId) {
        props["aria-describedby"] = [
          validationMessageId,
          hintId,
          props === null || props === void 0 ? void 0 : props["aria-describedby"]
        ].filter(Boolean).join(" ");
      }
      if (validationState === "error") {
        var _props2, _ariainvalid;
        var _1;
        (_1 = (_props2 = props)[_ariainvalid = "aria-invalid"]) !== null && _1 !== void 0 ? _1 : _props2[_ariainvalid] = true;
      }
      if (required) {
        if (options === null || options === void 0 ? void 0 : options.supportsRequired) {
          var _props3;
          var _required;
          (_required = (_props3 = props).required) !== null && _required !== void 0 ? _required : _props3.required = true;
        } else {
          var _props4, _ariarequired;
          var _22;
          (_22 = (_props4 = props)[_ariarequired = "aria-required"]) !== null && _22 !== void 0 ? _22 : _props4[_ariarequired] = true;
        }
      }
      if (options === null || options === void 0 ? void 0 : options.supportsSize) {
        var _props5;
        var _size;
        (_size = (_props5 = props).size) !== null && _size !== void 0 ? _size : _props5.size = context.size;
      }
      return props;
    }
    const renderField_unstable = (state, contextValues) => {
      let { children } = state;
      if (typeof children === "function") {
        children = children(getFieldControlProps(contextValues.field) || {});
      }
      return /* @__PURE__ */ jsx(FieldContextProvider, {
        value: contextValues === null || contextValues === void 0 ? void 0 : contextValues.field,
        children: /* @__PURE__ */ jsxs(state.root, {
          children: [
            state.label && /* @__PURE__ */ jsx(state.label, {}),
            children,
            state.validationMessage && /* @__PURE__ */ jsxs(state.validationMessage, {
              children: [
                state.validationMessageIcon && /* @__PURE__ */ jsx(state.validationMessageIcon, {}),
                state.validationMessage.children
              ]
            }),
            state.hint && /* @__PURE__ */ jsx(state.hint, {})
          ]
        })
      });
    };
    const useLabel_unstable = (props, ref) => {
      const { disabled = false, required = false, weight = "regular", size = "medium" } = props;
      return {
        disabled,
        required: optional(required === true ? "*" : required || void 0, {
          defaultProps: {
            "aria-hidden": "true"
          },
          elementType: "span"
        }),
        weight,
        size,
        components: {
          root: "label",
          required: "span"
        },
        root: always(getIntrinsicElementProps("label", {
          // FIXME:
          // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLLabelElement`
          // but since it would be a breaking change to fix it, we are casting ref to it's proper type
          ref,
          ...props
        }), {
          elementType: "label"
        })
      };
    };
    const renderLabel_unstable = (state) => {
      return /* @__PURE__ */ jsxs(state.root, {
        children: [
          state.root.children,
          state.required && /* @__PURE__ */ jsx(state.required, {})
        ]
      });
    };
    const labelClassNames = {
      root: "fui-Label",
      required: "fui-Label__required"
    };
    const useStyles$c = /* @__PURE__ */ __styles$3({
      root: {
        Bahqtrf: "fk6fouc",
        sj55zd: "f19n0e5"
      },
      disabled: {
        sj55zd: "f1s2aq7o"
      },
      required: {
        sj55zd: "f1whyuy6",
        uwmqm3: ["fycuoez", "f8wuabp"]
      },
      requiredDisabled: {
        sj55zd: "f1s2aq7o"
      },
      small: {
        Be2twd7: "fy9rknc",
        Bg96gwp: "fwrc4pm"
      },
      medium: {
        Be2twd7: "fkhj508",
        Bg96gwp: "f1i3iumi"
      },
      large: {
        Be2twd7: "fod5ikn",
        Bg96gwp: "faaz57k",
        Bhrd7zp: "fl43uef"
      },
      semibold: {
        Bhrd7zp: "fl43uef"
      }
    }, {
      d: [".fk6fouc{font-family:var(--fontFamilyBase);}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f1whyuy6{color:var(--colorPaletteRedForeground3);}", ".fycuoez{padding-left:4px;}", ".f8wuabp{padding-right:4px;}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}"]
    });
    const useLabelStyles_unstable = (state) => {
      const styles2 = useStyles$c();
      state.root.className = mergeClasses$2(labelClassNames.root, styles2.root, state.disabled && styles2.disabled, styles2[state.size], state.weight === "semibold" && styles2.semibold, state.root.className);
      if (state.required) {
        state.required.className = mergeClasses$2(labelClassNames.required, styles2.required, state.disabled && styles2.requiredDisabled, state.required.className);
      }
      return state;
    };
    const Label = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const state = useLabel_unstable(props, ref);
      useLabelStyles_unstable(state);
      useCustomStyleHook("useLabelStyles_unstable")(state);
      return renderLabel_unstable(state);
    });
    Label.displayName = "Label";
    const validationMessageIcons = {
      error: /* @__PURE__ */ reactExports.createElement(ErrorCircle12Filled, null),
      warning: /* @__PURE__ */ reactExports.createElement(Warning12Filled, null),
      success: /* @__PURE__ */ reactExports.createElement(CheckmarkCircle12Filled, null),
      none: void 0
    };
    const useField_unstable = (props, ref) => {
      const { children, orientation = "vertical", required = false, validationState = props.validationMessage ? "error" : "none", size = "medium" } = props;
      const baseId = useId("field-");
      const generatedControlId = baseId + "__control";
      const root2 = always(getIntrinsicElementProps(
        "div",
        {
          ...props,
          ref
        },
        /*excludedPropNames:*/
        [
          "children"
        ]
      ), {
        elementType: "div"
      });
      const label = optional(props.label, {
        defaultProps: {
          htmlFor: generatedControlId,
          id: baseId + "__label",
          required,
          size
        },
        elementType: Label
      });
      const validationMessage = optional(props.validationMessage, {
        defaultProps: {
          id: baseId + "__validationMessage",
          role: validationState === "error" ? "alert" : void 0
        },
        elementType: "div"
      });
      const hint = optional(props.hint, {
        defaultProps: {
          id: baseId + "__hint"
        },
        elementType: "div"
      });
      const defaultIcon = validationMessageIcons[validationState];
      const validationMessageIcon = optional(props.validationMessageIcon, {
        renderByDefault: !!defaultIcon,
        defaultProps: {
          children: defaultIcon
        },
        elementType: "span"
      });
      return {
        children,
        generatedControlId,
        orientation,
        required,
        size,
        validationState,
        components: {
          root: "div",
          label: Label,
          validationMessage: "div",
          validationMessageIcon: "span",
          hint: "div"
        },
        root: root2,
        label,
        validationMessageIcon,
        validationMessage,
        hint
      };
    };
    const fieldClassNames = {
      root: `fui-Field`,
      label: `fui-Field__label`,
      validationMessage: `fui-Field__validationMessage`,
      validationMessageIcon: `fui-Field__validationMessageIcon`,
      hint: `fui-Field__hint`
    };
    const useRootStyles$4 = /* @__PURE__ */ __styles$3({
      base: {
        mc9l5x: "f13qh94s"
      },
      horizontal: {
        Budl1dq: "f2wwaib",
        wkccdc: "f1645dqt"
      },
      horizontalNoLabel: {
        uwmqm3: ["f15jqgz8", "fggqkej"],
        Budl1dq: "f1c2z91y"
      }
    }, {
      d: [".f13qh94s{display:grid;}", ".f2wwaib{grid-template-columns:33% 1fr;}", ".f1645dqt{grid-template-rows:auto auto auto 1fr;}", ".f15jqgz8{padding-left:33%;}", ".fggqkej{padding-right:33%;}", ".f1c2z91y{grid-template-columns:1fr;}"]
    });
    const useLabelStyles$2 = /* @__PURE__ */ __styles$3({
      base: {
        z8tnut: "fclwglc",
        Byoj8tv: "fywfov9"
      },
      large: {
        z8tnut: "f1sl3k7w",
        Byoj8tv: "f1brlhvm"
      },
      vertical: {
        jrapky: "fyacil5"
      },
      verticalLarge: {
        jrapky: "f8l5zjj"
      },
      horizontal: {
        t21cq0: ["fkujibs", "f199hnxi"],
        Ijaq50: "f16hsg94",
        nk6f5a: "f1nzqi2z"
      }
    }, {
      d: [".fclwglc{padding-top:var(--spacingVerticalXXS);}", ".fywfov9{padding-bottom:var(--spacingVerticalXXS);}", ".f1sl3k7w{padding-top:1px;}", ".f1brlhvm{padding-bottom:1px;}", ".fyacil5{margin-bottom:var(--spacingVerticalXXS);}", ".f8l5zjj{margin-bottom:var(--spacingVerticalXS);}", ".fkujibs{margin-right:var(--spacingHorizontalM);}", ".f199hnxi{margin-left:var(--spacingHorizontalM);}", ".f16hsg94{grid-row-start:1;}", ".f1nzqi2z{grid-row-end:-1;}"]
    });
    const useSecondaryTextBaseClassName = /* @__PURE__ */ __resetStyles("r5c4z9l", null, [".r5c4z9l{margin-top:var(--spacingVerticalXXS);color:var(--colorNeutralForeground3);font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase200);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase200);}"]);
    const useSecondaryTextStyles = /* @__PURE__ */ __styles$3({
      error: {
        sj55zd: "f1hcrxcs"
      },
      withIcon: {
        uwmqm3: ["frawy03", "fg4c52"]
      }
    }, {
      d: [".f1hcrxcs{color:var(--colorPaletteRedForeground1);}", ".frawy03{padding-left:calc(12px + var(--spacingHorizontalXS));}", ".fg4c52{padding-right:calc(12px + var(--spacingHorizontalXS));}"]
    });
    const useValidationMessageIconBaseClassName = /* @__PURE__ */ __resetStyles("ra7h1uk", "r1rh6bd7", [".ra7h1uk{display:inline-block;font-size:12px;margin-left:calc(-12px - var(--spacingHorizontalXS));margin-right:var(--spacingHorizontalXS);line-height:0;vertical-align:-1px;}", ".r1rh6bd7{display:inline-block;font-size:12px;margin-right:calc(-12px - var(--spacingHorizontalXS));margin-left:var(--spacingHorizontalXS);line-height:0;vertical-align:-1px;}"]);
    const useValidationMessageIconStyles = /* @__PURE__ */ __styles$3({
      error: {
        sj55zd: "f1hcrxcs"
      },
      warning: {
        sj55zd: "f1k5f75o"
      },
      success: {
        sj55zd: "ffmvakt"
      }
    }, {
      d: [".f1hcrxcs{color:var(--colorPaletteRedForeground1);}", ".f1k5f75o{color:var(--colorPaletteDarkOrangeForeground1);}", ".ffmvakt{color:var(--colorPaletteGreenForeground1);}"]
    });
    const useFieldStyles_unstable = (state) => {
      const {
        validationState
      } = state;
      const horizontal = state.orientation === "horizontal";
      const rootStyles = useRootStyles$4();
      state.root.className = mergeClasses$2(fieldClassNames.root, rootStyles.base, horizontal && rootStyles.horizontal, horizontal && !state.label && rootStyles.horizontalNoLabel, state.root.className);
      const labelStyles = useLabelStyles$2();
      if (state.label) {
        state.label.className = mergeClasses$2(fieldClassNames.label, labelStyles.base, horizontal && labelStyles.horizontal, !horizontal && labelStyles.vertical, state.label.size === "large" && labelStyles.large, !horizontal && state.label.size === "large" && labelStyles.verticalLarge, state.label.className);
      }
      const validationMessageIconBaseClassName = useValidationMessageIconBaseClassName();
      const validationMessageIconStyles = useValidationMessageIconStyles();
      if (state.validationMessageIcon) {
        state.validationMessageIcon.className = mergeClasses$2(fieldClassNames.validationMessageIcon, validationMessageIconBaseClassName, validationState !== "none" && validationMessageIconStyles[validationState], state.validationMessageIcon.className);
      }
      const secondaryTextBaseClassName = useSecondaryTextBaseClassName();
      const secondaryTextStyles = useSecondaryTextStyles();
      if (state.validationMessage) {
        state.validationMessage.className = mergeClasses$2(fieldClassNames.validationMessage, secondaryTextBaseClassName, validationState === "error" && secondaryTextStyles.error, !!state.validationMessageIcon && secondaryTextStyles.withIcon, state.validationMessage.className);
      }
      if (state.hint) {
        state.hint.className = mergeClasses$2(fieldClassNames.hint, secondaryTextBaseClassName, state.hint.className);
      }
    };
    const Field = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const state = useField_unstable(props, ref);
      useFieldStyles_unstable(state);
      const context = useFieldContextValues_unstable(state);
      return renderField_unstable(state, context);
    });
    Field.displayName = "Field";
    const renderDivider_unstable = (state) => {
      return /* @__PURE__ */ jsx(state.root, {
        children: state.root.children !== void 0 && /* @__PURE__ */ jsx(state.wrapper, {
          children: state.root.children
        })
      });
    };
    const useDivider_unstable = (props, ref) => {
      const { alignContent = "center", appearance = "default", inset: inset2 = false, vertical = false, wrapper } = props;
      const dividerId = useId("divider-");
      return {
        // Props passed at the top-level
        alignContent,
        appearance,
        inset: inset2,
        vertical,
        // Slots definition
        components: {
          root: "div",
          wrapper: "div"
        },
        root: always(getIntrinsicElementProps("div", {
          role: "separator",
          "aria-orientation": vertical ? "vertical" : "horizontal",
          "aria-labelledby": props.children ? dividerId : void 0,
          ...props,
          // FIXME:
          // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
          // but since it would be a breaking change to fix it, we are casting ref to it's proper type
          ref
        }), {
          elementType: "div"
        }),
        wrapper: always(wrapper, {
          defaultProps: {
            id: dividerId,
            children: props.children
          },
          elementType: "div"
        })
      };
    };
    const dividerClassNames = {
      root: "fui-Divider",
      wrapper: "fui-Divider__wrapper"
    };
    const useBaseStyles = /* @__PURE__ */ __styles$3({
      base: {
        Bt984gj: "f122n59",
        B7ck84d: "f1ewtqcl",
        mc9l5x: "f22iagw",
        Beiy3e4: "f1063pyq",
        Bh6795r: "fqerorx",
        qhf8xq: "f10pi13n",
        Bahqtrf: "fk6fouc",
        Be2twd7: "fy9rknc",
        Bhrd7zp: "figsok6",
        Bg96gwp: "fwrc4pm",
        fsow6f: "f17mccla",
        Bcvre1j: "fyl8oag",
        Br0sdwz: "f16vkdww",
        Bn78ew0: "fhsnbul",
        li1rpt: "f1gw3sf2",
        ap17g6: "f1ly5f7u",
        B771hl4: "f1s3tz6t"
      },
      childless: {
        susq4k: "f1kyqvp9",
        Bicfajf: ["fzynn9s", "f1z0ukd1"],
        jwcpgy: ["fekrn8e", "ftdg338"],
        B4rk6o: "fesgyo"
      },
      start: {
        Bsft5z2: "f13zj6fq"
      },
      center: {
        Ftih45: "f1wl9k8s",
        Bsft5z2: "f13zj6fq"
      },
      end: {
        Ftih45: "f1wl9k8s"
      },
      brand: {
        sj55zd: "f16muhyy",
        Bq4z7u6: "fcbuu2a",
        Bk5zm6e: ["f1wdw2dr", "f1ttio3w"],
        Bqjgrrk: "f1582fpk",
        Bm6vgfq: ["f1ttio3w", "f1wdw2dr"],
        B0n5ga8: "f1ahrvm8",
        s924m2: ["f1cd3wbc", "f17hbk9y"],
        B1q35kw: "fvrapl0",
        Gp14am: ["f17hbk9y", "f1cd3wbc"]
      },
      "default": {
        sj55zd: "fkfq4zb",
        Bq4z7u6: "f1vccso1",
        Bk5zm6e: ["f1geml7w", "fjml6kk"],
        Bqjgrrk: "f1r7kh1m",
        Bm6vgfq: ["fjml6kk", "f1geml7w"],
        B0n5ga8: "f16j7guv",
        s924m2: ["fx01ahm", "fj1a37q"],
        B1q35kw: "fl8d8yv",
        Gp14am: ["fj1a37q", "fx01ahm"]
      },
      subtle: {
        sj55zd: "fkfq4zb",
        Bq4z7u6: "f5g06un",
        Bk5zm6e: ["f13sxdku", "f1n015lb"],
        Bqjgrrk: "f1x6bl8t",
        Bm6vgfq: ["f1n015lb", "f13sxdku"],
        B0n5ga8: "fvod1wy",
        s924m2: ["fwslg65", "flk0e17"],
        B1q35kw: "f103fvts",
        Gp14am: ["flk0e17", "fwslg65"]
      },
      strong: {
        sj55zd: "fkfq4zb",
        Bq4z7u6: "f10tv6oz",
        Bk5zm6e: ["f16xp3sf", "f1seuxxq"],
        Bqjgrrk: "fwrmqbx",
        Bm6vgfq: ["f1seuxxq", "f16xp3sf"],
        B0n5ga8: "ft83z1f",
        s924m2: ["f1g4150c", "f192dr6e"],
        B1q35kw: "f1qnawh6",
        Gp14am: ["f192dr6e", "f1g4150c"]
      }
    }, {
      d: [".f122n59{align-items:center;}", ".f1ewtqcl{box-sizing:border-box;}", ".f22iagw{display:flex;}", ".f1063pyq{flex-direction:row;}", ".fqerorx{flex-grow:1;}", ".f10pi13n{position:relative;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".f17mccla{text-align:center;}", ".fyl8oag::before{box-sizing:border-box;}", ".f16vkdww::before{display:flex;}", ".fhsnbul::before{flex-grow:1;}", ".f1gw3sf2::after{box-sizing:border-box;}", ".f1ly5f7u::after{display:flex;}", ".f1s3tz6t::after{flex-grow:1;}", ".f1kyqvp9::before{margin-bottom:0;}", ".fzynn9s::before{margin-right:0;}", ".f1z0ukd1::before{margin-left:0;}", ".fekrn8e::after{margin-left:0;}", ".ftdg338::after{margin-right:0;}", ".fesgyo::after{margin-top:0;}", '.f13zj6fq::after{content:"";}', '.f1wl9k8s::before{content:"";}', ".f16muhyy{color:var(--colorBrandForeground1);}", ".fcbuu2a::before{border-top-color:var(--colorBrandStroke1);}", ".f1wdw2dr::before{border-right-color:var(--colorBrandStroke1);}", ".f1ttio3w::before{border-left-color:var(--colorBrandStroke1);}", ".f1582fpk::before{border-bottom-color:var(--colorBrandStroke1);}", ".f1ahrvm8::after{border-top-color:var(--colorBrandStroke1);}", ".f1cd3wbc::after{border-right-color:var(--colorBrandStroke1);}", ".f17hbk9y::after{border-left-color:var(--colorBrandStroke1);}", ".fvrapl0::after{border-bottom-color:var(--colorBrandStroke1);}", ".fkfq4zb{color:var(--colorNeutralForeground2);}", ".f1vccso1::before{border-top-color:var(--colorNeutralStroke2);}", ".f1geml7w::before{border-right-color:var(--colorNeutralStroke2);}", ".fjml6kk::before{border-left-color:var(--colorNeutralStroke2);}", ".f1r7kh1m::before{border-bottom-color:var(--colorNeutralStroke2);}", ".f16j7guv::after{border-top-color:var(--colorNeutralStroke2);}", ".fx01ahm::after{border-right-color:var(--colorNeutralStroke2);}", ".fj1a37q::after{border-left-color:var(--colorNeutralStroke2);}", ".fl8d8yv::after{border-bottom-color:var(--colorNeutralStroke2);}", ".f5g06un::before{border-top-color:var(--colorNeutralStroke3);}", ".f13sxdku::before{border-right-color:var(--colorNeutralStroke3);}", ".f1n015lb::before{border-left-color:var(--colorNeutralStroke3);}", ".f1x6bl8t::before{border-bottom-color:var(--colorNeutralStroke3);}", ".fvod1wy::after{border-top-color:var(--colorNeutralStroke3);}", ".fwslg65::after{border-right-color:var(--colorNeutralStroke3);}", ".flk0e17::after{border-left-color:var(--colorNeutralStroke3);}", ".f103fvts::after{border-bottom-color:var(--colorNeutralStroke3);}", ".f10tv6oz::before{border-top-color:var(--colorNeutralStroke1);}", ".f16xp3sf::before{border-right-color:var(--colorNeutralStroke1);}", ".f1seuxxq::before{border-left-color:var(--colorNeutralStroke1);}", ".fwrmqbx::before{border-bottom-color:var(--colorNeutralStroke1);}", ".ft83z1f::after{border-top-color:var(--colorNeutralStroke1);}", ".f1g4150c::after{border-right-color:var(--colorNeutralStroke1);}", ".f192dr6e::after{border-left-color:var(--colorNeutralStroke1);}", ".f1qnawh6::after{border-bottom-color:var(--colorNeutralStroke1);}"]
    });
    const useHorizontalStyles = /* @__PURE__ */ __styles$3({
      base: {
        a9b677: "fly5x3f",
        Bdkvgpv: "f163fonl",
        B0qfbqy: "f51yk4v",
        pbipgd: "f13rof3u",
        Bm2nyyq: "f8rth92",
        xrcqlc: "f6czdpx",
        i5u598: "f1iyka9k"
      },
      inset: {
        uwmqm3: ["fjlbh76", "f11qrl6u"],
        z189sj: ["f11qrl6u", "fjlbh76"]
      },
      start: {
        Ftih45: "f1wl9k8s",
        Bicfajf: ["f1ojjlep", "fk1kexq"],
        Bxwl2t9: "f1he2m4d",
        jwcpgy: ["f12w1bnb", "f1558wlj"]
      },
      center: {
        Bicfajf: ["f1ojjlep", "fk1kexq"],
        jwcpgy: ["f12w1bnb", "f1558wlj"]
      },
      end: {
        Bicfajf: ["f1ojjlep", "fk1kexq"],
        Bsft5z2: "f13zj6fq",
        jwcpgy: ["f12w1bnb", "f1558wlj"],
        Iy66sp: "f1ayce8x"
      }
    }, {
      d: [".fly5x3f{width:100%;}", ".f163fonl::before{border-top-style:solid;}", ".f51yk4v::before{border-top-width:var(--strokeWidthThin);}", ".f13rof3u::before{min-width:8px;}", ".f8rth92::after{border-top-style:solid;}", ".f6czdpx::after{border-top-width:var(--strokeWidthThin);}", ".f1iyka9k::after{min-width:8px;}", ".fjlbh76{padding-left:12px;}", ".f11qrl6u{padding-right:12px;}", '.f1wl9k8s::before{content:"";}', ".f1ojjlep::before{margin-right:12px;}", ".fk1kexq::before{margin-left:12px;}", ".f1he2m4d::before{max-width:8px;}", ".f12w1bnb::after{margin-left:12px;}", ".f1558wlj::after{margin-right:12px;}", '.f13zj6fq::after{content:"";}', ".f1ayce8x::after{max-width:8px;}"]
    });
    const useVerticalStyles = /* @__PURE__ */ __styles$3({
      base: {
        Beiy3e4: "f1vx9l62",
        sshi5w: "f16gbxbe",
        m598lv: ["f1yq6w5o", "f1jpmc5p"],
        B4f6apu: ["f9sc749", "f1x8pvcy"],
        zkzzav: "fhkwbjy",
        Barhvk9: ["flthirb", "ftkbnf5"],
        Ihftqj: ["f13hvwk3", "f1en4csx"],
        Bde111x: "f19onpk6"
      },
      inset: {
        B6of3ja: "f1xdg43u",
        jrapky: "f1jlhsmd"
      },
      withChildren: {
        sshi5w: "f1tjaq3g"
      },
      start: {
        Ftih45: "f1wl9k8s",
        susq4k: "fg2pwug",
        Bbdr6tz: "fkjtzyi",
        B4rk6o: "f8vk40g"
      },
      center: {
        susq4k: "fg2pwug",
        B4rk6o: "f8vk40g"
      },
      end: {
        susq4k: "fg2pwug",
        Bsft5z2: "f13zj6fq",
        B4rk6o: "f8vk40g",
        gn64ia: "fqg5mu5"
      }
    }, {
      d: [".f1vx9l62{flex-direction:column;}", ".f16gbxbe{min-height:20px;}", ".f1yq6w5o::before{border-right-style:solid;}", ".f1jpmc5p::before{border-left-style:solid;}", ".f9sc749::before{border-right-width:var(--strokeWidthThin);}", ".f1x8pvcy::before{border-left-width:var(--strokeWidthThin);}", ".fhkwbjy::before{min-height:8px;}", ".flthirb::after{border-right-style:solid;}", ".ftkbnf5::after{border-left-style:solid;}", ".f13hvwk3::after{border-right-width:var(--strokeWidthThin);}", ".f1en4csx::after{border-left-width:var(--strokeWidthThin);}", ".f19onpk6::after{min-height:8px;}", ".f1xdg43u{margin-top:12px;}", ".f1jlhsmd{margin-bottom:12px;}", ".f1tjaq3g{min-height:84px;}", '.f1wl9k8s::before{content:"";}', ".fg2pwug::before{margin-bottom:12px;}", ".fkjtzyi::before{max-height:8px;}", ".f8vk40g::after{margin-top:12px;}", '.f13zj6fq::after{content:"";}', ".fqg5mu5::after{max-height:8px;}"]
    });
    const useDividerStyles_unstable = (state) => {
      const baseStyles = useBaseStyles();
      const horizontalStyles = useHorizontalStyles();
      const verticalStyles = useVerticalStyles();
      const {
        alignContent,
        appearance,
        inset: inset2,
        vertical
      } = state;
      state.root.className = mergeClasses$2(
        dividerClassNames.root,
        // Base styles
        baseStyles.base,
        baseStyles[alignContent],
        appearance && baseStyles[appearance],
        // Horizontal styles
        !vertical && horizontalStyles.base,
        !vertical && inset2 && horizontalStyles.inset,
        !vertical && horizontalStyles[alignContent],
        // Vertical styles
        vertical && verticalStyles.base,
        vertical && inset2 && verticalStyles.inset,
        vertical && verticalStyles[alignContent],
        vertical && state.root.children !== void 0 && verticalStyles.withChildren,
        // Childless styles
        state.root.children === void 0 && baseStyles.childless,
        // User provided class name
        state.root.className
      );
      if (state.wrapper) {
        state.wrapper.className = mergeClasses$2(dividerClassNames.wrapper, state.wrapper.className);
      }
      return state;
    };
    const Divider = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const state = useDivider_unstable(props, ref);
      useDividerStyles_unstable(state);
      useCustomStyleHook("useDividerStyles_unstable")(state);
      return renderDivider_unstable(state);
    });
    Divider.displayName = "Divider";
    const useInput_unstable = (props, ref) => {
      props = useFieldControlProps_unstable(props, {
        supportsLabelFor: true,
        supportsRequired: true,
        supportsSize: true
      });
      const overrides = useOverrides();
      var _overrides_inputDefaultAppearance;
      const { size = "medium", appearance = (_overrides_inputDefaultAppearance = overrides.inputDefaultAppearance) !== null && _overrides_inputDefaultAppearance !== void 0 ? _overrides_inputDefaultAppearance : "outline", onChange } = props;
      const [value, setValue] = useControllableState({
        state: props.value,
        defaultState: props.defaultValue,
        initialState: ""
      });
      const nativeProps = getPartitionedNativeProps({
        props,
        primarySlotTagName: "input",
        excludedPropNames: [
          "size",
          "onChange",
          "value",
          "defaultValue"
        ]
      });
      const state = {
        size,
        appearance,
        components: {
          root: "span",
          input: "input",
          contentBefore: "span",
          contentAfter: "span"
        },
        input: always(props.input, {
          defaultProps: {
            type: "text",
            ref,
            ...nativeProps.primary
          },
          elementType: "input"
        }),
        contentAfter: optional(props.contentAfter, {
          elementType: "span"
        }),
        contentBefore: optional(props.contentBefore, {
          elementType: "span"
        }),
        root: always(props.root, {
          defaultProps: nativeProps.root,
          elementType: "span"
        })
      };
      state.input.value = value;
      state.input.onChange = useEventCallback$1((ev) => {
        const newValue = ev.target.value;
        onChange === null || onChange === void 0 ? void 0 : onChange(ev, {
          value: newValue
        });
        setValue(newValue);
      });
      return state;
    };
    const renderInput_unstable = (state) => {
      return /* @__PURE__ */ jsxs(state.root, {
        children: [
          state.contentBefore && /* @__PURE__ */ jsx(state.contentBefore, {}),
          /* @__PURE__ */ jsx(state.input, {}),
          state.contentAfter && /* @__PURE__ */ jsx(state.contentAfter, {})
        ]
      });
    };
    const inputClassNames = {
      root: "fui-Input",
      input: "fui-Input__input",
      contentBefore: "fui-Input__contentBefore",
      contentAfter: "fui-Input__contentAfter"
    };
    const useRootClassName = /* @__PURE__ */ __resetStyles("r1jtohuq", "rl1z2p5", {
      r: [".r1jtohuq{display:inline-flex;align-items:center;flex-wrap:nowrap;gap:var(--spacingHorizontalXXS);border-radius:var(--borderRadiusMedium);position:relative;box-sizing:border-box;min-height:32px;padding:0 var(--spacingHorizontalMNudge);font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);background-color:var(--colorNeutralBackground1);border:1px solid var(--colorNeutralStroke1);border-bottom-color:var(--colorNeutralStrokeAccessible);}", '.r1jtohuq::after{box-sizing:border-box;content:"";position:absolute;left:-1px;bottom:-1px;right:-1px;height:max(2px, var(--borderRadiusMedium));border-bottom-left-radius:var(--borderRadiusMedium);border-bottom-right-radius:var(--borderRadiusMedium);border-bottom:2px solid var(--colorCompoundBrandStroke);clip-path:inset(calc(100% - 2px) 0 0 0);transform:scaleX(0);transition-property:transform;transition-duration:var(--durationUltraFast);transition-delay:var(--curveAccelerateMid);}', ".r1jtohuq:focus-within::after{transform:scaleX(1);transition-property:transform;transition-duration:var(--durationNormal);transition-delay:var(--curveDecelerateMid);}", ".r1jtohuq:focus-within:active::after{border-bottom-color:var(--colorCompoundBrandStrokePressed);}", ".r1jtohuq:focus-within{outline:2px solid transparent;}", ".rl1z2p5{display:inline-flex;align-items:center;flex-wrap:nowrap;gap:var(--spacingHorizontalXXS);border-radius:var(--borderRadiusMedium);position:relative;box-sizing:border-box;min-height:32px;padding:0 var(--spacingHorizontalMNudge);font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);background-color:var(--colorNeutralBackground1);border:1px solid var(--colorNeutralStroke1);border-bottom-color:var(--colorNeutralStrokeAccessible);}", '.rl1z2p5::after{box-sizing:border-box;content:"";position:absolute;right:-1px;bottom:-1px;left:-1px;height:max(2px, var(--borderRadiusMedium));border-bottom-right-radius:var(--borderRadiusMedium);border-bottom-left-radius:var(--borderRadiusMedium);border-bottom:2px solid var(--colorCompoundBrandStroke);clip-path:inset(calc(100% - 2px) 0 0 0);transform:scaleX(0);transition-property:transform;transition-duration:var(--durationUltraFast);transition-delay:var(--curveAccelerateMid);}', ".rl1z2p5:focus-within::after{transform:scaleX(1);transition-property:transform;transition-duration:var(--durationNormal);transition-delay:var(--curveDecelerateMid);}", ".rl1z2p5:focus-within:active::after{border-bottom-color:var(--colorCompoundBrandStrokePressed);}", ".rl1z2p5:focus-within{outline:2px solid transparent;}"],
      s: ["@media screen and (prefers-reduced-motion: reduce){.r1jtohuq::after{transition-duration:0.01ms;transition-delay:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.r1jtohuq:focus-within::after{transition-duration:0.01ms;transition-delay:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.rl1z2p5::after{transition-duration:0.01ms;transition-delay:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.rl1z2p5:focus-within::after{transition-duration:0.01ms;transition-delay:0.01ms;}}"]
    });
    const useRootStyles$3 = /* @__PURE__ */ __styles$3({
      small: {
        sshi5w: "f1pha7fy",
        uwmqm3: ["fk8j09s", "fdw0yi8"],
        z189sj: ["fdw0yi8", "fk8j09s"],
        Bahqtrf: "fk6fouc",
        Be2twd7: "fy9rknc",
        Bhrd7zp: "figsok6",
        Bg96gwp: "fwrc4pm"
      },
      medium: {},
      large: {
        sshi5w: "f1w5jphr",
        uwmqm3: ["f1uw59to", "fw5db7e"],
        z189sj: ["fw5db7e", "f1uw59to"],
        Bahqtrf: "fk6fouc",
        Be2twd7: "fod5ikn",
        Bhrd7zp: "figsok6",
        Bg96gwp: "faaz57k",
        i8kkvl: "f1rjii52",
        Belr9w4: "f1r7g2jn"
      },
      outline: {},
      outlineInteractive: {
        Bgoe8wy: "fvcxoqz",
        Bwzppfd: ["f1ub3y4t", "f1m52nbi"],
        oetu4i: "f1l4zc64",
        gg5e9n: ["f1m52nbi", "f1ub3y4t"],
        Drbcw7: "f8vnjqi",
        udz0bu: ["fz1etlk", "f1hc16gm"],
        Be8ivqh: "f1klwx88",
        ofdepl: ["f1hc16gm", "fz1etlk"]
      },
      underline: {
        De3pzq: "f1c21dwh",
        Bbmb7ep: ["f1krrbdw", "f1deotkl"],
        Beyfa6y: ["f1deotkl", "f1krrbdw"],
        B7oj6ja: ["f10ostut", "f1ozlkrg"],
        Btl43ni: ["f1ozlkrg", "f10ostut"],
        icvyot: "f1ern45e",
        vrafjx: ["f1n71otn", "f1deefiw"],
        wvpqe5: ["f1deefiw", "f1n71otn"],
        Eqx8gd: ["f1n6gb5g", "f15yvnhg"],
        B1piin3: ["f15yvnhg", "f1n6gb5g"]
      },
      underlineInteractive: {
        oetu4i: "f1l4zc64",
        Be8ivqh: "f1klwx88",
        B3778ie: ["f1nf3wye", "feulmo5"],
        d9w3h3: ["feulmo5", "f1nf3wye"],
        Bl18szs: ["f18vqdqu", "f53nyzz"],
        B4j8arr: ["f53nyzz", "f18vqdqu"]
      },
      filled: {
        g2u3we: "fghlq4f",
        h3c5rm: ["f1gn591s", "fjscplz"],
        B9xav0g: "fb073pr",
        zhjwy3: ["fjscplz", "f1gn591s"]
      },
      filledInteractive: {
        q7v0qe: "ftmjh5b",
        kmh5ft: ["f17blpuu", "fsrcdbj"],
        nagaa4: "f1tpwn32",
        B1yhkcb: ["fsrcdbj", "f17blpuu"]
      },
      invalid: {
        tvckwq: "fs4k3qj",
        gk2u95: ["fcee079", "fmyw78r"],
        hhx65j: "f1fgmyf4",
        Bxowmz0: ["fmyw78r", "fcee079"]
      },
      "filled-darker": {
        De3pzq: "f16xq7d1"
      },
      "filled-lighter": {
        De3pzq: "fxugw4r"
      },
      "filled-darker-shadow": {
        De3pzq: "f16xq7d1",
        E5pizo: "fyed02w"
      },
      "filled-lighter-shadow": {
        De3pzq: "fxugw4r",
        E5pizo: "fyed02w"
      },
      disabled: {
        Bceei9c: "fdrzuqr",
        De3pzq: "f1c21dwh",
        g2u3we: "f1jj8ep1",
        h3c5rm: ["f15xbau", "fy0fskl"],
        B9xav0g: "f4ikngz",
        zhjwy3: ["fy0fskl", "f15xbau"],
        Bjwas2f: "fg455y9",
        Bn1d65q: ["f1rvyvqg", "f14g86mu"],
        Bxeuatn: "f1cwzwz",
        n51gp8: ["f14g86mu", "f1rvyvqg"],
        Bsft5z2: "fhr9occ",
        Bduesf4: "f99w1ws"
      }
    }, {
      d: [".f1pha7fy{min-height:24px;}", ".fk8j09s{padding-left:var(--spacingHorizontalSNudge);}", ".fdw0yi8{padding-right:var(--spacingHorizontalSNudge);}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fy9rknc{font-size:var(--fontSizeBase200);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".fwrc4pm{line-height:var(--lineHeightBase200);}", ".f1w5jphr{min-height:40px;}", ".f1uw59to{padding-left:var(--spacingHorizontalM);}", ".fw5db7e{padding-right:var(--spacingHorizontalM);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".f1rjii52{column-gap:var(--spacingHorizontalSNudge);}", ".f1r7g2jn{row-gap:var(--spacingHorizontalSNudge);}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".f1krrbdw{border-bottom-right-radius:0;}", ".f1deotkl{border-bottom-left-radius:0;}", ".f10ostut{border-top-right-radius:0;}", ".f1ozlkrg{border-top-left-radius:0;}", ".f1ern45e{border-top-style:none;}", ".f1n71otn{border-right-style:none;}", ".f1deefiw{border-left-style:none;}", ".f1n6gb5g::after{left:0;}", ".f15yvnhg::after{right:0;}", ".f1nf3wye::after{border-bottom-right-radius:0;}", ".feulmo5::after{border-bottom-left-radius:0;}", ".f18vqdqu::after{border-top-right-radius:0;}", ".f53nyzz::after{border-top-left-radius:0;}", ".fghlq4f{border-top-color:var(--colorTransparentStroke);}", ".f1gn591s{border-right-color:var(--colorTransparentStroke);}", ".fjscplz{border-left-color:var(--colorTransparentStroke);}", ".fb073pr{border-bottom-color:var(--colorTransparentStroke);}", ".fs4k3qj:not(:focus-within),.fs4k3qj:hover:not(:focus-within){border-top-color:var(--colorPaletteRedBorder2);}", ".fcee079:not(:focus-within),.fcee079:hover:not(:focus-within){border-right-color:var(--colorPaletteRedBorder2);}", ".fmyw78r:not(:focus-within),.fmyw78r:hover:not(:focus-within){border-left-color:var(--colorPaletteRedBorder2);}", ".f1fgmyf4:not(:focus-within),.f1fgmyf4:hover:not(:focus-within){border-bottom-color:var(--colorPaletteRedBorder2);}", ".f16xq7d1{background-color:var(--colorNeutralBackground3);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".fyed02w{box-shadow:var(--shadow2);}", ".fdrzuqr{cursor:not-allowed;}", ".f1jj8ep1{border-top-color:var(--colorNeutralStrokeDisabled);}", ".f15xbau{border-right-color:var(--colorNeutralStrokeDisabled);}", ".fy0fskl{border-left-color:var(--colorNeutralStrokeDisabled);}", ".f4ikngz{border-bottom-color:var(--colorNeutralStrokeDisabled);}", ".fhr9occ::after{content:unset;}"],
      h: [".fvcxoqz:hover{border-top-color:var(--colorNeutralStroke1Hover);}", ".f1ub3y4t:hover{border-right-color:var(--colorNeutralStroke1Hover);}", ".f1m52nbi:hover{border-left-color:var(--colorNeutralStroke1Hover);}", ".f1l4zc64:hover{border-bottom-color:var(--colorNeutralStrokeAccessibleHover);}", ".ftmjh5b:hover,.ftmjh5b:focus-within{border-top-color:var(--colorTransparentStrokeInteractive);}", ".f17blpuu:hover,.f17blpuu:focus-within{border-right-color:var(--colorTransparentStrokeInteractive);}", ".fsrcdbj:hover,.fsrcdbj:focus-within{border-left-color:var(--colorTransparentStrokeInteractive);}", ".f1tpwn32:hover,.f1tpwn32:focus-within{border-bottom-color:var(--colorTransparentStrokeInteractive);}"],
      a: [".f8vnjqi:active,.f8vnjqi:focus-within{border-top-color:var(--colorNeutralStroke1Pressed);}", ".fz1etlk:active,.fz1etlk:focus-within{border-right-color:var(--colorNeutralStroke1Pressed);}", ".f1hc16gm:active,.f1hc16gm:focus-within{border-left-color:var(--colorNeutralStroke1Pressed);}", ".f1klwx88:active,.f1klwx88:focus-within{border-bottom-color:var(--colorNeutralStrokeAccessiblePressed);}"],
      m: [["@media (forced-colors: active){.fg455y9{border-top-color:GrayText;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.f14g86mu{border-left-color:GrayText;}.f1rvyvqg{border-right-color:GrayText;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.f1cwzwz{border-bottom-color:GrayText;}}", {
        m: "(forced-colors: active)"
      }]],
      w: [".f99w1ws:focus-within{outline-style:none;}"]
    });
    const useInputClassName = /* @__PURE__ */ __resetStyles("rvp2gzh", null, [".rvp2gzh{box-sizing:border-box;flex-grow:1;min-width:0;border-style:none;padding:0 var(--spacingHorizontalXXS);color:var(--colorNeutralForeground1);background-color:transparent;outline-style:none;font-family:inherit;font-size:inherit;font-weight:inherit;line-height:inherit;}", ".rvp2gzh::-webkit-input-placeholder{color:var(--colorNeutralForeground4);opacity:1;}", ".rvp2gzh::-moz-placeholder{color:var(--colorNeutralForeground4);opacity:1;}", ".rvp2gzh:-ms-input-placeholder{color:var(--colorNeutralForeground4);opacity:1;}", ".rvp2gzh::placeholder{color:var(--colorNeutralForeground4);opacity:1;}"]);
    const useInputElementStyles = /* @__PURE__ */ __styles$3({
      large: {
        uwmqm3: ["fk8j09s", "fdw0yi8"],
        z189sj: ["fdw0yi8", "fk8j09s"]
      },
      disabled: {
        sj55zd: "f1s2aq7o",
        De3pzq: "f1c21dwh",
        Bceei9c: "fdrzuqr",
        yvdlaj: "fahhnxm"
      }
    }, {
      d: [".fk8j09s{padding-left:var(--spacingHorizontalSNudge);}", ".fdw0yi8{padding-right:var(--spacingHorizontalSNudge);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".fdrzuqr{cursor:not-allowed;}", ".fahhnxm::-webkit-input-placeholder{color:var(--colorNeutralForegroundDisabled);}", ".fahhnxm::-moz-placeholder{color:var(--colorNeutralForegroundDisabled);}"]
    });
    const useContentClassName = /* @__PURE__ */ __resetStyles("r1572tok", null, [".r1572tok{box-sizing:border-box;color:var(--colorNeutralForeground3);display:flex;}", ".r1572tok>svg{font-size:20px;}"]);
    const useContentStyles = /* @__PURE__ */ __styles$3({
      disabled: {
        sj55zd: "f1s2aq7o"
      },
      small: {
        kwki1k: "f3u2cy0"
      },
      medium: {},
      large: {
        kwki1k: "fa420co"
      }
    }, {
      d: [".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".f3u2cy0>svg{font-size:16px;}", ".fa420co>svg{font-size:24px;}"]
    });
    const useInputStyles_unstable = (state) => {
      const {
        size,
        appearance
      } = state;
      const disabled = state.input.disabled;
      const invalid = `${state.input["aria-invalid"]}` === "true";
      const filled = appearance.startsWith("filled");
      const rootStyles = useRootStyles$3();
      const inputStyles = useInputElementStyles();
      const contentStyles = useContentStyles();
      state.root.className = mergeClasses$2(inputClassNames.root, useRootClassName(), rootStyles[size], rootStyles[appearance], !disabled && appearance === "outline" && rootStyles.outlineInteractive, !disabled && appearance === "underline" && rootStyles.underlineInteractive, !disabled && filled && rootStyles.filledInteractive, filled && rootStyles.filled, !disabled && invalid && rootStyles.invalid, disabled && rootStyles.disabled, state.root.className);
      state.input.className = mergeClasses$2(inputClassNames.input, useInputClassName(), size === "large" && inputStyles.large, disabled && inputStyles.disabled, state.input.className);
      const contentClasses = [useContentClassName(), disabled && contentStyles.disabled, contentStyles[size]];
      if (state.contentBefore) {
        state.contentBefore.className = mergeClasses$2(inputClassNames.contentBefore, ...contentClasses, state.contentBefore.className);
      }
      if (state.contentAfter) {
        state.contentAfter.className = mergeClasses$2(inputClassNames.contentAfter, ...contentClasses, state.contentAfter.className);
      }
      return state;
    };
    const Input = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const state = useInput_unstable(props, ref);
      useInputStyles_unstable(state);
      useCustomStyleHook("useInputStyles_unstable")(state);
      return renderInput_unstable(state);
    });
    Input.displayName = "Input";
    const renderImage_unstable = (state) => {
      return /* @__PURE__ */ jsx(state.root, {});
    };
    const useImage_unstable = (props, ref) => {
      const { bordered = false, fit = "default", block = false, shape = "square", shadow = false } = props;
      const state = {
        bordered,
        fit,
        block,
        shape,
        shadow,
        components: {
          root: "img"
        },
        root: always(getIntrinsicElementProps("img", {
          ref,
          ...props
        }), {
          elementType: "img"
        })
      };
      return state;
    };
    const imageClassNames = {
      root: "fui-Image"
    };
    const useStyles$b = /* @__PURE__ */ __styles$3({
      base: {
        g2u3we: "fj3muxo",
        h3c5rm: ["f1akhkt", "f1lxtadh"],
        B9xav0g: "f1aperda",
        zhjwy3: ["f1lxtadh", "f1akhkt"],
        Bbmb7ep: ["fzi6hpg", "fyowgf4"],
        Beyfa6y: ["fyowgf4", "fzi6hpg"],
        B7oj6ja: ["f3fg2lr", "f13av6d4"],
        Btl43ni: ["f13av6d4", "f3fg2lr"],
        B7ck84d: "f1ewtqcl",
        mc9l5x: "f14t3ns0"
      },
      bordered: {
        icvyot: "fzkkow9",
        vrafjx: ["fcdblym", "fjik90z"],
        oivjwe: "fg706s2",
        wvpqe5: ["fjik90z", "fcdblym"],
        B4j52fo: "f192inf7",
        Bekrc4i: ["f5tn483", "f1ojsxk5"],
        Bn0qgzm: "f1vxd6vx",
        ibv6hh: ["f1ojsxk5", "f5tn483"]
      },
      circular: {
        Bbmb7ep: ["f8fbkgy", "f1nfllo7"],
        Beyfa6y: ["f1nfllo7", "f8fbkgy"],
        B7oj6ja: ["f1djnp8u", "f1s8kh49"],
        Btl43ni: ["f1s8kh49", "f1djnp8u"]
      },
      rounded: {
        Bbmb7ep: ["f1aa9q02", "f16jpd5f"],
        Beyfa6y: ["f16jpd5f", "f1aa9q02"],
        B7oj6ja: ["f1jar5jt", "fyu767a"],
        Btl43ni: ["fyu767a", "f1jar5jt"]
      },
      square: {},
      shadow: {
        E5pizo: "f1whvlc6"
      },
      center: {
        st4lth: "f1plgu50",
        Ermj5k: "f14xojzb",
        Bqenvij: "f1l02sjl",
        a9b677: "fly5x3f"
      },
      contain: {
        st4lth: "f1kle4es",
        Ermj5k: "f14xojzb",
        Bqenvij: "f1l02sjl",
        a9b677: "fly5x3f"
      },
      "default": {},
      cover: {
        st4lth: "f1ps3kmd",
        Ermj5k: "f14xojzb",
        Bqenvij: "f1l02sjl",
        a9b677: "fly5x3f"
      },
      none: {
        st4lth: "f1plgu50",
        Ermj5k: ["f13uwng7", "fjmyj0p"],
        Bqenvij: "f1l02sjl",
        a9b677: "fly5x3f"
      },
      block: {
        a9b677: "fly5x3f"
      }
    }, {
      d: [".fj3muxo{border-top-color:var(--colorNeutralStroke1);}", ".f1akhkt{border-right-color:var(--colorNeutralStroke1);}", ".f1lxtadh{border-left-color:var(--colorNeutralStroke1);}", ".f1aperda{border-bottom-color:var(--colorNeutralStroke1);}", ".fzi6hpg{border-bottom-right-radius:var(--borderRadiusNone);}", ".fyowgf4{border-bottom-left-radius:var(--borderRadiusNone);}", ".f3fg2lr{border-top-right-radius:var(--borderRadiusNone);}", ".f13av6d4{border-top-left-radius:var(--borderRadiusNone);}", ".f1ewtqcl{box-sizing:border-box;}", ".f14t3ns0{display:inline-block;}", ".fzkkow9{border-top-style:solid;}", ".fcdblym{border-right-style:solid;}", ".fjik90z{border-left-style:solid;}", ".fg706s2{border-bottom-style:solid;}", ".f192inf7{border-top-width:var(--strokeWidthThin);}", ".f5tn483{border-right-width:var(--strokeWidthThin);}", ".f1ojsxk5{border-left-width:var(--strokeWidthThin);}", ".f1vxd6vx{border-bottom-width:var(--strokeWidthThin);}", ".f8fbkgy{border-bottom-right-radius:var(--borderRadiusCircular);}", ".f1nfllo7{border-bottom-left-radius:var(--borderRadiusCircular);}", ".f1djnp8u{border-top-right-radius:var(--borderRadiusCircular);}", ".f1s8kh49{border-top-left-radius:var(--borderRadiusCircular);}", ".f1aa9q02{border-bottom-right-radius:var(--borderRadiusMedium);}", ".f16jpd5f{border-bottom-left-radius:var(--borderRadiusMedium);}", ".f1jar5jt{border-top-right-radius:var(--borderRadiusMedium);}", ".fyu767a{border-top-left-radius:var(--borderRadiusMedium);}", ".f1whvlc6{box-shadow:var(--shadow4);}", ".f1plgu50{object-fit:none;}", ".f14xojzb{object-position:center;}", ".f1l02sjl{height:100%;}", ".fly5x3f{width:100%;}", ".f1kle4es{object-fit:contain;}", ".f1ps3kmd{object-fit:cover;}", ".f13uwng7{object-position:left top;}", ".fjmyj0p{object-position:right top;}"]
    });
    const useImageStyles_unstable = (state) => {
      const styles2 = useStyles$b();
      state.root.className = mergeClasses$2(imageClassNames.root, styles2.base, state.block && styles2.block, state.bordered && styles2.bordered, state.shadow && styles2.shadow, styles2[state.fit], styles2[state.shape], state.root.className);
    };
    const Image = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const state = useImage_unstable(props, ref);
      useImageStyles_unstable(state);
      useCustomStyleHook("useImageStyles_unstable")(state);
      return renderImage_unstable(state);
    });
    Image.displayName = "Image";
    const useLinkState_unstable = (state) => {
      const { disabled, disabledFocusable } = state;
      const { onClick, onKeyDown, role, tabIndex } = state.root;
      if (state.root.as === "a") {
        state.root.href = disabled ? void 0 : state.root.href;
        if (disabled || disabledFocusable) {
          state.root.role = role || "link";
        }
      }
      if (state.root.as === "a" || state.root.as === "span") {
        state.root.tabIndex = tabIndex !== null && tabIndex !== void 0 ? tabIndex : disabled && !disabledFocusable ? void 0 : 0;
      }
      state.root.onClick = (ev) => {
        if (disabled || disabledFocusable) {
          ev.preventDefault();
        } else {
          onClick === null || onClick === void 0 ? void 0 : onClick(ev);
        }
      };
      state.root.onKeyDown = (ev) => {
        if ((disabled || disabledFocusable) && (ev.key === Enter || ev.key === Space)) {
          ev.preventDefault();
          ev.stopPropagation();
        } else {
          onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown(ev);
        }
      };
      state.disabled = disabled || disabledFocusable;
      state.root["aria-disabled"] = disabled || disabledFocusable || void 0;
      if (state.root.as === "button") {
        state.root.disabled = disabled && !disabledFocusable;
      }
      return state;
    };
    const useLink_unstable = (props, ref) => {
      const backgroundAppearance = useBackgroundAppearance();
      const { appearance = "default", disabled = false, disabledFocusable = false, inline = false } = props;
      const elementType = props.as || (props.href ? "a" : "button");
      const propsWithAssignedAs = {
        role: elementType === "span" ? "button" : void 0,
        type: elementType === "button" ? "button" : void 0,
        ...props,
        as: elementType
      };
      const state = {
        // Props passed at the top-level
        appearance,
        disabled,
        disabledFocusable,
        inline,
        // Slots definition
        components: {
          root: elementType
        },
        root: always(getIntrinsicElementProps(elementType, {
          ref,
          ...propsWithAssignedAs
        }), {
          elementType
        }),
        backgroundAppearance
      };
      useLinkState_unstable(state);
      return state;
    };
    const linkClassNames = {
      root: "fui-Link"
    };
    const useStyles$a = /* @__PURE__ */ __styles$3({
      focusIndicator: {
        Bttzg6e: "fhgqx19",
        B3uz8dt: "f1olyrje",
        B6ihwck: "f1p93eir",
        g9k6zt: "f1nev41a"
      },
      root: {
        B486eqv: "f2hkw1w",
        De3pzq: "f3rmtva",
        B7ck84d: "f1ewtqcl",
        sj55zd: "fyind8e",
        Bceei9c: "f1k6fduh",
        mc9l5x: "f1w7gpdv",
        Bahqtrf: "fk6fouc",
        Be2twd7: "fkhj508",
        Bhrd7zp: "figsok6",
        B6of3ja: "f1hu3pq6",
        t21cq0: ["f11qmguv", "f1tyq0we"],
        jrapky: "f19f4twv",
        Frg6f3: ["f1tyq0we", "f11qmguv"],
        z8tnut: "f1g0x7ka",
        z189sj: ["fhxju0i", "f1cnd47f"],
        Byoj8tv: "f1qch9an",
        uwmqm3: ["f1cnd47f", "fhxju0i"],
        B68tc82: "fqv5qza",
        Bmxbyg5: "f1vmzxwi",
        fsow6f: ["f1o700av", "fes3tcz"],
        w71qe1: "f1iuv45f",
        Bkioxbp: "f1cmlufx",
        ygn44y: "f9n3di6",
        famaaq: "f1ids18y",
        Bde5pd6: "f1tx3yz7",
        Bi91k9c: "f1deo86v",
        i089h6: "f1eh06m1",
        lj723h: "f1iescvh"
      },
      button: {
        icvyot: "f1ern45e",
        vrafjx: ["f1n71otn", "f1deefiw"],
        oivjwe: "f1h8hb77",
        wvpqe5: ["f1deefiw", "f1n71otn"]
      },
      href: {
        Be2twd7: "fjoy568"
      },
      subtle: {
        sj55zd: "fkfq4zb",
        Bde5pd6: "f1tx3yz7",
        Bi91k9c: "fnwyq0v",
        i089h6: "f1eh06m1",
        lj723h: "flvvhsy"
      },
      inline: {
        w71qe1: "f13mvf36"
      },
      disabled: {
        w71qe1: "f1iuv45f",
        sj55zd: "f1s2aq7o",
        Bceei9c: "fdrzuqr",
        Bde5pd6: "fbnuktb",
        Bi91k9c: "fvgxktp",
        i089h6: "fljg2da",
        lj723h: "f19wldhg"
      },
      inverted: {
        sj55zd: "f1qz2gb0",
        Bi91k9c: "f1mlt8il",
        lj723h: "f1hsd4st"
      }
    }, {
      d: [".fhgqx19[data-fui-focus-visible]{text-decoration-color:var(--colorStrokeFocus2);}", ".f1olyrje[data-fui-focus-visible]{text-decoration-line:underline;}", ".f1p93eir[data-fui-focus-visible]{text-decoration-style:double;}", ".f1nev41a[data-fui-focus-visible]{outline-style:none;}", ".f3rmtva{background-color:transparent;}", ".f1ewtqcl{box-sizing:border-box;}", ".fyind8e{color:var(--colorBrandForegroundLink);}", ".f1k6fduh{cursor:pointer;}", ".f1w7gpdv{display:inline;}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1hu3pq6{margin-top:0;}", ".f11qmguv{margin-right:0;}", ".f1tyq0we{margin-left:0;}", ".f19f4twv{margin-bottom:0;}", ".f1g0x7ka{padding-top:0;}", ".fhxju0i{padding-right:0;}", ".f1cnd47f{padding-left:0;}", ".f1qch9an{padding-bottom:0;}", ".fqv5qza{overflow-x:inherit;}", ".f1vmzxwi{overflow-y:inherit;}", ".f1o700av{text-align:left;}", ".fes3tcz{text-align:right;}", ".f1iuv45f{text-decoration-line:none;}", ".f1cmlufx{text-decoration-thickness:var(--strokeWidthThin);}", ".f9n3di6{text-overflow:inherit;}", ".f1ids18y{-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;user-select:text;}", ".f1ern45e{border-top-style:none;}", ".f1n71otn{border-right-style:none;}", ".f1deefiw{border-left-style:none;}", ".f1h8hb77{border-bottom-style:none;}", ".fjoy568{font-size:inherit;}", ".fkfq4zb{color:var(--colorNeutralForeground2);}", ".f13mvf36{text-decoration-line:underline;}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}", ".fdrzuqr{cursor:not-allowed;}", ".f1qz2gb0{color:var(--colorBrandForegroundInverted);}"],
      i: [".f2hkw1w:focus-visible{outline-style:none;}"],
      h: [".f1tx3yz7:hover{text-decoration-line:underline;}", ".f1deo86v:hover{color:var(--colorBrandForegroundLinkHover);}", ".fnwyq0v:hover{color:var(--colorNeutralForeground2Hover);}", ".fbnuktb:hover{text-decoration-line:none;}", ".fvgxktp:hover{color:var(--colorNeutralForegroundDisabled);}", ".f1mlt8il:hover{color:var(--colorBrandForegroundInvertedHover);}"],
      a: [".f1eh06m1:active{text-decoration-line:underline;}", ".f1iescvh:active{color:var(--colorBrandForegroundLinkPressed);}", ".flvvhsy:active{color:var(--colorNeutralForeground2Pressed);}", ".fljg2da:active{text-decoration-line:none;}", ".f19wldhg:active{color:var(--colorNeutralForegroundDisabled);}", ".f1hsd4st:active{color:var(--colorBrandForegroundInvertedPressed);}"]
    });
    const useLinkStyles_unstable = (state) => {
      const styles2 = useStyles$a();
      const {
        appearance,
        disabled,
        inline,
        root: root2,
        backgroundAppearance
      } = state;
      state.root.className = mergeClasses$2(linkClassNames.root, styles2.root, styles2.focusIndicator, root2.as === "a" && root2.href && styles2.href, root2.as === "button" && styles2.button, appearance === "subtle" && styles2.subtle, backgroundAppearance === "inverted" && styles2.inverted, inline && styles2.inline, disabled && styles2.disabled, state.root.className);
      return state;
    };
    const renderLink_unstable = (state) => {
      return /* @__PURE__ */ jsx(state.root, {});
    };
    const Link = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const state = useLink_unstable(props, ref);
      useLinkStyles_unstable(state);
      return renderLink_unstable(state);
    });
    Link.displayName = "Link";
    const MenuContext = createContext(void 0);
    const menuContextDefaultValue = {
      open: false,
      setOpen: () => false,
      checkedValues: {},
      onCheckedValueChange: () => null,
      isSubmenu: false,
      triggerRef: {
        current: null
      },
      menuPopoverRef: {
        current: null
      },
      mountNode: null,
      triggerId: "",
      openOnContext: false,
      openOnHover: false,
      hasIcons: false,
      hasCheckmarks: false,
      inline: false,
      persistOnItemClick: false
    };
    const MenuProvider = MenuContext.Provider;
    const useMenuContext_unstable = (selector) => useContextSelector(MenuContext, (ctx = menuContextDefaultValue) => selector(ctx));
    const MenuTriggerContext = reactExports.createContext(void 0);
    const menuTriggerContextDefaultValue = false;
    const MenuTriggerContextProvider = MenuTriggerContext.Provider;
    const useMenuTriggerContext_unstable = () => {
      var _React_useContext;
      return (_React_useContext = reactExports.useContext(MenuTriggerContext)) !== null && _React_useContext !== void 0 ? _React_useContext : menuTriggerContextDefaultValue;
    };
    const MenuListContext = createContext(void 0);
    const menuListContextDefaultValue = {
      checkedValues: {},
      setFocusByFirstCharacter: () => null,
      toggleCheckbox: () => null,
      selectRadio: () => null,
      hasIcons: false,
      hasCheckmarks: false
    };
    const MenuListProvider = MenuListContext.Provider;
    const useMenuListContext_unstable = (selector) => useContextSelector(MenuListContext, (ctx = menuListContextDefaultValue) => selector(ctx));
    const MENU_ENTER_EVENT = "fuimenuenter";
    const useOnMenuMouseEnter = (options) => {
      const { refs, callback, element: element2, disabled } = options;
      const listener = useEventCallback$1((ev) => {
        const popoverRef = refs[0];
        const someMenuPopover = ev.target;
        var _popoverRef_current;
        const isOutsidePopover = !elementContains((_popoverRef_current = popoverRef.current) !== null && _popoverRef_current !== void 0 ? _popoverRef_current : null, someMenuPopover);
        if (isOutsidePopover && !disabled) {
          callback(ev);
        }
      });
      reactExports.useEffect(() => {
        if (element2 == null) {
          return;
        }
        if (!disabled) {
          element2.addEventListener(MENU_ENTER_EVENT, listener);
        }
        return () => {
          element2.removeEventListener(MENU_ENTER_EVENT, listener);
        };
      }, [
        listener,
        element2,
        disabled
      ]);
    };
    const dispatchMenuEnterEvent = (el, nativeEvent) => {
      el.dispatchEvent(new CustomEvent(MENU_ENTER_EVENT, {
        bubbles: true,
        detail: {
          nativeEvent
        }
      }));
    };
    function useIsSubmenu() {
      const menuContextValue = useMenuContext_unstable((context) => context.isSubmenu);
      const hasMenuListContext = useHasParentContext(MenuListContext);
      return menuContextValue || hasMenuListContext;
    }
    const submenuFallbackPositions = [
      "after",
      "after-bottom",
      "before-top",
      "before",
      "before-bottom",
      "above"
    ];
    const useMenu_unstable = (props) => {
      const isSubmenu = useIsSubmenu();
      const { hoverDelay = 500, inline = false, hasCheckmarks = false, hasIcons = false, closeOnScroll = false, openOnContext = false, persistOnItemClick = false, openOnHover = isSubmenu, defaultCheckedValues, mountNode = null } = props;
      const triggerId = useId("menu");
      const [contextTarget, setContextTarget] = usePositioningMouseTarget();
      const positioningState = {
        position: isSubmenu ? "after" : "below",
        align: isSubmenu ? "top" : "start",
        target: props.openOnContext ? contextTarget : void 0,
        fallbackPositions: isSubmenu ? submenuFallbackPositions : void 0,
        ...resolvePositioningShorthand(props.positioning)
      };
      const children = reactExports.Children.toArray(props.children);
      let menuTrigger = void 0;
      let menuPopover = void 0;
      if (children.length === 2) {
        menuTrigger = children[0];
        menuPopover = children[1];
      } else if (children.length === 1) {
        menuPopover = children[0];
      }
      const { targetRef: triggerRef, containerRef: menuPopoverRef } = usePositioning(positioningState);
      const [open, setOpen] = useMenuOpenState({
        hoverDelay,
        isSubmenu,
        setContextTarget,
        closeOnScroll,
        menuPopoverRef,
        triggerRef,
        open: props.open,
        defaultOpen: props.defaultOpen,
        onOpenChange: props.onOpenChange,
        openOnContext
      });
      const [checkedValues, onCheckedValueChange] = useMenuSelectableState({
        checkedValues: props.checkedValues,
        defaultCheckedValues,
        onCheckedValueChange: props.onCheckedValueChange
      });
      return {
        inline,
        hoverDelay,
        triggerId,
        isSubmenu,
        openOnHover,
        contextTarget,
        setContextTarget,
        hasCheckmarks,
        hasIcons,
        closeOnScroll,
        menuTrigger,
        menuPopover,
        mountNode,
        triggerRef,
        menuPopoverRef,
        components: {},
        openOnContext,
        open,
        setOpen,
        checkedValues,
        onCheckedValueChange,
        persistOnItemClick
      };
    };
    const useMenuSelectableState = (props) => {
      const [checkedValues, setCheckedValues] = useControllableState({
        state: props.checkedValues,
        defaultState: props.defaultCheckedValues,
        initialState: {}
      });
      const onCheckedValueChange = useEventCallback$1((e2, { name: name2, checkedItems }) => {
        var _props_onCheckedValueChange;
        (_props_onCheckedValueChange = props.onCheckedValueChange) === null || _props_onCheckedValueChange === void 0 ? void 0 : _props_onCheckedValueChange.call(props, e2, {
          name: name2,
          checkedItems
        });
        setCheckedValues((currentValue) => ({
          ...currentValue,
          [name2]: checkedItems
        }));
      });
      return [
        checkedValues,
        onCheckedValueChange
      ];
    };
    const useMenuOpenState = (state) => {
      const { targetDocument } = useFluent();
      const parentSetOpen = useMenuContext_unstable((context) => context.setOpen);
      const onOpenChange = useEventCallback$1((e2, data) => {
        var _state_onOpenChange;
        return (_state_onOpenChange = state.onOpenChange) === null || _state_onOpenChange === void 0 ? void 0 : _state_onOpenChange.call(state, e2, data);
      });
      const setOpenTimeout = reactExports.useRef(0);
      const enteringTriggerRef = reactExports.useRef(false);
      const [open, setOpenState] = useControllableState({
        state: state.open,
        defaultState: state.defaultOpen,
        initialState: false
      });
      const trySetOpen = useEventCallback$1((e2, data) => {
        const event = e2 instanceof CustomEvent && e2.type === MENU_ENTER_EVENT ? e2.detail.nativeEvent : e2;
        onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(event, {
          ...data
        });
        if (data.open && e2.type === "contextmenu") {
          state.setContextTarget(e2);
        }
        if (!data.open) {
          state.setContextTarget(void 0);
        }
        if (data.bubble) {
          parentSetOpen(e2, {
            ...data
          });
        }
        setOpenState(data.open);
      });
      const setOpen = useEventCallback$1((e2, data) => {
        clearTimeout(setOpenTimeout.current);
        if (!(e2 instanceof Event) && e2.persist) {
          e2.persist();
        }
        if (e2.type === "mouseleave" || e2.type === "mouseenter" || e2.type === "mousemove" || e2.type === MENU_ENTER_EVENT) {
          var _state_triggerRef_current;
          if ((_state_triggerRef_current = state.triggerRef.current) === null || _state_triggerRef_current === void 0 ? void 0 : _state_triggerRef_current.contains(e2.target)) {
            enteringTriggerRef.current = e2.type === "mouseenter" || e2.type === "mousemove";
          }
          setOpenTimeout.current = setTimeout(() => trySetOpen(e2, data), state.hoverDelay);
        } else {
          trySetOpen(e2, data);
        }
      });
      useOnClickOutside({
        contains: elementContains,
        disabled: !open,
        element: targetDocument,
        refs: [
          state.menuPopoverRef,
          !state.openOnContext && state.triggerRef
        ].filter(Boolean),
        callback: (event) => setOpen(event, {
          open: false,
          type: "clickOutside",
          event
        })
      });
      const closeOnScroll = state.openOnContext || state.closeOnScroll;
      useOnScrollOutside({
        contains: elementContains,
        element: targetDocument,
        callback: (event) => setOpen(event, {
          open: false,
          type: "scrollOutside",
          event
        }),
        refs: [
          state.menuPopoverRef,
          !state.openOnContext && state.triggerRef
        ].filter(Boolean),
        disabled: !open || !closeOnScroll
      });
      useOnMenuMouseEnter({
        element: targetDocument,
        callback: (event) => {
          if (!enteringTriggerRef.current) {
            setOpen(event, {
              open: false,
              type: "menuMouseEnter",
              event
            });
          }
        },
        disabled: !open,
        refs: [
          state.menuPopoverRef
        ]
      });
      reactExports.useEffect(() => {
        return () => {
          clearTimeout(setOpenTimeout.current);
        };
      }, []);
      const { findFirstFocusable } = useFocusFinders();
      const focusFirst = reactExports.useCallback(() => {
        const firstFocusable = findFirstFocusable(state.menuPopoverRef.current);
        firstFocusable === null || firstFocusable === void 0 ? void 0 : firstFocusable.focus();
      }, [
        findFirstFocusable,
        state.menuPopoverRef
      ]);
      reactExports.useEffect(() => {
        if (open) {
          focusFirst();
        }
      }, [
        open,
        focusFirst
      ]);
      return [
        open,
        setOpen
      ];
    };
    function useMenuContextValues_unstable(state) {
      const { checkedValues, hasCheckmarks, hasIcons, inline, isSubmenu, menuPopoverRef, mountNode, onCheckedValueChange, open, openOnContext, openOnHover, persistOnItemClick, setOpen, triggerId, triggerRef } = state;
      const menu = {
        checkedValues,
        hasCheckmarks,
        hasIcons,
        inline,
        isSubmenu,
        menuPopoverRef,
        mountNode,
        onCheckedValueChange,
        open,
        openOnContext,
        openOnHover,
        persistOnItemClick,
        setOpen,
        triggerId,
        triggerRef
      };
      return {
        menu
      };
    }
    const renderMenu_unstable = (state, contextValues) => {
      return /* @__PURE__ */ reactExports.createElement(MenuProvider, {
        value: contextValues.menu
      }, state.menuTrigger, state.open && state.menuPopover);
    };
    const Menu = (props) => {
      const state = useMenu_unstable(props);
      const contextValues = useMenuContextValues_unstable(state);
      return renderMenu_unstable(state, contextValues);
    };
    Menu.displayName = "Menu";
    const useCharacterSearch = (state, ref) => {
      const setFocusByFirstCharacter = useMenuListContext_unstable((context) => context.setFocusByFirstCharacter);
      const { onKeyDown: originalOnKeyDown } = state.root;
      state.root.onKeyDown = (e2) => {
        var _e_key;
        originalOnKeyDown === null || originalOnKeyDown === void 0 ? void 0 : originalOnKeyDown(e2);
        if (((_e_key = e2.key) === null || _e_key === void 0 ? void 0 : _e_key.length) > 1) {
          return;
        }
        if (ref.current) {
          setFocusByFirstCharacter === null || setFocusByFirstCharacter === void 0 ? void 0 : setFocusByFirstCharacter(e2, ref.current);
        }
      };
      return state;
    };
    const ChevronRightIcon = bundleIcon$1(ChevronRightFilled, ChevronRightRegular);
    const ChevronLeftIcon = bundleIcon$1(ChevronLeftFilled, ChevronLeftRegular);
    const useMenuItem_unstable = (props, ref) => {
      const isSubmenuTrigger = useMenuTriggerContext_unstable();
      const persistOnClickContext = useMenuContext_unstable((context) => context.persistOnItemClick);
      const { as: as2 = "div", disabled = false, hasSubmenu: hasSubmenu2 = isSubmenuTrigger, persistOnClick = persistOnClickContext } = props;
      const hasIcons = useMenuListContext_unstable((context) => context.hasIcons);
      const hasCheckmarks = useMenuListContext_unstable((context) => context.hasCheckmarks);
      const setOpen = useMenuContext_unstable((context) => context.setOpen);
      const { dir } = useFluent();
      const innerRef = reactExports.useRef(null);
      const dismissedWithKeyboardRef = reactExports.useRef(false);
      const state = {
        hasSubmenu: hasSubmenu2,
        disabled,
        persistOnClick,
        components: {
          root: "div",
          icon: "span",
          checkmark: "span",
          submenuIndicator: "span",
          content: "span",
          secondaryContent: "span"
        },
        root: always(getIntrinsicElementProps(as2, useARIAButtonProps(as2, {
          role: "menuitem",
          ...props,
          disabled: false,
          disabledFocusable: disabled,
          ref: useMergedRefs(ref, innerRef),
          onKeyDown: useEventCallback$1((event) => {
            var _props_onKeyDown;
            (_props_onKeyDown = props.onKeyDown) === null || _props_onKeyDown === void 0 ? void 0 : _props_onKeyDown.call(props, event);
            if (!event.isDefaultPrevented() && (event.key === Space || event.key === Enter)) {
              dismissedWithKeyboardRef.current = true;
            }
          }),
          onMouseEnter: useEventCallback$1((event) => {
            var _innerRef_current, _props_onMouseEnter;
            (_innerRef_current = innerRef.current) === null || _innerRef_current === void 0 ? void 0 : _innerRef_current.focus();
            (_props_onMouseEnter = props.onMouseEnter) === null || _props_onMouseEnter === void 0 ? void 0 : _props_onMouseEnter.call(props, event);
          }),
          onClick: useEventCallback$1((event) => {
            var _props_onClick;
            if (!hasSubmenu2 && !persistOnClick) {
              setOpen(event, {
                open: false,
                keyboard: dismissedWithKeyboardRef.current,
                bubble: true,
                type: "menuItemClick",
                event
              });
              dismissedWithKeyboardRef.current = false;
            }
            (_props_onClick = props.onClick) === null || _props_onClick === void 0 ? void 0 : _props_onClick.call(props, event);
          })
        })), {
          elementType: "div"
        }),
        icon: optional(props.icon, {
          renderByDefault: hasIcons,
          elementType: "span"
        }),
        checkmark: optional(props.checkmark, {
          renderByDefault: hasCheckmarks,
          elementType: "span"
        }),
        submenuIndicator: optional(props.submenuIndicator, {
          renderByDefault: hasSubmenu2,
          defaultProps: {
            children: dir === "ltr" ? /* @__PURE__ */ reactExports.createElement(ChevronRightIcon, null) : /* @__PURE__ */ reactExports.createElement(ChevronLeftIcon, null)
          },
          elementType: "span"
        }),
        content: optional(props.content, {
          renderByDefault: !!props.children,
          defaultProps: {
            children: props.children
          },
          elementType: "span"
        }),
        secondaryContent: optional(props.secondaryContent, {
          elementType: "span"
        })
      };
      useCharacterSearch(state, innerRef);
      return state;
    };
    const renderMenuItem_unstable = (state) => {
      return /* @__PURE__ */ jsxs(state.root, {
        children: [
          state.checkmark && /* @__PURE__ */ jsx(state.checkmark, {}),
          state.icon && /* @__PURE__ */ jsx(state.icon, {}),
          state.content && /* @__PURE__ */ jsx(state.content, {}),
          state.secondaryContent && /* @__PURE__ */ jsx(state.secondaryContent, {}),
          state.submenuIndicator && /* @__PURE__ */ jsx(state.submenuIndicator, {})
        ]
      });
    };
    const useStyles$9 = /* @__PURE__ */ __styles$3({
      root: {
        a9b677: "fjw5fx7",
        Bqenvij: "fd461yt",
        Bcdw1i0: "fd7fpy0"
      },
      rootChecked: {
        Bcdw1i0: "f1022m68"
      }
    }, {
      d: [".fjw5fx7{width:16px;}", ".fd461yt{height:16px;}", ".fd7fpy0{visibility:hidden;}", ".f1022m68{visibility:visible;}"]
    });
    const useCheckmarkStyles_unstable = (state) => {
      const styles2 = useStyles$9();
      if (state.checkmark) {
        state.checkmark.className = mergeClasses$2(styles2.root, state.checked && styles2.rootChecked, state.checkmark.className);
      }
    };
    const menuItemClassNames = {
      root: "fui-MenuItem",
      icon: "fui-MenuItem__icon",
      checkmark: "fui-MenuItem__checkmark",
      submenuIndicator: "fui-MenuItem__submenuIndicator",
      content: "fui-MenuItem__content",
      secondaryContent: "fui-MenuItem__secondaryContent"
    };
    const useRootBaseStyles = /* @__PURE__ */ __resetStyles("rbu42t4", "r3agqyg", [".rbu42t4{border-radius:var(--borderRadiusMedium);position:relative;color:var(--colorNeutralForeground2);background-color:var(--colorNeutralBackground1);padding-right:var(--spacingVerticalSNudge);padding-left:var(--spacingVerticalSNudge);padding-top:var(--spacingVerticalSNudge);box-sizing:border-box;max-width:290px;min-height:32px;flex-shrink:0;display:flex;align-items:start;font-size:var(--fontSizeBase300);cursor:pointer;gap:4px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;}", ".rbu42t4:hover{background-color:var(--colorNeutralBackground1Hover);color:var(--colorNeutralForeground2Hover);}", ".rbu42t4:hover .fui-Icon-filled{display:inline;}", ".rbu42t4:hover .fui-Icon-regular{display:none;}", ".rbu42t4:hover .fui-MenuItem__icon{color:var(--colorNeutralForeground2BrandSelected);}", ".rbu42t4:hover:active{background-color:var(--colorNeutralBackground1Pressed);color:var(--colorNeutralForeground2Pressed);}", ".rbu42t4:focus{outline-style:none;}", ".rbu42t4:focus-visible{outline-style:none;}", ".rbu42t4[data-fui-focus-visible]{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}", '.rbu42t4[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border-top-style:solid;border-right-style:solid;border-bottom-style:solid;border-left-style:solid;border-top-width:2px;border-right-width:2px;border-bottom-width:2px;border-left-width:2px;border-bottom-right-radius:var(--borderRadiusMedium);border-bottom-left-radius:var(--borderRadiusMedium);border-top-right-radius:var(--borderRadiusMedium);border-top-left-radius:var(--borderRadiusMedium);border-top-color:var(--colorStrokeFocus2);border-right-color:var(--colorStrokeFocus2);border-bottom-color:var(--colorStrokeFocus2);border-left-color:var(--colorStrokeFocus2);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}', ".r3agqyg{border-radius:var(--borderRadiusMedium);position:relative;color:var(--colorNeutralForeground2);background-color:var(--colorNeutralBackground1);padding-left:var(--spacingVerticalSNudge);padding-right:var(--spacingVerticalSNudge);padding-top:var(--spacingVerticalSNudge);box-sizing:border-box;max-width:290px;min-height:32px;flex-shrink:0;display:flex;align-items:start;font-size:var(--fontSizeBase300);cursor:pointer;gap:4px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;}", ".r3agqyg:hover{background-color:var(--colorNeutralBackground1Hover);color:var(--colorNeutralForeground2Hover);}", ".r3agqyg:hover .fui-Icon-filled{display:inline;}", ".r3agqyg:hover .fui-Icon-regular{display:none;}", ".r3agqyg:hover .fui-MenuItem__icon{color:var(--colorNeutralForeground2BrandSelected);}", ".r3agqyg:hover:active{background-color:var(--colorNeutralBackground1Pressed);color:var(--colorNeutralForeground2Pressed);}", ".r3agqyg:focus{outline-style:none;}", ".r3agqyg:focus-visible{outline-style:none;}", ".r3agqyg[data-fui-focus-visible]{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}", '.r3agqyg[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border-top-style:solid;border-left-style:solid;border-bottom-style:solid;border-right-style:solid;border-top-width:2px;border-left-width:2px;border-bottom-width:2px;border-right-width:2px;border-bottom-left-radius:var(--borderRadiusMedium);border-bottom-right-radius:var(--borderRadiusMedium);border-top-left-radius:var(--borderRadiusMedium);border-top-right-radius:var(--borderRadiusMedium);border-top-color:var(--colorStrokeFocus2);border-left-color:var(--colorStrokeFocus2);border-bottom-color:var(--colorStrokeFocus2);border-right-color:var(--colorStrokeFocus2);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}']);
    const useContentBaseStyles = /* @__PURE__ */ __resetStyles("r1ls86vo", "rpbc5dr", [".r1ls86vo{padding-left:2px;padding-right:2px;background-color:transparent;flex-grow:1;}", ".rpbc5dr{padding-right:2px;padding-left:2px;background-color:transparent;flex-grow:1;}"]);
    const useSecondaryContentBaseStyles = /* @__PURE__ */ __resetStyles("r79npjw", "r1j24c7y", [".r79npjw{padding-left:2px;padding-right:2px;color:var(--colorNeutralForeground3);}", ".r79npjw:hover{color:var(--colorNeutralForeground3Hover);}", ".r79npjw:focus{color:var(--colorNeutralForeground3Hover);}", ".r1j24c7y{padding-right:2px;padding-left:2px;color:var(--colorNeutralForeground3);}", ".r1j24c7y:hover{color:var(--colorNeutralForeground3Hover);}", ".r1j24c7y:focus{color:var(--colorNeutralForeground3Hover);}"]);
    const useIconBaseStyles = /* @__PURE__ */ __resetStyles("r9c34qo", null, [".r9c34qo{width:20px;height:20px;font-size:20px;line-height:0;align-items:center;display:inline-flex;justify-content:center;}"]);
    const useSubmenuIndicatorBaseStyles = /* @__PURE__ */ __resetStyles("r9c34qo", null, [".r9c34qo{width:20px;height:20px;font-size:20px;line-height:0;align-items:center;display:inline-flex;justify-content:center;}"]);
    const useStyles$8 = /* @__PURE__ */ __styles$3({
      checkmark: {
        B6of3ja: "fmnzpld"
      },
      splitItemMain: {
        Bh6795r: "fqerorx"
      },
      splitItemTrigger: {
        Btl43ni: ["f1ozlkrg", "f10ostut"],
        Beyfa6y: ["f1deotkl", "f1krrbdw"],
        uwmqm3: ["f1cnd47f", "fhxju0i"],
        Ftih45: "f1wl9k8s",
        Ccq8qp: "f1yn80uh",
        Baz25je: "f68mna0",
        cmx5o7: "f1p5zmk"
      },
      disabled: {
        sj55zd: "f1s2aq7o",
        Bi91k9c: "fvgxktp",
        Jwef8y: "f1ijtazh",
        eoavqd: "fphbwmw",
        Bk3fhr4: "f19vpps7",
        Bmfj8id: "fv5swzo",
        Bg7n49j: "f1q1x1ba",
        t0hwav: "ft33916",
        Bbusuzp: "f1dcs8yz",
        ze5xyy: "f1kc2mi9",
        Bctn1xl: "fk56vqo",
        Bh6z0a4: "f1ikwg0d"
      }
    }, {
      d: [".fmnzpld{margin-top:2px;}", ".fqerorx{flex-grow:1;}", ".f1ozlkrg{border-top-left-radius:0;}", ".f10ostut{border-top-right-radius:0;}", ".f1deotkl{border-bottom-left-radius:0;}", ".f1krrbdw{border-bottom-right-radius:0;}", ".f1cnd47f{padding-left:0;}", ".fhxju0i{padding-right:0;}", '.f1wl9k8s::before{content:"";}', ".f1yn80uh::before{width:var(--strokeWidthThin);}", ".f68mna0::before{height:24px;}", ".f1p5zmk::before{background-color:var(--colorNeutralStroke1);}", ".f1s2aq7o{color:var(--colorNeutralForegroundDisabled);}"],
      h: [".fvgxktp:hover{color:var(--colorNeutralForegroundDisabled);}", ".f1ijtazh:hover{background-color:var(--colorNeutralBackground1);}", ".fphbwmw:hover{cursor:not-allowed;}", ".f19vpps7:hover .fui-Icon-filled{display:none;}", ".fv5swzo:hover .fui-Icon-regular{display:inline;}", ".f1q1x1ba:hover .fui-MenuItem__icon{color:var(--colorNeutralForegroundDisabled);}"],
      f: [".ft33916:focus{color:var(--colorNeutralForegroundDisabled);}"],
      m: [["@media (forced-colors: active){.f1dcs8yz{color:GrayText;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.f1kc2mi9:hover{color:GrayText;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.fk56vqo:hover .fui-MenuItem__icon{color:GrayText;}}", {
        m: "(forced-colors: active)"
      }], ["@media (forced-colors: active){.f1ikwg0d:focus{color:GrayText;}}", {
        m: "(forced-colors: active)"
      }]]
    });
    const useMenuItemStyles_unstable = (state) => {
      const styles2 = useStyles$8();
      const rootBaseStyles = useRootBaseStyles();
      const contentBaseStyles = useContentBaseStyles();
      const secondaryContentBaseStyles = useSecondaryContentBaseStyles();
      const iconBaseStyles = useIconBaseStyles();
      const submenuIndicatorBaseStyles = useSubmenuIndicatorBaseStyles();
      state.root.className = mergeClasses$2(menuItemClassNames.root, rootBaseStyles, state.disabled && styles2.disabled, state.root.className);
      if (state.content) {
        state.content.className = mergeClasses$2(menuItemClassNames.content, contentBaseStyles, state.content.className);
      }
      if (state.checkmark) {
        state.checkmark.className = mergeClasses$2(menuItemClassNames.checkmark, styles2.checkmark, state.checkmark.className);
      }
      if (state.secondaryContent) {
        state.secondaryContent.className = mergeClasses$2(menuItemClassNames.secondaryContent, !state.disabled && secondaryContentBaseStyles, state.secondaryContent.className);
      }
      if (state.icon) {
        state.icon.className = mergeClasses$2(menuItemClassNames.icon, iconBaseStyles, state.icon.className);
      }
      if (state.submenuIndicator) {
        state.submenuIndicator.className = mergeClasses$2(menuItemClassNames.submenuIndicator, submenuIndicatorBaseStyles, state.submenuIndicator.className);
      }
      useCheckmarkStyles_unstable(state);
    };
    const MenuItem = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const state = useMenuItem_unstable(props, ref);
      useMenuItemStyles_unstable(state);
      useCustomStyleHook("useMenuItemStyles_unstable")(state);
      return renderMenuItem_unstable(state);
    });
    MenuItem.displayName = "MenuItem";
    const useMenuList_unstable = (props, ref) => {
      const { findAllFocusable } = useFocusFinders();
      const menuContext = useMenuContextSelectors();
      const hasMenuContext = useHasParentContext(MenuContext);
      const focusAttributes = useArrowNavigationGroup({
        circular: true,
        ignoreDefaultKeydown: {
          Tab: hasMenuContext
        }
      });
      if (usingPropsAndMenuContext(props, menuContext, hasMenuContext)) {
        console.warn("You are using both MenuList and Menu props, we recommend you to use Menu props when available");
      }
      const innerRef = reactExports.useRef(null);
      const setFocusByFirstCharacter = reactExports.useCallback((e2, itemEl) => {
        const acceptedRoles = [
          "menuitem",
          "menuitemcheckbox",
          "menuitemradio"
        ];
        if (!innerRef.current) {
          return;
        }
        const menuItems = findAllFocusable(innerRef.current, (el) => el.hasAttribute("role") && acceptedRoles.indexOf(el.getAttribute("role")) !== -1);
        let startIndex = menuItems.indexOf(itemEl) + 1;
        if (startIndex === menuItems.length) {
          startIndex = 0;
        }
        const firstChars = menuItems.map((menuItem) => {
          var _menuItem_textContent;
          return (_menuItem_textContent = menuItem.textContent) === null || _menuItem_textContent === void 0 ? void 0 : _menuItem_textContent.charAt(0).toLowerCase();
        });
        const char2 = e2.key.toLowerCase();
        const getIndexFirstChars = (start, firstChar) => {
          for (let i2 = start; i2 < firstChars.length; i2++) {
            if (char2 === firstChars[i2]) {
              return i2;
            }
          }
          return -1;
        };
        let index2 = getIndexFirstChars(startIndex);
        if (index2 === -1) {
          index2 = getIndexFirstChars(0);
        }
        if (index2 > -1) {
          menuItems[index2].focus();
        }
      }, [
        findAllFocusable
      ]);
      var _props_checkedValues;
      const [checkedValues, setCheckedValues] = useControllableState({
        state: (_props_checkedValues = props.checkedValues) !== null && _props_checkedValues !== void 0 ? _props_checkedValues : hasMenuContext ? menuContext.checkedValues : void 0,
        defaultState: props.defaultCheckedValues,
        initialState: {}
      });
      var _props_onCheckedValueChange;
      const handleCheckedValueChange = (_props_onCheckedValueChange = props.onCheckedValueChange) !== null && _props_onCheckedValueChange !== void 0 ? _props_onCheckedValueChange : hasMenuContext ? menuContext.onCheckedValueChange : void 0;
      const toggleCheckbox = useEventCallback$1((e2, name2, value, checked) => {
        const checkedItems = (checkedValues === null || checkedValues === void 0 ? void 0 : checkedValues[name2]) || [];
        const newCheckedItems = [
          ...checkedItems
        ];
        if (checked) {
          newCheckedItems.splice(newCheckedItems.indexOf(value), 1);
        } else {
          newCheckedItems.push(value);
        }
        handleCheckedValueChange === null || handleCheckedValueChange === void 0 ? void 0 : handleCheckedValueChange(e2, {
          name: name2,
          checkedItems: newCheckedItems
        });
        setCheckedValues((s2) => ({
          ...s2,
          [name2]: newCheckedItems
        }));
      });
      const selectRadio = useEventCallback$1((e2, name2, value) => {
        const newCheckedItems = [
          value
        ];
        setCheckedValues((s2) => ({
          ...s2,
          [name2]: newCheckedItems
        }));
        handleCheckedValueChange === null || handleCheckedValueChange === void 0 ? void 0 : handleCheckedValueChange(e2, {
          name: name2,
          checkedItems: newCheckedItems
        });
      });
      return {
        components: {
          root: "div"
        },
        root: always(getIntrinsicElementProps("div", {
          // FIXME:
          // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
          // but since it would be a breaking change to fix it, we are casting ref to it's proper type
          ref: useMergedRefs(ref, innerRef),
          role: "menu",
          "aria-labelledby": menuContext.triggerId,
          ...focusAttributes,
          ...props
        }), {
          elementType: "div"
        }),
        hasIcons: menuContext.hasIcons || false,
        hasCheckmarks: menuContext.hasCheckmarks || false,
        checkedValues,
        hasMenuContext,
        setFocusByFirstCharacter,
        selectRadio,
        toggleCheckbox
      };
    };
    const useMenuContextSelectors = () => {
      const checkedValues = useMenuContext_unstable((context) => context.checkedValues);
      const onCheckedValueChange = useMenuContext_unstable((context) => context.onCheckedValueChange);
      const triggerId = useMenuContext_unstable((context) => context.triggerId);
      const hasIcons = useMenuContext_unstable((context) => context.hasIcons);
      const hasCheckmarks = useMenuContext_unstable((context) => context.hasCheckmarks);
      return {
        checkedValues,
        onCheckedValueChange,
        triggerId,
        hasIcons,
        hasCheckmarks
      };
    };
    const usingPropsAndMenuContext = (props, contextValue, hasMenuContext) => {
      let isUsingPropsAndContext = false;
      for (const val in contextValue) {
        if (props[val]) {
          isUsingPropsAndContext = true;
        }
      }
      return hasMenuContext && isUsingPropsAndContext;
    };
    const renderMenuList_unstable = (state, contextValues) => {
      return /* @__PURE__ */ jsx(MenuListProvider, {
        value: contextValues.menuList,
        children: /* @__PURE__ */ jsx(state.root, {})
      });
    };
    function useMenuListContextValues_unstable(state) {
      const { checkedValues, hasCheckmarks, hasIcons, selectRadio, setFocusByFirstCharacter, toggleCheckbox } = state;
      const menuList = {
        checkedValues,
        hasCheckmarks,
        hasIcons,
        selectRadio,
        setFocusByFirstCharacter,
        toggleCheckbox
      };
      return {
        menuList
      };
    }
    const menuListClassNames = {
      root: "fui-MenuList"
    };
    const useStyles$7 = /* @__PURE__ */ __styles$3({
      root: {
        mc9l5x: "f22iagw",
        Beiy3e4: "f1vx9l62",
        i8kkvl: "f16mnhsx",
        Belr9w4: "fbi42co"
      },
      hasMenuContext: {
        Bqenvij: "f1l02sjl"
      }
    }, {
      d: [".f22iagw{display:flex;}", ".f1vx9l62{flex-direction:column;}", ".f16mnhsx{column-gap:2px;}", ".fbi42co{row-gap:2px;}", ".f1l02sjl{height:100%;}"]
    });
    const useMenuListStyles_unstable = (state) => {
      const styles2 = useStyles$7();
      state.root.className = mergeClasses$2(menuListClassNames.root, styles2.root, state.hasMenuContext && styles2.hasMenuContext, state.root.className);
      return state;
    };
    const MenuList = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const state = useMenuList_unstable(props, ref);
      const contextValues = useMenuListContextValues_unstable(state);
      useMenuListStyles_unstable(state);
      useCustomStyleHook("useMenuListStyles_unstable")(state);
      return renderMenuList_unstable(state, contextValues);
    });
    MenuList.displayName = "MenuList";
    const useMenuPopover_unstable = (props, ref) => {
      const popoverRef = useMenuContext_unstable((context) => context.menuPopoverRef);
      const setOpen = useMenuContext_unstable((context) => context.setOpen);
      const open = useMenuContext_unstable((context) => context.open);
      const openOnHover = useMenuContext_unstable((context) => context.openOnHover);
      const triggerRef = useMenuContext_unstable((context) => context.triggerRef);
      const isSubmenu = useIsSubmenu();
      const canDispatchCustomEventRef = reactExports.useRef(true);
      const throttleDispatchTimerRef = reactExports.useRef(0);
      const restoreFocusSourceAttributes = useRestoreFocusSource();
      const { dir } = useFluent();
      const CloseArrowKey = dir === "ltr" ? ArrowLeft : ArrowRight;
      const mouseOverListenerCallbackRef = reactExports.useCallback((node2) => {
        if (node2) {
          node2.addEventListener("mouseover", (e2) => {
            if (canDispatchCustomEventRef.current) {
              canDispatchCustomEventRef.current = false;
              dispatchMenuEnterEvent(popoverRef.current, e2);
              throttleDispatchTimerRef.current = setTimeout(() => canDispatchCustomEventRef.current = true, 250);
            }
          });
        }
      }, [
        popoverRef,
        throttleDispatchTimerRef
      ]);
      reactExports.useEffect(() => {
      }, []);
      var _useMenuContext_unstable;
      const inline = (_useMenuContext_unstable = useMenuContext_unstable((context) => context.inline)) !== null && _useMenuContext_unstable !== void 0 ? _useMenuContext_unstable : false;
      const mountNode = useMenuContext_unstable((context) => context.mountNode);
      const rootProps = always(getIntrinsicElementProps("div", {
        role: "presentation",
        ...restoreFocusSourceAttributes,
        ...props,
        // FIXME:
        // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
        // but since it would be a breaking change to fix it, we are casting ref to it's proper type
        ref: useMergedRefs(ref, popoverRef, mouseOverListenerCallbackRef)
      }), {
        elementType: "div"
      });
      const { onMouseEnter: onMouseEnterOriginal, onKeyDown: onKeyDownOriginal } = rootProps;
      rootProps.onMouseEnter = useEventCallback$1((event) => {
        if (openOnHover) {
          setOpen(event, {
            open: true,
            keyboard: false,
            type: "menuPopoverMouseEnter",
            event
          });
        }
        onMouseEnterOriginal === null || onMouseEnterOriginal === void 0 ? void 0 : onMouseEnterOriginal(event);
      });
      rootProps.onKeyDown = useEventCallback$1((event) => {
        const key = event.key;
        if (key === Escape || isSubmenu && key === CloseArrowKey) {
          var _popoverRef_current;
          if (open && ((_popoverRef_current = popoverRef.current) === null || _popoverRef_current === void 0 ? void 0 : _popoverRef_current.contains(event.target)) && !event.isDefaultPrevented()) {
            setOpen(event, {
              open: false,
              keyboard: true,
              type: "menuPopoverKeyDown",
              event
            });
            event.preventDefault();
          }
        }
        if (key === Tab) {
          setOpen(event, {
            open: false,
            keyboard: true,
            type: "menuPopoverKeyDown",
            event
          });
          if (!isSubmenu) {
            var _triggerRef_current;
            (_triggerRef_current = triggerRef.current) === null || _triggerRef_current === void 0 ? void 0 : _triggerRef_current.focus();
          }
        }
        onKeyDownOriginal === null || onKeyDownOriginal === void 0 ? void 0 : onKeyDownOriginal(event);
      });
      return {
        inline,
        mountNode,
        components: {
          root: "div"
        },
        root: rootProps
      };
    };
    const menuPopoverClassNames = {
      root: "fui-MenuPopover"
    };
    const useStyles$6 = /* @__PURE__ */ __styles$3({
      root: {
        Bbmb7ep: ["f1aa9q02", "f16jpd5f"],
        Beyfa6y: ["f16jpd5f", "f1aa9q02"],
        B7oj6ja: ["f1jar5jt", "fyu767a"],
        Btl43ni: ["fyu767a", "f1jar5jt"],
        De3pzq: "fxugw4r",
        sj55zd: "f19n0e5",
        B7ck84d: "f1ewtqcl",
        Bf4jedk: "fl8fusi",
        B2u0y6b: "f1kaai3v",
        B68tc82: "f1p9o1ba",
        a9b677: "f1ahpp82",
        E5pizo: "f1hg901r",
        z8tnut: "f10ra9hq",
        z189sj: ["f8wuabp", "fycuoez"],
        Byoj8tv: "f1y2xyjm",
        uwmqm3: ["fycuoez", "f8wuabp"],
        B4j52fo: "f5ogflp",
        Bekrc4i: ["f1hqa2wf", "finvdd3"],
        Bn0qgzm: "f1f09k3d",
        ibv6hh: ["finvdd3", "f1hqa2wf"],
        icvyot: "fzkkow9",
        vrafjx: ["fcdblym", "fjik90z"],
        oivjwe: "fg706s2",
        wvpqe5: ["fjik90z", "fcdblym"],
        g2u3we: "fghlq4f",
        h3c5rm: ["f1gn591s", "fjscplz"],
        B9xav0g: "fb073pr",
        zhjwy3: ["fjscplz", "f1gn591s"],
        Bahqtrf: "fk6fouc",
        Be2twd7: "fkhj508",
        Bhrd7zp: "figsok6",
        Bg96gwp: "f1i3iumi",
        B93otf3: "f18k4bn6",
        vin17d: "fo1kyvf",
        Ezkn3b: "fetxo7e",
        ex8oj8: "fmm77a6",
        Bksk4gw: "f12t24nk",
        Bc5phfd: "f1babd7",
        cbiifc: "f1jgo889",
        fyiq5g: "f1ij1pew",
        Bqc19t1: "f1gu8pa9",
        Eet2gb: "fhfnl4n",
        Bhl7k63: "fk8tkmz",
        Bv12yb3: "f3n0535",
        z0t1cu: "fi19xcv",
        Bks05zx: "f1mzajhk",
        Bvtglag: "fjp4h9y"
      }
    }, {
      d: [".f1aa9q02{border-bottom-right-radius:var(--borderRadiusMedium);}", ".f16jpd5f{border-bottom-left-radius:var(--borderRadiusMedium);}", ".f1jar5jt{border-top-right-radius:var(--borderRadiusMedium);}", ".fyu767a{border-top-left-radius:var(--borderRadiusMedium);}", ".fxugw4r{background-color:var(--colorNeutralBackground1);}", ".f19n0e5{color:var(--colorNeutralForeground1);}", ".f1ewtqcl{box-sizing:border-box;}", ".fl8fusi{min-width:138px;}", ".f1kaai3v{max-width:300px;}", ".f1p9o1ba{overflow-x:hidden;}", ".f1ahpp82{width:max-content;}", ".f1hg901r{box-shadow:var(--shadow16);}", ".f10ra9hq{padding-top:4px;}", ".f8wuabp{padding-right:4px;}", ".fycuoez{padding-left:4px;}", ".f1y2xyjm{padding-bottom:4px;}", ".f5ogflp{border-top-width:1px;}", ".f1hqa2wf{border-right-width:1px;}", ".finvdd3{border-left-width:1px;}", ".f1f09k3d{border-bottom-width:1px;}", ".fzkkow9{border-top-style:solid;}", ".fcdblym{border-right-style:solid;}", ".fjik90z{border-left-style:solid;}", ".fg706s2{border-bottom-style:solid;}", ".fghlq4f{border-top-color:var(--colorTransparentStroke);}", ".f1gn591s{border-right-color:var(--colorTransparentStroke);}", ".fjscplz{border-left-color:var(--colorTransparentStroke);}", ".fb073pr{border-bottom-color:var(--colorTransparentStroke);}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".f18k4bn6{animation-composition:accumulate;}", ".fo1kyvf{animation-duration:var(--durationSlower);}", ".fetxo7e{animation-timing-function:var(--curveDecelerateMid);}", ".fmm77a6{--slide-distance-x:0px;}", ".f12t24nk{--slide-distance-y:10px;}", ".f1babd7[data-popper-placement^=right]{--slide-distance-x:-10px;}", ".f1jgo889[data-popper-placement^=right]{--slide-distance-y:0px;}", ".f1ij1pew[data-popper-placement^=bottom]{--slide-distance-x:0px;}", ".f1gu8pa9[data-popper-placement^=bottom]{--slide-distance-y:-10px;}", ".fhfnl4n[data-popper-placement^=left]{--slide-distance-x:10px;}", ".fk8tkmz[data-popper-placement^=left]{--slide-distance-y:0px;}", ".f3n0535{animation-name:f5j8bii,fld5wjx;}"],
      k: ["@keyframes f5j8bii{from{opacity:0;}to{opacity:1;}}", "@keyframes fld5wjx{from{transform:translate(var(--slide-distance-x), var(--slide-distance-y));}}"],
      m: [["@media (prefers-reduced-motion){.fi19xcv[data-popper-placement]{animation-duration:1ms;}}", {
        m: "(prefers-reduced-motion)"
      }], ["@media (prefers-reduced-motion){.f1mzajhk[data-popper-placement]{animation-name:f5j8bii;}}", {
        m: "(prefers-reduced-motion)"
      }]],
      t: ["@supports not (animation-composition: accumulate){.fjp4h9y[data-popper-placement]{animation-name:f5j8bii;}}"]
    });
    const useMenuPopoverStyles_unstable = (state) => {
      const styles2 = useStyles$6();
      state.root.className = mergeClasses$2(menuPopoverClassNames.root, styles2.root, state.root.className);
      return state;
    };
    const renderMenuPopover_unstable = (state) => {
      if (state.inline) {
        return /* @__PURE__ */ jsx(state.root, {});
      }
      return /* @__PURE__ */ jsx(Portal, {
        mountNode: state.mountNode,
        children: /* @__PURE__ */ jsx(state.root, {})
      });
    };
    const MenuPopover = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const state = useMenuPopover_unstable(props, ref);
      useMenuPopoverStyles_unstable(state);
      useCustomStyleHook("useMenuPopoverStyles_unstable")(state);
      return renderMenuPopover_unstable(state);
    });
    MenuPopover.displayName = "MenuPopover";
    const useMenuTrigger_unstable = (props) => {
      const { children, disableButtonEnhancement = false } = props;
      const triggerRef = useMenuContext_unstable((context) => context.triggerRef);
      const menuPopoverRef = useMenuContext_unstable((context) => context.menuPopoverRef);
      const setOpen = useMenuContext_unstable((context) => context.setOpen);
      const open = useMenuContext_unstable((context) => context.open);
      const triggerId = useMenuContext_unstable((context) => context.triggerId);
      const openOnHover = useMenuContext_unstable((context) => context.openOnHover);
      const openOnContext = useMenuContext_unstable((context) => context.openOnContext);
      const restoreFocusTargetAttribute = useRestoreFocusTarget();
      const isSubmenu = useIsSubmenu();
      const { findFirstFocusable } = useFocusFinders();
      const focusFirst = reactExports.useCallback(() => {
        const firstFocusable = findFirstFocusable(menuPopoverRef.current);
        firstFocusable === null || firstFocusable === void 0 ? void 0 : firstFocusable.focus();
      }, [
        findFirstFocusable,
        menuPopoverRef
      ]);
      const openedWithKeyboardRef = reactExports.useRef(false);
      const hasMouseMoved = reactExports.useRef(false);
      const { dir } = useFluent();
      const OpenArrowKey = dir === "ltr" ? ArrowRight : ArrowLeft;
      const child = getTriggerChild(children);
      const onContextMenu = (event) => {
        if (isTargetDisabled(event) || event.isDefaultPrevented()) {
          return;
        }
        if (openOnContext) {
          event.preventDefault();
          setOpen(event, {
            open: true,
            keyboard: false,
            type: "menuTriggerContextMenu",
            event
          });
        }
      };
      const onClick = (event) => {
        if (isTargetDisabled(event)) {
          return;
        }
        if (!openOnContext) {
          setOpen(event, {
            open: !open,
            keyboard: openedWithKeyboardRef.current,
            type: "menuTriggerClick",
            event
          });
          openedWithKeyboardRef.current = false;
        }
      };
      const onKeyDown = (event) => {
        if (isTargetDisabled(event)) {
          return;
        }
        const key = event.key;
        if (!openOnContext && (isSubmenu && key === OpenArrowKey || !isSubmenu && key === ArrowDown)) {
          setOpen(event, {
            open: true,
            keyboard: true,
            type: "menuTriggerKeyDown",
            event
          });
        }
        if (key === Escape && !isSubmenu) {
          setOpen(event, {
            open: false,
            keyboard: true,
            type: "menuTriggerKeyDown",
            event
          });
        }
        if (open && key === OpenArrowKey && isSubmenu) {
          focusFirst();
        }
      };
      const onMouseEnter = (event) => {
        if (isTargetDisabled(event)) {
          return;
        }
        if (openOnHover && hasMouseMoved.current) {
          setOpen(event, {
            open: true,
            keyboard: false,
            type: "menuTriggerMouseEnter",
            event
          });
        }
      };
      const onMouseMove = (event) => {
        if (isTargetDisabled(event)) {
          return;
        }
        if (openOnHover && !hasMouseMoved.current) {
          setOpen(event, {
            open: true,
            keyboard: false,
            type: "menuTriggerMouseMove",
            event
          });
          hasMouseMoved.current = true;
        }
      };
      const onMouseLeave = (event) => {
        if (isTargetDisabled(event)) {
          return;
        }
        if (openOnHover) {
          setOpen(event, {
            open: false,
            keyboard: false,
            type: "menuTriggerMouseLeave",
            event
          });
        }
      };
      const contextMenuProps = {
        id: triggerId,
        ...restoreFocusTargetAttribute,
        ...child === null || child === void 0 ? void 0 : child.props,
        ref: useMergedRefs(triggerRef, child === null || child === void 0 ? void 0 : child.ref),
        onMouseEnter: useEventCallback$1(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onMouseEnter, onMouseEnter)),
        onMouseLeave: useEventCallback$1(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onMouseLeave, onMouseLeave)),
        onContextMenu: useEventCallback$1(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onContextMenu, onContextMenu)),
        onMouseMove: useEventCallback$1(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onMouseMove, onMouseMove))
      };
      const triggerChildProps = {
        "aria-haspopup": "menu",
        "aria-expanded": !open && !isSubmenu ? void 0 : open,
        ...contextMenuProps,
        onClick: useEventCallback$1(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onClick, onClick)),
        onKeyDown: useEventCallback$1(mergeCallbacks(child === null || child === void 0 ? void 0 : child.props.onKeyDown, onKeyDown))
      };
      const ariaButtonTriggerChildProps = useARIAButtonProps((child === null || child === void 0 ? void 0 : child.type) === "button" || (child === null || child === void 0 ? void 0 : child.type) === "a" ? child.type : "div", triggerChildProps);
      return {
        isSubmenu,
        children: applyTriggerPropsToChildren(children, openOnContext ? contextMenuProps : disableButtonEnhancement ? triggerChildProps : ariaButtonTriggerChildProps)
      };
    };
    const isTargetDisabled = (event) => {
      const isDisabled = (el) => el.hasAttribute("disabled") || el.hasAttribute("aria-disabled") && el.getAttribute("aria-disabled") === "true";
      if (isHTMLElement$1(event.target) && isDisabled(event.target)) {
        return true;
      }
      return isHTMLElement$1(event.currentTarget) && isDisabled(event.currentTarget);
    };
    const renderMenuTrigger_unstable = (state) => {
      return /* @__PURE__ */ reactExports.createElement(MenuTriggerContextProvider, {
        value: state.isSubmenu
      }, state.children);
    };
    const MenuTrigger = (props) => {
      const state = useMenuTrigger_unstable(props);
      return renderMenuTrigger_unstable(state);
    };
    MenuTrigger.displayName = "MenuTrigger";
    MenuTrigger.isFluentTriggerComponent = true;
    const DefaultSvg = () => /* @__PURE__ */ reactExports.createElement("svg", {
      className: "fui-Spinner__Progressbar"
    }, /* @__PURE__ */ reactExports.createElement("circle", {
      className: "fui-Spinner__Track"
    }), /* @__PURE__ */ reactExports.createElement("circle", {
      className: "fui-Spinner__Tail"
    }));
    const SpinnerContext = reactExports.createContext(void 0);
    const SpinnerContextDefaultValue = {};
    SpinnerContext.Provider;
    const useSpinnerContext = () => {
      var _React_useContext;
      return (_React_useContext = reactExports.useContext(SpinnerContext)) !== null && _React_useContext !== void 0 ? _React_useContext : SpinnerContextDefaultValue;
    };
    const useSpinner_unstable = (props, ref) => {
      const { size: contextSize } = useSpinnerContext();
      const { appearance = "primary", labelPosition = "after", size = contextSize !== null && contextSize !== void 0 ? contextSize : "medium", delay = 0 } = props;
      const baseId = useId("spinner");
      const { role = "progressbar", tabIndex, ...rest } = props;
      const nativeRoot = always(getIntrinsicElementProps("div", {
        // FIXME:
        // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
        // but since it would be a breaking change to fix it, we are casting ref to it's proper type
        ref,
        role,
        ...rest
      }, [
        "size"
      ]), {
        elementType: "div"
      });
      const [isVisible, setIsVisible] = reactExports.useState(true);
      const [setDelayTimeout, clearDelayTimeout] = useTimeout();
      reactExports.useEffect(() => {
        if (delay <= 0) {
          return;
        }
        setIsVisible(false);
        setDelayTimeout(() => {
          setIsVisible(true);
        }, delay);
        return () => {
          clearDelayTimeout();
        };
      }, [
        setDelayTimeout,
        clearDelayTimeout,
        delay
      ]);
      const labelShorthand = optional(props.label, {
        defaultProps: {
          id: baseId
        },
        renderByDefault: false,
        elementType: Label
      });
      const spinnerShortHand = optional(props.spinner, {
        renderByDefault: true,
        defaultProps: {
          children: /* @__PURE__ */ reactExports.createElement(DefaultSvg, null),
          tabIndex
        },
        elementType: "span"
      });
      if (labelShorthand && nativeRoot && !nativeRoot["aria-labelledby"]) {
        nativeRoot["aria-labelledby"] = labelShorthand.id;
      }
      const state = {
        appearance,
        delay,
        labelPosition,
        size,
        shouldRenderSpinner: isVisible,
        components: {
          root: "div",
          spinner: "span",
          label: Label
        },
        root: nativeRoot,
        spinner: spinnerShortHand,
        label: labelShorthand
      };
      return state;
    };
    const renderSpinner_unstable = (state) => {
      const { labelPosition, shouldRenderSpinner } = state;
      return /* @__PURE__ */ jsxs(state.root, {
        children: [
          state.label && shouldRenderSpinner && (labelPosition === "above" || labelPosition === "before") && /* @__PURE__ */ jsx(state.label, {}),
          state.spinner && shouldRenderSpinner && /* @__PURE__ */ jsx(state.spinner, {}),
          state.label && shouldRenderSpinner && (labelPosition === "below" || labelPosition === "after") && /* @__PURE__ */ jsx(state.label, {})
        ]
      });
    };
    const spinnerClassNames = {
      root: "fui-Spinner",
      spinner: "fui-Spinner__spinner",
      label: "fui-Spinner__label"
    };
    const useRootStyles$2 = /* @__PURE__ */ __styles$3({
      root: {
        mc9l5x: "f22iagw",
        Bt984gj: "f122n59",
        Brf1p80: "f4d9j23",
        Bg96gwp: "fez10in",
        i8kkvl: "f4px1ci",
        Belr9w4: "fn67r4l"
      },
      horizontal: {
        Beiy3e4: "f1063pyq"
      },
      vertical: {
        Beiy3e4: "f1vx9l62"
      }
    }, {
      d: [".f22iagw{display:flex;}", ".f122n59{align-items:center;}", ".f4d9j23{justify-content:center;}", ".fez10in{line-height:0;}", ".f4px1ci{column-gap:8px;}", ".fn67r4l{row-gap:8px;}", ".f1063pyq{flex-direction:row;}", ".f1vx9l62{flex-direction:column;}"]
    });
    const useLoaderStyles = /* @__PURE__ */ __styles$3({
      spinnerSVG: {
        B3aqqti: "f1or16p5",
        Brovlpu: "f1grzc83",
        Bxa1mx5: "f19shzzi",
        Bwaue66: ["f5tbecn", "f15qb8s7"],
        fyp1ls: "fn4mtlg",
        ag6ruv: "f1y80fxs",
        osj692: "f1r2crtq",
        aq5vjd: "f1wsi8sr",
        tlu9e1: "f1bkm2qd",
        J3u96z: "f1urqz7h",
        d32isg: "f1da2vov",
        Bsvqbuc: "f11rfva0",
        b3s3i5: "f1exc66"
      },
      "extra-tiny": {
        Bah9ito: "f1x2gjcb",
        ut6tcf: "f1vjiaua",
        B7p06xz: "fv1u54w",
        B807ibg: "f1oebb0s"
      },
      tiny: {
        Bah9ito: "f1j4wmu2",
        ut6tcf: "f1vppzuq",
        B7p06xz: "fv1u54w",
        B807ibg: "fngtx1d"
      },
      "extra-small": {
        Bah9ito: "fmpqlna",
        ut6tcf: "f15z5jzu",
        B7p06xz: "fv1u54w",
        B807ibg: "fadawes"
      },
      small: {
        Bah9ito: "fo52gbo",
        ut6tcf: "f1b41i3v",
        B7p06xz: "fv1u54w",
        B807ibg: "f1xqyyrl"
      },
      medium: {
        Bah9ito: "f1aiqagr",
        ut6tcf: "f1wtx80b",
        B7p06xz: "f1flujpd",
        B807ibg: "f1u06hy7"
      },
      large: {
        Bah9ito: "f1trdq7b",
        ut6tcf: "f9e0mc5",
        B7p06xz: "f1flujpd",
        B807ibg: "f13pmvhl"
      },
      "extra-large": {
        Bah9ito: "f89rf2a",
        ut6tcf: "f1w2xg3q",
        B7p06xz: "f1flujpd",
        B807ibg: "fmn74v6"
      },
      huge: {
        Bah9ito: "f1rx7k5y",
        ut6tcf: "f1vtyt49",
        B7p06xz: "f1owbg48",
        B807ibg: "f1fr1izd"
      }
    }, {
      f: [".f1or16p5:focus{outline-width:3px;}", ".f1grzc83:focus{outline-style:solid;}", ".f19shzzi:focus{outline-color:transparent;}"],
      k: ["@keyframes fb7n1on{0%{transform:rotate(0deg);}100%{transform:rotate(360deg);}}", "@keyframes f1gx3jof{0%{transform:rotate(0deg);}100%{transform:rotate(-360deg);}}"],
      d: [".f5tbecn>svg{animation-name:fb7n1on;}", ".f15qb8s7>svg{animation-name:f1gx3jof;}", ".fn4mtlg>svg{animation-duration:3s;}", ".f1y80fxs>svg{animation-iteration-count:infinite;}", ".f1r2crtq>svg{animation-timing-function:linear;}", ".f1wsi8sr>svg{background-color:transparent;}", ".f1da2vov>svg>circle{cx:50%;}", ".f11rfva0>svg>circle{cy:50%;}", ".f1exc66>svg>circle{fill:none;}", ".f1x2gjcb>svg{height:16px;}", ".f1vjiaua>svg{width:16px;}", ".fv1u54w>svg>circle{stroke-width:var(--strokeWidthThick);}", ".f1oebb0s>svg>circle{r:7px;}", ".f1j4wmu2>svg{height:20px;}", ".f1vppzuq>svg{width:20px;}", ".fngtx1d>svg>circle{r:9px;}", ".fmpqlna>svg{height:24px;}", ".f15z5jzu>svg{width:24px;}", ".fadawes>svg>circle{r:11px;}", ".fo52gbo>svg{height:28px;}", ".f1b41i3v>svg{width:28px;}", ".f1xqyyrl>svg>circle{r:13px;}", ".f1aiqagr>svg{height:32px;}", ".f1wtx80b>svg{width:32px;}", ".f1flujpd>svg>circle{stroke-width:var(--strokeWidthThicker);}", ".f1u06hy7>svg>circle{r:14.5px;}", ".f1trdq7b>svg{height:36px;}", ".f9e0mc5>svg{width:36px;}", ".f13pmvhl>svg>circle{r:16.5px;}", ".f89rf2a>svg{height:40px;}", ".f1w2xg3q>svg{width:40px;}", ".fmn74v6>svg>circle{r:18.5px;}", ".f1rx7k5y>svg{height:44px;}", ".f1vtyt49>svg{width:44px;}", ".f1owbg48>svg>circle{stroke-width:var(--strokeWidthThickest);}", ".f1fr1izd>svg>circle{r:20px;}"],
      m: [["@media screen and (prefers-reduced-motion: reduce){.f1bkm2qd>svg{animation-duration:0.01ms;}}", {
        m: "screen and (prefers-reduced-motion: reduce)"
      }], ["@media screen and (prefers-reduced-motion: reduce){.f1urqz7h>svg{animation-iteration-count:1;}}", {
        m: "screen and (prefers-reduced-motion: reduce)"
      }]]
    });
    const useTrackStyles = /* @__PURE__ */ __styles$3({
      inverted: {
        gwg7kz: "f1jvpmnu",
        Bvrehnu: "fq8a5sv",
        Bidp6o: "f1b4lwqj",
        cq3kgi: "f1najlst",
        Btwiser: "fjxod4",
        B8001xd: "fu3xdw0",
        Bdordwa: ["f1ttdh6v", "fmyjox0"],
        Bo2mdfu: "f1eseayc",
        E10nrc: "folzdkc",
        Bwl7w15: "fhlfkde",
        Bksq7rz: "f1esql28"
      },
      primary: {
        gwg7kz: "f11ditju",
        B8k2rxp: "f1m9nikz",
        Bvrehnu: "fq8a5sv",
        Bidp6o: "f1b4lwqj",
        cq3kgi: "f1najlst",
        Btwiser: "fjxod4",
        B8001xd: "fu3xdw0",
        Bdordwa: ["f1ttdh6v", "fmyjox0"],
        Bo2mdfu: "f1eseayc",
        E10nrc: "folzdkc",
        Bwl7w15: "fhlfkde",
        Bksq7rz: "f13qeqtg",
        y14cdu: "flglbw1"
      }
    }, {
      d: [".f1jvpmnu>svg>circle.fui-Spinner__Tail{stroke:var(--colorNeutralStrokeOnBrand2);}", ".fq8a5sv>svg>circle.fui-Spinner__Tail{animation-name:f1v1ql0f;}", ".f1b4lwqj>svg>circle.fui-Spinner__Tail{animation-duration:1.5s;}", ".f1najlst>svg>circle.fui-Spinner__Tail{animation-iteration-count:infinite;}", ".fjxod4>svg>circle.fui-Spinner__Tail{animation-timing-function:var(--curveEasyEase);}", ".fu3xdw0>svg>circle.fui-Spinner__Tail{stroke-linecap:round;}", ".f1ttdh6v>svg>circle.fui-Spinner__Tail{transform:rotate(-90deg);}", ".fmyjox0>svg>circle.fui-Spinner__Tail{transform:rotate(90deg);}", ".f1eseayc>svg>circle.fui-Spinner__Tail{transform-origin:50% 50%;}", ".f1esql28>svg>circle.fui-Spinner__Track{stroke:rgba(255, 255, 255, 0.2);}", ".f11ditju>svg>circle.fui-Spinner__Tail{stroke:var(--colorBrandStroke1);}", ".f13qeqtg>svg>circle.fui-Spinner__Track{stroke:var(--colorBrandStroke2Contrast);}"],
      k: ["@keyframes f1v1ql0f{0%{stroke-dasharray:1,150;stroke-dashoffset:0;}50%{stroke-dasharray:90,150;stroke-dashoffset:-35;}100%{stroke-dasharray:90,150;stroke-dashoffset:-124;}}"],
      m: [["@media screen and (prefers-reduced-motion: reduce){.folzdkc>svg>circle.fui-Spinner__Tail{animation-duration:0.01ms;}}", {
        m: "screen and (prefers-reduced-motion: reduce)"
      }], ["@media screen and (prefers-reduced-motion: reduce){.fhlfkde>svg>circle.fui-Spinner__Tail{animation-iteration-count:1;}}", {
        m: "screen and (prefers-reduced-motion: reduce)"
      }], ["@media screen and (forced-colors: active){.f1m9nikz>svg>circle.fui-Spinner__Tail{stroke:var(--colorNeutralStrokeOnBrand2);}}", {
        m: "screen and (forced-colors: active)"
      }], ["@media screen and (forced-colors: active){.flglbw1>svg>circle.fui-Spinner__Track{stroke:var(--colorNeutralBackgroundInverted);}}", {
        m: "screen and (forced-colors: active)"
      }]]
    });
    const useLabelStyles$1 = /* @__PURE__ */ __styles$3({
      inverted: {
        sj55zd: "f15aqcq"
      },
      primary: {},
      "extra-tiny": {
        Bahqtrf: "fk6fouc",
        Be2twd7: "fkhj508",
        Bhrd7zp: "figsok6",
        Bg96gwp: "f1i3iumi"
      },
      tiny: {
        Bahqtrf: "fk6fouc",
        Be2twd7: "fkhj508",
        Bhrd7zp: "figsok6",
        Bg96gwp: "f1i3iumi"
      },
      "extra-small": {
        Bahqtrf: "fk6fouc",
        Be2twd7: "fkhj508",
        Bhrd7zp: "figsok6",
        Bg96gwp: "f1i3iumi"
      },
      small: {
        Bahqtrf: "fk6fouc",
        Be2twd7: "fkhj508",
        Bhrd7zp: "figsok6",
        Bg96gwp: "f1i3iumi"
      },
      medium: {
        Bahqtrf: "fk6fouc",
        Be2twd7: "fod5ikn",
        Bhrd7zp: "fl43uef",
        Bg96gwp: "faaz57k"
      },
      large: {
        Bahqtrf: "fk6fouc",
        Be2twd7: "fod5ikn",
        Bhrd7zp: "fl43uef",
        Bg96gwp: "faaz57k"
      },
      "extra-large": {
        Bahqtrf: "fk6fouc",
        Be2twd7: "fod5ikn",
        Bhrd7zp: "fl43uef",
        Bg96gwp: "faaz57k"
      },
      huge: {
        Bahqtrf: "fk6fouc",
        Be2twd7: "f1pp30po",
        Bhrd7zp: "fl43uef",
        Bg96gwp: "f106mvju"
      }
    }, {
      d: [".f15aqcq{color:rgba(255, 255, 255, 1);}", ".fk6fouc{font-family:var(--fontFamilyBase);}", ".fkhj508{font-size:var(--fontSizeBase300);}", ".figsok6{font-weight:var(--fontWeightRegular);}", ".f1i3iumi{line-height:var(--lineHeightBase300);}", ".fod5ikn{font-size:var(--fontSizeBase400);}", ".fl43uef{font-weight:var(--fontWeightSemibold);}", ".faaz57k{line-height:var(--lineHeightBase400);}", ".f1pp30po{font-size:var(--fontSizeBase500);}", ".f106mvju{line-height:var(--lineHeightBase500);}"]
    });
    const useSpinnerStyles_unstable = (state) => {
      const {
        labelPosition,
        size,
        appearance = "primary"
      } = state;
      const rootStyles = useRootStyles$2();
      const spinnerStyles = useLoaderStyles();
      const labelStyles = useLabelStyles$1();
      const trackStyles = useTrackStyles();
      state.root.className = mergeClasses$2(spinnerClassNames.root, rootStyles.root, (labelPosition === "above" || labelPosition === "below") && rootStyles.vertical, (labelPosition === "before" || labelPosition === "after") && rootStyles.horizontal, state.root.className);
      if (state.spinner) {
        state.spinner.className = mergeClasses$2(spinnerClassNames.spinner, spinnerStyles.spinnerSVG, spinnerStyles[size], trackStyles[appearance], state.spinner.className);
      }
      if (state.label) {
        state.label.className = mergeClasses$2(spinnerClassNames.label, labelStyles[size], labelStyles[appearance], state.label.className);
      }
      return state;
    };
    const Spinner = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const state = useSpinner_unstable(props, ref);
      useSpinnerStyles_unstable(state);
      useCustomStyleHook("useSpinnerStyles_unstable")(state);
      return renderSpinner_unstable(state);
    });
    Spinner.displayName = "Spinner";
    const useSwitch_unstable = (props, ref) => {
      props = useFieldControlProps_unstable(props, {
        supportsLabelFor: true,
        supportsRequired: true
      });
      const { checked, defaultChecked, disabled, labelPosition = "after", onChange, required } = props;
      const nativeProps = getPartitionedNativeProps({
        props,
        primarySlotTagName: "input",
        excludedPropNames: [
          "checked",
          "defaultChecked",
          "onChange"
        ]
      });
      const id2 = useId("switch-", nativeProps.primary.id);
      const root2 = always(props.root, {
        defaultProps: {
          ref: useFocusWithin(),
          ...nativeProps.root
        },
        elementType: "div"
      });
      const indicator = always(props.indicator, {
        defaultProps: {
          "aria-hidden": true,
          children: /* @__PURE__ */ reactExports.createElement(CircleFilled, null)
        },
        elementType: "div"
      });
      const input = always(props.input, {
        defaultProps: {
          checked,
          defaultChecked,
          id: id2,
          ref,
          role: "switch",
          type: "checkbox",
          ...nativeProps.primary
        },
        elementType: "input"
      });
      input.onChange = mergeCallbacks(input.onChange, (ev) => onChange === null || onChange === void 0 ? void 0 : onChange(ev, {
        checked: ev.currentTarget.checked
      }));
      const label = optional(props.label, {
        defaultProps: {
          disabled,
          htmlFor: id2,
          required,
          size: "medium"
        },
        elementType: Label
      });
      return {
        labelPosition,
        components: {
          root: "div",
          indicator: "div",
          input: "input",
          label: Label
        },
        root: root2,
        indicator,
        input,
        label
      };
    };
    const renderSwitch_unstable = (state) => {
      const { labelPosition } = state;
      return /* @__PURE__ */ jsxs(state.root, {
        children: [
          /* @__PURE__ */ jsx(state.input, {}),
          labelPosition !== "after" && state.label && /* @__PURE__ */ jsx(state.label, {}),
          /* @__PURE__ */ jsx(state.indicator, {}),
          labelPosition === "after" && state.label && /* @__PURE__ */ jsx(state.label, {})
        ]
      });
    };
    const switchClassNames = {
      root: "fui-Switch",
      indicator: "fui-Switch__indicator",
      input: "fui-Switch__input",
      label: "fui-Switch__label"
    };
    const useRootBaseClassName = /* @__PURE__ */ __resetStyles("rugt7u1", "rqv95o1", [".rugt7u1{align-items:flex-start;box-sizing:border-box;display:inline-flex;position:relative;}", ".rugt7u1:focus{outline-style:none;}", ".rugt7u1:focus-visible{outline-style:none;}", ".rugt7u1[data-fui-focus-within]:focus-within{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}", '.rugt7u1[data-fui-focus-within]:focus-within::after{content:"";position:absolute;pointer-events:none;z-index:1;border-top-style:solid;border-right-style:solid;border-bottom-style:solid;border-left-style:solid;border-top-width:2px;border-right-width:2px;border-bottom-width:2px;border-left-width:2px;border-bottom-right-radius:var(--borderRadiusMedium);border-bottom-left-radius:var(--borderRadiusMedium);border-top-right-radius:var(--borderRadiusMedium);border-top-left-radius:var(--borderRadiusMedium);border-top-color:var(--colorStrokeFocus2);border-right-color:var(--colorStrokeFocus2);border-bottom-color:var(--colorStrokeFocus2);border-left-color:var(--colorStrokeFocus2);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}', ".rqv95o1{align-items:flex-start;box-sizing:border-box;display:inline-flex;position:relative;}", ".rqv95o1:focus{outline-style:none;}", ".rqv95o1:focus-visible{outline-style:none;}", ".rqv95o1[data-fui-focus-within]:focus-within{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}", '.rqv95o1[data-fui-focus-within]:focus-within::after{content:"";position:absolute;pointer-events:none;z-index:1;border-top-style:solid;border-left-style:solid;border-bottom-style:solid;border-right-style:solid;border-top-width:2px;border-left-width:2px;border-bottom-width:2px;border-right-width:2px;border-bottom-left-radius:var(--borderRadiusMedium);border-bottom-right-radius:var(--borderRadiusMedium);border-top-left-radius:var(--borderRadiusMedium);border-top-right-radius:var(--borderRadiusMedium);border-top-color:var(--colorStrokeFocus2);border-left-color:var(--colorStrokeFocus2);border-bottom-color:var(--colorStrokeFocus2);border-right-color:var(--colorStrokeFocus2);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}']);
    const useRootStyles$1 = /* @__PURE__ */ __styles$3({
      vertical: {
        Beiy3e4: "f1vx9l62"
      }
    }, {
      d: [".f1vx9l62{flex-direction:column;}"]
    });
    const useIndicatorBaseClassName = /* @__PURE__ */ __resetStyles("r13wlxb8", null, {
      r: [".r13wlxb8{border-radius:var(--borderRadiusCircular);border:1px solid;line-height:0;box-sizing:border-box;fill:currentColor;flex-shrink:0;font-size:18px;height:20px;margin:var(--spacingVerticalS) var(--spacingHorizontalS);pointer-events:none;transition-duration:var(--durationNormal);transition-timing-function:var(--curveEasyEase);transition-property:background,border,color;width:40px;}", ".r13wlxb8>*{transition-duration:var(--durationNormal);transition-timing-function:var(--curveEasyEase);transition-property:transform;}"],
      s: ["@media screen and (prefers-reduced-motion: reduce){.r13wlxb8{transition-duration:0.01ms;}}", "@media screen and (prefers-reduced-motion: reduce){.r13wlxb8>*{transition-duration:0.01ms;}}"]
    });
    const useIndicatorStyles = /* @__PURE__ */ __styles$3({
      labelAbove: {
        B6of3ja: "f1hu3pq6"
      }
    }, {
      d: [".f1hu3pq6{margin-top:0;}"]
    });
    const useInputBaseClassName = /* @__PURE__ */ __resetStyles("rw4brat", "r1f4bxyr", {
      r: [".rw4brat{box-sizing:border-box;cursor:pointer;height:100%;margin:0;opacity:0;position:absolute;width:calc(40px + 2 * var(--spacingHorizontalS));}", ".rw4brat:checked~.fui-Switch__indicator>*{transform:translateX(20px);}", ".rw4brat:disabled{cursor:default;}", ".rw4brat:disabled~.fui-Switch__indicator{color:var(--colorNeutralForegroundDisabled);}", ".rw4brat:disabled~.fui-Switch__label{cursor:default;color:var(--colorNeutralForegroundDisabled);}", ".rw4brat:enabled:not(:checked)~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessible);border-color:var(--colorNeutralStrokeAccessible);}", ".rw4brat:enabled:not(:checked)~.fui-Switch__label{color:var(--colorNeutralForeground1);}", ".rw4brat:enabled:not(:checked):hover~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessibleHover);border-color:var(--colorNeutralStrokeAccessibleHover);}", ".rw4brat:enabled:not(:checked):hover:active~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessiblePressed);border-color:var(--colorNeutralStrokeAccessiblePressed);}", ".rw4brat:enabled:checked~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackground);color:var(--colorNeutralForegroundInverted);border-color:var(--colorTransparentStroke);}", ".rw4brat:enabled:checked:hover~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackgroundHover);border-color:var(--colorTransparentStrokeInteractive);}", ".rw4brat:enabled:checked:hover:active~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackgroundPressed);border-color:var(--colorTransparentStrokeInteractive);}", ".rw4brat:disabled:not(:checked)~.fui-Switch__indicator{border-color:var(--colorNeutralStrokeDisabled);}", ".rw4brat:disabled:checked~.fui-Switch__indicator{background-color:var(--colorNeutralBackgroundDisabled);border-color:var(--colorTransparentStrokeDisabled);}", ".r1f4bxyr{box-sizing:border-box;cursor:pointer;height:100%;margin:0;opacity:0;position:absolute;width:calc(40px + 2 * var(--spacingHorizontalS));}", ".r1f4bxyr:checked~.fui-Switch__indicator>*{transform:translateX(-20px);}", ".r1f4bxyr:disabled{cursor:default;}", ".r1f4bxyr:disabled~.fui-Switch__indicator{color:var(--colorNeutralForegroundDisabled);}", ".r1f4bxyr:disabled~.fui-Switch__label{cursor:default;color:var(--colorNeutralForegroundDisabled);}", ".r1f4bxyr:enabled:not(:checked)~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessible);border-color:var(--colorNeutralStrokeAccessible);}", ".r1f4bxyr:enabled:not(:checked)~.fui-Switch__label{color:var(--colorNeutralForeground1);}", ".r1f4bxyr:enabled:not(:checked):hover~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessibleHover);border-color:var(--colorNeutralStrokeAccessibleHover);}", ".r1f4bxyr:enabled:not(:checked):hover:active~.fui-Switch__indicator{color:var(--colorNeutralStrokeAccessiblePressed);border-color:var(--colorNeutralStrokeAccessiblePressed);}", ".r1f4bxyr:enabled:checked~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackground);color:var(--colorNeutralForegroundInverted);border-color:var(--colorTransparentStroke);}", ".r1f4bxyr:enabled:checked:hover~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackgroundHover);border-color:var(--colorTransparentStrokeInteractive);}", ".r1f4bxyr:enabled:checked:hover:active~.fui-Switch__indicator{background-color:var(--colorCompoundBrandBackgroundPressed);border-color:var(--colorTransparentStrokeInteractive);}", ".r1f4bxyr:disabled:not(:checked)~.fui-Switch__indicator{border-color:var(--colorNeutralStrokeDisabled);}", ".r1f4bxyr:disabled:checked~.fui-Switch__indicator{background-color:var(--colorNeutralBackgroundDisabled);border-color:var(--colorTransparentStrokeDisabled);}"],
      s: ["@media (forced-colors: active){.rw4brat:disabled~.fui-Switch__indicator{color:GrayText;border-color:GrayText;}.rw4brat:disabled~.fui-Switch__label{color:GrayText;}.rw4brat:enabled:checked:hover~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}.rw4brat:enabled:checked~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}}", "@media (forced-colors: active){.r1f4bxyr:disabled~.fui-Switch__indicator{color:GrayText;border-color:GrayText;}.r1f4bxyr:disabled~.fui-Switch__label{color:GrayText;}.r1f4bxyr:enabled:checked:hover~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}.r1f4bxyr:enabled:checked~.fui-Switch__indicator{background-color:Highlight;color:Canvas;}}"]
    });
    const useInputStyles = /* @__PURE__ */ __styles$3({
      before: {
        j35jbq: ["f1e31b4d", "f1vgc2s3"],
        Bhzewxz: "f15twtuk"
      },
      after: {
        oyh7mz: ["f1vgc2s3", "f1e31b4d"],
        Bhzewxz: "f15twtuk"
      },
      above: {
        B5kzvoi: "f1yab3r1",
        Bqenvij: "f1aar7gd",
        a9b677: "fly5x3f"
      }
    }, {
      d: [".f1e31b4d{right:0;}", ".f1vgc2s3{left:0;}", ".f15twtuk{top:0;}", ".f1yab3r1{bottom:0;}", ".f1aar7gd{height:calc(20px + var(--spacingVerticalS));}", ".fly5x3f{width:100%;}"]
    });
    const useLabelStyles = /* @__PURE__ */ __styles$3({
      base: {
        Bceei9c: "f1k6fduh",
        jrapky: "f49ad5g",
        B6of3ja: "f1xlvstr",
        z8tnut: "f1kwiid1",
        z189sj: ["f1vdfbxk", "f1f5gg8d"],
        Byoj8tv: "f5b47ha",
        uwmqm3: ["f1f5gg8d", "f1vdfbxk"]
      },
      above: {
        z8tnut: "f1ywm7hm",
        Byoj8tv: "f14wxoun",
        a9b677: "fly5x3f"
      },
      after: {
        uwmqm3: ["fruq291", "f7x41pl"]
      },
      before: {
        z189sj: ["f7x41pl", "fruq291"]
      }
    }, {
      d: [".f1k6fduh{cursor:pointer;}", ".f49ad5g{margin-bottom:calc((20px - var(--lineHeightBase300)) / 2);}", ".f1xlvstr{margin-top:calc((20px - var(--lineHeightBase300)) / 2);}", ".f1kwiid1{padding-top:var(--spacingVerticalS);}", ".f1vdfbxk{padding-right:var(--spacingHorizontalS);}", ".f1f5gg8d{padding-left:var(--spacingHorizontalS);}", ".f5b47ha{padding-bottom:var(--spacingVerticalS);}", ".f1ywm7hm{padding-top:var(--spacingVerticalXS);}", ".f14wxoun{padding-bottom:var(--spacingVerticalXS);}", ".fly5x3f{width:100%;}", ".fruq291{padding-left:var(--spacingHorizontalXS);}", ".f7x41pl{padding-right:var(--spacingHorizontalXS);}"]
    });
    const useSwitchStyles_unstable = (state) => {
      const rootBaseClassName = useRootBaseClassName();
      const rootStyles = useRootStyles$1();
      const indicatorBaseClassName = useIndicatorBaseClassName();
      const indicatorStyles = useIndicatorStyles();
      const inputBaseClassName = useInputBaseClassName();
      const inputStyles = useInputStyles();
      const labelStyles = useLabelStyles();
      const {
        label,
        labelPosition
      } = state;
      state.root.className = mergeClasses$2(switchClassNames.root, rootBaseClassName, labelPosition === "above" && rootStyles.vertical, state.root.className);
      state.indicator.className = mergeClasses$2(switchClassNames.indicator, indicatorBaseClassName, label && labelPosition === "above" && indicatorStyles.labelAbove, state.indicator.className);
      state.input.className = mergeClasses$2(switchClassNames.input, inputBaseClassName, label && inputStyles[labelPosition], state.input.className);
      if (state.label) {
        state.label.className = mergeClasses$2(switchClassNames.label, labelStyles.base, labelStyles[labelPosition], state.label.className);
      }
      return state;
    };
    const Switch = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const state = useSwitch_unstable(props, ref);
      useSwitchStyles_unstable(state);
      useCustomStyleHook("useSwitchStyles_unstable")(state);
      return renderSwitch_unstable(state);
    });
    Switch.displayName = "Switch";
    const disableScrollElementProp = "__fluentDisableScrollElement";
    function useDisableBodyScroll() {
      const { targetDocument } = useFluent();
      return reactExports.useCallback(() => {
        if (targetDocument) {
          return disableScroll(targetDocument.body);
        }
      }, [
        targetDocument
      ]);
    }
    function disableScroll(target) {
      var _target_ownerDocument_defaultView;
      const { clientWidth } = target.ownerDocument.documentElement;
      var _target_ownerDocument_defaultView_innerWidth;
      const innerWidth = (_target_ownerDocument_defaultView_innerWidth = (_target_ownerDocument_defaultView = target.ownerDocument.defaultView) === null || _target_ownerDocument_defaultView === void 0 ? void 0 : _target_ownerDocument_defaultView.innerWidth) !== null && _target_ownerDocument_defaultView_innerWidth !== void 0 ? _target_ownerDocument_defaultView_innerWidth : 0;
      assertIsDisableScrollElement(target);
      if (target[disableScrollElementProp].count === 0) {
        target.style.overflow = "hidden";
        target.style.paddingRight = `${innerWidth - clientWidth}px`;
      }
      target[disableScrollElementProp].count++;
      return () => {
        target[disableScrollElementProp].count--;
        if (target[disableScrollElementProp].count === 0) {
          target.style.overflow = target[disableScrollElementProp].previousOverflowStyle;
          target.style.paddingRight = target[disableScrollElementProp].previousPaddingRightStyle;
        }
      };
    }
    function assertIsDisableScrollElement(element2) {
      var _element, _disableScrollElementProp;
      var _2;
      (_2 = (_element = element2)[_disableScrollElementProp = disableScrollElementProp]) !== null && _2 !== void 0 ? _2 : _element[_disableScrollElementProp] = {
        count: 0,
        previousOverflowStyle: element2.style.overflow,
        previousPaddingRightStyle: element2.style.paddingRight
      };
    }
    function useFocusFirstElement(open, modalType) {
      const { findFirstFocusable } = useFocusFinders();
      const { targetDocument } = useFluent();
      const dialogRef = reactExports.useRef(null);
      reactExports.useEffect(() => {
        if (!open) {
          return;
        }
        const element2 = dialogRef.current && findFirstFocusable(dialogRef.current);
        if (element2) {
          element2.focus();
        } else {
          var _dialogRef_current;
          (_dialogRef_current = dialogRef.current) === null || _dialogRef_current === void 0 ? void 0 : _dialogRef_current.focus();
        }
      }, [
        findFirstFocusable,
        open,
        modalType,
        targetDocument
      ]);
      return dialogRef;
    }
    const defaultContextValue$2 = {
      open: false,
      inertTrapFocus: false,
      modalType: "modal",
      isNestedDialog: false,
      dialogRef: {
        current: null
      },
      requestOpenChange() {
      }
    };
    const DialogContext = createContext(void 0);
    const DialogProvider = DialogContext.Provider;
    const useDialogContext_unstable = (selector) => useContextSelector(DialogContext, (ctx = defaultContextValue$2) => selector(ctx));
    const defaultContextValue$1 = false;
    const DialogSurfaceContext = reactExports.createContext(void 0);
    const DialogSurfaceProvider = DialogSurfaceContext.Provider;
    const useDialogSurfaceContext_unstable = () => {
      var _useContext;
      return (_useContext = reactExports.useContext(DialogSurfaceContext)) !== null && _useContext !== void 0 ? _useContext : defaultContextValue$1;
    };
    const useDialog_unstable = (props) => {
      const { children, modalType = "modal", onOpenChange, inertTrapFocus = false } = props;
      const [trigger, content2] = childrenToTriggerAndContent(children);
      const [open, setOpen] = useControllableState({
        state: props.open,
        defaultState: props.defaultOpen,
        initialState: false
      });
      const requestOpenChange = useEventCallback$1((data) => {
        onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(data.event, data);
        if (!data.event.isDefaultPrevented()) {
          setOpen(data.open);
        }
      });
      const focusRef = useFocusFirstElement(open, modalType);
      const disableBodyScroll = useDisableBodyScroll();
      const isBodyScrollLocked = Boolean(open && modalType !== "non-modal");
      useIsomorphicLayoutEffect(() => {
        if (isBodyScrollLocked) {
          return disableBodyScroll();
        }
      }, [
        disableBodyScroll,
        isBodyScrollLocked
      ]);
      const { modalAttributes, triggerAttributes } = useModalAttributes({
        trapFocus: modalType !== "non-modal",
        legacyTrapFocus: !inertTrapFocus
      });
      return {
        components: {
          backdrop: "div"
        },
        inertTrapFocus,
        open,
        modalType,
        content: content2,
        trigger,
        requestOpenChange,
        dialogTitleId: useId("dialog-title-"),
        isNestedDialog: useHasParentContext(DialogContext),
        dialogRef: focusRef,
        modalAttributes: modalType !== "non-modal" ? modalAttributes : void 0,
        triggerAttributes
      };
    };
    function childrenToTriggerAndContent(children) {
      const childrenArray = reactExports.Children.toArray(children);
      switch (childrenArray.length) {
        case 2:
          return childrenArray;
        case 1:
          return [
            void 0,
            childrenArray[0]
          ];
        default:
          return [
            void 0,
            void 0
          ];
      }
    }
    function _objectWithoutPropertiesLoose$1(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i2;
      for (i2 = 0; i2 < sourceKeys.length; i2++) {
        key = sourceKeys[i2];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function _inheritsLoose$1(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var propTypes = { exports: {} };
    var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
    var ReactPropTypesSecret = ReactPropTypesSecret_1;
    function emptyFunction() {
    }
    function emptyFunctionWithReset() {
    }
    emptyFunctionWithReset.resetWarningCache = emptyFunction;
    var factoryWithThrowingShims = function() {
      function shim2(props, propName, componentName, location2, propFullName, secret) {
        if (secret === ReactPropTypesSecret) {
          return;
        }
        var err = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        err.name = "Invariant Violation";
        throw err;
      }
      shim2.isRequired = shim2;
      function getShim() {
        return shim2;
      }
      var ReactPropTypes = {
        array: shim2,
        bool: shim2,
        func: shim2,
        number: shim2,
        object: shim2,
        string: shim2,
        symbol: shim2,
        any: shim2,
        arrayOf: getShim,
        element: shim2,
        elementType: shim2,
        instanceOf: getShim,
        node: shim2,
        objectOf: getShim,
        oneOf: getShim,
        oneOfType: getShim,
        shape: getShim,
        exact: getShim,
        checkPropTypes: emptyFunctionWithReset,
        resetWarningCache: emptyFunction
      };
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
    {
      propTypes.exports = factoryWithThrowingShims();
    }
    var propTypesExports = propTypes.exports;
    const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
    const config = {
      disabled: false
    };
    const TransitionGroupContext = React.createContext(null);
    var forceReflow = function forceReflow2(node2) {
      return node2.scrollTop;
    };
    var UNMOUNTED = "unmounted";
    var EXITED = "exited";
    var ENTERING = "entering";
    var ENTERED = "entered";
    var EXITING = "exiting";
    var Transition = /* @__PURE__ */ function(_React$Component) {
      _inheritsLoose$1(Transition2, _React$Component);
      function Transition2(props, context) {
        var _this;
        _this = _React$Component.call(this, props, context) || this;
        var parentGroup = context;
        var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
        var initialStatus;
        _this.appearStatus = null;
        if (props.in) {
          if (appear) {
            initialStatus = EXITED;
            _this.appearStatus = ENTERING;
          } else {
            initialStatus = ENTERED;
          }
        } else {
          if (props.unmountOnExit || props.mountOnEnter) {
            initialStatus = UNMOUNTED;
          } else {
            initialStatus = EXITED;
          }
        }
        _this.state = {
          status: initialStatus
        };
        _this.nextCallback = null;
        return _this;
      }
      Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
        var nextIn = _ref.in;
        if (nextIn && prevState.status === UNMOUNTED) {
          return {
            status: EXITED
          };
        }
        return null;
      };
      var _proto = Transition2.prototype;
      _proto.componentDidMount = function componentDidMount() {
        this.updateStatus(true, this.appearStatus);
      };
      _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
        var nextStatus = null;
        if (prevProps !== this.props) {
          var status = this.state.status;
          if (this.props.in) {
            if (status !== ENTERING && status !== ENTERED) {
              nextStatus = ENTERING;
            }
          } else {
            if (status === ENTERING || status === ENTERED) {
              nextStatus = EXITING;
            }
          }
        }
        this.updateStatus(false, nextStatus);
      };
      _proto.componentWillUnmount = function componentWillUnmount() {
        this.cancelNextCallback();
      };
      _proto.getTimeouts = function getTimeouts() {
        var timeout = this.props.timeout;
        var exit2, enter, appear;
        exit2 = enter = appear = timeout;
        if (timeout != null && typeof timeout !== "number") {
          exit2 = timeout.exit;
          enter = timeout.enter;
          appear = timeout.appear !== void 0 ? timeout.appear : enter;
        }
        return {
          exit: exit2,
          enter,
          appear
        };
      };
      _proto.updateStatus = function updateStatus(mounting, nextStatus) {
        if (mounting === void 0) {
          mounting = false;
        }
        if (nextStatus !== null) {
          this.cancelNextCallback();
          if (nextStatus === ENTERING) {
            if (this.props.unmountOnExit || this.props.mountOnEnter) {
              var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
              if (node2)
                forceReflow(node2);
            }
            this.performEnter(mounting);
          } else {
            this.performExit();
          }
        } else if (this.props.unmountOnExit && this.state.status === EXITED) {
          this.setState({
            status: UNMOUNTED
          });
        }
      };
      _proto.performEnter = function performEnter(mounting) {
        var _this2 = this;
        var enter = this.props.enter;
        var appearing = this.context ? this.context.isMounting : mounting;
        var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
        var timeouts = this.getTimeouts();
        var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
        if (!mounting && !enter || config.disabled) {
          this.safeSetState({
            status: ENTERED
          }, function() {
            _this2.props.onEntered(maybeNode);
          });
          return;
        }
        this.props.onEnter(maybeNode, maybeAppearing);
        this.safeSetState({
          status: ENTERING
        }, function() {
          _this2.props.onEntering(maybeNode, maybeAppearing);
          _this2.onTransitionEnd(enterTimeout, function() {
            _this2.safeSetState({
              status: ENTERED
            }, function() {
              _this2.props.onEntered(maybeNode, maybeAppearing);
            });
          });
        });
      };
      _proto.performExit = function performExit() {
        var _this3 = this;
        var exit2 = this.props.exit;
        var timeouts = this.getTimeouts();
        var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
        if (!exit2 || config.disabled) {
          this.safeSetState({
            status: EXITED
          }, function() {
            _this3.props.onExited(maybeNode);
          });
          return;
        }
        this.props.onExit(maybeNode);
        this.safeSetState({
          status: EXITING
        }, function() {
          _this3.props.onExiting(maybeNode);
          _this3.onTransitionEnd(timeouts.exit, function() {
            _this3.safeSetState({
              status: EXITED
            }, function() {
              _this3.props.onExited(maybeNode);
            });
          });
        });
      };
      _proto.cancelNextCallback = function cancelNextCallback() {
        if (this.nextCallback !== null) {
          this.nextCallback.cancel();
          this.nextCallback = null;
        }
      };
      _proto.safeSetState = function safeSetState(nextState, callback) {
        callback = this.setNextCallback(callback);
        this.setState(nextState, callback);
      };
      _proto.setNextCallback = function setNextCallback(callback) {
        var _this4 = this;
        var active = true;
        this.nextCallback = function(event) {
          if (active) {
            active = false;
            _this4.nextCallback = null;
            callback(event);
          }
        };
        this.nextCallback.cancel = function() {
          active = false;
        };
        return this.nextCallback;
      };
      _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
        this.setNextCallback(handler);
        var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
        var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;
        if (!node2 || doesNotHaveTimeoutOrListener) {
          setTimeout(this.nextCallback, 0);
          return;
        }
        if (this.props.addEndListener) {
          var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node2, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
          this.props.addEndListener(maybeNode, maybeNextCallback);
        }
        if (timeout != null) {
          setTimeout(this.nextCallback, timeout);
        }
      };
      _proto.render = function render() {
        var status = this.state.status;
        if (status === UNMOUNTED) {
          return null;
        }
        var _this$props = this.props, children = _this$props.children;
        _this$props.in;
        _this$props.mountOnEnter;
        _this$props.unmountOnExit;
        _this$props.appear;
        _this$props.enter;
        _this$props.exit;
        _this$props.timeout;
        _this$props.addEndListener;
        _this$props.onEnter;
        _this$props.onEntering;
        _this$props.onEntered;
        _this$props.onExit;
        _this$props.onExiting;
        _this$props.onExited;
        _this$props.nodeRef;
        var childProps = _objectWithoutPropertiesLoose$1(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
        return (
          // allows for nested Transitions
          /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
            value: null
          }, typeof children === "function" ? children(status, childProps) : React.cloneElement(React.Children.only(children), childProps))
        );
      };
      return Transition2;
    }(React.Component);
    Transition.contextType = TransitionGroupContext;
    Transition.propTypes = {};
    function noop$1() {
    }
    Transition.defaultProps = {
      in: false,
      mountOnEnter: false,
      unmountOnExit: false,
      appear: false,
      enter: true,
      exit: true,
      onEnter: noop$1,
      onEntering: noop$1,
      onEntered: noop$1,
      onExit: noop$1,
      onExiting: noop$1,
      onExited: noop$1
    };
    Transition.UNMOUNTED = UNMOUNTED;
    Transition.EXITED = EXITED;
    Transition.ENTERING = ENTERING;
    Transition.ENTERED = ENTERED;
    Transition.EXITING = EXITING;
    const Transition$1 = Transition;
    const defaultContextValue = void 0;
    const DialogTransitionContext = reactExports.createContext(void 0);
    const DialogTransitionProvider = DialogTransitionContext.Provider;
    const useDialogTransitionContext_unstable = () => {
      var _React_useContext;
      return (_React_useContext = reactExports.useContext(DialogTransitionContext)) !== null && _React_useContext !== void 0 ? _React_useContext : defaultContextValue;
    };
    const renderDialog_unstable = (state, contextValues) => {
      const { content: content2, trigger } = state;
      return /* @__PURE__ */ jsx(DialogProvider, {
        value: contextValues.dialog,
        children: /* @__PURE__ */ jsxs(DialogSurfaceProvider, {
          value: contextValues.dialogSurface,
          children: [
            trigger,
            /* @__PURE__ */ jsx(Transition$1, {
              mountOnEnter: true,
              unmountOnExit: true,
              in: state.open,
              nodeRef: state.dialogRef,
              appear: true,
              // FIXME: this should not be hardcoded tokens.durationGentle
              timeout: 250,
              children: (status) => /* @__PURE__ */ jsx(DialogTransitionProvider, {
                value: status,
                children: content2
              })
            })
          ]
        })
      });
    };
    function useDialogContextValues_unstable(state) {
      const { modalType, open, dialogRef, dialogTitleId, isNestedDialog, inertTrapFocus, requestOpenChange, modalAttributes, triggerAttributes } = state;
      const dialog = {
        open,
        modalType,
        dialogRef,
        dialogTitleId,
        isNestedDialog,
        inertTrapFocus,
        modalAttributes,
        triggerAttributes,
        requestOpenChange
      };
      const dialogSurface = false;
      return {
        dialog,
        dialogSurface
      };
    }
    const Dialog = /* @__PURE__ */ reactExports.memo((props) => {
      const state = useDialog_unstable(props);
      const contextValues = useDialogContextValues_unstable(state);
      return renderDialog_unstable(state, contextValues);
    });
    Dialog.displayName = "Dialog";
    const useDialogTrigger_unstable = (props) => {
      const isInsideSurfaceDialog = useDialogSurfaceContext_unstable();
      const { children, disableButtonEnhancement = false, action = isInsideSurfaceDialog ? "close" : "open" } = props;
      const child = getTriggerChild(children);
      const requestOpenChange = useDialogContext_unstable((ctx) => ctx.requestOpenChange);
      const { triggerAttributes } = useModalAttributes();
      const handleClick = useEventCallback$1((event) => {
        var _child_props_onClick, _child_props;
        child === null || child === void 0 ? void 0 : (_child_props_onClick = (_child_props = child.props).onClick) === null || _child_props_onClick === void 0 ? void 0 : _child_props_onClick.call(_child_props, event);
        if (!event.isDefaultPrevented()) {
          requestOpenChange({
            event,
            type: "triggerClick",
            open: action === "open"
          });
        }
      });
      const triggerChildProps = {
        ...child === null || child === void 0 ? void 0 : child.props,
        ref: child === null || child === void 0 ? void 0 : child.ref,
        onClick: handleClick,
        ...triggerAttributes
      };
      const ariaButtonTriggerChildProps = useARIAButtonProps((child === null || child === void 0 ? void 0 : child.type) === "button" || (child === null || child === void 0 ? void 0 : child.type) === "a" ? child.type : "div", {
        ...triggerChildProps,
        type: "button"
      });
      return {
        children: applyTriggerPropsToChildren(children, disableButtonEnhancement ? triggerChildProps : ariaButtonTriggerChildProps)
      };
    };
    const renderDialogTrigger_unstable = (state) => state.children;
    const DialogTrigger = (props) => {
      const state = useDialogTrigger_unstable(props);
      return renderDialogTrigger_unstable(state);
    };
    DialogTrigger.displayName = "DialogTrigger";
    DialogTrigger.isFluentTriggerComponent = true;
    const useDialogActions_unstable = (props, ref) => {
      const { position: position2 = "end", fluid = false } = props;
      return {
        components: {
          root: "div"
        },
        root: always(getIntrinsicElementProps("div", {
          // FIXME:
          // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
          // but since it would be a breaking change to fix it, we are casting ref to it's proper type
          ref,
          ...props
        }), {
          elementType: "div"
        }),
        position: position2,
        fluid
      };
    };
    const renderDialogActions_unstable = (state) => {
      return /* @__PURE__ */ jsx(state.root, {});
    };
    const dialogActionsClassNames = {
      root: "fui-DialogActions"
    };
    const useResetStyles$1 = /* @__PURE__ */ __resetStyles("r78gbj", null, {
      r: [".r78gbj{column-gap:8px;row-gap:8px;height:fit-content;box-sizing:border-box;display:flex;grid-row-start:3;grid-row-end:3;}"],
      s: ["@media screen and (max-width: 480px){.r78gbj{flex-direction:column;justify-self:stretch;}}"]
    });
    const useStyles$5 = /* @__PURE__ */ __styles$3({
      gridPositionEnd: {
        Bdqf98w: "f1a7i8kp",
        Br312pm: "fd46tj4",
        Bw0ie65: "fsyjsko",
        B6n781s: "f1f41i0t",
        Bv5d0be: "f1jaqex3",
        v4ugfu: "f2ao6jk"
      },
      gridPositionStart: {
        Bdqf98w: "fsxvdwy",
        Br312pm: "fwpfdsa",
        Bw0ie65: "f1e2fz10",
        Bojbm9c: "f11ihkml",
        Bv5d0be: "fce5bvx",
        v4ugfu: "f2ao6jk"
      },
      fluidStart: {
        Bw0ie65: "fsyjsko"
      },
      fluidEnd: {
        Br312pm: "fwpfdsa"
      }
    }, {
      d: [".f1a7i8kp{justify-self:end;}", ".fd46tj4{grid-column-start:2;}", ".fsyjsko{grid-column-end:4;}", ".fsxvdwy{justify-self:start;}", ".fwpfdsa{grid-column-start:1;}", ".f1e2fz10{grid-column-end:2;}"],
      m: [["@media screen and (max-width: 480px){.f1f41i0t{grid-column-start:1;}}", {
        m: "screen and (max-width: 480px)"
      }], ["@media screen and (max-width: 480px){.f1jaqex3{grid-row-start:4;}}", {
        m: "screen and (max-width: 480px)"
      }], ["@media screen and (max-width: 480px){.f2ao6jk{grid-row-end:auto;}}", {
        m: "screen and (max-width: 480px)"
      }], ["@media screen and (max-width: 480px){.f11ihkml{grid-column-end:4;}}", {
        m: "screen and (max-width: 480px)"
      }], ["@media screen and (max-width: 480px){.fce5bvx{grid-row-start:3;}}", {
        m: "screen and (max-width: 480px)"
      }]]
    });
    const useDialogActionsStyles_unstable = (state) => {
      const resetStyles = useResetStyles$1();
      const styles2 = useStyles$5();
      state.root.className = mergeClasses$2(dialogActionsClassNames.root, resetStyles, state.position === "start" && styles2.gridPositionStart, state.position === "end" && styles2.gridPositionEnd, state.fluid && state.position === "start" && styles2.fluidStart, state.fluid && state.position === "end" && styles2.fluidEnd, state.root.className);
      return state;
    };
    const DialogActions = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const state = useDialogActions_unstable(props, ref);
      useDialogActionsStyles_unstable(state);
      useCustomStyleHook("useDialogActionsStyles_unstable")(state);
      return renderDialogActions_unstable(state);
    });
    DialogActions.displayName = "DialogActions";
    const useDialogBody_unstable = (props, ref) => {
      var _props_as;
      return {
        components: {
          root: "div"
        },
        root: always(getIntrinsicElementProps((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : "div", {
          // FIXME:
          // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
          // but since it would be a breaking change to fix it, we are casting ref to it's proper type
          ref,
          ...props
        }), {
          elementType: "div"
        })
      };
    };
    const renderDialogBody_unstable = (state) => {
      return /* @__PURE__ */ jsx(state.root, {});
    };
    const dialogBodyClassNames = {
      root: "fui-DialogBody"
    };
    const useResetStyles = /* @__PURE__ */ __resetStyles("r71plkv", null, {
      r: [".r71plkv{overflow-x:unset;overflow-y:unset;column-gap:8px;row-gap:8px;display:grid;max-height:calc(100vh - 2 * 24px);box-sizing:border-box;grid-template-rows:auto 1fr;grid-template-columns:1fr 1fr auto;}"],
      s: ["@media screen and (max-width: 480px){.r71plkv{max-width:100vw;grid-template-rows:auto 1fr auto;}}"]
    });
    const useDialogBodyStyles_unstable = (state) => {
      const resetStyles = useResetStyles();
      state.root.className = mergeClasses$2(dialogBodyClassNames.root, resetStyles, state.root.className);
      return state;
    };
    const DialogBody = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const state = useDialogBody_unstable(props, ref);
      useDialogBodyStyles_unstable(state);
      useCustomStyleHook("useDialogBodyStyles_unstable")(state);
      return renderDialogBody_unstable(state);
    });
    DialogBody.displayName = "DialogBody";
    const dialogTitleClassNames = {
      root: "fui-DialogTitle",
      action: "fui-DialogTitle__action"
    };
    const useRootResetStyles = /* @__PURE__ */ __resetStyles("rztv7rx", "rt0yqbx", [".rztv7rx{font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase500);font-weight:var(--fontWeightSemibold);line-height:var(--lineHeightBase500);margin-top:0;margin-right:0;margin-bottom:0;margin-left:0;grid-row-start:1;grid-row-end:1;grid-column-start:1;grid-column-end:3;}", ".rt0yqbx{font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase500);font-weight:var(--fontWeightSemibold);line-height:var(--lineHeightBase500);margin-top:0;margin-left:0;margin-bottom:0;margin-right:0;grid-row-start:1;grid-row-end:1;grid-column-start:1;grid-column-end:3;}"]);
    const useStyles$4 = /* @__PURE__ */ __styles$3({
      rootWithoutAction: {
        Bw0ie65: "fsyjsko"
      }
    }, {
      d: [".fsyjsko{grid-column-end:4;}"]
    });
    const useActionResetStyles = /* @__PURE__ */ __resetStyles("r13kcrze", null, [".r13kcrze{grid-row-start:1;grid-row-end:1;grid-column-start:3;justify-self:end;align-self:start;}"]);
    const useDialogTitleInternalStyles = /* @__PURE__ */ __resetStyles("r1rmtaxz", "rk1fn6x", [".r1rmtaxz{overflow-x:visible;overflow-y:visible;padding-top:0;padding-right:0;padding-bottom:0;padding-left:0;border-top-style:none;border-right-style:none;border-bottom-style:none;border-left-style:none;position:relative;box-sizing:content-box;background-color:inherit;color:inherit;font-family:inherit;font-size:inherit;cursor:pointer;line-height:0;-webkit-appearance:button;text-align:unset;}", ".r1rmtaxz:focus{outline-style:none;}", ".r1rmtaxz:focus-visible{outline-style:none;}", ".r1rmtaxz[data-fui-focus-visible]{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}", '.r1rmtaxz[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border-top-style:solid;border-right-style:solid;border-bottom-style:solid;border-left-style:solid;border-top-width:2px;border-right-width:2px;border-bottom-width:2px;border-left-width:2px;border-bottom-right-radius:var(--borderRadiusMedium);border-bottom-left-radius:var(--borderRadiusMedium);border-top-right-radius:var(--borderRadiusMedium);border-top-left-radius:var(--borderRadiusMedium);border-top-color:var(--colorStrokeFocus2);border-right-color:var(--colorStrokeFocus2);border-bottom-color:var(--colorStrokeFocus2);border-left-color:var(--colorStrokeFocus2);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}', ".rk1fn6x{overflow-x:visible;overflow-y:visible;padding-top:0;padding-left:0;padding-bottom:0;padding-right:0;border-top-style:none;border-left-style:none;border-bottom-style:none;border-right-style:none;position:relative;box-sizing:content-box;background-color:inherit;color:inherit;font-family:inherit;font-size:inherit;cursor:pointer;line-height:0;-webkit-appearance:button;text-align:unset;}", ".rk1fn6x:focus{outline-style:none;}", ".rk1fn6x:focus-visible{outline-style:none;}", ".rk1fn6x[data-fui-focus-visible]{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}", '.rk1fn6x[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border-top-style:solid;border-left-style:solid;border-bottom-style:solid;border-right-style:solid;border-top-width:2px;border-left-width:2px;border-bottom-width:2px;border-right-width:2px;border-bottom-left-radius:var(--borderRadiusMedium);border-bottom-right-radius:var(--borderRadiusMedium);border-top-left-radius:var(--borderRadiusMedium);border-top-right-radius:var(--borderRadiusMedium);border-top-color:var(--colorStrokeFocus2);border-left-color:var(--colorStrokeFocus2);border-bottom-color:var(--colorStrokeFocus2);border-right-color:var(--colorStrokeFocus2);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}']);
    const useDialogTitleStyles_unstable = (state) => {
      const rootResetStyles = useRootResetStyles();
      const actionResetStyles = useActionResetStyles();
      const styles2 = useStyles$4();
      state.root.className = mergeClasses$2(dialogTitleClassNames.root, rootResetStyles, !state.action && styles2.rootWithoutAction, state.root.className);
      if (state.action) {
        state.action.className = mergeClasses$2(dialogTitleClassNames.action, actionResetStyles, state.action.className);
      }
      return state;
    };
    const useDialogTitle_unstable = (props, ref) => {
      const { action } = props;
      const modalType = useDialogContext_unstable((ctx) => ctx.modalType);
      const internalStyles = useDialogTitleInternalStyles();
      return {
        components: {
          root: "h2",
          action: "div"
        },
        root: always(getIntrinsicElementProps("h2", {
          ref,
          id: useDialogContext_unstable((ctx) => ctx.dialogTitleId),
          ...props
        }), {
          elementType: "h2"
        }),
        action: optional(action, {
          renderByDefault: modalType === "non-modal",
          defaultProps: {
            children: /* @__PURE__ */ reactExports.createElement(DialogTrigger, {
              disableButtonEnhancement: true,
              action: "close"
            }, /* @__PURE__ */ reactExports.createElement("button", {
              type: "button",
              className: internalStyles,
              // TODO: find a better way to add internal labels
              "aria-label": "close"
            }, /* @__PURE__ */ reactExports.createElement(Dismiss20Regular, null)))
          },
          elementType: "div"
        })
      };
    };
    const renderDialogTitle_unstable = (state) => {
      return /* @__PURE__ */ jsxs(reactExports.Fragment, {
        children: [
          /* @__PURE__ */ jsx(state.root, {
            children: state.root.children
          }),
          state.action && /* @__PURE__ */ jsx(state.action, {})
        ]
      });
    };
    const DialogTitle = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const state = useDialogTitle_unstable(props, ref);
      useDialogTitleStyles_unstable(state);
      useCustomStyleHook("useDialogTitleStyles_unstable")(state);
      return renderDialogTitle_unstable(state);
    });
    DialogTitle.displayName = "DialogTitle";
    const useDialogSurface_unstable = (props, ref) => {
      const modalType = useDialogContext_unstable((ctx) => ctx.modalType);
      const isNestedDialog = useDialogContext_unstable((ctx) => ctx.isNestedDialog);
      const transitionStatus = useDialogTransitionContext_unstable();
      const modalAttributes = useDialogContext_unstable((ctx) => ctx.modalAttributes);
      const dialogRef = useDialogContext_unstable((ctx) => ctx.dialogRef);
      const requestOpenChange = useDialogContext_unstable((ctx) => ctx.requestOpenChange);
      const dialogTitleID = useDialogContext_unstable((ctx) => ctx.dialogTitleId);
      const handledBackdropClick = useEventCallback$1((event) => {
        if (isResolvedShorthand(props.backdrop)) {
          var _props_backdrop_onClick, _props_backdrop;
          (_props_backdrop_onClick = (_props_backdrop = props.backdrop).onClick) === null || _props_backdrop_onClick === void 0 ? void 0 : _props_backdrop_onClick.call(_props_backdrop, event);
        }
        if (modalType === "modal" && !event.isDefaultPrevented()) {
          requestOpenChange({
            event,
            open: false,
            type: "backdropClick"
          });
        }
      });
      const handleKeyDown = useEventCallback$1((event) => {
        var _props_onKeyDown;
        (_props_onKeyDown = props.onKeyDown) === null || _props_onKeyDown === void 0 ? void 0 : _props_onKeyDown.call(props, event);
        if (event.key === Escape && !event.isDefaultPrevented()) {
          requestOpenChange({
            event,
            open: false,
            type: "escapeKeyDown"
          });
          event.preventDefault();
        }
      });
      const backdrop = optional(props.backdrop, {
        renderByDefault: modalType !== "non-modal",
        defaultProps: {
          "aria-hidden": "true"
        },
        elementType: "div"
      });
      if (backdrop) {
        backdrop.onClick = handledBackdropClick;
      }
      return {
        components: {
          backdrop: "div",
          root: "div"
        },
        backdrop,
        isNestedDialog,
        transitionStatus,
        mountNode: props.mountNode,
        root: always(getIntrinsicElementProps("div", {
          tabIndex: -1,
          "aria-modal": modalType !== "non-modal",
          role: modalType === "alert" ? "alertdialog" : "dialog",
          "aria-labelledby": props["aria-label"] ? void 0 : dialogTitleID,
          ...props,
          ...modalAttributes,
          onKeyDown: handleKeyDown,
          // FIXME:
          // `DialogSurfaceElement` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
          // but since it would be a breaking change to fix it, we are casting ref to it's proper type
          ref: useMergedRefs(ref, dialogRef)
        }), {
          elementType: "div"
        })
      };
    };
    const renderDialogSurface_unstable = (state, contextValues) => {
      return /* @__PURE__ */ jsxs(Portal, {
        mountNode: state.mountNode,
        children: [
          state.backdrop && /* @__PURE__ */ jsx(state.backdrop, {}),
          /* @__PURE__ */ jsx(DialogSurfaceProvider, {
            value: contextValues.dialogSurface,
            children: /* @__PURE__ */ jsx(state.root, {})
          })
        ]
      });
    };
    const dialogSurfaceClassNames = {
      root: "fui-DialogSurface",
      backdrop: "fui-DialogSurface__backdrop"
    };
    const useRootBaseStyle = /* @__PURE__ */ __resetStyles("r1v93r34", "r1m90yqy", {
      r: [".r1v93r34{top:0;right:0;bottom:0;left:0;padding-top:24px;padding-right:24px;padding-bottom:24px;padding-left:24px;margin-top:auto;margin-right:auto;margin-bottom:auto;margin-left:auto;border-top-style:solid;border-right-style:solid;border-bottom-style:solid;border-left-style:solid;overflow-x:unset;overflow-y:unset;border-top-width:1px;border-right-width:1px;border-bottom-width:1px;border-left-width:1px;border-top-color:var(--colorTransparentStroke);border-right-color:var(--colorTransparentStroke);border-bottom-color:var(--colorTransparentStroke);border-left-color:var(--colorTransparentStroke);border-bottom-right-radius:var(--borderRadiusXLarge);border-bottom-left-radius:var(--borderRadiusXLarge);border-top-right-radius:var(--borderRadiusXLarge);border-top-left-radius:var(--borderRadiusXLarge);display:block;-webkit-user-select:unset;-moz-user-select:unset;-ms-user-select:unset;user-select:unset;visibility:unset;position:fixed;height:fit-content;max-width:600px;max-height:100vh;box-sizing:border-box;background-color:var(--colorNeutralBackground1);color:var(--colorNeutralForeground1);}", ".r1v93r34:focus{outline-style:none;}", ".r1v93r34:focus-visible{outline-style:none;}", ".r1v93r34[data-fui-focus-visible]{border-top-color:transparent;border-right-color:transparent;border-bottom-color:transparent;border-left-color:transparent;}", '.r1v93r34[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border-top-style:solid;border-right-style:solid;border-bottom-style:solid;border-left-style:solid;border-top-width:2px;border-right-width:2px;border-bottom-width:2px;border-left-width:2px;border-bottom-right-radius:var(--borderRadiusMedium);border-bottom-left-radius:var(--borderRadiusMedium);border-top-right-radius:var(--borderRadiusMedium);border-top-left-radius:var(--borderRadiusMedium);border-top-color:var(--colorStrokeFocus2);border-right-color:var(--colorStrokeFocus2);border-bottom-color:var(--colorStrokeFocus2);border-left-color:var(--colorStrokeFocus2);top:calc(2px * -1);right:calc(2px * -1);bottom:calc(2px * -1);left:calc(2px * -1);}', ".r1m90yqy{top:0;left:0;bottom:0;right:0;padding-top:24px;padding-left:24px;padding-bottom:24px;padding-right:24px;margin-top:auto;margin-left:auto;margin-bottom:auto;margin-right:auto;border-top-style:solid;border-left-style:solid;border-bottom-style:solid;border-right-style:solid;overflow-x:unset;overflow-y:unset;border-top-width:1px;border-left-width:1px;border-bottom-width:1px;border-right-width:1px;border-top-color:var(--colorTransparentStroke);border-left-color:var(--colorTransparentStroke);border-bottom-color:var(--colorTransparentStroke);border-right-color:var(--colorTransparentStroke);border-bottom-left-radius:var(--borderRadiusXLarge);border-bottom-right-radius:var(--borderRadiusXLarge);border-top-left-radius:var(--borderRadiusXLarge);border-top-right-radius:var(--borderRadiusXLarge);display:block;-webkit-user-select:unset;-moz-user-select:unset;-ms-user-select:unset;user-select:unset;visibility:unset;position:fixed;height:fit-content;max-width:600px;max-height:100vh;box-sizing:border-box;background-color:var(--colorNeutralBackground1);color:var(--colorNeutralForeground1);}", ".r1m90yqy:focus{outline-style:none;}", ".r1m90yqy:focus-visible{outline-style:none;}", ".r1m90yqy[data-fui-focus-visible]{border-top-color:transparent;border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;}", '.r1m90yqy[data-fui-focus-visible]::after{content:"";position:absolute;pointer-events:none;z-index:1;border-top-style:solid;border-left-style:solid;border-bottom-style:solid;border-right-style:solid;border-top-width:2px;border-left-width:2px;border-bottom-width:2px;border-right-width:2px;border-bottom-left-radius:var(--borderRadiusMedium);border-bottom-right-radius:var(--borderRadiusMedium);border-top-left-radius:var(--borderRadiusMedium);border-top-right-radius:var(--borderRadiusMedium);border-top-color:var(--colorStrokeFocus2);border-left-color:var(--colorStrokeFocus2);border-bottom-color:var(--colorStrokeFocus2);border-right-color:var(--colorStrokeFocus2);top:calc(2px * -1);left:calc(2px * -1);bottom:calc(2px * -1);right:calc(2px * -1);}'],
      s: ["@media screen and (max-width: 480px){.r1v93r34{max-width:100vw;}}", "@media screen and (max-width: 480px){.r1m90yqy{max-width:100vw;}}"]
    });
    const useRootStyles = /* @__PURE__ */ __styles$3({
      animated: {
        abs64n: "fk73vx1",
        B3o57yi: "fc397y7",
        Bmy1vo4: "f1b86uth",
        Bkqvd7p: "f18ad807",
        E5pizo: "f1yzz98r",
        Bz10aip: "f15ofi6c"
      },
      unmounted: {},
      entering: {},
      entered: {
        E5pizo: "f10nrhrw",
        Bz10aip: "f186d0ee",
        abs64n: "f5p0z4x"
      },
      idle: {},
      exiting: {
        Bkqvd7p: "f1mfizis"
      },
      exited: {}
    }, {
      d: [".fk73vx1{opacity:0;}", ".fc397y7{transition-duration:var(--durationGentle);}", ".f1b86uth{transition-property:opacity,transform,box-shadow;}", ".f18ad807{transition-timing-function:var(--curveDecelerateMid);}", ".f1yzz98r{box-shadow:0px 0px 0px 0px rgba(0, 0, 0, 0.1);}", ".f15ofi6c{transform:scale(0.85) translateZ(0);}", ".f10nrhrw{box-shadow:var(--shadow64);}", ".f186d0ee{transform:scale(1) translateZ(0);}", ".f5p0z4x{opacity:1;}", ".f1mfizis{transition-timing-function:var(--curveAccelerateMin);}"]
    });
    const useBackdropBaseStyle = /* @__PURE__ */ __resetStyles("raidwwn", "r17vltcu", [".raidwwn{top:0px;right:0px;bottom:0px;left:0px;background-color:rgba(0, 0, 0, 0.4);position:fixed;transition-duration:var(--durationGentle);transition-timing-function:var(--curveLinear);transition-property:opacity;will-change:opacity;opacity:0;}", ".r17vltcu{top:0px;left:0px;bottom:0px;right:0px;background-color:rgba(0, 0, 0, 0.4);position:fixed;transition-duration:var(--durationGentle);transition-timing-function:var(--curveLinear);transition-property:opacity;will-change:opacity;opacity:0;}"]);
    const useBackdropStyles = /* @__PURE__ */ __styles$3({
      nestedDialogBackdrop: {
        De3pzq: "f1c21dwh"
      },
      unmounted: {},
      entering: {},
      entered: {
        abs64n: "f5p0z4x"
      },
      idle: {},
      exiting: {
        Bkqvd7p: "f1mfizis"
      },
      exited: {}
    }, {
      d: [".f1c21dwh{background-color:var(--colorTransparentBackground);}", ".f5p0z4x{opacity:1;}", ".f1mfizis{transition-timing-function:var(--curveAccelerateMin);}"]
    });
    const useDialogSurfaceStyles_unstable = (state) => {
      const {
        isNestedDialog,
        root: root2,
        backdrop,
        transitionStatus
      } = state;
      const rootBaseStyle = useRootBaseStyle();
      const rootStyles = useRootStyles();
      const backdropBaseStyle = useBackdropBaseStyle();
      const backdropStyles = useBackdropStyles();
      root2.className = mergeClasses$2(dialogSurfaceClassNames.root, rootBaseStyle, transitionStatus && rootStyles.animated, transitionStatus && rootStyles[transitionStatus], root2.className);
      if (backdrop) {
        backdrop.className = mergeClasses$2(dialogSurfaceClassNames.backdrop, backdropBaseStyle, isNestedDialog && backdropStyles.nestedDialogBackdrop, transitionStatus && backdropStyles[transitionStatus], backdrop.className);
      }
      return state;
    };
    function useDialogSurfaceContextValues_unstable(state) {
      const dialogSurface = true;
      return {
        dialogSurface
      };
    }
    const DialogSurface = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const state = useDialogSurface_unstable(props, ref);
      const contextValues = useDialogSurfaceContextValues_unstable();
      useDialogSurfaceStyles_unstable(state);
      useCustomStyleHook("useDialogSurfaceStyles_unstable")(state);
      return renderDialogSurface_unstable(state, contextValues);
    });
    DialogSurface.displayName = "DialogSurface";
    const useDialogContent_unstable = (props, ref) => {
      var _props_as;
      return {
        components: {
          root: "div"
        },
        root: always(getIntrinsicElementProps((_props_as = props.as) !== null && _props_as !== void 0 ? _props_as : "div", {
          // FIXME:
          // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
          // but since it would be a breaking change to fix it, we are casting ref to it's proper type
          ref,
          ...props
        }), {
          elementType: "div"
        })
      };
    };
    const renderDialogContent_unstable = (state) => {
      return /* @__PURE__ */ jsx(state.root, {});
    };
    const dialogContentClassNames = {
      root: "fui-DialogContent"
    };
    const useStyles$3 = /* @__PURE__ */ __resetStyles("r1e0mpcm", "r1equu0b", [".r1e0mpcm{padding-top:var(--strokeWidthThick);padding-right:var(--strokeWidthThick);padding-bottom:var(--strokeWidthThick);padding-left:var(--strokeWidthThick);margin-top:calc(var(--strokeWidthThick) * -1);margin-right:calc(var(--strokeWidthThick) * -1);margin-bottom:calc(var(--strokeWidthThick) * -1);margin-left:calc(var(--strokeWidthThick) * -1);font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);overflow-y:auto;min-height:32px;box-sizing:border-box;grid-row-start:2;grid-row-end:2;grid-column-start:1;grid-column-end:4;}", ".r1equu0b{padding-top:var(--strokeWidthThick);padding-left:var(--strokeWidthThick);padding-bottom:var(--strokeWidthThick);padding-right:var(--strokeWidthThick);margin-top:calc(var(--strokeWidthThick) * -1);margin-left:calc(var(--strokeWidthThick) * -1);margin-bottom:calc(var(--strokeWidthThick) * -1);margin-right:calc(var(--strokeWidthThick) * -1);font-family:var(--fontFamilyBase);font-size:var(--fontSizeBase300);font-weight:var(--fontWeightRegular);line-height:var(--lineHeightBase300);overflow-y:auto;min-height:32px;box-sizing:border-box;grid-row-start:2;grid-row-end:2;grid-column-start:1;grid-column-end:4;}"]);
    const useDialogContentStyles_unstable = (state) => {
      const styles2 = useStyles$3();
      state.root.className = mergeClasses$2(dialogContentClassNames.root, styles2, state.root.className);
      return state;
    };
    const DialogContent = /* @__PURE__ */ reactExports.forwardRef((props, ref) => {
      const state = useDialogContent_unstable(props, ref);
      useDialogContentStyles_unstable(state);
      useCustomStyleHook("useDialogContentStyles_unstable")(state);
      return renderDialogContent_unstable(state);
    });
    DialogContent.displayName = "DialogContent";
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var Subscribable = /* @__PURE__ */ function() {
      function Subscribable2() {
        this.listeners = [];
      }
      var _proto = Subscribable2.prototype;
      _proto.subscribe = function subscribe2(listener) {
        var _this = this;
        var callback = listener || function() {
          return void 0;
        };
        this.listeners.push(callback);
        this.onSubscribe();
        return function() {
          _this.listeners = _this.listeners.filter(function(x2) {
            return x2 !== callback;
          });
          _this.onUnsubscribe();
        };
      };
      _proto.hasListeners = function hasListeners() {
        return this.listeners.length > 0;
      };
      _proto.onSubscribe = function onSubscribe() {
      };
      _proto.onUnsubscribe = function onUnsubscribe() {
      };
      return Subscribable2;
    }();
    function _extends$2() {
      _extends$2 = Object.assign || function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends$2.apply(this, arguments);
    }
    var isServer = typeof window === "undefined";
    function noop() {
      return void 0;
    }
    function functionalUpdate(updater, input) {
      return typeof updater === "function" ? updater(input) : updater;
    }
    function isValidTimeout(value) {
      return typeof value === "number" && value >= 0 && value !== Infinity;
    }
    function ensureQueryKeyArray(value) {
      return Array.isArray(value) ? value : [value];
    }
    function timeUntilStale(updatedAt, staleTime) {
      return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
    }
    function parseQueryArgs(arg1, arg2, arg3) {
      if (!isQueryKey(arg1)) {
        return arg1;
      }
      if (typeof arg2 === "function") {
        return _extends$2({}, arg3, {
          queryKey: arg1,
          queryFn: arg2
        });
      }
      return _extends$2({}, arg2, {
        queryKey: arg1
      });
    }
    function parseMutationArgs(arg1, arg2, arg3) {
      if (isQueryKey(arg1)) {
        if (typeof arg2 === "function") {
          return _extends$2({}, arg3, {
            mutationKey: arg1,
            mutationFn: arg2
          });
        }
        return _extends$2({}, arg2, {
          mutationKey: arg1
        });
      }
      if (typeof arg1 === "function") {
        return _extends$2({}, arg2, {
          mutationFn: arg1
        });
      }
      return _extends$2({}, arg1);
    }
    function parseFilterArgs(arg1, arg2, arg3) {
      return isQueryKey(arg1) ? [_extends$2({}, arg2, {
        queryKey: arg1
      }), arg3] : [arg1 || {}, arg2];
    }
    function mapQueryStatusFilter(active, inactive) {
      if (active === true && inactive === true || active == null && inactive == null) {
        return "all";
      } else if (active === false && inactive === false) {
        return "none";
      } else {
        var isActive = active != null ? active : !inactive;
        return isActive ? "active" : "inactive";
      }
    }
    function matchQuery(filters, query) {
      var active = filters.active, exact = filters.exact, fetching = filters.fetching, inactive = filters.inactive, predicate = filters.predicate, queryKey = filters.queryKey, stale = filters.stale;
      if (isQueryKey(queryKey)) {
        if (exact) {
          if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
            return false;
          }
        } else if (!partialMatchKey(query.queryKey, queryKey)) {
          return false;
        }
      }
      var queryStatusFilter = mapQueryStatusFilter(active, inactive);
      if (queryStatusFilter === "none") {
        return false;
      } else if (queryStatusFilter !== "all") {
        var isActive = query.isActive();
        if (queryStatusFilter === "active" && !isActive) {
          return false;
        }
        if (queryStatusFilter === "inactive" && isActive) {
          return false;
        }
      }
      if (typeof stale === "boolean" && query.isStale() !== stale) {
        return false;
      }
      if (typeof fetching === "boolean" && query.isFetching() !== fetching) {
        return false;
      }
      if (predicate && !predicate(query)) {
        return false;
      }
      return true;
    }
    function matchMutation(filters, mutation) {
      var exact = filters.exact, fetching = filters.fetching, predicate = filters.predicate, mutationKey = filters.mutationKey;
      if (isQueryKey(mutationKey)) {
        if (!mutation.options.mutationKey) {
          return false;
        }
        if (exact) {
          if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {
            return false;
          }
        } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
          return false;
        }
      }
      if (typeof fetching === "boolean" && mutation.state.status === "loading" !== fetching) {
        return false;
      }
      if (predicate && !predicate(mutation)) {
        return false;
      }
      return true;
    }
    function hashQueryKeyByOptions(queryKey, options) {
      var hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;
      return hashFn(queryKey);
    }
    function hashQueryKey(queryKey) {
      var asArray = ensureQueryKeyArray(queryKey);
      return stableValueHash(asArray);
    }
    function stableValueHash(value) {
      return JSON.stringify(value, function(_2, val) {
        return isPlainObject$3(val) ? Object.keys(val).sort().reduce(function(result, key) {
          result[key] = val[key];
          return result;
        }, {}) : val;
      });
    }
    function partialMatchKey(a2, b2) {
      return partialDeepEqual(ensureQueryKeyArray(a2), ensureQueryKeyArray(b2));
    }
    function partialDeepEqual(a2, b2) {
      if (a2 === b2) {
        return true;
      }
      if (typeof a2 !== typeof b2) {
        return false;
      }
      if (a2 && b2 && typeof a2 === "object" && typeof b2 === "object") {
        return !Object.keys(b2).some(function(key) {
          return !partialDeepEqual(a2[key], b2[key]);
        });
      }
      return false;
    }
    function replaceEqualDeep(a2, b2) {
      if (a2 === b2) {
        return a2;
      }
      var array = Array.isArray(a2) && Array.isArray(b2);
      if (array || isPlainObject$3(a2) && isPlainObject$3(b2)) {
        var aSize = array ? a2.length : Object.keys(a2).length;
        var bItems = array ? b2 : Object.keys(b2);
        var bSize = bItems.length;
        var copy2 = array ? [] : {};
        var equalItems = 0;
        for (var i2 = 0; i2 < bSize; i2++) {
          var key = array ? i2 : bItems[i2];
          copy2[key] = replaceEqualDeep(a2[key], b2[key]);
          if (copy2[key] === a2[key]) {
            equalItems++;
          }
        }
        return aSize === bSize && equalItems === aSize ? a2 : copy2;
      }
      return b2;
    }
    function shallowEqualObjects(a2, b2) {
      if (a2 && !b2 || b2 && !a2) {
        return false;
      }
      for (var key in a2) {
        if (a2[key] !== b2[key]) {
          return false;
        }
      }
      return true;
    }
    function isPlainObject$3(o2) {
      if (!hasObjectPrototype(o2)) {
        return false;
      }
      var ctor = o2.constructor;
      if (typeof ctor === "undefined") {
        return true;
      }
      var prot = ctor.prototype;
      if (!hasObjectPrototype(prot)) {
        return false;
      }
      if (!prot.hasOwnProperty("isPrototypeOf")) {
        return false;
      }
      return true;
    }
    function hasObjectPrototype(o2) {
      return Object.prototype.toString.call(o2) === "[object Object]";
    }
    function isQueryKey(value) {
      return typeof value === "string" || Array.isArray(value);
    }
    function sleep(timeout) {
      return new Promise(function(resolve) {
        setTimeout(resolve, timeout);
      });
    }
    function scheduleMicrotask(callback) {
      Promise.resolve().then(callback).catch(function(error) {
        return setTimeout(function() {
          throw error;
        });
      });
    }
    function getAbortController() {
      if (typeof AbortController === "function") {
        return new AbortController();
      }
    }
    var FocusManager = /* @__PURE__ */ function(_Subscribable) {
      _inheritsLoose(FocusManager2, _Subscribable);
      function FocusManager2() {
        var _this;
        _this = _Subscribable.call(this) || this;
        _this.setup = function(onFocus) {
          var _window2;
          if (!isServer && ((_window2 = window) == null ? void 0 : _window2.addEventListener)) {
            var listener = function listener2() {
              return onFocus();
            };
            window.addEventListener("visibilitychange", listener, false);
            window.addEventListener("focus", listener, false);
            return function() {
              window.removeEventListener("visibilitychange", listener);
              window.removeEventListener("focus", listener);
            };
          }
        };
        return _this;
      }
      var _proto = FocusManager2.prototype;
      _proto.onSubscribe = function onSubscribe() {
        if (!this.cleanup) {
          this.setEventListener(this.setup);
        }
      };
      _proto.onUnsubscribe = function onUnsubscribe() {
        if (!this.hasListeners()) {
          var _this$cleanup;
          (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
          this.cleanup = void 0;
        }
      };
      _proto.setEventListener = function setEventListener(setup) {
        var _this$cleanup2, _this2 = this;
        this.setup = setup;
        (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
        this.cleanup = setup(function(focused) {
          if (typeof focused === "boolean") {
            _this2.setFocused(focused);
          } else {
            _this2.onFocus();
          }
        });
      };
      _proto.setFocused = function setFocused(focused) {
        this.focused = focused;
        if (focused) {
          this.onFocus();
        }
      };
      _proto.onFocus = function onFocus() {
        this.listeners.forEach(function(listener) {
          listener();
        });
      };
      _proto.isFocused = function isFocused() {
        if (typeof this.focused === "boolean") {
          return this.focused;
        }
        if (typeof document === "undefined") {
          return true;
        }
        return [void 0, "visible", "prerender"].includes(document.visibilityState);
      };
      return FocusManager2;
    }(Subscribable);
    var focusManager = new FocusManager();
    var OnlineManager = /* @__PURE__ */ function(_Subscribable) {
      _inheritsLoose(OnlineManager2, _Subscribable);
      function OnlineManager2() {
        var _this;
        _this = _Subscribable.call(this) || this;
        _this.setup = function(onOnline) {
          var _window2;
          if (!isServer && ((_window2 = window) == null ? void 0 : _window2.addEventListener)) {
            var listener = function listener2() {
              return onOnline();
            };
            window.addEventListener("online", listener, false);
            window.addEventListener("offline", listener, false);
            return function() {
              window.removeEventListener("online", listener);
              window.removeEventListener("offline", listener);
            };
          }
        };
        return _this;
      }
      var _proto = OnlineManager2.prototype;
      _proto.onSubscribe = function onSubscribe() {
        if (!this.cleanup) {
          this.setEventListener(this.setup);
        }
      };
      _proto.onUnsubscribe = function onUnsubscribe() {
        if (!this.hasListeners()) {
          var _this$cleanup;
          (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
          this.cleanup = void 0;
        }
      };
      _proto.setEventListener = function setEventListener(setup) {
        var _this$cleanup2, _this2 = this;
        this.setup = setup;
        (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
        this.cleanup = setup(function(online) {
          if (typeof online === "boolean") {
            _this2.setOnline(online);
          } else {
            _this2.onOnline();
          }
        });
      };
      _proto.setOnline = function setOnline(online) {
        this.online = online;
        if (online) {
          this.onOnline();
        }
      };
      _proto.onOnline = function onOnline() {
        this.listeners.forEach(function(listener) {
          listener();
        });
      };
      _proto.isOnline = function isOnline() {
        if (typeof this.online === "boolean") {
          return this.online;
        }
        if (typeof navigator === "undefined" || typeof navigator.onLine === "undefined") {
          return true;
        }
        return navigator.onLine;
      };
      return OnlineManager2;
    }(Subscribable);
    var onlineManager = new OnlineManager();
    function defaultRetryDelay(failureCount) {
      return Math.min(1e3 * Math.pow(2, failureCount), 3e4);
    }
    function isCancelable(value) {
      return typeof (value == null ? void 0 : value.cancel) === "function";
    }
    var CancelledError = function CancelledError2(options) {
      this.revert = options == null ? void 0 : options.revert;
      this.silent = options == null ? void 0 : options.silent;
    };
    function isCancelledError(value) {
      return value instanceof CancelledError;
    }
    var Retryer = function Retryer2(config2) {
      var _this = this;
      var cancelRetry = false;
      var cancelFn;
      var continueFn;
      var promiseResolve;
      var promiseReject;
      this.abort = config2.abort;
      this.cancel = function(cancelOptions) {
        return cancelFn == null ? void 0 : cancelFn(cancelOptions);
      };
      this.cancelRetry = function() {
        cancelRetry = true;
      };
      this.continueRetry = function() {
        cancelRetry = false;
      };
      this.continue = function() {
        return continueFn == null ? void 0 : continueFn();
      };
      this.failureCount = 0;
      this.isPaused = false;
      this.isResolved = false;
      this.isTransportCancelable = false;
      this.promise = new Promise(function(outerResolve, outerReject) {
        promiseResolve = outerResolve;
        promiseReject = outerReject;
      });
      var resolve = function resolve2(value) {
        if (!_this.isResolved) {
          _this.isResolved = true;
          config2.onSuccess == null ? void 0 : config2.onSuccess(value);
          continueFn == null ? void 0 : continueFn();
          promiseResolve(value);
        }
      };
      var reject = function reject2(value) {
        if (!_this.isResolved) {
          _this.isResolved = true;
          config2.onError == null ? void 0 : config2.onError(value);
          continueFn == null ? void 0 : continueFn();
          promiseReject(value);
        }
      };
      var pause = function pause2() {
        return new Promise(function(continueResolve) {
          continueFn = continueResolve;
          _this.isPaused = true;
          config2.onPause == null ? void 0 : config2.onPause();
        }).then(function() {
          continueFn = void 0;
          _this.isPaused = false;
          config2.onContinue == null ? void 0 : config2.onContinue();
        });
      };
      var run = function run2() {
        if (_this.isResolved) {
          return;
        }
        var promiseOrValue;
        try {
          promiseOrValue = config2.fn();
        } catch (error) {
          promiseOrValue = Promise.reject(error);
        }
        cancelFn = function cancelFn2(cancelOptions) {
          if (!_this.isResolved) {
            reject(new CancelledError(cancelOptions));
            _this.abort == null ? void 0 : _this.abort();
            if (isCancelable(promiseOrValue)) {
              try {
                promiseOrValue.cancel();
              } catch (_unused) {
              }
            }
          }
        };
        _this.isTransportCancelable = isCancelable(promiseOrValue);
        Promise.resolve(promiseOrValue).then(resolve).catch(function(error) {
          var _config$retry, _config$retryDelay;
          if (_this.isResolved) {
            return;
          }
          var retry = (_config$retry = config2.retry) != null ? _config$retry : 3;
          var retryDelay = (_config$retryDelay = config2.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;
          var delay = typeof retryDelay === "function" ? retryDelay(_this.failureCount, error) : retryDelay;
          var shouldRetry = retry === true || typeof retry === "number" && _this.failureCount < retry || typeof retry === "function" && retry(_this.failureCount, error);
          if (cancelRetry || !shouldRetry) {
            reject(error);
            return;
          }
          _this.failureCount++;
          config2.onFail == null ? void 0 : config2.onFail(_this.failureCount, error);
          sleep(delay).then(function() {
            if (!focusManager.isFocused() || !onlineManager.isOnline()) {
              return pause();
            }
          }).then(function() {
            if (cancelRetry) {
              reject(error);
            } else {
              run2();
            }
          });
        });
      };
      run();
    };
    var NotifyManager = /* @__PURE__ */ function() {
      function NotifyManager2() {
        this.queue = [];
        this.transactions = 0;
        this.notifyFn = function(callback) {
          callback();
        };
        this.batchNotifyFn = function(callback) {
          callback();
        };
      }
      var _proto = NotifyManager2.prototype;
      _proto.batch = function batch(callback) {
        var result;
        this.transactions++;
        try {
          result = callback();
        } finally {
          this.transactions--;
          if (!this.transactions) {
            this.flush();
          }
        }
        return result;
      };
      _proto.schedule = function schedule(callback) {
        var _this = this;
        if (this.transactions) {
          this.queue.push(callback);
        } else {
          scheduleMicrotask(function() {
            _this.notifyFn(callback);
          });
        }
      };
      _proto.batchCalls = function batchCalls(callback) {
        var _this2 = this;
        return function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this2.schedule(function() {
            callback.apply(void 0, args);
          });
        };
      };
      _proto.flush = function flush() {
        var _this3 = this;
        var queue = this.queue;
        this.queue = [];
        if (queue.length) {
          scheduleMicrotask(function() {
            _this3.batchNotifyFn(function() {
              queue.forEach(function(callback) {
                _this3.notifyFn(callback);
              });
            });
          });
        }
      };
      _proto.setNotifyFunction = function setNotifyFunction(fn) {
        this.notifyFn = fn;
      };
      _proto.setBatchNotifyFunction = function setBatchNotifyFunction(fn) {
        this.batchNotifyFn = fn;
      };
      return NotifyManager2;
    }();
    var notifyManager = new NotifyManager();
    var logger$1 = console;
    function getLogger() {
      return logger$1;
    }
    function setLogger(newLogger) {
      logger$1 = newLogger;
    }
    var Query = /* @__PURE__ */ function() {
      function Query2(config2) {
        this.abortSignalConsumed = false;
        this.hadObservers = false;
        this.defaultOptions = config2.defaultOptions;
        this.setOptions(config2.options);
        this.observers = [];
        this.cache = config2.cache;
        this.queryKey = config2.queryKey;
        this.queryHash = config2.queryHash;
        this.initialState = config2.state || this.getDefaultState(this.options);
        this.state = this.initialState;
        this.meta = config2.meta;
        this.scheduleGc();
      }
      var _proto = Query2.prototype;
      _proto.setOptions = function setOptions(options) {
        var _this$options$cacheTi;
        this.options = _extends$2({}, this.defaultOptions, options);
        this.meta = options == null ? void 0 : options.meta;
        this.cacheTime = Math.max(this.cacheTime || 0, (_this$options$cacheTi = this.options.cacheTime) != null ? _this$options$cacheTi : 5 * 60 * 1e3);
      };
      _proto.setDefaultOptions = function setDefaultOptions(options) {
        this.defaultOptions = options;
      };
      _proto.scheduleGc = function scheduleGc() {
        var _this = this;
        this.clearGcTimeout();
        if (isValidTimeout(this.cacheTime)) {
          this.gcTimeout = setTimeout(function() {
            _this.optionalRemove();
          }, this.cacheTime);
        }
      };
      _proto.clearGcTimeout = function clearGcTimeout() {
        if (this.gcTimeout) {
          clearTimeout(this.gcTimeout);
          this.gcTimeout = void 0;
        }
      };
      _proto.optionalRemove = function optionalRemove() {
        if (!this.observers.length) {
          if (this.state.isFetching) {
            if (this.hadObservers) {
              this.scheduleGc();
            }
          } else {
            this.cache.remove(this);
          }
        }
      };
      _proto.setData = function setData(updater, options) {
        var _this$options$isDataE, _this$options;
        var prevData = this.state.data;
        var data = functionalUpdate(updater, prevData);
        if ((_this$options$isDataE = (_this$options = this.options).isDataEqual) == null ? void 0 : _this$options$isDataE.call(_this$options, prevData, data)) {
          data = prevData;
        } else if (this.options.structuralSharing !== false) {
          data = replaceEqualDeep(prevData, data);
        }
        this.dispatch({
          data,
          type: "success",
          dataUpdatedAt: options == null ? void 0 : options.updatedAt
        });
        return data;
      };
      _proto.setState = function setState(state, setStateOptions) {
        this.dispatch({
          type: "setState",
          state,
          setStateOptions
        });
      };
      _proto.cancel = function cancel(options) {
        var _this$retryer;
        var promise = this.promise;
        (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);
        return promise ? promise.then(noop).catch(noop) : Promise.resolve();
      };
      _proto.destroy = function destroy() {
        this.clearGcTimeout();
        this.cancel({
          silent: true
        });
      };
      _proto.reset = function reset() {
        this.destroy();
        this.setState(this.initialState);
      };
      _proto.isActive = function isActive() {
        return this.observers.some(function(observer) {
          return observer.options.enabled !== false;
        });
      };
      _proto.isFetching = function isFetching() {
        return this.state.isFetching;
      };
      _proto.isStale = function isStale2() {
        return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(function(observer) {
          return observer.getCurrentResult().isStale;
        });
      };
      _proto.isStaleByTime = function isStaleByTime(staleTime) {
        if (staleTime === void 0) {
          staleTime = 0;
        }
        return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);
      };
      _proto.onFocus = function onFocus() {
        var _this$retryer2;
        var observer = this.observers.find(function(x2) {
          return x2.shouldFetchOnWindowFocus();
        });
        if (observer) {
          observer.refetch();
        }
        (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();
      };
      _proto.onOnline = function onOnline() {
        var _this$retryer3;
        var observer = this.observers.find(function(x2) {
          return x2.shouldFetchOnReconnect();
        });
        if (observer) {
          observer.refetch();
        }
        (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();
      };
      _proto.addObserver = function addObserver(observer) {
        if (this.observers.indexOf(observer) === -1) {
          this.observers.push(observer);
          this.hadObservers = true;
          this.clearGcTimeout();
          this.cache.notify({
            type: "observerAdded",
            query: this,
            observer
          });
        }
      };
      _proto.removeObserver = function removeObserver(observer) {
        if (this.observers.indexOf(observer) !== -1) {
          this.observers = this.observers.filter(function(x2) {
            return x2 !== observer;
          });
          if (!this.observers.length) {
            if (this.retryer) {
              if (this.retryer.isTransportCancelable || this.abortSignalConsumed) {
                this.retryer.cancel({
                  revert: true
                });
              } else {
                this.retryer.cancelRetry();
              }
            }
            if (this.cacheTime) {
              this.scheduleGc();
            } else {
              this.cache.remove(this);
            }
          }
          this.cache.notify({
            type: "observerRemoved",
            query: this,
            observer
          });
        }
      };
      _proto.getObserversCount = function getObserversCount() {
        return this.observers.length;
      };
      _proto.invalidate = function invalidate() {
        if (!this.state.isInvalidated) {
          this.dispatch({
            type: "invalidate"
          });
        }
      };
      _proto.fetch = function fetch2(options, fetchOptions) {
        var _this2 = this, _this$options$behavio, _context$fetchOptions, _abortController$abor;
        if (this.state.isFetching) {
          if (this.state.dataUpdatedAt && (fetchOptions == null ? void 0 : fetchOptions.cancelRefetch)) {
            this.cancel({
              silent: true
            });
          } else if (this.promise) {
            var _this$retryer4;
            (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry();
            return this.promise;
          }
        }
        if (options) {
          this.setOptions(options);
        }
        if (!this.options.queryFn) {
          var observer = this.observers.find(function(x2) {
            return x2.options.queryFn;
          });
          if (observer) {
            this.setOptions(observer.options);
          }
        }
        var queryKey = ensureQueryKeyArray(this.queryKey);
        var abortController = getAbortController();
        var queryFnContext = {
          queryKey,
          pageParam: void 0,
          meta: this.meta
        };
        Object.defineProperty(queryFnContext, "signal", {
          enumerable: true,
          get: function get2() {
            if (abortController) {
              _this2.abortSignalConsumed = true;
              return abortController.signal;
            }
            return void 0;
          }
        });
        var fetchFn = function fetchFn2() {
          if (!_this2.options.queryFn) {
            return Promise.reject("Missing queryFn");
          }
          _this2.abortSignalConsumed = false;
          return _this2.options.queryFn(queryFnContext);
        };
        var context = {
          fetchOptions,
          options: this.options,
          queryKey,
          state: this.state,
          fetchFn,
          meta: this.meta
        };
        if ((_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch) {
          var _this$options$behavio2;
          (_this$options$behavio2 = this.options.behavior) == null ? void 0 : _this$options$behavio2.onFetch(context);
        }
        this.revertState = this.state;
        if (!this.state.isFetching || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {
          var _context$fetchOptions2;
          this.dispatch({
            type: "fetch",
            meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta
          });
        }
        this.retryer = new Retryer({
          fn: context.fetchFn,
          abort: abortController == null ? void 0 : (_abortController$abor = abortController.abort) == null ? void 0 : _abortController$abor.bind(abortController),
          onSuccess: function onSuccess(data) {
            _this2.setData(data);
            _this2.cache.config.onSuccess == null ? void 0 : _this2.cache.config.onSuccess(data, _this2);
            if (_this2.cacheTime === 0) {
              _this2.optionalRemove();
            }
          },
          onError: function onError(error) {
            if (!(isCancelledError(error) && error.silent)) {
              _this2.dispatch({
                type: "error",
                error
              });
            }
            if (!isCancelledError(error)) {
              _this2.cache.config.onError == null ? void 0 : _this2.cache.config.onError(error, _this2);
              getLogger().error(error);
            }
            if (_this2.cacheTime === 0) {
              _this2.optionalRemove();
            }
          },
          onFail: function onFail() {
            _this2.dispatch({
              type: "failed"
            });
          },
          onPause: function onPause() {
            _this2.dispatch({
              type: "pause"
            });
          },
          onContinue: function onContinue() {
            _this2.dispatch({
              type: "continue"
            });
          },
          retry: context.options.retry,
          retryDelay: context.options.retryDelay
        });
        this.promise = this.retryer.promise;
        return this.promise;
      };
      _proto.dispatch = function dispatch(action) {
        var _this3 = this;
        this.state = this.reducer(this.state, action);
        notifyManager.batch(function() {
          _this3.observers.forEach(function(observer) {
            observer.onQueryUpdate(action);
          });
          _this3.cache.notify({
            query: _this3,
            type: "queryUpdated",
            action
          });
        });
      };
      _proto.getDefaultState = function getDefaultState2(options) {
        var data = typeof options.initialData === "function" ? options.initialData() : options.initialData;
        var hasInitialData = typeof options.initialData !== "undefined";
        var initialDataUpdatedAt = hasInitialData ? typeof options.initialDataUpdatedAt === "function" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
        var hasData = typeof data !== "undefined";
        return {
          data,
          dataUpdateCount: 0,
          dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,
          error: null,
          errorUpdateCount: 0,
          errorUpdatedAt: 0,
          fetchFailureCount: 0,
          fetchMeta: null,
          isFetching: false,
          isInvalidated: false,
          isPaused: false,
          status: hasData ? "success" : "idle"
        };
      };
      _proto.reducer = function reducer2(state, action) {
        var _action$meta, _action$dataUpdatedAt;
        switch (action.type) {
          case "failed":
            return _extends$2({}, state, {
              fetchFailureCount: state.fetchFailureCount + 1
            });
          case "pause":
            return _extends$2({}, state, {
              isPaused: true
            });
          case "continue":
            return _extends$2({}, state, {
              isPaused: false
            });
          case "fetch":
            return _extends$2({}, state, {
              fetchFailureCount: 0,
              fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,
              isFetching: true,
              isPaused: false
            }, !state.dataUpdatedAt && {
              error: null,
              status: "loading"
            });
          case "success":
            return _extends$2({}, state, {
              data: action.data,
              dataUpdateCount: state.dataUpdateCount + 1,
              dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),
              error: null,
              fetchFailureCount: 0,
              isFetching: false,
              isInvalidated: false,
              isPaused: false,
              status: "success"
            });
          case "error":
            var error = action.error;
            if (isCancelledError(error) && error.revert && this.revertState) {
              return _extends$2({}, this.revertState);
            }
            return _extends$2({}, state, {
              error,
              errorUpdateCount: state.errorUpdateCount + 1,
              errorUpdatedAt: Date.now(),
              fetchFailureCount: state.fetchFailureCount + 1,
              isFetching: false,
              isPaused: false,
              status: "error"
            });
          case "invalidate":
            return _extends$2({}, state, {
              isInvalidated: true
            });
          case "setState":
            return _extends$2({}, state, action.state);
          default:
            return state;
        }
      };
      return Query2;
    }();
    var QueryCache = /* @__PURE__ */ function(_Subscribable) {
      _inheritsLoose(QueryCache2, _Subscribable);
      function QueryCache2(config2) {
        var _this;
        _this = _Subscribable.call(this) || this;
        _this.config = config2 || {};
        _this.queries = [];
        _this.queriesMap = {};
        return _this;
      }
      var _proto = QueryCache2.prototype;
      _proto.build = function build(client, options, state) {
        var _options$queryHash;
        var queryKey = options.queryKey;
        var queryHash = (_options$queryHash = options.queryHash) != null ? _options$queryHash : hashQueryKeyByOptions(queryKey, options);
        var query = this.get(queryHash);
        if (!query) {
          query = new Query({
            cache: this,
            queryKey,
            queryHash,
            options: client.defaultQueryOptions(options),
            state,
            defaultOptions: client.getQueryDefaults(queryKey),
            meta: options.meta
          });
          this.add(query);
        }
        return query;
      };
      _proto.add = function add2(query) {
        if (!this.queriesMap[query.queryHash]) {
          this.queriesMap[query.queryHash] = query;
          this.queries.push(query);
          this.notify({
            type: "queryAdded",
            query
          });
        }
      };
      _proto.remove = function remove(query) {
        var queryInMap = this.queriesMap[query.queryHash];
        if (queryInMap) {
          query.destroy();
          this.queries = this.queries.filter(function(x2) {
            return x2 !== query;
          });
          if (queryInMap === query) {
            delete this.queriesMap[query.queryHash];
          }
          this.notify({
            type: "queryRemoved",
            query
          });
        }
      };
      _proto.clear = function clear() {
        var _this2 = this;
        notifyManager.batch(function() {
          _this2.queries.forEach(function(query) {
            _this2.remove(query);
          });
        });
      };
      _proto.get = function get2(queryHash) {
        return this.queriesMap[queryHash];
      };
      _proto.getAll = function getAll() {
        return this.queries;
      };
      _proto.find = function find2(arg1, arg2) {
        var _parseFilterArgs = parseFilterArgs(arg1, arg2), filters = _parseFilterArgs[0];
        if (typeof filters.exact === "undefined") {
          filters.exact = true;
        }
        return this.queries.find(function(query) {
          return matchQuery(filters, query);
        });
      };
      _proto.findAll = function findAll(arg1, arg2) {
        var _parseFilterArgs2 = parseFilterArgs(arg1, arg2), filters = _parseFilterArgs2[0];
        return Object.keys(filters).length > 0 ? this.queries.filter(function(query) {
          return matchQuery(filters, query);
        }) : this.queries;
      };
      _proto.notify = function notify(event) {
        var _this3 = this;
        notifyManager.batch(function() {
          _this3.listeners.forEach(function(listener) {
            listener(event);
          });
        });
      };
      _proto.onFocus = function onFocus() {
        var _this4 = this;
        notifyManager.batch(function() {
          _this4.queries.forEach(function(query) {
            query.onFocus();
          });
        });
      };
      _proto.onOnline = function onOnline() {
        var _this5 = this;
        notifyManager.batch(function() {
          _this5.queries.forEach(function(query) {
            query.onOnline();
          });
        });
      };
      return QueryCache2;
    }(Subscribable);
    var Mutation = /* @__PURE__ */ function() {
      function Mutation2(config2) {
        this.options = _extends$2({}, config2.defaultOptions, config2.options);
        this.mutationId = config2.mutationId;
        this.mutationCache = config2.mutationCache;
        this.observers = [];
        this.state = config2.state || getDefaultState();
        this.meta = config2.meta;
      }
      var _proto = Mutation2.prototype;
      _proto.setState = function setState(state) {
        this.dispatch({
          type: "setState",
          state
        });
      };
      _proto.addObserver = function addObserver(observer) {
        if (this.observers.indexOf(observer) === -1) {
          this.observers.push(observer);
        }
      };
      _proto.removeObserver = function removeObserver(observer) {
        this.observers = this.observers.filter(function(x2) {
          return x2 !== observer;
        });
      };
      _proto.cancel = function cancel() {
        if (this.retryer) {
          this.retryer.cancel();
          return this.retryer.promise.then(noop).catch(noop);
        }
        return Promise.resolve();
      };
      _proto.continue = function _continue() {
        if (this.retryer) {
          this.retryer.continue();
          return this.retryer.promise;
        }
        return this.execute();
      };
      _proto.execute = function execute() {
        var _this = this;
        var data;
        var restored = this.state.status === "loading";
        var promise = Promise.resolve();
        if (!restored) {
          this.dispatch({
            type: "loading",
            variables: this.options.variables
          });
          promise = promise.then(function() {
            _this.mutationCache.config.onMutate == null ? void 0 : _this.mutationCache.config.onMutate(_this.state.variables, _this);
          }).then(function() {
            return _this.options.onMutate == null ? void 0 : _this.options.onMutate(_this.state.variables);
          }).then(function(context) {
            if (context !== _this.state.context) {
              _this.dispatch({
                type: "loading",
                context,
                variables: _this.state.variables
              });
            }
          });
        }
        return promise.then(function() {
          return _this.executeMutation();
        }).then(function(result) {
          data = result;
          _this.mutationCache.config.onSuccess == null ? void 0 : _this.mutationCache.config.onSuccess(data, _this.state.variables, _this.state.context, _this);
        }).then(function() {
          return _this.options.onSuccess == null ? void 0 : _this.options.onSuccess(data, _this.state.variables, _this.state.context);
        }).then(function() {
          return _this.options.onSettled == null ? void 0 : _this.options.onSettled(data, null, _this.state.variables, _this.state.context);
        }).then(function() {
          _this.dispatch({
            type: "success",
            data
          });
          return data;
        }).catch(function(error) {
          _this.mutationCache.config.onError == null ? void 0 : _this.mutationCache.config.onError(error, _this.state.variables, _this.state.context, _this);
          getLogger().error(error);
          return Promise.resolve().then(function() {
            return _this.options.onError == null ? void 0 : _this.options.onError(error, _this.state.variables, _this.state.context);
          }).then(function() {
            return _this.options.onSettled == null ? void 0 : _this.options.onSettled(void 0, error, _this.state.variables, _this.state.context);
          }).then(function() {
            _this.dispatch({
              type: "error",
              error
            });
            throw error;
          });
        });
      };
      _proto.executeMutation = function executeMutation() {
        var _this2 = this, _this$options$retry;
        this.retryer = new Retryer({
          fn: function fn() {
            if (!_this2.options.mutationFn) {
              return Promise.reject("No mutationFn found");
            }
            return _this2.options.mutationFn(_this2.state.variables);
          },
          onFail: function onFail() {
            _this2.dispatch({
              type: "failed"
            });
          },
          onPause: function onPause() {
            _this2.dispatch({
              type: "pause"
            });
          },
          onContinue: function onContinue() {
            _this2.dispatch({
              type: "continue"
            });
          },
          retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,
          retryDelay: this.options.retryDelay
        });
        return this.retryer.promise;
      };
      _proto.dispatch = function dispatch(action) {
        var _this3 = this;
        this.state = reducer(this.state, action);
        notifyManager.batch(function() {
          _this3.observers.forEach(function(observer) {
            observer.onMutationUpdate(action);
          });
          _this3.mutationCache.notify(_this3);
        });
      };
      return Mutation2;
    }();
    function getDefaultState() {
      return {
        context: void 0,
        data: void 0,
        error: null,
        failureCount: 0,
        isPaused: false,
        status: "idle",
        variables: void 0
      };
    }
    function reducer(state, action) {
      switch (action.type) {
        case "failed":
          return _extends$2({}, state, {
            failureCount: state.failureCount + 1
          });
        case "pause":
          return _extends$2({}, state, {
            isPaused: true
          });
        case "continue":
          return _extends$2({}, state, {
            isPaused: false
          });
        case "loading":
          return _extends$2({}, state, {
            context: action.context,
            data: void 0,
            error: null,
            isPaused: false,
            status: "loading",
            variables: action.variables
          });
        case "success":
          return _extends$2({}, state, {
            data: action.data,
            error: null,
            status: "success",
            isPaused: false
          });
        case "error":
          return _extends$2({}, state, {
            data: void 0,
            error: action.error,
            failureCount: state.failureCount + 1,
            isPaused: false,
            status: "error"
          });
        case "setState":
          return _extends$2({}, state, action.state);
        default:
          return state;
      }
    }
    var MutationCache = /* @__PURE__ */ function(_Subscribable) {
      _inheritsLoose(MutationCache2, _Subscribable);
      function MutationCache2(config2) {
        var _this;
        _this = _Subscribable.call(this) || this;
        _this.config = config2 || {};
        _this.mutations = [];
        _this.mutationId = 0;
        return _this;
      }
      var _proto = MutationCache2.prototype;
      _proto.build = function build(client, options, state) {
        var mutation = new Mutation({
          mutationCache: this,
          mutationId: ++this.mutationId,
          options: client.defaultMutationOptions(options),
          state,
          defaultOptions: options.mutationKey ? client.getMutationDefaults(options.mutationKey) : void 0,
          meta: options.meta
        });
        this.add(mutation);
        return mutation;
      };
      _proto.add = function add2(mutation) {
        this.mutations.push(mutation);
        this.notify(mutation);
      };
      _proto.remove = function remove(mutation) {
        this.mutations = this.mutations.filter(function(x2) {
          return x2 !== mutation;
        });
        mutation.cancel();
        this.notify(mutation);
      };
      _proto.clear = function clear() {
        var _this2 = this;
        notifyManager.batch(function() {
          _this2.mutations.forEach(function(mutation) {
            _this2.remove(mutation);
          });
        });
      };
      _proto.getAll = function getAll() {
        return this.mutations;
      };
      _proto.find = function find2(filters) {
        if (typeof filters.exact === "undefined") {
          filters.exact = true;
        }
        return this.mutations.find(function(mutation) {
          return matchMutation(filters, mutation);
        });
      };
      _proto.findAll = function findAll(filters) {
        return this.mutations.filter(function(mutation) {
          return matchMutation(filters, mutation);
        });
      };
      _proto.notify = function notify(mutation) {
        var _this3 = this;
        notifyManager.batch(function() {
          _this3.listeners.forEach(function(listener) {
            listener(mutation);
          });
        });
      };
      _proto.onFocus = function onFocus() {
        this.resumePausedMutations();
      };
      _proto.onOnline = function onOnline() {
        this.resumePausedMutations();
      };
      _proto.resumePausedMutations = function resumePausedMutations() {
        var pausedMutations = this.mutations.filter(function(x2) {
          return x2.state.isPaused;
        });
        return notifyManager.batch(function() {
          return pausedMutations.reduce(function(promise, mutation) {
            return promise.then(function() {
              return mutation.continue().catch(noop);
            });
          }, Promise.resolve());
        });
      };
      return MutationCache2;
    }(Subscribable);
    function infiniteQueryBehavior() {
      return {
        onFetch: function onFetch(context) {
          context.fetchFn = function() {
            var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;
            var refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;
            var fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;
            var pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;
            var isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === "forward";
            var isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === "backward";
            var oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];
            var oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];
            var abortController = getAbortController();
            var abortSignal = abortController == null ? void 0 : abortController.signal;
            var newPageParams = oldPageParams;
            var cancelled = false;
            var queryFn2 = context.options.queryFn || function() {
              return Promise.reject("Missing queryFn");
            };
            var buildNewPages = function buildNewPages2(pages, param2, page, previous2) {
              newPageParams = previous2 ? [param2].concat(newPageParams) : [].concat(newPageParams, [param2]);
              return previous2 ? [page].concat(pages) : [].concat(pages, [page]);
            };
            var fetchPage = function fetchPage2(pages, manual2, param2, previous2) {
              if (cancelled) {
                return Promise.reject("Cancelled");
              }
              if (typeof param2 === "undefined" && !manual2 && pages.length) {
                return Promise.resolve(pages);
              }
              var queryFnContext = {
                queryKey: context.queryKey,
                signal: abortSignal,
                pageParam: param2,
                meta: context.meta
              };
              var queryFnResult = queryFn2(queryFnContext);
              var promise2 = Promise.resolve(queryFnResult).then(function(page) {
                return buildNewPages(pages, param2, page, previous2);
              });
              if (isCancelable(queryFnResult)) {
                var promiseAsAny = promise2;
                promiseAsAny.cancel = queryFnResult.cancel;
              }
              return promise2;
            };
            var promise;
            if (!oldPages.length) {
              promise = fetchPage([]);
            } else if (isFetchingNextPage) {
              var manual = typeof pageParam !== "undefined";
              var param = manual ? pageParam : getNextPageParam(context.options, oldPages);
              promise = fetchPage(oldPages, manual, param);
            } else if (isFetchingPreviousPage) {
              var _manual = typeof pageParam !== "undefined";
              var _param = _manual ? pageParam : getPreviousPageParam(context.options, oldPages);
              promise = fetchPage(oldPages, _manual, _param, true);
            } else {
              (function() {
                newPageParams = [];
                var manual2 = typeof context.options.getNextPageParam === "undefined";
                var shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true;
                promise = shouldFetchFirstPage ? fetchPage([], manual2, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0]));
                var _loop = function _loop2(i3) {
                  promise = promise.then(function(pages) {
                    var shouldFetchNextPage = refetchPage && oldPages[i3] ? refetchPage(oldPages[i3], i3, oldPages) : true;
                    if (shouldFetchNextPage) {
                      var _param2 = manual2 ? oldPageParams[i3] : getNextPageParam(context.options, pages);
                      return fetchPage(pages, manual2, _param2);
                    }
                    return Promise.resolve(buildNewPages(pages, oldPageParams[i3], oldPages[i3]));
                  });
                };
                for (var i2 = 1; i2 < oldPages.length; i2++) {
                  _loop(i2);
                }
              })();
            }
            var finalPromise = promise.then(function(pages) {
              return {
                pages,
                pageParams: newPageParams
              };
            });
            var finalPromiseAsAny = finalPromise;
            finalPromiseAsAny.cancel = function() {
              cancelled = true;
              abortController == null ? void 0 : abortController.abort();
              if (isCancelable(promise)) {
                promise.cancel();
              }
            };
            return finalPromise;
          };
        }
      };
    }
    function getNextPageParam(options, pages) {
      return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);
    }
    function getPreviousPageParam(options, pages) {
      return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);
    }
    var QueryClient = /* @__PURE__ */ function() {
      function QueryClient2(config2) {
        if (config2 === void 0) {
          config2 = {};
        }
        this.queryCache = config2.queryCache || new QueryCache();
        this.mutationCache = config2.mutationCache || new MutationCache();
        this.defaultOptions = config2.defaultOptions || {};
        this.queryDefaults = [];
        this.mutationDefaults = [];
      }
      var _proto = QueryClient2.prototype;
      _proto.mount = function mount() {
        var _this = this;
        this.unsubscribeFocus = focusManager.subscribe(function() {
          if (focusManager.isFocused() && onlineManager.isOnline()) {
            _this.mutationCache.onFocus();
            _this.queryCache.onFocus();
          }
        });
        this.unsubscribeOnline = onlineManager.subscribe(function() {
          if (focusManager.isFocused() && onlineManager.isOnline()) {
            _this.mutationCache.onOnline();
            _this.queryCache.onOnline();
          }
        });
      };
      _proto.unmount = function unmount() {
        var _this$unsubscribeFocu, _this$unsubscribeOnli;
        (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);
        (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);
      };
      _proto.isFetching = function isFetching(arg1, arg2) {
        var _parseFilterArgs = parseFilterArgs(arg1, arg2), filters = _parseFilterArgs[0];
        filters.fetching = true;
        return this.queryCache.findAll(filters).length;
      };
      _proto.isMutating = function isMutating(filters) {
        return this.mutationCache.findAll(_extends$2({}, filters, {
          fetching: true
        })).length;
      };
      _proto.getQueryData = function getQueryData(queryKey, filters) {
        var _this$queryCache$find;
        return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;
      };
      _proto.getQueriesData = function getQueriesData(queryKeyOrFilters) {
        return this.getQueryCache().findAll(queryKeyOrFilters).map(function(_ref) {
          var queryKey = _ref.queryKey, state = _ref.state;
          var data = state.data;
          return [queryKey, data];
        });
      };
      _proto.setQueryData = function setQueryData(queryKey, updater, options) {
        var parsedOptions = parseQueryArgs(queryKey);
        var defaultedOptions = this.defaultQueryOptions(parsedOptions);
        return this.queryCache.build(this, defaultedOptions).setData(updater, options);
      };
      _proto.setQueriesData = function setQueriesData(queryKeyOrFilters, updater, options) {
        var _this2 = this;
        return notifyManager.batch(function() {
          return _this2.getQueryCache().findAll(queryKeyOrFilters).map(function(_ref2) {
            var queryKey = _ref2.queryKey;
            return [queryKey, _this2.setQueryData(queryKey, updater, options)];
          });
        });
      };
      _proto.getQueryState = function getQueryState(queryKey, filters) {
        var _this$queryCache$find2;
        return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;
      };
      _proto.removeQueries = function removeQueries(arg1, arg2) {
        var _parseFilterArgs2 = parseFilterArgs(arg1, arg2), filters = _parseFilterArgs2[0];
        var queryCache2 = this.queryCache;
        notifyManager.batch(function() {
          queryCache2.findAll(filters).forEach(function(query) {
            queryCache2.remove(query);
          });
        });
      };
      _proto.resetQueries = function resetQueries(arg1, arg2, arg3) {
        var _this3 = this;
        var _parseFilterArgs3 = parseFilterArgs(arg1, arg2, arg3), filters = _parseFilterArgs3[0], options = _parseFilterArgs3[1];
        var queryCache2 = this.queryCache;
        var refetchFilters = _extends$2({}, filters, {
          active: true
        });
        return notifyManager.batch(function() {
          queryCache2.findAll(filters).forEach(function(query) {
            query.reset();
          });
          return _this3.refetchQueries(refetchFilters, options);
        });
      };
      _proto.cancelQueries = function cancelQueries(arg1, arg2, arg3) {
        var _this4 = this;
        var _parseFilterArgs4 = parseFilterArgs(arg1, arg2, arg3), filters = _parseFilterArgs4[0], _parseFilterArgs4$ = _parseFilterArgs4[1], cancelOptions = _parseFilterArgs4$ === void 0 ? {} : _parseFilterArgs4$;
        if (typeof cancelOptions.revert === "undefined") {
          cancelOptions.revert = true;
        }
        var promises = notifyManager.batch(function() {
          return _this4.queryCache.findAll(filters).map(function(query) {
            return query.cancel(cancelOptions);
          });
        });
        return Promise.all(promises).then(noop).catch(noop);
      };
      _proto.invalidateQueries = function invalidateQueries(arg1, arg2, arg3) {
        var _ref3, _filters$refetchActiv, _filters$refetchInact, _this5 = this;
        var _parseFilterArgs5 = parseFilterArgs(arg1, arg2, arg3), filters = _parseFilterArgs5[0], options = _parseFilterArgs5[1];
        var refetchFilters = _extends$2({}, filters, {
          // if filters.refetchActive is not provided and filters.active is explicitly false,
          // e.g. invalidateQueries({ active: false }), we don't want to refetch active queries
          active: (_ref3 = (_filters$refetchActiv = filters.refetchActive) != null ? _filters$refetchActiv : filters.active) != null ? _ref3 : true,
          inactive: (_filters$refetchInact = filters.refetchInactive) != null ? _filters$refetchInact : false
        });
        return notifyManager.batch(function() {
          _this5.queryCache.findAll(filters).forEach(function(query) {
            query.invalidate();
          });
          return _this5.refetchQueries(refetchFilters, options);
        });
      };
      _proto.refetchQueries = function refetchQueries(arg1, arg2, arg3) {
        var _this6 = this;
        var _parseFilterArgs6 = parseFilterArgs(arg1, arg2, arg3), filters = _parseFilterArgs6[0], options = _parseFilterArgs6[1];
        var promises = notifyManager.batch(function() {
          return _this6.queryCache.findAll(filters).map(function(query) {
            return query.fetch(void 0, _extends$2({}, options, {
              meta: {
                refetchPage: filters == null ? void 0 : filters.refetchPage
              }
            }));
          });
        });
        var promise = Promise.all(promises).then(noop);
        if (!(options == null ? void 0 : options.throwOnError)) {
          promise = promise.catch(noop);
        }
        return promise;
      };
      _proto.fetchQuery = function fetchQuery(arg1, arg2, arg3) {
        var parsedOptions = parseQueryArgs(arg1, arg2, arg3);
        var defaultedOptions = this.defaultQueryOptions(parsedOptions);
        if (typeof defaultedOptions.retry === "undefined") {
          defaultedOptions.retry = false;
        }
        var query = this.queryCache.build(this, defaultedOptions);
        return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
      };
      _proto.prefetchQuery = function prefetchQuery(arg1, arg2, arg3) {
        return this.fetchQuery(arg1, arg2, arg3).then(noop).catch(noop);
      };
      _proto.fetchInfiniteQuery = function fetchInfiniteQuery(arg1, arg2, arg3) {
        var parsedOptions = parseQueryArgs(arg1, arg2, arg3);
        parsedOptions.behavior = infiniteQueryBehavior();
        return this.fetchQuery(parsedOptions);
      };
      _proto.prefetchInfiniteQuery = function prefetchInfiniteQuery(arg1, arg2, arg3) {
        return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop).catch(noop);
      };
      _proto.cancelMutations = function cancelMutations() {
        var _this7 = this;
        var promises = notifyManager.batch(function() {
          return _this7.mutationCache.getAll().map(function(mutation) {
            return mutation.cancel();
          });
        });
        return Promise.all(promises).then(noop).catch(noop);
      };
      _proto.resumePausedMutations = function resumePausedMutations() {
        return this.getMutationCache().resumePausedMutations();
      };
      _proto.executeMutation = function executeMutation(options) {
        return this.mutationCache.build(this, options).execute();
      };
      _proto.getQueryCache = function getQueryCache() {
        return this.queryCache;
      };
      _proto.getMutationCache = function getMutationCache() {
        return this.mutationCache;
      };
      _proto.getDefaultOptions = function getDefaultOptions() {
        return this.defaultOptions;
      };
      _proto.setDefaultOptions = function setDefaultOptions(options) {
        this.defaultOptions = options;
      };
      _proto.setQueryDefaults = function setQueryDefaults(queryKey, options) {
        var result = this.queryDefaults.find(function(x2) {
          return hashQueryKey(queryKey) === hashQueryKey(x2.queryKey);
        });
        if (result) {
          result.defaultOptions = options;
        } else {
          this.queryDefaults.push({
            queryKey,
            defaultOptions: options
          });
        }
      };
      _proto.getQueryDefaults = function getQueryDefaults(queryKey) {
        var _this$queryDefaults$f;
        return queryKey ? (_this$queryDefaults$f = this.queryDefaults.find(function(x2) {
          return partialMatchKey(queryKey, x2.queryKey);
        })) == null ? void 0 : _this$queryDefaults$f.defaultOptions : void 0;
      };
      _proto.setMutationDefaults = function setMutationDefaults(mutationKey, options) {
        var result = this.mutationDefaults.find(function(x2) {
          return hashQueryKey(mutationKey) === hashQueryKey(x2.mutationKey);
        });
        if (result) {
          result.defaultOptions = options;
        } else {
          this.mutationDefaults.push({
            mutationKey,
            defaultOptions: options
          });
        }
      };
      _proto.getMutationDefaults = function getMutationDefaults(mutationKey) {
        var _this$mutationDefault;
        return mutationKey ? (_this$mutationDefault = this.mutationDefaults.find(function(x2) {
          return partialMatchKey(mutationKey, x2.mutationKey);
        })) == null ? void 0 : _this$mutationDefault.defaultOptions : void 0;
      };
      _proto.defaultQueryOptions = function defaultQueryOptions(options) {
        if (options == null ? void 0 : options._defaulted) {
          return options;
        }
        var defaultedOptions = _extends$2({}, this.defaultOptions.queries, this.getQueryDefaults(options == null ? void 0 : options.queryKey), options, {
          _defaulted: true
        });
        if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {
          defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);
        }
        return defaultedOptions;
      };
      _proto.defaultQueryObserverOptions = function defaultQueryObserverOptions(options) {
        return this.defaultQueryOptions(options);
      };
      _proto.defaultMutationOptions = function defaultMutationOptions(options) {
        if (options == null ? void 0 : options._defaulted) {
          return options;
        }
        return _extends$2({}, this.defaultOptions.mutations, this.getMutationDefaults(options == null ? void 0 : options.mutationKey), options, {
          _defaulted: true
        });
      };
      _proto.clear = function clear() {
        this.queryCache.clear();
        this.mutationCache.clear();
      };
      return QueryClient2;
    }();
    var QueryObserver = /* @__PURE__ */ function(_Subscribable) {
      _inheritsLoose(QueryObserver2, _Subscribable);
      function QueryObserver2(client, options) {
        var _this;
        _this = _Subscribable.call(this) || this;
        _this.client = client;
        _this.options = options;
        _this.trackedProps = [];
        _this.selectError = null;
        _this.bindMethods();
        _this.setOptions(options);
        return _this;
      }
      var _proto = QueryObserver2.prototype;
      _proto.bindMethods = function bindMethods() {
        this.remove = this.remove.bind(this);
        this.refetch = this.refetch.bind(this);
      };
      _proto.onSubscribe = function onSubscribe() {
        if (this.listeners.length === 1) {
          this.currentQuery.addObserver(this);
          if (shouldFetchOnMount(this.currentQuery, this.options)) {
            this.executeFetch();
          }
          this.updateTimers();
        }
      };
      _proto.onUnsubscribe = function onUnsubscribe() {
        if (!this.listeners.length) {
          this.destroy();
        }
      };
      _proto.shouldFetchOnReconnect = function shouldFetchOnReconnect() {
        return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);
      };
      _proto.shouldFetchOnWindowFocus = function shouldFetchOnWindowFocus() {
        return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);
      };
      _proto.destroy = function destroy() {
        this.listeners = [];
        this.clearTimers();
        this.currentQuery.removeObserver(this);
      };
      _proto.setOptions = function setOptions(options, notifyOptions) {
        var prevOptions = this.options;
        var prevQuery = this.currentQuery;
        this.options = this.client.defaultQueryObserverOptions(options);
        if (typeof this.options.enabled !== "undefined" && typeof this.options.enabled !== "boolean") {
          throw new Error("Expected enabled to be a boolean");
        }
        if (!this.options.queryKey) {
          this.options.queryKey = prevOptions.queryKey;
        }
        this.updateQuery();
        var mounted = this.hasListeners();
        if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {
          this.executeFetch();
        }
        this.updateResult(notifyOptions);
        if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {
          this.updateStaleTimeout();
        }
        var nextRefetchInterval = this.computeRefetchInterval();
        if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {
          this.updateRefetchInterval(nextRefetchInterval);
        }
      };
      _proto.getOptimisticResult = function getOptimisticResult(options) {
        var defaultedOptions = this.client.defaultQueryObserverOptions(options);
        var query = this.client.getQueryCache().build(this.client, defaultedOptions);
        return this.createResult(query, defaultedOptions);
      };
      _proto.getCurrentResult = function getCurrentResult() {
        return this.currentResult;
      };
      _proto.trackResult = function trackResult(result, defaultedOptions) {
        var _this2 = this;
        var trackedResult = {};
        var trackProp = function trackProp2(key) {
          if (!_this2.trackedProps.includes(key)) {
            _this2.trackedProps.push(key);
          }
        };
        Object.keys(result).forEach(function(key) {
          Object.defineProperty(trackedResult, key, {
            configurable: false,
            enumerable: true,
            get: function get2() {
              trackProp(key);
              return result[key];
            }
          });
        });
        if (defaultedOptions.useErrorBoundary || defaultedOptions.suspense) {
          trackProp("error");
        }
        return trackedResult;
      };
      _proto.getNextResult = function getNextResult(options) {
        var _this3 = this;
        return new Promise(function(resolve, reject) {
          var unsubscribe = _this3.subscribe(function(result) {
            if (!result.isFetching) {
              unsubscribe();
              if (result.isError && (options == null ? void 0 : options.throwOnError)) {
                reject(result.error);
              } else {
                resolve(result);
              }
            }
          });
        });
      };
      _proto.getCurrentQuery = function getCurrentQuery() {
        return this.currentQuery;
      };
      _proto.remove = function remove() {
        this.client.getQueryCache().remove(this.currentQuery);
      };
      _proto.refetch = function refetch(options) {
        return this.fetch(_extends$2({}, options, {
          meta: {
            refetchPage: options == null ? void 0 : options.refetchPage
          }
        }));
      };
      _proto.fetchOptimistic = function fetchOptimistic(options) {
        var _this4 = this;
        var defaultedOptions = this.client.defaultQueryObserverOptions(options);
        var query = this.client.getQueryCache().build(this.client, defaultedOptions);
        return query.fetch().then(function() {
          return _this4.createResult(query, defaultedOptions);
        });
      };
      _proto.fetch = function fetch2(fetchOptions) {
        var _this5 = this;
        return this.executeFetch(fetchOptions).then(function() {
          _this5.updateResult();
          return _this5.currentResult;
        });
      };
      _proto.executeFetch = function executeFetch(fetchOptions) {
        this.updateQuery();
        var promise = this.currentQuery.fetch(this.options, fetchOptions);
        if (!(fetchOptions == null ? void 0 : fetchOptions.throwOnError)) {
          promise = promise.catch(noop);
        }
        return promise;
      };
      _proto.updateStaleTimeout = function updateStaleTimeout() {
        var _this6 = this;
        this.clearStaleTimeout();
        if (isServer || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {
          return;
        }
        var time = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime);
        var timeout = time + 1;
        this.staleTimeoutId = setTimeout(function() {
          if (!_this6.currentResult.isStale) {
            _this6.updateResult();
          }
        }, timeout);
      };
      _proto.computeRefetchInterval = function computeRefetchInterval() {
        var _this$options$refetch;
        return typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;
      };
      _proto.updateRefetchInterval = function updateRefetchInterval(nextInterval) {
        var _this7 = this;
        this.clearRefetchInterval();
        this.currentRefetchInterval = nextInterval;
        if (isServer || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {
          return;
        }
        this.refetchIntervalId = setInterval(function() {
          if (_this7.options.refetchIntervalInBackground || focusManager.isFocused()) {
            _this7.executeFetch();
          }
        }, this.currentRefetchInterval);
      };
      _proto.updateTimers = function updateTimers() {
        this.updateStaleTimeout();
        this.updateRefetchInterval(this.computeRefetchInterval());
      };
      _proto.clearTimers = function clearTimers() {
        this.clearStaleTimeout();
        this.clearRefetchInterval();
      };
      _proto.clearStaleTimeout = function clearStaleTimeout() {
        if (this.staleTimeoutId) {
          clearTimeout(this.staleTimeoutId);
          this.staleTimeoutId = void 0;
        }
      };
      _proto.clearRefetchInterval = function clearRefetchInterval() {
        if (this.refetchIntervalId) {
          clearInterval(this.refetchIntervalId);
          this.refetchIntervalId = void 0;
        }
      };
      _proto.createResult = function createResult(query, options) {
        var prevQuery = this.currentQuery;
        var prevOptions = this.options;
        var prevResult = this.currentResult;
        var prevResultState = this.currentResultState;
        var prevResultOptions = this.currentResultOptions;
        var queryChange = query !== prevQuery;
        var queryInitialState = queryChange ? query.state : this.currentQueryInitialState;
        var prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;
        var state = query.state;
        var dataUpdatedAt = state.dataUpdatedAt, error = state.error, errorUpdatedAt = state.errorUpdatedAt, isFetching = state.isFetching, status = state.status;
        var isPreviousData = false;
        var isPlaceholderData = false;
        var data;
        if (options.optimisticResults) {
          var mounted = this.hasListeners();
          var fetchOnMount = !mounted && shouldFetchOnMount(query, options);
          var fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);
          if (fetchOnMount || fetchOptionally) {
            isFetching = true;
            if (!dataUpdatedAt) {
              status = "loading";
            }
          }
        }
        if (options.keepPreviousData && !state.dataUpdateCount && (prevQueryResult == null ? void 0 : prevQueryResult.isSuccess) && status !== "error") {
          data = prevQueryResult.data;
          dataUpdatedAt = prevQueryResult.dataUpdatedAt;
          status = prevQueryResult.status;
          isPreviousData = true;
        } else if (options.select && typeof state.data !== "undefined") {
          if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {
            data = this.selectResult;
          } else {
            try {
              this.selectFn = options.select;
              data = options.select(state.data);
              if (options.structuralSharing !== false) {
                data = replaceEqualDeep(prevResult == null ? void 0 : prevResult.data, data);
              }
              this.selectResult = data;
              this.selectError = null;
            } catch (selectError) {
              getLogger().error(selectError);
              this.selectError = selectError;
            }
          }
        } else {
          data = state.data;
        }
        if (typeof options.placeholderData !== "undefined" && typeof data === "undefined" && (status === "loading" || status === "idle")) {
          var placeholderData;
          if ((prevResult == null ? void 0 : prevResult.isPlaceholderData) && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {
            placeholderData = prevResult.data;
          } else {
            placeholderData = typeof options.placeholderData === "function" ? options.placeholderData() : options.placeholderData;
            if (options.select && typeof placeholderData !== "undefined") {
              try {
                placeholderData = options.select(placeholderData);
                if (options.structuralSharing !== false) {
                  placeholderData = replaceEqualDeep(prevResult == null ? void 0 : prevResult.data, placeholderData);
                }
                this.selectError = null;
              } catch (selectError) {
                getLogger().error(selectError);
                this.selectError = selectError;
              }
            }
          }
          if (typeof placeholderData !== "undefined") {
            status = "success";
            data = placeholderData;
            isPlaceholderData = true;
          }
        }
        if (this.selectError) {
          error = this.selectError;
          data = this.selectResult;
          errorUpdatedAt = Date.now();
          status = "error";
        }
        var result = {
          status,
          isLoading: status === "loading",
          isSuccess: status === "success",
          isError: status === "error",
          isIdle: status === "idle",
          data,
          dataUpdatedAt,
          error,
          errorUpdatedAt,
          failureCount: state.fetchFailureCount,
          errorUpdateCount: state.errorUpdateCount,
          isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,
          isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,
          isFetching,
          isRefetching: isFetching && status !== "loading",
          isLoadingError: status === "error" && state.dataUpdatedAt === 0,
          isPlaceholderData,
          isPreviousData,
          isRefetchError: status === "error" && state.dataUpdatedAt !== 0,
          isStale: isStale(query, options),
          refetch: this.refetch,
          remove: this.remove
        };
        return result;
      };
      _proto.shouldNotifyListeners = function shouldNotifyListeners(result, prevResult) {
        if (!prevResult) {
          return true;
        }
        var _this$options = this.options, notifyOnChangeProps = _this$options.notifyOnChangeProps, notifyOnChangePropsExclusions = _this$options.notifyOnChangePropsExclusions;
        if (!notifyOnChangeProps && !notifyOnChangePropsExclusions) {
          return true;
        }
        if (notifyOnChangeProps === "tracked" && !this.trackedProps.length) {
          return true;
        }
        var includedProps = notifyOnChangeProps === "tracked" ? this.trackedProps : notifyOnChangeProps;
        return Object.keys(result).some(function(key) {
          var typedKey = key;
          var changed = result[typedKey] !== prevResult[typedKey];
          var isIncluded = includedProps == null ? void 0 : includedProps.some(function(x2) {
            return x2 === key;
          });
          var isExcluded = notifyOnChangePropsExclusions == null ? void 0 : notifyOnChangePropsExclusions.some(function(x2) {
            return x2 === key;
          });
          return changed && !isExcluded && (!includedProps || isIncluded);
        });
      };
      _proto.updateResult = function updateResult(notifyOptions) {
        var prevResult = this.currentResult;
        this.currentResult = this.createResult(this.currentQuery, this.options);
        this.currentResultState = this.currentQuery.state;
        this.currentResultOptions = this.options;
        if (shallowEqualObjects(this.currentResult, prevResult)) {
          return;
        }
        var defaultNotifyOptions = {
          cache: true
        };
        if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && this.shouldNotifyListeners(this.currentResult, prevResult)) {
          defaultNotifyOptions.listeners = true;
        }
        this.notify(_extends$2({}, defaultNotifyOptions, notifyOptions));
      };
      _proto.updateQuery = function updateQuery() {
        var query = this.client.getQueryCache().build(this.client, this.options);
        if (query === this.currentQuery) {
          return;
        }
        var prevQuery = this.currentQuery;
        this.currentQuery = query;
        this.currentQueryInitialState = query.state;
        this.previousQueryResult = this.currentResult;
        if (this.hasListeners()) {
          prevQuery == null ? void 0 : prevQuery.removeObserver(this);
          query.addObserver(this);
        }
      };
      _proto.onQueryUpdate = function onQueryUpdate(action) {
        var notifyOptions = {};
        if (action.type === "success") {
          notifyOptions.onSuccess = true;
        } else if (action.type === "error" && !isCancelledError(action.error)) {
          notifyOptions.onError = true;
        }
        this.updateResult(notifyOptions);
        if (this.hasListeners()) {
          this.updateTimers();
        }
      };
      _proto.notify = function notify(notifyOptions) {
        var _this8 = this;
        notifyManager.batch(function() {
          if (notifyOptions.onSuccess) {
            _this8.options.onSuccess == null ? void 0 : _this8.options.onSuccess(_this8.currentResult.data);
            _this8.options.onSettled == null ? void 0 : _this8.options.onSettled(_this8.currentResult.data, null);
          } else if (notifyOptions.onError) {
            _this8.options.onError == null ? void 0 : _this8.options.onError(_this8.currentResult.error);
            _this8.options.onSettled == null ? void 0 : _this8.options.onSettled(void 0, _this8.currentResult.error);
          }
          if (notifyOptions.listeners) {
            _this8.listeners.forEach(function(listener) {
              listener(_this8.currentResult);
            });
          }
          if (notifyOptions.cache) {
            _this8.client.getQueryCache().notify({
              query: _this8.currentQuery,
              type: "observerResultsUpdated"
            });
          }
        });
      };
      return QueryObserver2;
    }(Subscribable);
    function shouldLoadOnMount(query, options) {
      return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === "error" && options.retryOnMount === false);
    }
    function shouldFetchOnMount(query, options) {
      return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);
    }
    function shouldFetchOn(query, options, field) {
      if (options.enabled !== false) {
        var value = typeof field === "function" ? field(query) : field;
        return value === "always" || value !== false && isStale(query, options);
      }
      return false;
    }
    function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
      return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== "error") && isStale(query, options);
    }
    function isStale(query, options) {
      return query.isStaleByTime(options.staleTime);
    }
    var MutationObserver$1 = /* @__PURE__ */ function(_Subscribable) {
      _inheritsLoose(MutationObserver2, _Subscribable);
      function MutationObserver2(client, options) {
        var _this;
        _this = _Subscribable.call(this) || this;
        _this.client = client;
        _this.setOptions(options);
        _this.bindMethods();
        _this.updateResult();
        return _this;
      }
      var _proto = MutationObserver2.prototype;
      _proto.bindMethods = function bindMethods() {
        this.mutate = this.mutate.bind(this);
        this.reset = this.reset.bind(this);
      };
      _proto.setOptions = function setOptions(options) {
        this.options = this.client.defaultMutationOptions(options);
      };
      _proto.onUnsubscribe = function onUnsubscribe() {
        if (!this.listeners.length) {
          var _this$currentMutation;
          (_this$currentMutation = this.currentMutation) == null ? void 0 : _this$currentMutation.removeObserver(this);
        }
      };
      _proto.onMutationUpdate = function onMutationUpdate(action) {
        this.updateResult();
        var notifyOptions = {
          listeners: true
        };
        if (action.type === "success") {
          notifyOptions.onSuccess = true;
        } else if (action.type === "error") {
          notifyOptions.onError = true;
        }
        this.notify(notifyOptions);
      };
      _proto.getCurrentResult = function getCurrentResult() {
        return this.currentResult;
      };
      _proto.reset = function reset() {
        this.currentMutation = void 0;
        this.updateResult();
        this.notify({
          listeners: true
        });
      };
      _proto.mutate = function mutate2(variables, options) {
        this.mutateOptions = options;
        if (this.currentMutation) {
          this.currentMutation.removeObserver(this);
        }
        this.currentMutation = this.client.getMutationCache().build(this.client, _extends$2({}, this.options, {
          variables: typeof variables !== "undefined" ? variables : this.options.variables
        }));
        this.currentMutation.addObserver(this);
        return this.currentMutation.execute();
      };
      _proto.updateResult = function updateResult() {
        var state = this.currentMutation ? this.currentMutation.state : getDefaultState();
        var result = _extends$2({}, state, {
          isLoading: state.status === "loading",
          isSuccess: state.status === "success",
          isError: state.status === "error",
          isIdle: state.status === "idle",
          mutate: this.mutate,
          reset: this.reset
        });
        this.currentResult = result;
      };
      _proto.notify = function notify(options) {
        var _this2 = this;
        notifyManager.batch(function() {
          if (_this2.mutateOptions) {
            if (options.onSuccess) {
              _this2.mutateOptions.onSuccess == null ? void 0 : _this2.mutateOptions.onSuccess(_this2.currentResult.data, _this2.currentResult.variables, _this2.currentResult.context);
              _this2.mutateOptions.onSettled == null ? void 0 : _this2.mutateOptions.onSettled(_this2.currentResult.data, null, _this2.currentResult.variables, _this2.currentResult.context);
            } else if (options.onError) {
              _this2.mutateOptions.onError == null ? void 0 : _this2.mutateOptions.onError(_this2.currentResult.error, _this2.currentResult.variables, _this2.currentResult.context);
              _this2.mutateOptions.onSettled == null ? void 0 : _this2.mutateOptions.onSettled(void 0, _this2.currentResult.error, _this2.currentResult.variables, _this2.currentResult.context);
            }
          }
          if (options.listeners) {
            _this2.listeners.forEach(function(listener) {
              listener(_this2.currentResult);
            });
          }
        });
      };
      return MutationObserver2;
    }(Subscribable);
    var unstable_batchedUpdates = ReactDOM.unstable_batchedUpdates;
    notifyManager.setBatchNotifyFunction(unstable_batchedUpdates);
    var logger = console;
    setLogger(logger);
    var defaultContext = /* @__PURE__ */ React.createContext(void 0);
    var QueryClientSharingContext = /* @__PURE__ */ React.createContext(false);
    function getQueryClientContext(contextSharing) {
      if (contextSharing && typeof window !== "undefined") {
        if (!window.ReactQueryClientContext) {
          window.ReactQueryClientContext = defaultContext;
        }
        return window.ReactQueryClientContext;
      }
      return defaultContext;
    }
    var useQueryClient = function useQueryClient2() {
      var queryClient2 = React.useContext(getQueryClientContext(React.useContext(QueryClientSharingContext)));
      if (!queryClient2) {
        throw new Error("No QueryClient set, use QueryClientProvider to set one");
      }
      return queryClient2;
    };
    var QueryClientProvider = function QueryClientProvider2(_ref) {
      var client = _ref.client, _ref$contextSharing = _ref.contextSharing, contextSharing = _ref$contextSharing === void 0 ? false : _ref$contextSharing, children = _ref.children;
      React.useEffect(function() {
        client.mount();
        return function() {
          client.unmount();
        };
      }, [client]);
      var Context = getQueryClientContext(contextSharing);
      return /* @__PURE__ */ React.createElement(QueryClientSharingContext.Provider, {
        value: contextSharing
      }, /* @__PURE__ */ React.createElement(Context.Provider, {
        value: client
      }, children));
    };
    function createValue() {
      var _isReset = false;
      return {
        clearReset: function clearReset() {
          _isReset = false;
        },
        reset: function reset() {
          _isReset = true;
        },
        isReset: function isReset() {
          return _isReset;
        }
      };
    }
    var QueryErrorResetBoundaryContext = /* @__PURE__ */ React.createContext(createValue());
    var useQueryErrorResetBoundary = function useQueryErrorResetBoundary2() {
      return React.useContext(QueryErrorResetBoundaryContext);
    };
    function shouldThrowError(suspense, _useErrorBoundary, params) {
      if (typeof _useErrorBoundary === "function") {
        return _useErrorBoundary.apply(void 0, params);
      }
      if (typeof _useErrorBoundary === "boolean")
        return _useErrorBoundary;
      return !!suspense;
    }
    function useMutation$1(arg1, arg2, arg3) {
      var mountedRef = React.useRef(false);
      var _React$useState = React.useState(0), forceUpdate = _React$useState[1];
      var options = parseMutationArgs(arg1, arg2, arg3);
      var queryClient2 = useQueryClient();
      var obsRef = React.useRef();
      if (!obsRef.current) {
        obsRef.current = new MutationObserver$1(queryClient2, options);
      } else {
        obsRef.current.setOptions(options);
      }
      var currentResult = obsRef.current.getCurrentResult();
      React.useEffect(function() {
        mountedRef.current = true;
        var unsubscribe = obsRef.current.subscribe(notifyManager.batchCalls(function() {
          if (mountedRef.current) {
            forceUpdate(function(x2) {
              return x2 + 1;
            });
          }
        }));
        return function() {
          mountedRef.current = false;
          unsubscribe();
        };
      }, []);
      var mutate2 = React.useCallback(function(variables, mutateOptions) {
        obsRef.current.mutate(variables, mutateOptions).catch(noop);
      }, []);
      if (currentResult.error && shouldThrowError(void 0, obsRef.current.options.useErrorBoundary, [currentResult.error])) {
        throw currentResult.error;
      }
      return _extends$2({}, currentResult, {
        mutate: mutate2,
        mutateAsync: currentResult.mutate
      });
    }
    function useBaseQuery(options, Observer) {
      var mountedRef = React.useRef(false);
      var _React$useState = React.useState(0), forceUpdate = _React$useState[1];
      var queryClient2 = useQueryClient();
      var errorResetBoundary = useQueryErrorResetBoundary();
      var defaultedOptions = queryClient2.defaultQueryObserverOptions(options);
      defaultedOptions.optimisticResults = true;
      if (defaultedOptions.onError) {
        defaultedOptions.onError = notifyManager.batchCalls(defaultedOptions.onError);
      }
      if (defaultedOptions.onSuccess) {
        defaultedOptions.onSuccess = notifyManager.batchCalls(defaultedOptions.onSuccess);
      }
      if (defaultedOptions.onSettled) {
        defaultedOptions.onSettled = notifyManager.batchCalls(defaultedOptions.onSettled);
      }
      if (defaultedOptions.suspense) {
        if (typeof defaultedOptions.staleTime !== "number") {
          defaultedOptions.staleTime = 1e3;
        }
        if (defaultedOptions.cacheTime === 0) {
          defaultedOptions.cacheTime = 1;
        }
      }
      if (defaultedOptions.suspense || defaultedOptions.useErrorBoundary) {
        if (!errorResetBoundary.isReset()) {
          defaultedOptions.retryOnMount = false;
        }
      }
      var _React$useState2 = React.useState(function() {
        return new Observer(queryClient2, defaultedOptions);
      }), observer = _React$useState2[0];
      var result = observer.getOptimisticResult(defaultedOptions);
      React.useEffect(function() {
        mountedRef.current = true;
        errorResetBoundary.clearReset();
        var unsubscribe = observer.subscribe(notifyManager.batchCalls(function() {
          if (mountedRef.current) {
            forceUpdate(function(x2) {
              return x2 + 1;
            });
          }
        }));
        observer.updateResult();
        return function() {
          mountedRef.current = false;
          unsubscribe();
        };
      }, [errorResetBoundary, observer]);
      React.useEffect(function() {
        observer.setOptions(defaultedOptions, {
          listeners: false
        });
      }, [defaultedOptions, observer]);
      if (defaultedOptions.suspense && result.isLoading) {
        throw observer.fetchOptimistic(defaultedOptions).then(function(_ref) {
          var data = _ref.data;
          defaultedOptions.onSuccess == null ? void 0 : defaultedOptions.onSuccess(data);
          defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(data, null);
        }).catch(function(error) {
          errorResetBoundary.clearReset();
          defaultedOptions.onError == null ? void 0 : defaultedOptions.onError(error);
          defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(void 0, error);
        });
      }
      if (result.isError && !errorResetBoundary.isReset() && !result.isFetching && shouldThrowError(defaultedOptions.suspense, defaultedOptions.useErrorBoundary, [result.error, observer.getCurrentQuery()])) {
        throw result.error;
      }
      if (defaultedOptions.notifyOnChangeProps === "tracked") {
        result = observer.trackResult(result, defaultedOptions);
      }
      return result;
    }
    function useQuery$1(arg1, arg2, arg3) {
      var parsedOptions = parseQueryArgs(arg1, arg2, arg3);
      return useBaseQuery(parsedOptions, QueryObserver);
    }
    const queryCache = new QueryCache();
    const queryClient = new QueryClient({
      queryCache,
      defaultOptions: {
        queries: {
          enabled: true,
          retry: 0,
          staleTime: 0,
          cacheTime: 15 * 60 * 1e3,
          refetchOnWindowFocus: false,
          refetchOnMount: true,
          suspense: true
        }
      }
    });
    var lodash = { exports: {} };
    /**
     * @license
     * Lodash <https://lodash.com/>
     * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */
    lodash.exports;
    (function(module2, exports2) {
      (function() {
        var undefined$1;
        var VERSION = "4.17.21";
        var LARGE_ARRAY_SIZE = 200;
        var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        var MAX_MEMOIZE_SIZE = 500;
        var PLACEHOLDER = "__lodash_placeholder__";
        var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
        var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
        var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
        var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
        var HOT_COUNT = 800, HOT_SPAN = 16;
        var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
        var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
        var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var wrapFlags = [
          ["ary", WRAP_ARY_FLAG],
          ["bind", WRAP_BIND_FLAG],
          ["bindKey", WRAP_BIND_KEY_FLAG],
          ["curry", WRAP_CURRY_FLAG],
          ["curryRight", WRAP_CURRY_RIGHT_FLAG],
          ["flip", WRAP_FLIP_FLAG],
          ["partial", WRAP_PARTIAL_FLAG],
          ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
          ["rearg", WRAP_REARG_FLAG]
        ];
        var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
        var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
        var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
        var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
        var reTrimStart = /^\s+/;
        var reWhitespace = /\s/;
        var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
        var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
        var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
        var reEscapeChar = /\\(\\)?/g;
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
        var reFlags = /\w*$/;
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary = /^0b[01]+$/i;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var reIsOctal = /^0o[0-7]+$/i;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
        var reNoMatch = /($^)/;
        var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
        var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
        var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
        var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
        var reApos = RegExp(rsApos, "g");
        var reComboMark = RegExp(rsCombo, "g");
        var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
        var reUnicodeWord = RegExp([
          rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
          rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
          rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
          rsUpper + "+" + rsOptContrUpper,
          rsOrdUpper,
          rsOrdLower,
          rsDigits,
          rsEmoji
        ].join("|"), "g");
        var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
        var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
        var contextProps = [
          "Array",
          "Buffer",
          "DataView",
          "Date",
          "Error",
          "Float32Array",
          "Float64Array",
          "Function",
          "Int8Array",
          "Int16Array",
          "Int32Array",
          "Map",
          "Math",
          "Object",
          "Promise",
          "RegExp",
          "Set",
          "String",
          "Symbol",
          "TypeError",
          "Uint8Array",
          "Uint8ClampedArray",
          "Uint16Array",
          "Uint32Array",
          "WeakMap",
          "_",
          "clearTimeout",
          "isFinite",
          "parseInt",
          "setTimeout"
        ];
        var templateCounter = -1;
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
        var deburredLetters = {
          // Latin-1 Supplement block.
          "À": "A",
          "Á": "A",
          "Â": "A",
          "Ã": "A",
          "Ä": "A",
          "Å": "A",
          "à": "a",
          "á": "a",
          "â": "a",
          "ã": "a",
          "ä": "a",
          "å": "a",
          "Ç": "C",
          "ç": "c",
          "Ð": "D",
          "ð": "d",
          "È": "E",
          "É": "E",
          "Ê": "E",
          "Ë": "E",
          "è": "e",
          "é": "e",
          "ê": "e",
          "ë": "e",
          "Ì": "I",
          "Í": "I",
          "Î": "I",
          "Ï": "I",
          "ì": "i",
          "í": "i",
          "î": "i",
          "ï": "i",
          "Ñ": "N",
          "ñ": "n",
          "Ò": "O",
          "Ó": "O",
          "Ô": "O",
          "Õ": "O",
          "Ö": "O",
          "Ø": "O",
          "ò": "o",
          "ó": "o",
          "ô": "o",
          "õ": "o",
          "ö": "o",
          "ø": "o",
          "Ù": "U",
          "Ú": "U",
          "Û": "U",
          "Ü": "U",
          "ù": "u",
          "ú": "u",
          "û": "u",
          "ü": "u",
          "Ý": "Y",
          "ý": "y",
          "ÿ": "y",
          "Æ": "Ae",
          "æ": "ae",
          "Þ": "Th",
          "þ": "th",
          "ß": "ss",
          // Latin Extended-A block.
          "Ā": "A",
          "Ă": "A",
          "Ą": "A",
          "ā": "a",
          "ă": "a",
          "ą": "a",
          "Ć": "C",
          "Ĉ": "C",
          "Ċ": "C",
          "Č": "C",
          "ć": "c",
          "ĉ": "c",
          "ċ": "c",
          "č": "c",
          "Ď": "D",
          "Đ": "D",
          "ď": "d",
          "đ": "d",
          "Ē": "E",
          "Ĕ": "E",
          "Ė": "E",
          "Ę": "E",
          "Ě": "E",
          "ē": "e",
          "ĕ": "e",
          "ė": "e",
          "ę": "e",
          "ě": "e",
          "Ĝ": "G",
          "Ğ": "G",
          "Ġ": "G",
          "Ģ": "G",
          "ĝ": "g",
          "ğ": "g",
          "ġ": "g",
          "ģ": "g",
          "Ĥ": "H",
          "Ħ": "H",
          "ĥ": "h",
          "ħ": "h",
          "Ĩ": "I",
          "Ī": "I",
          "Ĭ": "I",
          "Į": "I",
          "İ": "I",
          "ĩ": "i",
          "ī": "i",
          "ĭ": "i",
          "į": "i",
          "ı": "i",
          "Ĵ": "J",
          "ĵ": "j",
          "Ķ": "K",
          "ķ": "k",
          "ĸ": "k",
          "Ĺ": "L",
          "Ļ": "L",
          "Ľ": "L",
          "Ŀ": "L",
          "Ł": "L",
          "ĺ": "l",
          "ļ": "l",
          "ľ": "l",
          "ŀ": "l",
          "ł": "l",
          "Ń": "N",
          "Ņ": "N",
          "Ň": "N",
          "Ŋ": "N",
          "ń": "n",
          "ņ": "n",
          "ň": "n",
          "ŋ": "n",
          "Ō": "O",
          "Ŏ": "O",
          "Ő": "O",
          "ō": "o",
          "ŏ": "o",
          "ő": "o",
          "Ŕ": "R",
          "Ŗ": "R",
          "Ř": "R",
          "ŕ": "r",
          "ŗ": "r",
          "ř": "r",
          "Ś": "S",
          "Ŝ": "S",
          "Ş": "S",
          "Š": "S",
          "ś": "s",
          "ŝ": "s",
          "ş": "s",
          "š": "s",
          "Ţ": "T",
          "Ť": "T",
          "Ŧ": "T",
          "ţ": "t",
          "ť": "t",
          "ŧ": "t",
          "Ũ": "U",
          "Ū": "U",
          "Ŭ": "U",
          "Ů": "U",
          "Ű": "U",
          "Ų": "U",
          "ũ": "u",
          "ū": "u",
          "ŭ": "u",
          "ů": "u",
          "ű": "u",
          "ų": "u",
          "Ŵ": "W",
          "ŵ": "w",
          "Ŷ": "Y",
          "ŷ": "y",
          "Ÿ": "Y",
          "Ź": "Z",
          "Ż": "Z",
          "Ž": "Z",
          "ź": "z",
          "ż": "z",
          "ž": "z",
          "Ĳ": "IJ",
          "ĳ": "ij",
          "Œ": "Oe",
          "œ": "oe",
          "ŉ": "'n",
          "ſ": "s"
        };
        var htmlEscapes = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;"
        };
        var htmlUnescapes = {
          "&amp;": "&",
          "&lt;": "<",
          "&gt;": ">",
          "&quot;": '"',
          "&#39;": "'"
        };
        var stringEscapes = {
          "\\": "\\",
          "'": "'",
          "\n": "n",
          "\r": "r",
          "\u2028": "u2028",
          "\u2029": "u2029"
        };
        var freeParseFloat = parseFloat, freeParseInt = parseInt;
        var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root2 = freeGlobal || freeSelf || Function("return this")();
        var freeExports = exports2 && !exports2.nodeType && exports2;
        var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var freeProcess = moduleExports && freeGlobal.process;
        var nodeUtil = function() {
          try {
            var types2 = freeModule && freeModule.require && freeModule.require("util").types;
            if (types2) {
              return types2;
            }
            return freeProcess && freeProcess.binding && freeProcess.binding("util");
          } catch (e2) {
          }
        }();
        var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        function apply(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }
        function arrayAggregator(array, setter, iteratee, accumulator) {
          var index2 = -1, length2 = array == null ? 0 : array.length;
          while (++index2 < length2) {
            var value = array[index2];
            setter(accumulator, value, iteratee(value), array);
          }
          return accumulator;
        }
        function arrayEach(array, iteratee) {
          var index2 = -1, length2 = array == null ? 0 : array.length;
          while (++index2 < length2) {
            if (iteratee(array[index2], index2, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEachRight(array, iteratee) {
          var length2 = array == null ? 0 : array.length;
          while (length2--) {
            if (iteratee(array[length2], length2, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEvery(array, predicate) {
          var index2 = -1, length2 = array == null ? 0 : array.length;
          while (++index2 < length2) {
            if (!predicate(array[index2], index2, array)) {
              return false;
            }
          }
          return true;
        }
        function arrayFilter(array, predicate) {
          var index2 = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
          while (++index2 < length2) {
            var value = array[index2];
            if (predicate(value, index2, array)) {
              result[resIndex++] = value;
            }
          }
          return result;
        }
        function arrayIncludes(array, value) {
          var length2 = array == null ? 0 : array.length;
          return !!length2 && baseIndexOf(array, value, 0) > -1;
        }
        function arrayIncludesWith(array, value, comparator) {
          var index2 = -1, length2 = array == null ? 0 : array.length;
          while (++index2 < length2) {
            if (comparator(value, array[index2])) {
              return true;
            }
          }
          return false;
        }
        function arrayMap(array, iteratee) {
          var index2 = -1, length2 = array == null ? 0 : array.length, result = Array(length2);
          while (++index2 < length2) {
            result[index2] = iteratee(array[index2], index2, array);
          }
          return result;
        }
        function arrayPush(array, values) {
          var index2 = -1, length2 = values.length, offset2 = array.length;
          while (++index2 < length2) {
            array[offset2 + index2] = values[index2];
          }
          return array;
        }
        function arrayReduce(array, iteratee, accumulator, initAccum) {
          var index2 = -1, length2 = array == null ? 0 : array.length;
          if (initAccum && length2) {
            accumulator = array[++index2];
          }
          while (++index2 < length2) {
            accumulator = iteratee(accumulator, array[index2], index2, array);
          }
          return accumulator;
        }
        function arrayReduceRight(array, iteratee, accumulator, initAccum) {
          var length2 = array == null ? 0 : array.length;
          if (initAccum && length2) {
            accumulator = array[--length2];
          }
          while (length2--) {
            accumulator = iteratee(accumulator, array[length2], length2, array);
          }
          return accumulator;
        }
        function arraySome(array, predicate) {
          var index2 = -1, length2 = array == null ? 0 : array.length;
          while (++index2 < length2) {
            if (predicate(array[index2], index2, array)) {
              return true;
            }
          }
          return false;
        }
        var asciiSize = baseProperty("length");
        function asciiToArray(string2) {
          return string2.split("");
        }
        function asciiWords(string2) {
          return string2.match(reAsciiWord) || [];
        }
        function baseFindKey(collection, predicate, eachFunc) {
          var result;
          eachFunc(collection, function(value, key, collection2) {
            if (predicate(value, key, collection2)) {
              result = key;
              return false;
            }
          });
          return result;
        }
        function baseFindIndex(array, predicate, fromIndex, fromRight) {
          var length2 = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
          while (fromRight ? index2-- : ++index2 < length2) {
            if (predicate(array[index2], index2, array)) {
              return index2;
            }
          }
          return -1;
        }
        function baseIndexOf(array, value, fromIndex) {
          return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
        }
        function baseIndexOfWith(array, value, fromIndex, comparator) {
          var index2 = fromIndex - 1, length2 = array.length;
          while (++index2 < length2) {
            if (comparator(array[index2], value)) {
              return index2;
            }
          }
          return -1;
        }
        function baseIsNaN(value) {
          return value !== value;
        }
        function baseMean(array, iteratee) {
          var length2 = array == null ? 0 : array.length;
          return length2 ? baseSum(array, iteratee) / length2 : NAN;
        }
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined$1 : object[key];
          };
        }
        function basePropertyOf(object) {
          return function(key) {
            return object == null ? undefined$1 : object[key];
          };
        }
        function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
          eachFunc(collection, function(value, index2, collection2) {
            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
          });
          return accumulator;
        }
        function baseSortBy(array, comparer) {
          var length2 = array.length;
          array.sort(comparer);
          while (length2--) {
            array[length2] = array[length2].value;
          }
          return array;
        }
        function baseSum(array, iteratee) {
          var result, index2 = -1, length2 = array.length;
          while (++index2 < length2) {
            var current = iteratee(array[index2]);
            if (current !== undefined$1) {
              result = result === undefined$1 ? current : result + current;
            }
          }
          return result;
        }
        function baseTimes(n2, iteratee) {
          var index2 = -1, result = Array(n2);
          while (++index2 < n2) {
            result[index2] = iteratee(index2);
          }
          return result;
        }
        function baseToPairs(object, props) {
          return arrayMap(props, function(key) {
            return [key, object[key]];
          });
        }
        function baseTrim(string2) {
          return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
        }
        function baseUnary(func) {
          return function(value) {
            return func(value);
          };
        }
        function baseValues(object, props) {
          return arrayMap(props, function(key) {
            return object[key];
          });
        }
        function cacheHas(cache2, key) {
          return cache2.has(key);
        }
        function charsStartIndex(strSymbols, chrSymbols) {
          var index2 = -1, length2 = strSymbols.length;
          while (++index2 < length2 && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
          }
          return index2;
        }
        function charsEndIndex(strSymbols, chrSymbols) {
          var index2 = strSymbols.length;
          while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
          }
          return index2;
        }
        function countHolders(array, placeholder) {
          var length2 = array.length, result = 0;
          while (length2--) {
            if (array[length2] === placeholder) {
              ++result;
            }
          }
          return result;
        }
        var deburrLetter = basePropertyOf(deburredLetters);
        var escapeHtmlChar = basePropertyOf(htmlEscapes);
        function escapeStringChar(chr) {
          return "\\" + stringEscapes[chr];
        }
        function getValue(object, key) {
          return object == null ? undefined$1 : object[key];
        }
        function hasUnicode(string2) {
          return reHasUnicode.test(string2);
        }
        function hasUnicodeWord(string2) {
          return reHasUnicodeWord.test(string2);
        }
        function iteratorToArray(iterator) {
          var data, result = [];
          while (!(data = iterator.next()).done) {
            result.push(data.value);
          }
          return result;
        }
        function mapToArray(map2) {
          var index2 = -1, result = Array(map2.size);
          map2.forEach(function(value, key) {
            result[++index2] = [key, value];
          });
          return result;
        }
        function overArg(func, transform2) {
          return function(arg) {
            return func(transform2(arg));
          };
        }
        function replaceHolders(array, placeholder) {
          var index2 = -1, length2 = array.length, resIndex = 0, result = [];
          while (++index2 < length2) {
            var value = array[index2];
            if (value === placeholder || value === PLACEHOLDER) {
              array[index2] = PLACEHOLDER;
              result[resIndex++] = index2;
            }
          }
          return result;
        }
        function setToArray(set2) {
          var index2 = -1, result = Array(set2.size);
          set2.forEach(function(value) {
            result[++index2] = value;
          });
          return result;
        }
        function setToPairs(set2) {
          var index2 = -1, result = Array(set2.size);
          set2.forEach(function(value) {
            result[++index2] = [value, value];
          });
          return result;
        }
        function strictIndexOf(array, value, fromIndex) {
          var index2 = fromIndex - 1, length2 = array.length;
          while (++index2 < length2) {
            if (array[index2] === value) {
              return index2;
            }
          }
          return -1;
        }
        function strictLastIndexOf(array, value, fromIndex) {
          var index2 = fromIndex + 1;
          while (index2--) {
            if (array[index2] === value) {
              return index2;
            }
          }
          return index2;
        }
        function stringSize(string2) {
          return hasUnicode(string2) ? unicodeSize(string2) : asciiSize(string2);
        }
        function stringToArray(string2) {
          return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
        }
        function trimmedEndIndex(string2) {
          var index2 = string2.length;
          while (index2-- && reWhitespace.test(string2.charAt(index2))) {
          }
          return index2;
        }
        var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
        function unicodeSize(string2) {
          var result = reUnicode.lastIndex = 0;
          while (reUnicode.test(string2)) {
            ++result;
          }
          return result;
        }
        function unicodeToArray(string2) {
          return string2.match(reUnicode) || [];
        }
        function unicodeWords(string2) {
          return string2.match(reUnicodeWord) || [];
        }
        var runInContext = function runInContext2(context) {
          context = context == null ? root2 : _2.defaults(root2.Object(), context, _2.pick(root2, contextProps));
          var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
          var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
          var coreJsData = context["__core-js_shared__"];
          var funcToString = funcProto.toString;
          var hasOwnProperty2 = objectProto.hasOwnProperty;
          var idCounter = 0;
          var maskSrcKey = function() {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
            return uid ? "Symbol(src)_1." + uid : "";
          }();
          var nativeObjectToString = objectProto.toString;
          var objectCtorString = funcToString.call(Object2);
          var oldDash = root2._;
          var reIsNative = RegExp2(
            "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
          );
          var Buffer2 = moduleExports ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice2 = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1;
          var defineProperty2 = function() {
            try {
              var func = getNative(Object2, "defineProperty");
              func({}, "", {});
              return func;
            } catch (e2) {
            }
          }();
          var ctxClearTimeout = context.clearTimeout !== root2.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root2.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root2.setTimeout && context.setTimeout;
          var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
          var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
          var metaMap = WeakMap2 && new WeakMap2();
          var realNames = {};
          var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
          var symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
          function lodash2(value) {
            if (isObjectLike(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
              if (value instanceof LodashWrapper) {
                return value;
              }
              if (hasOwnProperty2.call(value, "__wrapped__")) {
                return wrapperClone(value);
              }
            }
            return new LodashWrapper(value);
          }
          var baseCreate = function() {
            function object() {
            }
            return function(proto2) {
              if (!isObject2(proto2)) {
                return {};
              }
              if (objectCreate) {
                return objectCreate(proto2);
              }
              object.prototype = proto2;
              var result2 = new object();
              object.prototype = undefined$1;
              return result2;
            };
          }();
          function baseLodash() {
          }
          function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__chain__ = !!chainAll;
            this.__index__ = 0;
            this.__values__ = undefined$1;
          }
          lodash2.templateSettings = {
            /**
             * Used to detect `data` property values to be HTML-escaped.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "escape": reEscape,
            /**
             * Used to detect code to be evaluated.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "evaluate": reEvaluate,
            /**
             * Used to detect `data` property values to inject.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "interpolate": reInterpolate,
            /**
             * Used to reference the data object in the template text.
             *
             * @memberOf _.templateSettings
             * @type {string}
             */
            "variable": "",
            /**
             * Used to import variables into the compiled template.
             *
             * @memberOf _.templateSettings
             * @type {Object}
             */
            "imports": {
              /**
               * A reference to the `lodash` function.
               *
               * @memberOf _.templateSettings.imports
               * @type {Function}
               */
              "_": lodash2
            }
          };
          lodash2.prototype = baseLodash.prototype;
          lodash2.prototype.constructor = lodash2;
          LodashWrapper.prototype = baseCreate(baseLodash.prototype);
          LodashWrapper.prototype.constructor = LodashWrapper;
          function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = MAX_ARRAY_LENGTH;
            this.__views__ = [];
          }
          function lazyClone() {
            var result2 = new LazyWrapper(this.__wrapped__);
            result2.__actions__ = copyArray(this.__actions__);
            result2.__dir__ = this.__dir__;
            result2.__filtered__ = this.__filtered__;
            result2.__iteratees__ = copyArray(this.__iteratees__);
            result2.__takeCount__ = this.__takeCount__;
            result2.__views__ = copyArray(this.__views__);
            return result2;
          }
          function lazyReverse() {
            if (this.__filtered__) {
              var result2 = new LazyWrapper(this);
              result2.__dir__ = -1;
              result2.__filtered__ = true;
            } else {
              result2 = this.clone();
              result2.__dir__ *= -1;
            }
            return result2;
          }
          function lazyValue() {
            var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length2 = end - start, index2 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length2, this.__takeCount__);
            if (!isArr || !isRight && arrLength == length2 && takeCount == length2) {
              return baseWrapperValue(array, this.__actions__);
            }
            var result2 = [];
            outer:
              while (length2-- && resIndex < takeCount) {
                index2 += dir;
                var iterIndex = -1, value = array[index2];
                while (++iterIndex < iterLength) {
                  var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                  if (type == LAZY_MAP_FLAG) {
                    value = computed;
                  } else if (!computed) {
                    if (type == LAZY_FILTER_FLAG) {
                      continue outer;
                    } else {
                      break outer;
                    }
                  }
                }
                result2[resIndex++] = value;
              }
            return result2;
          }
          LazyWrapper.prototype = baseCreate(baseLodash.prototype);
          LazyWrapper.prototype.constructor = LazyWrapper;
          function Hash(entries) {
            var index2 = -1, length2 = entries == null ? 0 : entries.length;
            this.clear();
            while (++index2 < length2) {
              var entry = entries[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
          }
          function hashDelete(key) {
            var result2 = this.has(key) && delete this.__data__[key];
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result2 = data[key];
              return result2 === HASH_UNDEFINED ? undefined$1 : result2;
            }
            return hasOwnProperty2.call(data, key) ? data[key] : undefined$1;
          }
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined$1 : hasOwnProperty2.call(data, key);
          }
          function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value;
            return this;
          }
          Hash.prototype.clear = hashClear;
          Hash.prototype["delete"] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;
          function ListCache(entries) {
            var index2 = -1, length2 = entries == null ? 0 : entries.length;
            this.clear();
            while (++index2 < length2) {
              var entry = entries[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
          }
          function listCacheDelete(key) {
            var data = this.__data__, index2 = assocIndexOf(data, key);
            if (index2 < 0) {
              return false;
            }
            var lastIndex2 = data.length - 1;
            if (index2 == lastIndex2) {
              data.pop();
            } else {
              splice2.call(data, index2, 1);
            }
            --this.size;
            return true;
          }
          function listCacheGet(key) {
            var data = this.__data__, index2 = assocIndexOf(data, key);
            return index2 < 0 ? undefined$1 : data[index2][1];
          }
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }
          function listCacheSet(key, value) {
            var data = this.__data__, index2 = assocIndexOf(data, key);
            if (index2 < 0) {
              ++this.size;
              data.push([key, value]);
            } else {
              data[index2][1] = value;
            }
            return this;
          }
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype["delete"] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;
          function MapCache(entries) {
            var index2 = -1, length2 = entries == null ? 0 : entries.length;
            this.clear();
            while (++index2 < length2) {
              var entry = entries[index2];
              this.set(entry[0], entry[1]);
            }
          }
          function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
              "hash": new Hash(),
              "map": new (Map2 || ListCache)(),
              "string": new Hash()
            };
          }
          function mapCacheDelete(key) {
            var result2 = getMapData(this, key)["delete"](key);
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }
          function mapCacheSet(key, value) {
            var data = getMapData(this, key), size2 = data.size;
            data.set(key, value);
            this.size += data.size == size2 ? 0 : 1;
            return this;
          }
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype["delete"] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;
          function SetCache(values2) {
            var index2 = -1, length2 = values2 == null ? 0 : values2.length;
            this.__data__ = new MapCache();
            while (++index2 < length2) {
              this.add(values2[index2]);
            }
          }
          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);
            return this;
          }
          function setCacheHas(value) {
            return this.__data__.has(value);
          }
          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
          SetCache.prototype.has = setCacheHas;
          function Stack2(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
          }
          function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
          }
          function stackDelete(key) {
            var data = this.__data__, result2 = data["delete"](key);
            this.size = data.size;
            return result2;
          }
          function stackGet(key) {
            return this.__data__.get(key);
          }
          function stackHas(key) {
            return this.__data__.has(key);
          }
          function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
              var pairs = data.__data__;
              if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
              }
              data = this.__data__ = new MapCache(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
          }
          Stack2.prototype.clear = stackClear;
          Stack2.prototype["delete"] = stackDelete;
          Stack2.prototype.get = stackGet;
          Stack2.prototype.has = stackHas;
          Stack2.prototype.set = stackSet;
          function arrayLikeKeys(value, inherited) {
            var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length2 = result2.length;
            for (var key in value) {
              if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
              (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
              isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
              isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
              isIndex(key, length2)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function arraySample(array) {
            var length2 = array.length;
            return length2 ? array[baseRandom(0, length2 - 1)] : undefined$1;
          }
          function arraySampleSize(array, n2) {
            return shuffleSelf(copyArray(array), baseClamp(n2, 0, array.length));
          }
          function arrayShuffle(array) {
            return shuffleSelf(copyArray(array));
          }
          function assignMergeValue(object, key, value) {
            if (value !== undefined$1 && !eq(object[key], value) || value === undefined$1 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === undefined$1 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assocIndexOf(array, key) {
            var length2 = array.length;
            while (length2--) {
              if (eq(array[length2][0], key)) {
                return length2;
              }
            }
            return -1;
          }
          function baseAggregator(collection, setter, iteratee2, accumulator) {
            baseEach(collection, function(value, key, collection2) {
              setter(accumulator, value, iteratee2(value), collection2);
            });
            return accumulator;
          }
          function baseAssign(object, source) {
            return object && copyObject(source, keys2(source), object);
          }
          function baseAssignIn(object, source) {
            return object && copyObject(source, keysIn(source), object);
          }
          function baseAssignValue(object, key, value) {
            if (key == "__proto__" && defineProperty2) {
              defineProperty2(object, key, {
                "configurable": true,
                "enumerable": true,
                "value": value,
                "writable": true
              });
            } else {
              object[key] = value;
            }
          }
          function baseAt(object, paths) {
            var index2 = -1, length2 = paths.length, result2 = Array2(length2), skip = object == null;
            while (++index2 < length2) {
              result2[index2] = skip ? undefined$1 : get2(object, paths[index2]);
            }
            return result2;
          }
          function baseClamp(number2, lower, upper) {
            if (number2 === number2) {
              if (upper !== undefined$1) {
                number2 = number2 <= upper ? number2 : upper;
              }
              if (lower !== undefined$1) {
                number2 = number2 >= lower ? number2 : lower;
              }
            }
            return number2;
          }
          function baseClone(value, bitmask, customizer, key, object, stack) {
            var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
            if (customizer) {
              result2 = object ? customizer(value, key, object, stack) : customizer(value);
            }
            if (result2 !== undefined$1) {
              return result2;
            }
            if (!isObject2(value)) {
              return value;
            }
            var isArr = isArray2(value);
            if (isArr) {
              result2 = initCloneArray(value);
              if (!isDeep) {
                return copyArray(value, result2);
              }
            } else {
              var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
              if (isBuffer2(value)) {
                return cloneBuffer(value, isDeep);
              }
              if (tag == objectTag || tag == argsTag || isFunc && !object) {
                result2 = isFlat || isFunc ? {} : initCloneObject(value);
                if (!isDeep) {
                  return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
                }
              } else {
                if (!cloneableTags[tag]) {
                  return object ? value : {};
                }
                result2 = initCloneByTag(value, tag, isDeep);
              }
            }
            stack || (stack = new Stack2());
            var stacked = stack.get(value);
            if (stacked) {
              return stacked;
            }
            stack.set(value, result2);
            if (isSet(value)) {
              value.forEach(function(subValue) {
                result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
              });
            } else if (isMap(value)) {
              value.forEach(function(subValue, key2) {
                result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
              });
            }
            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys2;
            var props = isArr ? undefined$1 : keysFunc(value);
            arrayEach(props || value, function(subValue, key2) {
              if (props) {
                key2 = subValue;
                subValue = value[key2];
              }
              assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
            return result2;
          }
          function baseConforms(source) {
            var props = keys2(source);
            return function(object) {
              return baseConformsTo(object, source, props);
            };
          }
          function baseConformsTo(object, source, props) {
            var length2 = props.length;
            if (object == null) {
              return !length2;
            }
            object = Object2(object);
            while (length2--) {
              var key = props[length2], predicate = source[key], value = object[key];
              if (value === undefined$1 && !(key in object) || !predicate(value)) {
                return false;
              }
            }
            return true;
          }
          function baseDelay(func, wait, args) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return setTimeout2(function() {
              func.apply(undefined$1, args);
            }, wait);
          }
          function baseDifference(array, values2, iteratee2, comparator) {
            var index2 = -1, includes3 = arrayIncludes, isCommon = true, length2 = array.length, result2 = [], valuesLength = values2.length;
            if (!length2) {
              return result2;
            }
            if (iteratee2) {
              values2 = arrayMap(values2, baseUnary(iteratee2));
            }
            if (comparator) {
              includes3 = arrayIncludesWith;
              isCommon = false;
            } else if (values2.length >= LARGE_ARRAY_SIZE) {
              includes3 = cacheHas;
              isCommon = false;
              values2 = new SetCache(values2);
            }
            outer:
              while (++index2 < length2) {
                var value = array[index2], computed = iteratee2 == null ? value : iteratee2(value);
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var valuesIndex = valuesLength;
                  while (valuesIndex--) {
                    if (values2[valuesIndex] === computed) {
                      continue outer;
                    }
                  }
                  result2.push(value);
                } else if (!includes3(values2, computed, comparator)) {
                  result2.push(value);
                }
              }
            return result2;
          }
          var baseEach = createBaseEach(baseForOwn);
          var baseEachRight = createBaseEach(baseForOwnRight, true);
          function baseEvery(collection, predicate) {
            var result2 = true;
            baseEach(collection, function(value, index2, collection2) {
              result2 = !!predicate(value, index2, collection2);
              return result2;
            });
            return result2;
          }
          function baseExtremum(array, iteratee2, comparator) {
            var index2 = -1, length2 = array.length;
            while (++index2 < length2) {
              var value = array[index2], current = iteratee2(value);
              if (current != null && (computed === undefined$1 ? current === current && !isSymbol(current) : comparator(current, computed))) {
                var computed = current, result2 = value;
              }
            }
            return result2;
          }
          function baseFill(array, value, start, end) {
            var length2 = array.length;
            start = toInteger(start);
            if (start < 0) {
              start = -start > length2 ? 0 : length2 + start;
            }
            end = end === undefined$1 || end > length2 ? length2 : toInteger(end);
            if (end < 0) {
              end += length2;
            }
            end = start > end ? 0 : toLength(end);
            while (start < end) {
              array[start++] = value;
            }
            return array;
          }
          function baseFilter(collection, predicate) {
            var result2 = [];
            baseEach(collection, function(value, index2, collection2) {
              if (predicate(value, index2, collection2)) {
                result2.push(value);
              }
            });
            return result2;
          }
          function baseFlatten(array, depth, predicate, isStrict, result2) {
            var index2 = -1, length2 = array.length;
            predicate || (predicate = isFlattenable);
            result2 || (result2 = []);
            while (++index2 < length2) {
              var value = array[index2];
              if (depth > 0 && predicate(value)) {
                if (depth > 1) {
                  baseFlatten(value, depth - 1, predicate, isStrict, result2);
                } else {
                  arrayPush(result2, value);
                }
              } else if (!isStrict) {
                result2[result2.length] = value;
              }
            }
            return result2;
          }
          var baseFor = createBaseFor();
          var baseForRight = createBaseFor(true);
          function baseForOwn(object, iteratee2) {
            return object && baseFor(object, iteratee2, keys2);
          }
          function baseForOwnRight(object, iteratee2) {
            return object && baseForRight(object, iteratee2, keys2);
          }
          function baseFunctions(object, props) {
            return arrayFilter(props, function(key) {
              return isFunction2(object[key]);
            });
          }
          function baseGet(object, path2) {
            path2 = castPath(path2, object);
            var index2 = 0, length2 = path2.length;
            while (object != null && index2 < length2) {
              object = object[toKey(path2[index2++])];
            }
            return index2 && index2 == length2 ? object : undefined$1;
          }
          function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result2 = keysFunc(object);
            return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
          }
          function baseGetTag(value) {
            if (value == null) {
              return value === undefined$1 ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
          }
          function baseGt(value, other) {
            return value > other;
          }
          function baseHas(object, key) {
            return object != null && hasOwnProperty2.call(object, key);
          }
          function baseHasIn(object, key) {
            return object != null && key in Object2(object);
          }
          function baseInRange(number2, start, end) {
            return number2 >= nativeMin(start, end) && number2 < nativeMax(start, end);
          }
          function baseIntersection(arrays, iteratee2, comparator) {
            var includes3 = comparator ? arrayIncludesWith : arrayIncludes, length2 = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
            while (othIndex--) {
              var array = arrays[othIndex];
              if (othIndex && iteratee2) {
                array = arrayMap(array, baseUnary(iteratee2));
              }
              maxLength = nativeMin(array.length, maxLength);
              caches[othIndex] = !comparator && (iteratee2 || length2 >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$1;
            }
            array = arrays[0];
            var index2 = -1, seen = caches[0];
            outer:
              while (++index2 < length2 && result2.length < maxLength) {
                var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (!(seen ? cacheHas(seen, computed) : includes3(result2, computed, comparator))) {
                  othIndex = othLength;
                  while (--othIndex) {
                    var cache2 = caches[othIndex];
                    if (!(cache2 ? cacheHas(cache2, computed) : includes3(arrays[othIndex], computed, comparator))) {
                      continue outer;
                    }
                  }
                  if (seen) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseInverter(object, setter, iteratee2, accumulator) {
            baseForOwn(object, function(value, key, object2) {
              setter(accumulator, iteratee2(value), key, object2);
            });
            return accumulator;
          }
          function baseInvoke(object, path2, args) {
            path2 = castPath(path2, object);
            object = parent(object, path2);
            var func = object == null ? object : object[toKey(last(path2))];
            return func == null ? undefined$1 : apply(func, object, args);
          }
          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
          }
          function baseIsArrayBuffer(value) {
            return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
          }
          function baseIsDate(value) {
            return isObjectLike(value) && baseGetTag(value) == dateTag;
          }
          function baseIsEqual(value, other, bitmask, customizer, stack) {
            if (value === other) {
              return true;
            }
            if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
              return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
          }
          function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
            var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
            objTag = objTag == argsTag ? objectTag : objTag;
            othTag = othTag == argsTag ? objectTag : othTag;
            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer2(object)) {
              if (!isBuffer2(other)) {
                return false;
              }
              objIsArr = true;
              objIsObj = false;
            }
            if (isSameTag && !objIsObj) {
              stack || (stack = new Stack2());
              return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
            }
            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
              var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                stack || (stack = new Stack2());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
              }
            }
            if (!isSameTag) {
              return false;
            }
            stack || (stack = new Stack2());
            return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
          }
          function baseIsMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag;
          }
          function baseIsMatch(object, source, matchData, customizer) {
            var index2 = matchData.length, length2 = index2, noCustomizer = !customizer;
            if (object == null) {
              return !length2;
            }
            object = Object2(object);
            while (index2--) {
              var data = matchData[index2];
              if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                return false;
              }
            }
            while (++index2 < length2) {
              data = matchData[index2];
              var key = data[0], objValue = object[key], srcValue = data[1];
              if (noCustomizer && data[2]) {
                if (objValue === undefined$1 && !(key in object)) {
                  return false;
                }
              } else {
                var stack = new Stack2();
                if (customizer) {
                  var result2 = customizer(objValue, srcValue, key, object, source, stack);
                }
                if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                  return false;
                }
              }
            }
            return true;
          }
          function baseIsNative(value) {
            if (!isObject2(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }
          function baseIsRegExp(value) {
            return isObjectLike(value) && baseGetTag(value) == regexpTag;
          }
          function baseIsSet(value) {
            return isObjectLike(value) && getTag(value) == setTag;
          }
          function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
          }
          function baseIteratee(value) {
            if (typeof value == "function") {
              return value;
            }
            if (value == null) {
              return identity;
            }
            if (typeof value == "object") {
              return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            }
            return property(value);
          }
          function baseKeys(object) {
            if (!isPrototype(object)) {
              return nativeKeys(object);
            }
            var result2 = [];
            for (var key in Object2(object)) {
              if (hasOwnProperty2.call(object, key) && key != "constructor") {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseKeysIn(object) {
            if (!isObject2(object)) {
              return nativeKeysIn(object);
            }
            var isProto = isPrototype(object), result2 = [];
            for (var key in object) {
              if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseLt(value, other) {
            return value < other;
          }
          function baseMap(collection, iteratee2) {
            var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value, key, collection2) {
              result2[++index2] = iteratee2(value, key, collection2);
            });
            return result2;
          }
          function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) {
              return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            }
            return function(object) {
              return object === source || baseIsMatch(object, source, matchData);
            };
          }
          function baseMatchesProperty(path2, srcValue) {
            if (isKey(path2) && isStrictComparable(srcValue)) {
              return matchesStrictComparable(toKey(path2), srcValue);
            }
            return function(object) {
              var objValue = get2(object, path2);
              return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
            };
          }
          function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) {
              return;
            }
            baseFor(source, function(srcValue, key) {
              stack || (stack = new Stack2());
              if (isObject2(srcValue)) {
                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
              } else {
                var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined$1;
                if (newValue === undefined$1) {
                  newValue = srcValue;
                }
                assignMergeValue(object, key, newValue);
              }
            }, keysIn);
          }
          function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
            if (stacked) {
              assignMergeValue(object, key, stacked);
              return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined$1;
            var isCommon = newValue === undefined$1;
            if (isCommon) {
              var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
              newValue = srcValue;
              if (isArr || isBuff || isTyped) {
                if (isArray2(objValue)) {
                  newValue = objValue;
                } else if (isArrayLikeObject(objValue)) {
                  newValue = copyArray(objValue);
                } else if (isBuff) {
                  isCommon = false;
                  newValue = cloneBuffer(srcValue, true);
                } else if (isTyped) {
                  isCommon = false;
                  newValue = cloneTypedArray(srcValue, true);
                } else {
                  newValue = [];
                }
              } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
                newValue = objValue;
                if (isArguments(objValue)) {
                  newValue = toPlainObject(objValue);
                } else if (!isObject2(objValue) || isFunction2(objValue)) {
                  newValue = initCloneObject(srcValue);
                }
              } else {
                isCommon = false;
              }
            }
            if (isCommon) {
              stack.set(srcValue, newValue);
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
              stack["delete"](srcValue);
            }
            assignMergeValue(object, key, newValue);
          }
          function baseNth(array, n2) {
            var length2 = array.length;
            if (!length2) {
              return;
            }
            n2 += n2 < 0 ? length2 : 0;
            return isIndex(n2, length2) ? array[n2] : undefined$1;
          }
          function baseOrderBy(collection, iteratees, orders) {
            if (iteratees.length) {
              iteratees = arrayMap(iteratees, function(iteratee2) {
                if (isArray2(iteratee2)) {
                  return function(value) {
                    return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                  };
                }
                return iteratee2;
              });
            } else {
              iteratees = [identity];
            }
            var index2 = -1;
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            var result2 = baseMap(collection, function(value, key, collection2) {
              var criteria = arrayMap(iteratees, function(iteratee2) {
                return iteratee2(value);
              });
              return { "criteria": criteria, "index": ++index2, "value": value };
            });
            return baseSortBy(result2, function(object, other) {
              return compareMultiple(object, other, orders);
            });
          }
          function basePick(object, paths) {
            return basePickBy(object, paths, function(value, path2) {
              return hasIn(object, path2);
            });
          }
          function basePickBy(object, paths, predicate) {
            var index2 = -1, length2 = paths.length, result2 = {};
            while (++index2 < length2) {
              var path2 = paths[index2], value = baseGet(object, path2);
              if (predicate(value, path2)) {
                baseSet(result2, castPath(path2, object), value);
              }
            }
            return result2;
          }
          function basePropertyDeep(path2) {
            return function(object) {
              return baseGet(object, path2);
            };
          }
          function basePullAll(array, values2, iteratee2, comparator) {
            var indexOf3 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length2 = values2.length, seen = array;
            if (array === values2) {
              values2 = copyArray(values2);
            }
            if (iteratee2) {
              seen = arrayMap(array, baseUnary(iteratee2));
            }
            while (++index2 < length2) {
              var fromIndex = 0, value = values2[index2], computed = iteratee2 ? iteratee2(value) : value;
              while ((fromIndex = indexOf3(seen, computed, fromIndex, comparator)) > -1) {
                if (seen !== array) {
                  splice2.call(seen, fromIndex, 1);
                }
                splice2.call(array, fromIndex, 1);
              }
            }
            return array;
          }
          function basePullAt(array, indexes) {
            var length2 = array ? indexes.length : 0, lastIndex2 = length2 - 1;
            while (length2--) {
              var index2 = indexes[length2];
              if (length2 == lastIndex2 || index2 !== previous2) {
                var previous2 = index2;
                if (isIndex(index2)) {
                  splice2.call(array, index2, 1);
                } else {
                  baseUnset(array, index2);
                }
              }
            }
            return array;
          }
          function baseRandom(lower, upper) {
            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
          }
          function baseRange(start, end, step, fromRight) {
            var index2 = -1, length2 = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length2);
            while (length2--) {
              result2[fromRight ? length2 : ++index2] = start;
              start += step;
            }
            return result2;
          }
          function baseRepeat(string2, n2) {
            var result2 = "";
            if (!string2 || n2 < 1 || n2 > MAX_SAFE_INTEGER) {
              return result2;
            }
            do {
              if (n2 % 2) {
                result2 += string2;
              }
              n2 = nativeFloor(n2 / 2);
              if (n2) {
                string2 += string2;
              }
            } while (n2);
            return result2;
          }
          function baseRest(func, start) {
            return setToString(overRest(func, start, identity), func + "");
          }
          function baseSample(collection) {
            return arraySample(values(collection));
          }
          function baseSampleSize(collection, n2) {
            var array = values(collection);
            return shuffleSelf(array, baseClamp(n2, 0, array.length));
          }
          function baseSet(object, path2, value, customizer) {
            if (!isObject2(object)) {
              return object;
            }
            path2 = castPath(path2, object);
            var index2 = -1, length2 = path2.length, lastIndex2 = length2 - 1, nested = object;
            while (nested != null && ++index2 < length2) {
              var key = toKey(path2[index2]), newValue = value;
              if (key === "__proto__" || key === "constructor" || key === "prototype") {
                return object;
              }
              if (index2 != lastIndex2) {
                var objValue = nested[key];
                newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
                if (newValue === undefined$1) {
                  newValue = isObject2(objValue) ? objValue : isIndex(path2[index2 + 1]) ? [] : {};
                }
              }
              assignValue(nested, key, newValue);
              nested = nested[key];
            }
            return object;
          }
          var baseSetData = !metaMap ? identity : function(func, data) {
            metaMap.set(func, data);
            return func;
          };
          var baseSetToString = !defineProperty2 ? identity : function(func, string2) {
            return defineProperty2(func, "toString", {
              "configurable": true,
              "enumerable": false,
              "value": constant(string2),
              "writable": true
            });
          };
          function baseShuffle(collection) {
            return shuffleSelf(values(collection));
          }
          function baseSlice(array, start, end) {
            var index2 = -1, length2 = array.length;
            if (start < 0) {
              start = -start > length2 ? 0 : length2 + start;
            }
            end = end > length2 ? length2 : end;
            if (end < 0) {
              end += length2;
            }
            length2 = start > end ? 0 : end - start >>> 0;
            start >>>= 0;
            var result2 = Array2(length2);
            while (++index2 < length2) {
              result2[index2] = array[index2 + start];
            }
            return result2;
          }
          function baseSome(collection, predicate) {
            var result2;
            baseEach(collection, function(value, index2, collection2) {
              result2 = predicate(value, index2, collection2);
              return !result2;
            });
            return !!result2;
          }
          function baseSortedIndex(array, value, retHighest) {
            var low = 0, high = array == null ? low : array.length;
            if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
              while (low < high) {
                var mid = low + high >>> 1, computed = array[mid];
                if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                  low = mid + 1;
                } else {
                  high = mid;
                }
              }
              return high;
            }
            return baseSortedIndexBy(array, value, identity, retHighest);
          }
          function baseSortedIndexBy(array, value, iteratee2, retHighest) {
            var low = 0, high = array == null ? 0 : array.length;
            if (high === 0) {
              return 0;
            }
            value = iteratee2(value);
            var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined$1;
            while (low < high) {
              var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined$1, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
              if (valIsNaN) {
                var setLow = retHighest || othIsReflexive;
              } else if (valIsUndefined) {
                setLow = othIsReflexive && (retHighest || othIsDefined);
              } else if (valIsNull) {
                setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
              } else if (valIsSymbol) {
                setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
              } else if (othIsNull || othIsSymbol) {
                setLow = false;
              } else {
                setLow = retHighest ? computed <= value : computed < value;
              }
              if (setLow) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
          }
          function baseSortedUniq(array, iteratee2) {
            var index2 = -1, length2 = array.length, resIndex = 0, result2 = [];
            while (++index2 < length2) {
              var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
              if (!index2 || !eq(computed, seen)) {
                var seen = computed;
                result2[resIndex++] = value === 0 ? 0 : value;
              }
            }
            return result2;
          }
          function baseToNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            return +value;
          }
          function baseToString(value) {
            if (typeof value == "string") {
              return value;
            }
            if (isArray2(value)) {
              return arrayMap(value, baseToString) + "";
            }
            if (isSymbol(value)) {
              return symbolToString ? symbolToString.call(value) : "";
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function baseUniq(array, iteratee2, comparator) {
            var index2 = -1, includes3 = arrayIncludes, length2 = array.length, isCommon = true, result2 = [], seen = result2;
            if (comparator) {
              isCommon = false;
              includes3 = arrayIncludesWith;
            } else if (length2 >= LARGE_ARRAY_SIZE) {
              var set3 = iteratee2 ? null : createSet(array);
              if (set3) {
                return setToArray(set3);
              }
              isCommon = false;
              includes3 = cacheHas;
              seen = new SetCache();
            } else {
              seen = iteratee2 ? [] : result2;
            }
            outer:
              while (++index2 < length2) {
                var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var seenIndex = seen.length;
                  while (seenIndex--) {
                    if (seen[seenIndex] === computed) {
                      continue outer;
                    }
                  }
                  if (iteratee2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                } else if (!includes3(seen, computed, comparator)) {
                  if (seen !== result2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseUnset(object, path2) {
            path2 = castPath(path2, object);
            object = parent(object, path2);
            return object == null || delete object[toKey(last(path2))];
          }
          function baseUpdate(object, path2, updater, customizer) {
            return baseSet(object, path2, updater(baseGet(object, path2)), customizer);
          }
          function baseWhile(array, predicate, isDrop, fromRight) {
            var length2 = array.length, index2 = fromRight ? length2 : -1;
            while ((fromRight ? index2-- : ++index2 < length2) && predicate(array[index2], index2, array)) {
            }
            return isDrop ? baseSlice(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length2) : baseSlice(array, fromRight ? index2 + 1 : 0, fromRight ? length2 : index2);
          }
          function baseWrapperValue(value, actions) {
            var result2 = value;
            if (result2 instanceof LazyWrapper) {
              result2 = result2.value();
            }
            return arrayReduce(actions, function(result3, action) {
              return action.func.apply(action.thisArg, arrayPush([result3], action.args));
            }, result2);
          }
          function baseXor(arrays, iteratee2, comparator) {
            var length2 = arrays.length;
            if (length2 < 2) {
              return length2 ? baseUniq(arrays[0]) : [];
            }
            var index2 = -1, result2 = Array2(length2);
            while (++index2 < length2) {
              var array = arrays[index2], othIndex = -1;
              while (++othIndex < length2) {
                if (othIndex != index2) {
                  result2[index2] = baseDifference(result2[index2] || array, arrays[othIndex], iteratee2, comparator);
                }
              }
            }
            return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
          }
          function baseZipObject(props, values2, assignFunc) {
            var index2 = -1, length2 = props.length, valsLength = values2.length, result2 = {};
            while (++index2 < length2) {
              var value = index2 < valsLength ? values2[index2] : undefined$1;
              assignFunc(result2, props[index2], value);
            }
            return result2;
          }
          function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : [];
          }
          function castFunction(value) {
            return typeof value == "function" ? value : identity;
          }
          function castPath(value, object) {
            if (isArray2(value)) {
              return value;
            }
            return isKey(value, object) ? [value] : stringToPath(toString2(value));
          }
          var castRest = baseRest;
          function castSlice(array, start, end) {
            var length2 = array.length;
            end = end === undefined$1 ? length2 : end;
            return !start && end >= length2 ? array : baseSlice(array, start, end);
          }
          var clearTimeout2 = ctxClearTimeout || function(id2) {
            return root2.clearTimeout(id2);
          };
          function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
              return buffer.slice();
            }
            var length2 = buffer.length, result2 = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
            buffer.copy(result2);
            return result2;
          }
          function cloneArrayBuffer(arrayBuffer) {
            var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
            return result2;
          }
          function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
          }
          function cloneRegExp(regexp) {
            var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result2.lastIndex = regexp.lastIndex;
            return result2;
          }
          function cloneSymbol(symbol) {
            return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
          }
          function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
          }
          function compareAscending(value, other) {
            if (value !== other) {
              var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
              var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
              if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                return 1;
              }
              if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                return -1;
              }
            }
            return 0;
          }
          function compareMultiple(object, other, orders) {
            var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length2 = objCriteria.length, ordersLength = orders.length;
            while (++index2 < length2) {
              var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
              if (result2) {
                if (index2 >= ordersLength) {
                  return result2;
                }
                var order2 = orders[index2];
                return result2 * (order2 == "desc" ? -1 : 1);
              }
            }
            return object.index - other.index;
          }
          function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
            while (++leftIndex < leftLength) {
              result2[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[holders[argsIndex]] = args[argsIndex];
              }
            }
            while (rangeLength--) {
              result2[leftIndex++] = args[argsIndex++];
            }
            return result2;
          }
          function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
            while (++argsIndex < rangeLength) {
              result2[argsIndex] = args[argsIndex];
            }
            var offset2 = argsIndex;
            while (++rightIndex < rightLength) {
              result2[offset2 + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[offset2 + holders[holdersIndex]] = args[argsIndex++];
              }
            }
            return result2;
          }
          function copyArray(source, array) {
            var index2 = -1, length2 = source.length;
            array || (array = Array2(length2));
            while (++index2 < length2) {
              array[index2] = source[index2];
            }
            return array;
          }
          function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index2 = -1, length2 = props.length;
            while (++index2 < length2) {
              var key = props[index2];
              var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined$1;
              if (newValue === undefined$1) {
                newValue = source[key];
              }
              if (isNew) {
                baseAssignValue(object, key, newValue);
              } else {
                assignValue(object, key, newValue);
              }
            }
            return object;
          }
          function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
          }
          function copySymbolsIn(source, object) {
            return copyObject(source, getSymbolsIn(source), object);
          }
          function createAggregator(setter, initializer) {
            return function(collection, iteratee2) {
              var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
              return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
            };
          }
          function createAssigner(assigner) {
            return baseRest(function(object, sources) {
              var index2 = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : undefined$1, guard = length2 > 2 ? sources[2] : undefined$1;
              customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : undefined$1;
              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length2 < 3 ? undefined$1 : customizer;
                length2 = 1;
              }
              object = Object2(object);
              while (++index2 < length2) {
                var source = sources[index2];
                if (source) {
                  assigner(object, source, index2, customizer);
                }
              }
              return object;
            });
          }
          function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee2) {
              if (collection == null) {
                return collection;
              }
              if (!isArrayLike(collection)) {
                return eachFunc(collection, iteratee2);
              }
              var length2 = collection.length, index2 = fromRight ? length2 : -1, iterable = Object2(collection);
              while (fromRight ? index2-- : ++index2 < length2) {
                if (iteratee2(iterable[index2], index2, iterable) === false) {
                  break;
                }
              }
              return collection;
            };
          }
          function createBaseFor(fromRight) {
            return function(object, iteratee2, keysFunc) {
              var index2 = -1, iterable = Object2(object), props = keysFunc(object), length2 = props.length;
              while (length2--) {
                var key = props[fromRight ? length2 : ++index2];
                if (iteratee2(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object;
            };
          }
          function createBind(func, bitmask, thisArg) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
              return fn.apply(isBind ? thisArg : this, arguments);
            }
            return wrapper;
          }
          function createCaseFirst(methodName) {
            return function(string2) {
              string2 = toString2(string2);
              var strSymbols = hasUnicode(string2) ? stringToArray(string2) : undefined$1;
              var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
              var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
              return chr[methodName]() + trailing;
            };
          }
          function createCompounder(callback) {
            return function(string2) {
              return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
            };
          }
          function createCtor(Ctor) {
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return new Ctor();
                case 1:
                  return new Ctor(args[0]);
                case 2:
                  return new Ctor(args[0], args[1]);
                case 3:
                  return new Ctor(args[0], args[1], args[2]);
                case 4:
                  return new Ctor(args[0], args[1], args[2], args[3]);
                case 5:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                case 6:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                case 7:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
              }
              var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
              return isObject2(result2) ? result2 : thisBinding;
            };
          }
          function createCurry(func, bitmask, arity) {
            var Ctor = createCtor(func);
            function wrapper() {
              var length2 = arguments.length, args = Array2(length2), index2 = length2, placeholder = getHolder(wrapper);
              while (index2--) {
                args[index2] = arguments[index2];
              }
              var holders = length2 < 3 && args[0] !== placeholder && args[length2 - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
              length2 -= holders.length;
              if (length2 < arity) {
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  undefined$1,
                  args,
                  holders,
                  undefined$1,
                  undefined$1,
                  arity - length2
                );
              }
              var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
              return apply(fn, this, args);
            }
            return wrapper;
          }
          function createFind(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
              var iterable = Object2(collection);
              if (!isArrayLike(collection)) {
                var iteratee2 = getIteratee(predicate, 3);
                collection = keys2(collection);
                predicate = function(key) {
                  return iteratee2(iterable[key], key, iterable);
                };
              }
              var index2 = findIndexFunc(collection, predicate, fromIndex);
              return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined$1;
            };
          }
          function createFlow(fromRight) {
            return flatRest(function(funcs) {
              var length2 = funcs.length, index2 = length2, prereq = LodashWrapper.prototype.thru;
              if (fromRight) {
                funcs.reverse();
              }
              while (index2--) {
                var func = funcs[index2];
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                  var wrapper = new LodashWrapper([], true);
                }
              }
              index2 = wrapper ? index2 : length2;
              while (++index2 < length2) {
                func = funcs[index2];
                var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined$1;
                if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                  wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                } else {
                  wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                }
              }
              return function() {
                var args = arguments, value = args[0];
                if (wrapper && args.length == 1 && isArray2(value)) {
                  return wrapper.plant(value).value();
                }
                var index3 = 0, result2 = length2 ? funcs[index3].apply(this, args) : value;
                while (++index3 < length2) {
                  result2 = funcs[index3].call(this, result2);
                }
                return result2;
              };
            });
          }
          function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
            var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
            function wrapper() {
              var length2 = arguments.length, args = Array2(length2), index2 = length2;
              while (index2--) {
                args[index2] = arguments[index2];
              }
              if (isCurried) {
                var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
              }
              if (partials) {
                args = composeArgs(args, partials, holders, isCurried);
              }
              if (partialsRight) {
                args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
              }
              length2 -= holdersCount;
              if (isCurried && length2 < arity) {
                var newHolders = replaceHolders(args, placeholder);
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper.placeholder,
                  thisArg,
                  args,
                  newHolders,
                  argPos,
                  ary2,
                  arity - length2
                );
              }
              var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
              length2 = args.length;
              if (argPos) {
                args = reorder(args, argPos);
              } else if (isFlip && length2 > 1) {
                args.reverse();
              }
              if (isAry && ary2 < length2) {
                args.length = ary2;
              }
              if (this && this !== root2 && this instanceof wrapper) {
                fn = Ctor || createCtor(fn);
              }
              return fn.apply(thisBinding, args);
            }
            return wrapper;
          }
          function createInverter(setter, toIteratee) {
            return function(object, iteratee2) {
              return baseInverter(object, setter, toIteratee(iteratee2), {});
            };
          }
          function createMathOperation(operator, defaultValue) {
            return function(value, other) {
              var result2;
              if (value === undefined$1 && other === undefined$1) {
                return defaultValue;
              }
              if (value !== undefined$1) {
                result2 = value;
              }
              if (other !== undefined$1) {
                if (result2 === undefined$1) {
                  return other;
                }
                if (typeof value == "string" || typeof other == "string") {
                  value = baseToString(value);
                  other = baseToString(other);
                } else {
                  value = baseToNumber(value);
                  other = baseToNumber(other);
                }
                result2 = operator(value, other);
              }
              return result2;
            };
          }
          function createOver(arrayFunc) {
            return flatRest(function(iteratees) {
              iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
              return baseRest(function(args) {
                var thisArg = this;
                return arrayFunc(iteratees, function(iteratee2) {
                  return apply(iteratee2, thisArg, args);
                });
              });
            });
          }
          function createPadding(length2, chars) {
            chars = chars === undefined$1 ? " " : baseToString(chars);
            var charsLength = chars.length;
            if (charsLength < 2) {
              return charsLength ? baseRepeat(chars, length2) : chars;
            }
            var result2 = baseRepeat(chars, nativeCeil(length2 / stringSize(chars)));
            return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length2).join("") : result2.slice(0, length2);
          }
          function createPartial(func, bitmask, thisArg, partials) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
              while (++leftIndex < leftLength) {
                args[leftIndex] = partials[leftIndex];
              }
              while (argsLength--) {
                args[leftIndex++] = arguments[++argsIndex];
              }
              return apply(fn, isBind ? thisArg : this, args);
            }
            return wrapper;
          }
          function createRange(fromRight) {
            return function(start, end, step) {
              if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
                end = step = undefined$1;
              }
              start = toFinite(start);
              if (end === undefined$1) {
                end = start;
                start = 0;
              } else {
                end = toFinite(end);
              }
              step = step === undefined$1 ? start < end ? 1 : -1 : toFinite(step);
              return baseRange(start, end, step, fromRight);
            };
          }
          function createRelationalOperation(operator) {
            return function(value, other) {
              if (!(typeof value == "string" && typeof other == "string")) {
                value = toNumber(value);
                other = toNumber(other);
              }
              return operator(value, other);
            };
          }
          function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
            var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
              bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
            }
            var newData = [
              func,
              bitmask,
              thisArg,
              newPartials,
              newHolders,
              newPartialsRight,
              newHoldersRight,
              argPos,
              ary2,
              arity
            ];
            var result2 = wrapFunc.apply(undefined$1, newData);
            if (isLaziable(func)) {
              setData(result2, newData);
            }
            result2.placeholder = placeholder;
            return setWrapToString(result2, func, bitmask);
          }
          function createRound(methodName) {
            var func = Math2[methodName];
            return function(number2, precision) {
              number2 = toNumber(number2);
              precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
              if (precision && nativeIsFinite(number2)) {
                var pair = (toString2(number2) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
                pair = (toString2(value) + "e").split("e");
                return +(pair[0] + "e" + (+pair[1] - precision));
              }
              return func(number2);
            };
          }
          var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values2) {
            return new Set2(values2);
          };
          function createToPairs(keysFunc) {
            return function(object) {
              var tag = getTag(object);
              if (tag == mapTag) {
                return mapToArray(object);
              }
              if (tag == setTag) {
                return setToPairs(object);
              }
              return baseToPairs(object, keysFunc(object));
            };
          }
          function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
            if (!isBindKey && typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var length2 = partials ? partials.length : 0;
            if (!length2) {
              bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
              partials = holders = undefined$1;
            }
            ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0);
            arity = arity === undefined$1 ? arity : toInteger(arity);
            length2 -= holders ? holders.length : 0;
            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
              var partialsRight = partials, holdersRight = holders;
              partials = holders = undefined$1;
            }
            var data = isBindKey ? undefined$1 : getData(func);
            var newData = [
              func,
              bitmask,
              thisArg,
              partials,
              holders,
              partialsRight,
              holdersRight,
              argPos,
              ary2,
              arity
            ];
            if (data) {
              mergeData(newData, data);
            }
            func = newData[0];
            bitmask = newData[1];
            thisArg = newData[2];
            partials = newData[3];
            holders = newData[4];
            arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length2, 0);
            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
              bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
            }
            if (!bitmask || bitmask == WRAP_BIND_FLAG) {
              var result2 = createBind(func, bitmask, thisArg);
            } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
              result2 = createCurry(func, bitmask, arity);
            } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
              result2 = createPartial(func, bitmask, thisArg, partials);
            } else {
              result2 = createHybrid.apply(undefined$1, newData);
            }
            var setter = data ? baseSetData : setData;
            return setWrapToString(setter(result2, newData), func, bitmask);
          }
          function customDefaultsAssignIn(objValue, srcValue, key, object) {
            if (objValue === undefined$1 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
              return srcValue;
            }
            return objValue;
          }
          function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
            if (isObject2(objValue) && isObject2(srcValue)) {
              stack.set(srcValue, objValue);
              baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
              stack["delete"](srcValue);
            }
            return objValue;
          }
          function customOmitClone(value) {
            return isPlainObject2(value) ? undefined$1 : value;
          }
          function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
              return false;
            }
            var arrStacked = stack.get(array);
            var othStacked = stack.get(other);
            if (arrStacked && othStacked) {
              return arrStacked == other && othStacked == array;
            }
            var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
            stack.set(array, other);
            stack.set(other, array);
            while (++index2 < arrLength) {
              var arrValue = array[index2], othValue = other[index2];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
              }
              if (compared !== undefined$1) {
                if (compared) {
                  continue;
                }
                result2 = false;
                break;
              }
              if (seen) {
                if (!arraySome(other, function(othValue2, othIndex) {
                  if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                    return seen.push(othIndex);
                  }
                })) {
                  result2 = false;
                  break;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                result2 = false;
                break;
              }
            }
            stack["delete"](array);
            stack["delete"](other);
            return result2;
          }
          function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
            switch (tag) {
              case dataViewTag:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                  return false;
                }
                object = object.buffer;
                other = other.buffer;
              case arrayBufferTag:
                if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                  return false;
                }
                return true;
              case boolTag:
              case dateTag:
              case numberTag:
                return eq(+object, +other);
              case errorTag:
                return object.name == other.name && object.message == other.message;
              case regexpTag:
              case stringTag:
                return object == other + "";
              case mapTag:
                var convert2 = mapToArray;
              case setTag:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                convert2 || (convert2 = setToArray);
                if (object.size != other.size && !isPartial) {
                  return false;
                }
                var stacked = stack.get(object);
                if (stacked) {
                  return stacked == other;
                }
                bitmask |= COMPARE_UNORDERED_FLAG;
                stack.set(object, other);
                var result2 = equalArrays(convert2(object), convert2(other), bitmask, customizer, equalFunc, stack);
                stack["delete"](object);
                return result2;
              case symbolTag:
                if (symbolValueOf) {
                  return symbolValueOf.call(object) == symbolValueOf.call(other);
                }
            }
            return false;
          }
          function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) {
              return false;
            }
            var index2 = objLength;
            while (index2--) {
              var key = objProps[index2];
              if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
                return false;
              }
            }
            var objStacked = stack.get(object);
            var othStacked = stack.get(other);
            if (objStacked && othStacked) {
              return objStacked == other && othStacked == object;
            }
            var result2 = true;
            stack.set(object, other);
            stack.set(other, object);
            var skipCtor = isPartial;
            while (++index2 < objLength) {
              key = objProps[index2];
              var objValue = object[key], othValue = other[key];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
              }
              if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                result2 = false;
                break;
              }
              skipCtor || (skipCtor = key == "constructor");
            }
            if (result2 && !skipCtor) {
              var objCtor = object.constructor, othCtor = other.constructor;
              if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                result2 = false;
              }
            }
            stack["delete"](object);
            stack["delete"](other);
            return result2;
          }
          function flatRest(func) {
            return setToString(overRest(func, undefined$1, flatten), func + "");
          }
          function getAllKeys(object) {
            return baseGetAllKeys(object, keys2, getSymbols);
          }
          function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn);
          }
          var getData = !metaMap ? noop2 : function(func) {
            return metaMap.get(func);
          };
          function getFuncName(func) {
            var result2 = func.name + "", array = realNames[result2], length2 = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
            while (length2--) {
              var data = array[length2], otherFunc = data.func;
              if (otherFunc == null || otherFunc == func) {
                return data.name;
              }
            }
            return result2;
          }
          function getHolder(func) {
            var object = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
            return object.placeholder;
          }
          function getIteratee() {
            var result2 = lodash2.iteratee || iteratee;
            result2 = result2 === iteratee ? baseIteratee : result2;
            return arguments.length ? result2(arguments[0], arguments[1]) : result2;
          }
          function getMapData(map3, key) {
            var data = map3.__data__;
            return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
          }
          function getMatchData(object) {
            var result2 = keys2(object), length2 = result2.length;
            while (length2--) {
              var key = result2[length2], value = object[key];
              result2[length2] = [key, value, isStrictComparable(value)];
            }
            return result2;
          }
          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined$1;
          }
          function getRawTag(value) {
            var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
            try {
              value[symToStringTag] = undefined$1;
              var unmasked = true;
            } catch (e2) {
            }
            var result2 = nativeObjectToString.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag;
              } else {
                delete value[symToStringTag];
              }
            }
            return result2;
          }
          var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
            if (object == null) {
              return [];
            }
            object = Object2(object);
            return arrayFilter(nativeGetSymbols(object), function(symbol) {
              return propertyIsEnumerable.call(object, symbol);
            });
          };
          var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
            var result2 = [];
            while (object) {
              arrayPush(result2, getSymbols(object));
              object = getPrototype(object);
            }
            return result2;
          };
          var getTag = baseGetTag;
          if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
            getTag = function(value) {
              var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;
                  case mapCtorString:
                    return mapTag;
                  case promiseCtorString:
                    return promiseTag;
                  case setCtorString:
                    return setTag;
                  case weakMapCtorString:
                    return weakMapTag;
                }
              }
              return result2;
            };
          }
          function getView(start, end, transforms) {
            var index2 = -1, length2 = transforms.length;
            while (++index2 < length2) {
              var data = transforms[index2], size2 = data.size;
              switch (data.type) {
                case "drop":
                  start += size2;
                  break;
                case "dropRight":
                  end -= size2;
                  break;
                case "take":
                  end = nativeMin(end, start + size2);
                  break;
                case "takeRight":
                  start = nativeMax(start, end - size2);
                  break;
              }
            }
            return { "start": start, "end": end };
          }
          function getWrapDetails(source) {
            var match5 = source.match(reWrapDetails);
            return match5 ? match5[1].split(reSplitDetails) : [];
          }
          function hasPath(object, path2, hasFunc) {
            path2 = castPath(path2, object);
            var index2 = -1, length2 = path2.length, result2 = false;
            while (++index2 < length2) {
              var key = toKey(path2[index2]);
              if (!(result2 = object != null && hasFunc(object, key))) {
                break;
              }
              object = object[key];
            }
            if (result2 || ++index2 != length2) {
              return result2;
            }
            length2 = object == null ? 0 : object.length;
            return !!length2 && isLength(length2) && isIndex(key, length2) && (isArray2(object) || isArguments(object));
          }
          function initCloneArray(array) {
            var length2 = array.length, result2 = new array.constructor(length2);
            if (length2 && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
              result2.index = array.index;
              result2.input = array.input;
            }
            return result2;
          }
          function initCloneObject(object) {
            return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
          }
          function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag:
                return cloneArrayBuffer(object);
              case boolTag:
              case dateTag:
                return new Ctor(+object);
              case dataViewTag:
                return cloneDataView(object, isDeep);
              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                return cloneTypedArray(object, isDeep);
              case mapTag:
                return new Ctor();
              case numberTag:
              case stringTag:
                return new Ctor(object);
              case regexpTag:
                return cloneRegExp(object);
              case setTag:
                return new Ctor();
              case symbolTag:
                return cloneSymbol(object);
            }
          }
          function insertWrapDetails(source, details) {
            var length2 = details.length;
            if (!length2) {
              return source;
            }
            var lastIndex2 = length2 - 1;
            details[lastIndex2] = (length2 > 1 ? "& " : "") + details[lastIndex2];
            details = details.join(length2 > 2 ? ", " : " ");
            return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
          }
          function isFlattenable(value) {
            return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
          }
          function isIndex(value, length2) {
            var type = typeof value;
            length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
            return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
          }
          function isIterateeCall(value, index2, object) {
            if (!isObject2(object)) {
              return false;
            }
            var type = typeof index2;
            if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
              return eq(object[index2], value);
            }
            return false;
          }
          function isKey(value, object) {
            if (isArray2(value)) {
              return false;
            }
            var type = typeof value;
            if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
              return true;
            }
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
          }
          function isKeyable(value) {
            var type = typeof value;
            return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
          }
          function isLaziable(func) {
            var funcName = getFuncName(func), other = lodash2[funcName];
            if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
              return false;
            }
            if (func === other) {
              return true;
            }
            var data = getData(other);
            return !!data && func === data[0];
          }
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }
          var isMaskable = coreJsData ? isFunction2 : stubFalse;
          function isPrototype(value) {
            var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto;
            return value === proto2;
          }
          function isStrictComparable(value) {
            return value === value && !isObject2(value);
          }
          function matchesStrictComparable(key, srcValue) {
            return function(object) {
              if (object == null) {
                return false;
              }
              return object[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object));
            };
          }
          function memoizeCapped(func) {
            var result2 = memoize(func, function(key) {
              if (cache2.size === MAX_MEMOIZE_SIZE) {
                cache2.clear();
              }
              return key;
            });
            var cache2 = result2.cache;
            return result2;
          }
          function mergeData(data, source) {
            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
            var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
            if (!(isCommon || isCombo)) {
              return data;
            }
            if (srcBitmask & WRAP_BIND_FLAG) {
              data[2] = source[2];
              newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
            }
            var value = source[3];
            if (value) {
              var partials = data[3];
              data[3] = partials ? composeArgs(partials, value, source[4]) : value;
              data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
            }
            value = source[5];
            if (value) {
              partials = data[5];
              data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
              data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
            }
            value = source[7];
            if (value) {
              data[7] = value;
            }
            if (srcBitmask & WRAP_ARY_FLAG) {
              data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            }
            if (data[9] == null) {
              data[9] = source[9];
            }
            data[0] = source[0];
            data[1] = newBitmask;
            return data;
          }
          function nativeKeysIn(object) {
            var result2 = [];
            if (object != null) {
              for (var key in Object2(object)) {
                result2.push(key);
              }
            }
            return result2;
          }
          function objectToString(value) {
            return nativeObjectToString.call(value);
          }
          function overRest(func, start, transform3) {
            start = nativeMax(start === undefined$1 ? func.length - 1 : start, 0);
            return function() {
              var args = arguments, index2 = -1, length2 = nativeMax(args.length - start, 0), array = Array2(length2);
              while (++index2 < length2) {
                array[index2] = args[start + index2];
              }
              index2 = -1;
              var otherArgs = Array2(start + 1);
              while (++index2 < start) {
                otherArgs[index2] = args[index2];
              }
              otherArgs[start] = transform3(array);
              return apply(func, this, otherArgs);
            };
          }
          function parent(object, path2) {
            return path2.length < 2 ? object : baseGet(object, baseSlice(path2, 0, -1));
          }
          function reorder(array, indexes) {
            var arrLength = array.length, length2 = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
            while (length2--) {
              var index2 = indexes[length2];
              array[length2] = isIndex(index2, arrLength) ? oldArray[index2] : undefined$1;
            }
            return array;
          }
          function safeGet(object, key) {
            if (key === "constructor" && typeof object[key] === "function") {
              return;
            }
            if (key == "__proto__") {
              return;
            }
            return object[key];
          }
          var setData = shortOut(baseSetData);
          var setTimeout2 = ctxSetTimeout || function(func, wait) {
            return root2.setTimeout(func, wait);
          };
          var setToString = shortOut(baseSetToString);
          function setWrapToString(wrapper, reference, bitmask) {
            var source = reference + "";
            return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
          }
          function shortOut(func) {
            var count = 0, lastCalled = 0;
            return function() {
              var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return arguments[0];
                }
              } else {
                count = 0;
              }
              return func.apply(undefined$1, arguments);
            };
          }
          function shuffleSelf(array, size2) {
            var index2 = -1, length2 = array.length, lastIndex2 = length2 - 1;
            size2 = size2 === undefined$1 ? length2 : size2;
            while (++index2 < size2) {
              var rand = baseRandom(index2, lastIndex2), value = array[rand];
              array[rand] = array[index2];
              array[index2] = value;
            }
            array.length = size2;
            return array;
          }
          var stringToPath = memoizeCapped(function(string2) {
            var result2 = [];
            if (string2.charCodeAt(0) === 46) {
              result2.push("");
            }
            string2.replace(rePropName, function(match5, number2, quote, subString) {
              result2.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match5);
            });
            return result2;
          });
          function toKey(value) {
            if (typeof value == "string" || isSymbol(value)) {
              return value;
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e2) {
              }
              try {
                return func + "";
              } catch (e2) {
              }
            }
            return "";
          }
          function updateWrapDetails(details, bitmask) {
            arrayEach(wrapFlags, function(pair) {
              var value = "_." + pair[0];
              if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                details.push(value);
              }
            });
            return details.sort();
          }
          function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) {
              return wrapper.clone();
            }
            var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
            result2.__actions__ = copyArray(wrapper.__actions__);
            result2.__index__ = wrapper.__index__;
            result2.__values__ = wrapper.__values__;
            return result2;
          }
          function chunk(array, size2, guard) {
            if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined$1) {
              size2 = 1;
            } else {
              size2 = nativeMax(toInteger(size2), 0);
            }
            var length2 = array == null ? 0 : array.length;
            if (!length2 || size2 < 1) {
              return [];
            }
            var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length2 / size2));
            while (index2 < length2) {
              result2[resIndex++] = baseSlice(array, index2, index2 += size2);
            }
            return result2;
          }
          function compact(array) {
            var index2 = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result2 = [];
            while (++index2 < length2) {
              var value = array[index2];
              if (value) {
                result2[resIndex++] = value;
              }
            }
            return result2;
          }
          function concat() {
            var length2 = arguments.length;
            if (!length2) {
              return [];
            }
            var args = Array2(length2 - 1), array = arguments[0], index2 = length2;
            while (index2--) {
              args[index2 - 1] = arguments[index2];
            }
            return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
          }
          var difference = baseRest(function(array, values2) {
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
          });
          var differenceBy = baseRest(function(array, values2) {
            var iteratee2 = last(values2);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined$1;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
          });
          var differenceWith = baseRest(function(array, values2) {
            var comparator = last(values2);
            if (isArrayLikeObject(comparator)) {
              comparator = undefined$1;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined$1, comparator) : [];
          });
          function drop(array, n2, guard) {
            var length2 = array == null ? 0 : array.length;
            if (!length2) {
              return [];
            }
            n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
            return baseSlice(array, n2 < 0 ? 0 : n2, length2);
          }
          function dropRight(array, n2, guard) {
            var length2 = array == null ? 0 : array.length;
            if (!length2) {
              return [];
            }
            n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
            n2 = length2 - n2;
            return baseSlice(array, 0, n2 < 0 ? 0 : n2);
          }
          function dropRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
          }
          function dropWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
          }
          function fill(array, value, start, end) {
            var length2 = array == null ? 0 : array.length;
            if (!length2) {
              return [];
            }
            if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
              start = 0;
              end = length2;
            }
            return baseFill(array, value, start, end);
          }
          function findIndex(array, predicate, fromIndex) {
            var length2 = array == null ? 0 : array.length;
            if (!length2) {
              return -1;
            }
            var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index2 < 0) {
              index2 = nativeMax(length2 + index2, 0);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index2);
          }
          function findLastIndex(array, predicate, fromIndex) {
            var length2 = array == null ? 0 : array.length;
            if (!length2) {
              return -1;
            }
            var index2 = length2 - 1;
            if (fromIndex !== undefined$1) {
              index2 = toInteger(fromIndex);
              index2 = fromIndex < 0 ? nativeMax(length2 + index2, 0) : nativeMin(index2, length2 - 1);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index2, true);
          }
          function flatten(array) {
            var length2 = array == null ? 0 : array.length;
            return length2 ? baseFlatten(array, 1) : [];
          }
          function flattenDeep(array) {
            var length2 = array == null ? 0 : array.length;
            return length2 ? baseFlatten(array, INFINITY) : [];
          }
          function flattenDepth(array, depth) {
            var length2 = array == null ? 0 : array.length;
            if (!length2) {
              return [];
            }
            depth = depth === undefined$1 ? 1 : toInteger(depth);
            return baseFlatten(array, depth);
          }
          function fromPairs(pairs) {
            var index2 = -1, length2 = pairs == null ? 0 : pairs.length, result2 = {};
            while (++index2 < length2) {
              var pair = pairs[index2];
              result2[pair[0]] = pair[1];
            }
            return result2;
          }
          function head(array) {
            return array && array.length ? array[0] : undefined$1;
          }
          function indexOf2(array, value, fromIndex) {
            var length2 = array == null ? 0 : array.length;
            if (!length2) {
              return -1;
            }
            var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index2 < 0) {
              index2 = nativeMax(length2 + index2, 0);
            }
            return baseIndexOf(array, value, index2);
          }
          function initial(array) {
            var length2 = array == null ? 0 : array.length;
            return length2 ? baseSlice(array, 0, -1) : [];
          }
          var intersection = baseRest(function(arrays) {
            var mapped = arrayMap(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
          });
          var intersectionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            if (iteratee2 === last(mapped)) {
              iteratee2 = undefined$1;
            } else {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
          });
          var intersectionWith = baseRest(function(arrays) {
            var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            comparator = typeof comparator == "function" ? comparator : undefined$1;
            if (comparator) {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
          });
          function join2(array, separator) {
            return array == null ? "" : nativeJoin.call(array, separator);
          }
          function last(array) {
            var length2 = array == null ? 0 : array.length;
            return length2 ? array[length2 - 1] : undefined$1;
          }
          function lastIndexOf(array, value, fromIndex) {
            var length2 = array == null ? 0 : array.length;
            if (!length2) {
              return -1;
            }
            var index2 = length2;
            if (fromIndex !== undefined$1) {
              index2 = toInteger(fromIndex);
              index2 = index2 < 0 ? nativeMax(length2 + index2, 0) : nativeMin(index2, length2 - 1);
            }
            return value === value ? strictLastIndexOf(array, value, index2) : baseFindIndex(array, baseIsNaN, index2, true);
          }
          function nth(array, n2) {
            return array && array.length ? baseNth(array, toInteger(n2)) : undefined$1;
          }
          var pull = baseRest(pullAll);
          function pullAll(array, values2) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
          }
          function pullAllBy(array, values2, iteratee2) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
          }
          function pullAllWith(array, values2, comparator) {
            return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined$1, comparator) : array;
          }
          var pullAt = flatRest(function(array, indexes) {
            var length2 = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
            basePullAt(array, arrayMap(indexes, function(index2) {
              return isIndex(index2, length2) ? +index2 : index2;
            }).sort(compareAscending));
            return result2;
          });
          function remove(array, predicate) {
            var result2 = [];
            if (!(array && array.length)) {
              return result2;
            }
            var index2 = -1, indexes = [], length2 = array.length;
            predicate = getIteratee(predicate, 3);
            while (++index2 < length2) {
              var value = array[index2];
              if (predicate(value, index2, array)) {
                result2.push(value);
                indexes.push(index2);
              }
            }
            basePullAt(array, indexes);
            return result2;
          }
          function reverse(array) {
            return array == null ? array : nativeReverse.call(array);
          }
          function slice2(array, start, end) {
            var length2 = array == null ? 0 : array.length;
            if (!length2) {
              return [];
            }
            if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
              start = 0;
              end = length2;
            } else {
              start = start == null ? 0 : toInteger(start);
              end = end === undefined$1 ? length2 : toInteger(end);
            }
            return baseSlice(array, start, end);
          }
          function sortedIndex(array, value) {
            return baseSortedIndex(array, value);
          }
          function sortedIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
          }
          function sortedIndexOf(array, value) {
            var length2 = array == null ? 0 : array.length;
            if (length2) {
              var index2 = baseSortedIndex(array, value);
              if (index2 < length2 && eq(array[index2], value)) {
                return index2;
              }
            }
            return -1;
          }
          function sortedLastIndex(array, value) {
            return baseSortedIndex(array, value, true);
          }
          function sortedLastIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
          }
          function sortedLastIndexOf(array, value) {
            var length2 = array == null ? 0 : array.length;
            if (length2) {
              var index2 = baseSortedIndex(array, value, true) - 1;
              if (eq(array[index2], value)) {
                return index2;
              }
            }
            return -1;
          }
          function sortedUniq(array) {
            return array && array.length ? baseSortedUniq(array) : [];
          }
          function sortedUniqBy(array, iteratee2) {
            return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function tail(array) {
            var length2 = array == null ? 0 : array.length;
            return length2 ? baseSlice(array, 1, length2) : [];
          }
          function take(array, n2, guard) {
            if (!(array && array.length)) {
              return [];
            }
            n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
            return baseSlice(array, 0, n2 < 0 ? 0 : n2);
          }
          function takeRight(array, n2, guard) {
            var length2 = array == null ? 0 : array.length;
            if (!length2) {
              return [];
            }
            n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
            n2 = length2 - n2;
            return baseSlice(array, n2 < 0 ? 0 : n2, length2);
          }
          function takeRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
          }
          function takeWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
          }
          var union = baseRest(function(arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
          });
          var unionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined$1;
            }
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
          });
          var unionWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined$1;
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
          });
          function uniq(array) {
            return array && array.length ? baseUniq(array) : [];
          }
          function uniqBy(array, iteratee2) {
            return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function uniqWith(array, comparator) {
            comparator = typeof comparator == "function" ? comparator : undefined$1;
            return array && array.length ? baseUniq(array, undefined$1, comparator) : [];
          }
          function unzip(array) {
            if (!(array && array.length)) {
              return [];
            }
            var length2 = 0;
            array = arrayFilter(array, function(group) {
              if (isArrayLikeObject(group)) {
                length2 = nativeMax(group.length, length2);
                return true;
              }
            });
            return baseTimes(length2, function(index2) {
              return arrayMap(array, baseProperty(index2));
            });
          }
          function unzipWith(array, iteratee2) {
            if (!(array && array.length)) {
              return [];
            }
            var result2 = unzip(array);
            if (iteratee2 == null) {
              return result2;
            }
            return arrayMap(result2, function(group) {
              return apply(iteratee2, undefined$1, group);
            });
          }
          var without = baseRest(function(array, values2) {
            return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
          });
          var xor = baseRest(function(arrays) {
            return baseXor(arrayFilter(arrays, isArrayLikeObject));
          });
          var xorBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined$1;
            }
            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
          });
          var xorWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined$1;
            return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
          });
          var zip = baseRest(unzip);
          function zipObject(props, values2) {
            return baseZipObject(props || [], values2 || [], assignValue);
          }
          function zipObjectDeep(props, values2) {
            return baseZipObject(props || [], values2 || [], baseSet);
          }
          var zipWith = baseRest(function(arrays) {
            var length2 = arrays.length, iteratee2 = length2 > 1 ? arrays[length2 - 1] : undefined$1;
            iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
            return unzipWith(arrays, iteratee2);
          });
          function chain(value) {
            var result2 = lodash2(value);
            result2.__chain__ = true;
            return result2;
          }
          function tap(value, interceptor) {
            interceptor(value);
            return value;
          }
          function thru(value, interceptor) {
            return interceptor(value);
          }
          var wrapperAt = flatRest(function(paths) {
            var length2 = paths.length, start = length2 ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
              return baseAt(object, paths);
            };
            if (length2 > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
              return this.thru(interceptor);
            }
            value = value.slice(start, +start + (length2 ? 1 : 0));
            value.__actions__.push({
              "func": thru,
              "args": [interceptor],
              "thisArg": undefined$1
            });
            return new LodashWrapper(value, this.__chain__).thru(function(array) {
              if (length2 && !array.length) {
                array.push(undefined$1);
              }
              return array;
            });
          });
          function wrapperChain() {
            return chain(this);
          }
          function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
          }
          function wrapperNext() {
            if (this.__values__ === undefined$1) {
              this.__values__ = toArray2(this.value());
            }
            var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
            return { "done": done, "value": value };
          }
          function wrapperToIterator() {
            return this;
          }
          function wrapperPlant(value) {
            var result2, parent2 = this;
            while (parent2 instanceof baseLodash) {
              var clone3 = wrapperClone(parent2);
              clone3.__index__ = 0;
              clone3.__values__ = undefined$1;
              if (result2) {
                previous2.__wrapped__ = clone3;
              } else {
                result2 = clone3;
              }
              var previous2 = clone3;
              parent2 = parent2.__wrapped__;
            }
            previous2.__wrapped__ = value;
            return result2;
          }
          function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
              var wrapped = value;
              if (this.__actions__.length) {
                wrapped = new LazyWrapper(this);
              }
              wrapped = wrapped.reverse();
              wrapped.__actions__.push({
                "func": thru,
                "args": [reverse],
                "thisArg": undefined$1
              });
              return new LodashWrapper(wrapped, this.__chain__);
            }
            return this.thru(reverse);
          }
          function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
          }
          var countBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty2.call(result2, key)) {
              ++result2[key];
            } else {
              baseAssignValue(result2, key, 1);
            }
          });
          function every(collection, predicate, guard) {
            var func = isArray2(collection) ? arrayEvery : baseEvery;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined$1;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          function filter(collection, predicate) {
            var func = isArray2(collection) ? arrayFilter : baseFilter;
            return func(collection, getIteratee(predicate, 3));
          }
          var find2 = createFind(findIndex);
          var findLast = createFind(findLastIndex);
          function flatMap(collection, iteratee2) {
            return baseFlatten(map2(collection, iteratee2), 1);
          }
          function flatMapDeep(collection, iteratee2) {
            return baseFlatten(map2(collection, iteratee2), INFINITY);
          }
          function flatMapDepth(collection, iteratee2, depth) {
            depth = depth === undefined$1 ? 1 : toInteger(depth);
            return baseFlatten(map2(collection, iteratee2), depth);
          }
          function forEach2(collection, iteratee2) {
            var func = isArray2(collection) ? arrayEach : baseEach;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function forEachRight(collection, iteratee2) {
            var func = isArray2(collection) ? arrayEachRight : baseEachRight;
            return func(collection, getIteratee(iteratee2, 3));
          }
          var groupBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty2.call(result2, key)) {
              result2[key].push(value);
            } else {
              baseAssignValue(result2, key, [value]);
            }
          });
          function includes2(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection) ? collection : values(collection);
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length2 = collection.length;
            if (fromIndex < 0) {
              fromIndex = nativeMax(length2 + fromIndex, 0);
            }
            return isString2(collection) ? fromIndex <= length2 && collection.indexOf(value, fromIndex) > -1 : !!length2 && baseIndexOf(collection, value, fromIndex) > -1;
          }
          var invokeMap = baseRest(function(collection, path2, args) {
            var index2 = -1, isFunc = typeof path2 == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value) {
              result2[++index2] = isFunc ? apply(path2, value, args) : baseInvoke(value, path2, args);
            });
            return result2;
          });
          var keyBy = createAggregator(function(result2, value, key) {
            baseAssignValue(result2, key, value);
          });
          function map2(collection, iteratee2) {
            var func = isArray2(collection) ? arrayMap : baseMap;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function orderBy(collection, iteratees, orders, guard) {
            if (collection == null) {
              return [];
            }
            if (!isArray2(iteratees)) {
              iteratees = iteratees == null ? [] : [iteratees];
            }
            orders = guard ? undefined$1 : orders;
            if (!isArray2(orders)) {
              orders = orders == null ? [] : [orders];
            }
            return baseOrderBy(collection, iteratees, orders);
          }
          var partition = createAggregator(function(result2, value, key) {
            result2[key ? 0 : 1].push(value);
          }, function() {
            return [[], []];
          });
          function reduce(collection, iteratee2, accumulator) {
            var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
          }
          function reduceRight(collection, iteratee2, accumulator) {
            var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
          }
          function reject(collection, predicate) {
            var func = isArray2(collection) ? arrayFilter : baseFilter;
            return func(collection, negate(getIteratee(predicate, 3)));
          }
          function sample(collection) {
            var func = isArray2(collection) ? arraySample : baseSample;
            return func(collection);
          }
          function sampleSize(collection, n2, guard) {
            if (guard ? isIterateeCall(collection, n2, guard) : n2 === undefined$1) {
              n2 = 1;
            } else {
              n2 = toInteger(n2);
            }
            var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
            return func(collection, n2);
          }
          function shuffle(collection) {
            var func = isArray2(collection) ? arrayShuffle : baseShuffle;
            return func(collection);
          }
          function size(collection) {
            if (collection == null) {
              return 0;
            }
            if (isArrayLike(collection)) {
              return isString2(collection) ? stringSize(collection) : collection.length;
            }
            var tag = getTag(collection);
            if (tag == mapTag || tag == setTag) {
              return collection.size;
            }
            return baseKeys(collection).length;
          }
          function some2(collection, predicate, guard) {
            var func = isArray2(collection) ? arraySome : baseSome;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined$1;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          var sortBy = baseRest(function(collection, iteratees) {
            if (collection == null) {
              return [];
            }
            var length2 = iteratees.length;
            if (length2 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
              iteratees = [];
            } else if (length2 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
              iteratees = [iteratees[0]];
            }
            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
          });
          var now2 = ctxNow || function() {
            return root2.Date.now();
          };
          function after(n2, func) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n2 = toInteger(n2);
            return function() {
              if (--n2 < 1) {
                return func.apply(this, arguments);
              }
            };
          }
          function ary(func, n2, guard) {
            n2 = guard ? undefined$1 : n2;
            n2 = func && n2 == null ? func.length : n2;
            return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n2);
          }
          function before(n2, func) {
            var result2;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n2 = toInteger(n2);
            return function() {
              if (--n2 > 0) {
                result2 = func.apply(this, arguments);
              }
              if (n2 <= 1) {
                func = undefined$1;
              }
              return result2;
            };
          }
          var bind2 = baseRest(function(func, thisArg, partials) {
            var bitmask = WRAP_BIND_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bind2));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(func, bitmask, thisArg, partials, holders);
          });
          var bindKey = baseRest(function(object, key, partials) {
            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bindKey));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(key, bitmask, object, partials, holders);
          });
          function curry(func, arity, guard) {
            arity = guard ? undefined$1 : arity;
            var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
            result2.placeholder = curry.placeholder;
            return result2;
          }
          function curryRight(func, arity, guard) {
            arity = guard ? undefined$1 : arity;
            var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
            result2.placeholder = curryRight.placeholder;
            return result2;
          }
          function debounce2(func, wait, options) {
            var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            wait = toNumber(wait) || 0;
            if (isObject2(options)) {
              leading = !!options.leading;
              maxing = "maxWait" in options;
              maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            function invokeFunc(time) {
              var args = lastArgs, thisArg = lastThis;
              lastArgs = lastThis = undefined$1;
              lastInvokeTime = time;
              result2 = func.apply(thisArg, args);
              return result2;
            }
            function leadingEdge(time) {
              lastInvokeTime = time;
              timerId = setTimeout2(timerExpired, wait);
              return leading ? invokeFunc(time) : result2;
            }
            function remainingWait(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
              return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }
            function shouldInvoke(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
              return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
              var time = now2();
              if (shouldInvoke(time)) {
                return trailingEdge(time);
              }
              timerId = setTimeout2(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
              timerId = undefined$1;
              if (trailing && lastArgs) {
                return invokeFunc(time);
              }
              lastArgs = lastThis = undefined$1;
              return result2;
            }
            function cancel() {
              if (timerId !== undefined$1) {
                clearTimeout2(timerId);
              }
              lastInvokeTime = 0;
              lastArgs = lastCallTime = lastThis = timerId = undefined$1;
            }
            function flush() {
              return timerId === undefined$1 ? result2 : trailingEdge(now2());
            }
            function debounced() {
              var time = now2(), isInvoking = shouldInvoke(time);
              lastArgs = arguments;
              lastThis = this;
              lastCallTime = time;
              if (isInvoking) {
                if (timerId === undefined$1) {
                  return leadingEdge(lastCallTime);
                }
                if (maxing) {
                  clearTimeout2(timerId);
                  timerId = setTimeout2(timerExpired, wait);
                  return invokeFunc(lastCallTime);
                }
              }
              if (timerId === undefined$1) {
                timerId = setTimeout2(timerExpired, wait);
              }
              return result2;
            }
            debounced.cancel = cancel;
            debounced.flush = flush;
            return debounced;
          }
          var defer = baseRest(function(func, args) {
            return baseDelay(func, 1, args);
          });
          var delay = baseRest(function(func, wait, args) {
            return baseDelay(func, toNumber(wait) || 0, args);
          });
          function flip2(func) {
            return createWrap(func, WRAP_FLIP_FLAG);
          }
          function memoize(func, resolver2) {
            if (typeof func != "function" || resolver2 != null && typeof resolver2 != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var memoized = function() {
              var args = arguments, key = resolver2 ? resolver2.apply(this, args) : args[0], cache2 = memoized.cache;
              if (cache2.has(key)) {
                return cache2.get(key);
              }
              var result2 = func.apply(this, args);
              memoized.cache = cache2.set(key, result2) || cache2;
              return result2;
            };
            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
          }
          memoize.Cache = MapCache;
          function negate(predicate) {
            if (typeof predicate != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return !predicate.call(this);
                case 1:
                  return !predicate.call(this, args[0]);
                case 2:
                  return !predicate.call(this, args[0], args[1]);
                case 3:
                  return !predicate.call(this, args[0], args[1], args[2]);
              }
              return !predicate.apply(this, args);
            };
          }
          function once(func) {
            return before(2, func);
          }
          var overArgs = castRest(function(func, transforms) {
            transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
            var funcsLength = transforms.length;
            return baseRest(function(args) {
              var index2 = -1, length2 = nativeMin(args.length, funcsLength);
              while (++index2 < length2) {
                args[index2] = transforms[index2].call(this, args[index2]);
              }
              return apply(func, this, args);
            });
          });
          var partial = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partial));
            return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
          });
          var partialRight = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight));
            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
          });
          var rearg = flatRest(function(func, indexes) {
            return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
          });
          function rest(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start = start === undefined$1 ? start : toInteger(start);
            return baseRest(func, start);
          }
          function spread2(func, start) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start = start == null ? 0 : nativeMax(toInteger(start), 0);
            return baseRest(function(args) {
              var array = args[start], otherArgs = castSlice(args, 0, start);
              if (array) {
                arrayPush(otherArgs, array);
              }
              return apply(func, this, otherArgs);
            });
          }
          function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (isObject2(options)) {
              leading = "leading" in options ? !!options.leading : leading;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            return debounce2(func, wait, {
              "leading": leading,
              "maxWait": wait,
              "trailing": trailing
            });
          }
          function unary(func) {
            return ary(func, 1);
          }
          function wrap2(value, wrapper) {
            return partial(castFunction(wrapper), value);
          }
          function castArray() {
            if (!arguments.length) {
              return [];
            }
            var value = arguments[0];
            return isArray2(value) ? value : [value];
          }
          function clone2(value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG);
          }
          function cloneWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined$1;
            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
          }
          function cloneDeep(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
          }
          function cloneDeepWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined$1;
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
          }
          function conformsTo(object, source) {
            return source == null || baseConformsTo(object, source, keys2(source));
          }
          function eq(value, other) {
            return value === other || value !== value && other !== other;
          }
          var gt = createRelationalOperation(baseGt);
          var gte = createRelationalOperation(function(value, other) {
            return value >= other;
          });
          var isArguments = baseIsArguments(function() {
            return arguments;
          }()) ? baseIsArguments : function(value) {
            return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
          };
          var isArray2 = Array2.isArray;
          var isArrayBuffer2 = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction2(value);
          }
          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
          }
          function isBoolean2(value) {
            return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
          }
          var isBuffer2 = nativeIsBuffer || stubFalse;
          var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
          function isElement(value) {
            return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
          }
          function isEmpty(value) {
            if (value == null) {
              return true;
            }
            if (isArrayLike(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer2(value) || isTypedArray(value) || isArguments(value))) {
              return !value.length;
            }
            var tag = getTag(value);
            if (tag == mapTag || tag == setTag) {
              return !value.size;
            }
            if (isPrototype(value)) {
              return !baseKeys(value).length;
            }
            for (var key in value) {
              if (hasOwnProperty2.call(value, key)) {
                return false;
              }
            }
            return true;
          }
          function isEqual(value, other) {
            return baseIsEqual(value, other);
          }
          function isEqualWith(value, other, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined$1;
            var result2 = customizer ? customizer(value, other) : undefined$1;
            return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
          }
          function isError(value) {
            if (!isObjectLike(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
          }
          function isFinite2(value) {
            return typeof value == "number" && nativeIsFinite(value);
          }
          function isFunction2(value) {
            if (!isObject2(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
          }
          function isInteger(value) {
            return typeof value == "number" && value == toInteger(value);
          }
          function isLength(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }
          function isObject2(value) {
            var type = typeof value;
            return value != null && (type == "object" || type == "function");
          }
          function isObjectLike(value) {
            return value != null && typeof value == "object";
          }
          var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
          function isMatch(object, source) {
            return object === source || baseIsMatch(object, source, getMatchData(source));
          }
          function isMatchWith(object, source, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined$1;
            return baseIsMatch(object, source, getMatchData(source), customizer);
          }
          function isNaN2(value) {
            return isNumber2(value) && value != +value;
          }
          function isNative(value) {
            if (isMaskable(value)) {
              throw new Error2(CORE_ERROR_TEXT);
            }
            return baseIsNative(value);
          }
          function isNull(value) {
            return value === null;
          }
          function isNil(value) {
            return value == null;
          }
          function isNumber2(value) {
            return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
          }
          function isPlainObject2(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
              return false;
            }
            var proto2 = getPrototype(value);
            if (proto2 === null) {
              return true;
            }
            var Ctor = hasOwnProperty2.call(proto2, "constructor") && proto2.constructor;
            return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
          }
          var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
          function isSafeInteger(value) {
            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
          }
          var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
          function isString2(value) {
            return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
          }
          function isSymbol(value) {
            return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
          }
          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
          function isUndefined2(value) {
            return value === undefined$1;
          }
          function isWeakMap(value) {
            return isObjectLike(value) && getTag(value) == weakMapTag;
          }
          function isWeakSet(value) {
            return isObjectLike(value) && baseGetTag(value) == weakSetTag;
          }
          var lt = createRelationalOperation(baseLt);
          var lte = createRelationalOperation(function(value, other) {
            return value <= other;
          });
          function toArray2(value) {
            if (!value) {
              return [];
            }
            if (isArrayLike(value)) {
              return isString2(value) ? stringToArray(value) : copyArray(value);
            }
            if (symIterator && value[symIterator]) {
              return iteratorToArray(value[symIterator]());
            }
            var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
            return func(value);
          }
          function toFinite(value) {
            if (!value) {
              return value === 0 ? value : 0;
            }
            value = toNumber(value);
            if (value === INFINITY || value === -INFINITY) {
              var sign2 = value < 0 ? -1 : 1;
              return sign2 * MAX_INTEGER;
            }
            return value === value ? value : 0;
          }
          function toInteger(value) {
            var result2 = toFinite(value), remainder = result2 % 1;
            return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
          }
          function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
          }
          function toNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            if (isObject2(value)) {
              var other = typeof value.valueOf == "function" ? value.valueOf() : value;
              value = isObject2(other) ? other + "" : other;
            }
            if (typeof value != "string") {
              return value === 0 ? value : +value;
            }
            value = baseTrim(value);
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
          }
          function toPlainObject(value) {
            return copyObject(value, keysIn(value));
          }
          function toSafeInteger(value) {
            return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
          }
          function toString2(value) {
            return value == null ? "" : baseToString(value);
          }
          var assign2 = createAssigner(function(object, source) {
            if (isPrototype(source) || isArrayLike(source)) {
              copyObject(source, keys2(source), object);
              return;
            }
            for (var key in source) {
              if (hasOwnProperty2.call(source, key)) {
                assignValue(object, key, source[key]);
              }
            }
          });
          var assignIn = createAssigner(function(object, source) {
            copyObject(source, keysIn(source), object);
          });
          var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object, customizer);
          });
          var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keys2(source), object, customizer);
          });
          var at = flatRest(baseAt);
          function create2(prototype, properties) {
            var result2 = baseCreate(prototype);
            return properties == null ? result2 : baseAssign(result2, properties);
          }
          var defaults2 = baseRest(function(object, sources) {
            object = Object2(object);
            var index2 = -1;
            var length2 = sources.length;
            var guard = length2 > 2 ? sources[2] : undefined$1;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              length2 = 1;
            }
            while (++index2 < length2) {
              var source = sources[index2];
              var props = keysIn(source);
              var propsIndex = -1;
              var propsLength = props.length;
              while (++propsIndex < propsLength) {
                var key = props[propsIndex];
                var value = object[key];
                if (value === undefined$1 || eq(value, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
                  object[key] = source[key];
                }
              }
            }
            return object;
          });
          var defaultsDeep = baseRest(function(args) {
            args.push(undefined$1, customDefaultsMerge);
            return apply(mergeWith, undefined$1, args);
          });
          function findKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
          }
          function findLastKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
          }
          function forIn(object, iteratee2) {
            return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forInRight(object, iteratee2) {
            return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forOwn(object, iteratee2) {
            return object && baseForOwn(object, getIteratee(iteratee2, 3));
          }
          function forOwnRight(object, iteratee2) {
            return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
          }
          function functions(object) {
            return object == null ? [] : baseFunctions(object, keys2(object));
          }
          function functionsIn(object) {
            return object == null ? [] : baseFunctions(object, keysIn(object));
          }
          function get2(object, path2, defaultValue) {
            var result2 = object == null ? undefined$1 : baseGet(object, path2);
            return result2 === undefined$1 ? defaultValue : result2;
          }
          function has(object, path2) {
            return object != null && hasPath(object, path2, baseHas);
          }
          function hasIn(object, path2) {
            return object != null && hasPath(object, path2, baseHasIn);
          }
          var invert = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            result2[value] = key;
          }, constant(identity));
          var invertBy = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            if (hasOwnProperty2.call(result2, value)) {
              result2[value].push(key);
            } else {
              result2[value] = [key];
            }
          }, getIteratee);
          var invoke = baseRest(baseInvoke);
          function keys2(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
          }
          function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
          }
          function mapKeys(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, iteratee2(value, key, object2), value);
            });
            return result2;
          }
          function mapValues(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, key, iteratee2(value, key, object2));
            });
            return result2;
          }
          var merge2 = createAssigner(function(object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
          });
          var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer);
          });
          var omit = flatRest(function(object, paths) {
            var result2 = {};
            if (object == null) {
              return result2;
            }
            var isDeep = false;
            paths = arrayMap(paths, function(path2) {
              path2 = castPath(path2, object);
              isDeep || (isDeep = path2.length > 1);
              return path2;
            });
            copyObject(object, getAllKeysIn(object), result2);
            if (isDeep) {
              result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
            }
            var length2 = paths.length;
            while (length2--) {
              baseUnset(result2, paths[length2]);
            }
            return result2;
          });
          function omitBy(object, predicate) {
            return pickBy2(object, negate(getIteratee(predicate)));
          }
          var pick = flatRest(function(object, paths) {
            return object == null ? {} : basePick(object, paths);
          });
          function pickBy2(object, predicate) {
            if (object == null) {
              return {};
            }
            var props = arrayMap(getAllKeysIn(object), function(prop) {
              return [prop];
            });
            predicate = getIteratee(predicate);
            return basePickBy(object, props, function(value, path2) {
              return predicate(value, path2[0]);
            });
          }
          function result(object, path2, defaultValue) {
            path2 = castPath(path2, object);
            var index2 = -1, length2 = path2.length;
            if (!length2) {
              length2 = 1;
              object = undefined$1;
            }
            while (++index2 < length2) {
              var value = object == null ? undefined$1 : object[toKey(path2[index2])];
              if (value === undefined$1) {
                index2 = length2;
                value = defaultValue;
              }
              object = isFunction2(value) ? value.call(object) : value;
            }
            return object;
          }
          function set2(object, path2, value) {
            return object == null ? object : baseSet(object, path2, value);
          }
          function setWith(object, path2, value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined$1;
            return object == null ? object : baseSet(object, path2, value, customizer);
          }
          var toPairs = createToPairs(keys2);
          var toPairsIn = createToPairs(keysIn);
          function transform2(object, iteratee2, accumulator) {
            var isArr = isArray2(object), isArrLike = isArr || isBuffer2(object) || isTypedArray(object);
            iteratee2 = getIteratee(iteratee2, 4);
            if (accumulator == null) {
              var Ctor = object && object.constructor;
              if (isArrLike) {
                accumulator = isArr ? new Ctor() : [];
              } else if (isObject2(object)) {
                accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
              } else {
                accumulator = {};
              }
            }
            (isArrLike ? arrayEach : baseForOwn)(object, function(value, index2, object2) {
              return iteratee2(accumulator, value, index2, object2);
            });
            return accumulator;
          }
          function unset(object, path2) {
            return object == null ? true : baseUnset(object, path2);
          }
          function update(object, path2, updater) {
            return object == null ? object : baseUpdate(object, path2, castFunction(updater));
          }
          function updateWith(object, path2, updater, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined$1;
            return object == null ? object : baseUpdate(object, path2, castFunction(updater), customizer);
          }
          function values(object) {
            return object == null ? [] : baseValues(object, keys2(object));
          }
          function valuesIn(object) {
            return object == null ? [] : baseValues(object, keysIn(object));
          }
          function clamp(number2, lower, upper) {
            if (upper === undefined$1) {
              upper = lower;
              lower = undefined$1;
            }
            if (upper !== undefined$1) {
              upper = toNumber(upper);
              upper = upper === upper ? upper : 0;
            }
            if (lower !== undefined$1) {
              lower = toNumber(lower);
              lower = lower === lower ? lower : 0;
            }
            return baseClamp(toNumber(number2), lower, upper);
          }
          function inRange(number2, start, end) {
            start = toFinite(start);
            if (end === undefined$1) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            number2 = toNumber(number2);
            return baseInRange(number2, start, end);
          }
          function random(lower, upper, floating) {
            if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
              upper = floating = undefined$1;
            }
            if (floating === undefined$1) {
              if (typeof upper == "boolean") {
                floating = upper;
                upper = undefined$1;
              } else if (typeof lower == "boolean") {
                floating = lower;
                lower = undefined$1;
              }
            }
            if (lower === undefined$1 && upper === undefined$1) {
              lower = 0;
              upper = 1;
            } else {
              lower = toFinite(lower);
              if (upper === undefined$1) {
                upper = lower;
                lower = 0;
              } else {
                upper = toFinite(upper);
              }
            }
            if (lower > upper) {
              var temp = lower;
              lower = upper;
              upper = temp;
            }
            if (floating || lower % 1 || upper % 1) {
              var rand = nativeRandom();
              return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
            }
            return baseRandom(lower, upper);
          }
          var camelCase = createCompounder(function(result2, word, index2) {
            word = word.toLowerCase();
            return result2 + (index2 ? capitalize(word) : word);
          });
          function capitalize(string2) {
            return upperFirst(toString2(string2).toLowerCase());
          }
          function deburr(string2) {
            string2 = toString2(string2);
            return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
          }
          function endsWith(string2, target, position2) {
            string2 = toString2(string2);
            target = baseToString(target);
            var length2 = string2.length;
            position2 = position2 === undefined$1 ? length2 : baseClamp(toInteger(position2), 0, length2);
            var end = position2;
            position2 -= target.length;
            return position2 >= 0 && string2.slice(position2, end) == target;
          }
          function escape2(string2) {
            string2 = toString2(string2);
            return string2 && reHasUnescapedHtml.test(string2) ? string2.replace(reUnescapedHtml, escapeHtmlChar) : string2;
          }
          function escapeRegExp(string2) {
            string2 = toString2(string2);
            return string2 && reHasRegExpChar.test(string2) ? string2.replace(reRegExpChar, "\\$&") : string2;
          }
          var kebabCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? "-" : "") + word.toLowerCase();
          });
          var lowerCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? " " : "") + word.toLowerCase();
          });
          var lowerFirst = createCaseFirst("toLowerCase");
          function pad(string2, length2, chars) {
            string2 = toString2(string2);
            length2 = toInteger(length2);
            var strLength = length2 ? stringSize(string2) : 0;
            if (!length2 || strLength >= length2) {
              return string2;
            }
            var mid = (length2 - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string2 + createPadding(nativeCeil(mid), chars);
          }
          function padEnd(string2, length2, chars) {
            string2 = toString2(string2);
            length2 = toInteger(length2);
            var strLength = length2 ? stringSize(string2) : 0;
            return length2 && strLength < length2 ? string2 + createPadding(length2 - strLength, chars) : string2;
          }
          function padStart(string2, length2, chars) {
            string2 = toString2(string2);
            length2 = toInteger(length2);
            var strLength = length2 ? stringSize(string2) : 0;
            return length2 && strLength < length2 ? createPadding(length2 - strLength, chars) + string2 : string2;
          }
          function parseInt2(string2, radix, guard) {
            if (guard || radix == null) {
              radix = 0;
            } else if (radix) {
              radix = +radix;
            }
            return nativeParseInt(toString2(string2).replace(reTrimStart, ""), radix || 0);
          }
          function repeat2(string2, n2, guard) {
            if (guard ? isIterateeCall(string2, n2, guard) : n2 === undefined$1) {
              n2 = 1;
            } else {
              n2 = toInteger(n2);
            }
            return baseRepeat(toString2(string2), n2);
          }
          function replace2() {
            var args = arguments, string2 = toString2(args[0]);
            return args.length < 3 ? string2 : string2.replace(args[1], args[2]);
          }
          var snakeCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? "_" : "") + word.toLowerCase();
          });
          function split(string2, separator, limit) {
            if (limit && typeof limit != "number" && isIterateeCall(string2, separator, limit)) {
              separator = limit = undefined$1;
            }
            limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
            if (!limit) {
              return [];
            }
            string2 = toString2(string2);
            if (string2 && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
              separator = baseToString(separator);
              if (!separator && hasUnicode(string2)) {
                return castSlice(stringToArray(string2), 0, limit);
              }
            }
            return string2.split(separator, limit);
          }
          var startCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? " " : "") + upperFirst(word);
          });
          function startsWith(string2, target, position2) {
            string2 = toString2(string2);
            position2 = position2 == null ? 0 : baseClamp(toInteger(position2), 0, string2.length);
            target = baseToString(target);
            return string2.slice(position2, position2 + target.length) == target;
          }
          function template(string2, options, guard) {
            var settings = lodash2.templateSettings;
            if (guard && isIterateeCall(string2, options, guard)) {
              options = undefined$1;
            }
            string2 = toString2(string2);
            options = assignInWith({}, options, settings, customDefaultsAssignIn);
            var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues(imports, importsKeys);
            var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
            var reDelimiters = RegExp2(
              (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
              "g"
            );
            var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
            string2.replace(reDelimiters, function(match5, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset2) {
              interpolateValue || (interpolateValue = esTemplateValue);
              source += string2.slice(index2, offset2).replace(reUnescapedString, escapeStringChar);
              if (escapeValue) {
                isEscaping = true;
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }
              if (interpolateValue) {
                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
              }
              index2 = offset2 + match5.length;
              return match5;
            });
            source += "';\n";
            var variable = hasOwnProperty2.call(options, "variable") && options.variable;
            if (!variable) {
              source = "with (obj) {\n" + source + "\n}\n";
            } else if (reForbiddenIdentifierChars.test(variable)) {
              throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var result2 = attempt(function() {
              return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
            });
            result2.source = source;
            if (isError(result2)) {
              throw result2;
            }
            return result2;
          }
          function toLower(value) {
            return toString2(value).toLowerCase();
          }
          function toUpper(value) {
            return toString2(value).toUpperCase();
          }
          function trim2(string2, chars, guard) {
            string2 = toString2(string2);
            if (string2 && (guard || chars === undefined$1)) {
              return baseTrim(string2);
            }
            if (!string2 || !(chars = baseToString(chars))) {
              return string2;
            }
            var strSymbols = stringToArray(string2), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start, end).join("");
          }
          function trimEnd(string2, chars, guard) {
            string2 = toString2(string2);
            if (string2 && (guard || chars === undefined$1)) {
              return string2.slice(0, trimmedEndIndex(string2) + 1);
            }
            if (!string2 || !(chars = baseToString(chars))) {
              return string2;
            }
            var strSymbols = stringToArray(string2), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
            return castSlice(strSymbols, 0, end).join("");
          }
          function trimStart(string2, chars, guard) {
            string2 = toString2(string2);
            if (string2 && (guard || chars === undefined$1)) {
              return string2.replace(reTrimStart, "");
            }
            if (!string2 || !(chars = baseToString(chars))) {
              return string2;
            }
            var strSymbols = stringToArray(string2), start = charsStartIndex(strSymbols, stringToArray(chars));
            return castSlice(strSymbols, start).join("");
          }
          function truncate(string2, options) {
            var length2 = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (isObject2(options)) {
              var separator = "separator" in options ? options.separator : separator;
              length2 = "length" in options ? toInteger(options.length) : length2;
              omission = "omission" in options ? baseToString(options.omission) : omission;
            }
            string2 = toString2(string2);
            var strLength = string2.length;
            if (hasUnicode(string2)) {
              var strSymbols = stringToArray(string2);
              strLength = strSymbols.length;
            }
            if (length2 >= strLength) {
              return string2;
            }
            var end = length2 - stringSize(omission);
            if (end < 1) {
              return omission;
            }
            var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string2.slice(0, end);
            if (separator === undefined$1) {
              return result2 + omission;
            }
            if (strSymbols) {
              end += result2.length - end;
            }
            if (isRegExp(separator)) {
              if (string2.slice(end).search(separator)) {
                var match5, substring = result2;
                if (!separator.global) {
                  separator = RegExp2(separator.source, toString2(reFlags.exec(separator)) + "g");
                }
                separator.lastIndex = 0;
                while (match5 = separator.exec(substring)) {
                  var newEnd = match5.index;
                }
                result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
              }
            } else if (string2.indexOf(baseToString(separator), end) != end) {
              var index2 = result2.lastIndexOf(separator);
              if (index2 > -1) {
                result2 = result2.slice(0, index2);
              }
            }
            return result2 + omission;
          }
          function unescape2(string2) {
            string2 = toString2(string2);
            return string2 && reHasEscapedHtml.test(string2) ? string2.replace(reEscapedHtml, unescapeHtmlChar) : string2;
          }
          var upperCase = createCompounder(function(result2, word, index2) {
            return result2 + (index2 ? " " : "") + word.toUpperCase();
          });
          var upperFirst = createCaseFirst("toUpperCase");
          function words(string2, pattern, guard) {
            string2 = toString2(string2);
            pattern = guard ? undefined$1 : pattern;
            if (pattern === undefined$1) {
              return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
            }
            return string2.match(pattern) || [];
          }
          var attempt = baseRest(function(func, args) {
            try {
              return apply(func, undefined$1, args);
            } catch (e2) {
              return isError(e2) ? e2 : new Error2(e2);
            }
          });
          var bindAll = flatRest(function(object, methodNames) {
            arrayEach(methodNames, function(key) {
              key = toKey(key);
              baseAssignValue(object, key, bind2(object[key], object));
            });
            return object;
          });
          function cond(pairs) {
            var length2 = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
            pairs = !length2 ? [] : arrayMap(pairs, function(pair) {
              if (typeof pair[1] != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              return [toIteratee(pair[0]), pair[1]];
            });
            return baseRest(function(args) {
              var index2 = -1;
              while (++index2 < length2) {
                var pair = pairs[index2];
                if (apply(pair[0], this, args)) {
                  return apply(pair[1], this, args);
                }
              }
            });
          }
          function conforms(source) {
            return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
          }
          function constant(value) {
            return function() {
              return value;
            };
          }
          function defaultTo(value, defaultValue) {
            return value == null || value !== value ? defaultValue : value;
          }
          var flow2 = createFlow();
          var flowRight = createFlow(true);
          function identity(value) {
            return value;
          }
          function iteratee(func) {
            return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
          }
          function matches(source) {
            return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
          }
          function matchesProperty(path2, srcValue) {
            return baseMatchesProperty(path2, baseClone(srcValue, CLONE_DEEP_FLAG));
          }
          var method = baseRest(function(path2, args) {
            return function(object) {
              return baseInvoke(object, path2, args);
            };
          });
          var methodOf = baseRest(function(object, args) {
            return function(path2) {
              return baseInvoke(object, path2, args);
            };
          });
          function mixin2(object, source, options) {
            var props = keys2(source), methodNames = baseFunctions(source, props);
            if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
              options = source;
              source = object;
              object = this;
              methodNames = baseFunctions(source, keys2(source));
            }
            var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
            arrayEach(methodNames, function(methodName) {
              var func = source[methodName];
              object[methodName] = func;
              if (isFunc) {
                object.prototype[methodName] = function() {
                  var chainAll = this.__chain__;
                  if (chain2 || chainAll) {
                    var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                    actions.push({ "func": func, "args": arguments, "thisArg": object });
                    result2.__chain__ = chainAll;
                    return result2;
                  }
                  return func.apply(object, arrayPush([this.value()], arguments));
                };
              }
            });
            return object;
          }
          function noConflict() {
            if (root2._ === this) {
              root2._ = oldDash;
            }
            return this;
          }
          function noop2() {
          }
          function nthArg(n2) {
            n2 = toInteger(n2);
            return baseRest(function(args) {
              return baseNth(args, n2);
            });
          }
          var over = createOver(arrayMap);
          var overEvery = createOver(arrayEvery);
          var overSome = createOver(arraySome);
          function property(path2) {
            return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
          }
          function propertyOf(object) {
            return function(path2) {
              return object == null ? undefined$1 : baseGet(object, path2);
            };
          }
          var range = createRange();
          var rangeRight = createRange(true);
          function stubArray() {
            return [];
          }
          function stubFalse() {
            return false;
          }
          function stubObject() {
            return {};
          }
          function stubString() {
            return "";
          }
          function stubTrue() {
            return true;
          }
          function times(n2, iteratee2) {
            n2 = toInteger(n2);
            if (n2 < 1 || n2 > MAX_SAFE_INTEGER) {
              return [];
            }
            var index2 = MAX_ARRAY_LENGTH, length2 = nativeMin(n2, MAX_ARRAY_LENGTH);
            iteratee2 = getIteratee(iteratee2);
            n2 -= MAX_ARRAY_LENGTH;
            var result2 = baseTimes(length2, iteratee2);
            while (++index2 < n2) {
              iteratee2(index2);
            }
            return result2;
          }
          function toPath(value) {
            if (isArray2(value)) {
              return arrayMap(value, toKey);
            }
            return isSymbol(value) ? [value] : copyArray(stringToPath(toString2(value)));
          }
          function uniqueId2(prefix2) {
            var id2 = ++idCounter;
            return toString2(prefix2) + id2;
          }
          var add2 = createMathOperation(function(augend, addend) {
            return augend + addend;
          }, 0);
          var ceil = createRound("ceil");
          var divide = createMathOperation(function(dividend, divisor) {
            return dividend / divisor;
          }, 1);
          var floor = createRound("floor");
          function max2(array) {
            return array && array.length ? baseExtremum(array, identity, baseGt) : undefined$1;
          }
          function maxBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
          }
          function mean(array) {
            return baseMean(array, identity);
          }
          function meanBy(array, iteratee2) {
            return baseMean(array, getIteratee(iteratee2, 2));
          }
          function min2(array) {
            return array && array.length ? baseExtremum(array, identity, baseLt) : undefined$1;
          }
          function minBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
          }
          var multiply = createMathOperation(function(multiplier, multiplicand) {
            return multiplier * multiplicand;
          }, 1);
          var round2 = createRound("round");
          var subtract2 = createMathOperation(function(minuend, subtrahend) {
            return minuend - subtrahend;
          }, 0);
          function sum(array) {
            return array && array.length ? baseSum(array, identity) : 0;
          }
          function sumBy(array, iteratee2) {
            return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
          }
          lodash2.after = after;
          lodash2.ary = ary;
          lodash2.assign = assign2;
          lodash2.assignIn = assignIn;
          lodash2.assignInWith = assignInWith;
          lodash2.assignWith = assignWith;
          lodash2.at = at;
          lodash2.before = before;
          lodash2.bind = bind2;
          lodash2.bindAll = bindAll;
          lodash2.bindKey = bindKey;
          lodash2.castArray = castArray;
          lodash2.chain = chain;
          lodash2.chunk = chunk;
          lodash2.compact = compact;
          lodash2.concat = concat;
          lodash2.cond = cond;
          lodash2.conforms = conforms;
          lodash2.constant = constant;
          lodash2.countBy = countBy;
          lodash2.create = create2;
          lodash2.curry = curry;
          lodash2.curryRight = curryRight;
          lodash2.debounce = debounce2;
          lodash2.defaults = defaults2;
          lodash2.defaultsDeep = defaultsDeep;
          lodash2.defer = defer;
          lodash2.delay = delay;
          lodash2.difference = difference;
          lodash2.differenceBy = differenceBy;
          lodash2.differenceWith = differenceWith;
          lodash2.drop = drop;
          lodash2.dropRight = dropRight;
          lodash2.dropRightWhile = dropRightWhile;
          lodash2.dropWhile = dropWhile;
          lodash2.fill = fill;
          lodash2.filter = filter;
          lodash2.flatMap = flatMap;
          lodash2.flatMapDeep = flatMapDeep;
          lodash2.flatMapDepth = flatMapDepth;
          lodash2.flatten = flatten;
          lodash2.flattenDeep = flattenDeep;
          lodash2.flattenDepth = flattenDepth;
          lodash2.flip = flip2;
          lodash2.flow = flow2;
          lodash2.flowRight = flowRight;
          lodash2.fromPairs = fromPairs;
          lodash2.functions = functions;
          lodash2.functionsIn = functionsIn;
          lodash2.groupBy = groupBy;
          lodash2.initial = initial;
          lodash2.intersection = intersection;
          lodash2.intersectionBy = intersectionBy;
          lodash2.intersectionWith = intersectionWith;
          lodash2.invert = invert;
          lodash2.invertBy = invertBy;
          lodash2.invokeMap = invokeMap;
          lodash2.iteratee = iteratee;
          lodash2.keyBy = keyBy;
          lodash2.keys = keys2;
          lodash2.keysIn = keysIn;
          lodash2.map = map2;
          lodash2.mapKeys = mapKeys;
          lodash2.mapValues = mapValues;
          lodash2.matches = matches;
          lodash2.matchesProperty = matchesProperty;
          lodash2.memoize = memoize;
          lodash2.merge = merge2;
          lodash2.mergeWith = mergeWith;
          lodash2.method = method;
          lodash2.methodOf = methodOf;
          lodash2.mixin = mixin2;
          lodash2.negate = negate;
          lodash2.nthArg = nthArg;
          lodash2.omit = omit;
          lodash2.omitBy = omitBy;
          lodash2.once = once;
          lodash2.orderBy = orderBy;
          lodash2.over = over;
          lodash2.overArgs = overArgs;
          lodash2.overEvery = overEvery;
          lodash2.overSome = overSome;
          lodash2.partial = partial;
          lodash2.partialRight = partialRight;
          lodash2.partition = partition;
          lodash2.pick = pick;
          lodash2.pickBy = pickBy2;
          lodash2.property = property;
          lodash2.propertyOf = propertyOf;
          lodash2.pull = pull;
          lodash2.pullAll = pullAll;
          lodash2.pullAllBy = pullAllBy;
          lodash2.pullAllWith = pullAllWith;
          lodash2.pullAt = pullAt;
          lodash2.range = range;
          lodash2.rangeRight = rangeRight;
          lodash2.rearg = rearg;
          lodash2.reject = reject;
          lodash2.remove = remove;
          lodash2.rest = rest;
          lodash2.reverse = reverse;
          lodash2.sampleSize = sampleSize;
          lodash2.set = set2;
          lodash2.setWith = setWith;
          lodash2.shuffle = shuffle;
          lodash2.slice = slice2;
          lodash2.sortBy = sortBy;
          lodash2.sortedUniq = sortedUniq;
          lodash2.sortedUniqBy = sortedUniqBy;
          lodash2.split = split;
          lodash2.spread = spread2;
          lodash2.tail = tail;
          lodash2.take = take;
          lodash2.takeRight = takeRight;
          lodash2.takeRightWhile = takeRightWhile;
          lodash2.takeWhile = takeWhile;
          lodash2.tap = tap;
          lodash2.throttle = throttle;
          lodash2.thru = thru;
          lodash2.toArray = toArray2;
          lodash2.toPairs = toPairs;
          lodash2.toPairsIn = toPairsIn;
          lodash2.toPath = toPath;
          lodash2.toPlainObject = toPlainObject;
          lodash2.transform = transform2;
          lodash2.unary = unary;
          lodash2.union = union;
          lodash2.unionBy = unionBy;
          lodash2.unionWith = unionWith;
          lodash2.uniq = uniq;
          lodash2.uniqBy = uniqBy;
          lodash2.uniqWith = uniqWith;
          lodash2.unset = unset;
          lodash2.unzip = unzip;
          lodash2.unzipWith = unzipWith;
          lodash2.update = update;
          lodash2.updateWith = updateWith;
          lodash2.values = values;
          lodash2.valuesIn = valuesIn;
          lodash2.without = without;
          lodash2.words = words;
          lodash2.wrap = wrap2;
          lodash2.xor = xor;
          lodash2.xorBy = xorBy;
          lodash2.xorWith = xorWith;
          lodash2.zip = zip;
          lodash2.zipObject = zipObject;
          lodash2.zipObjectDeep = zipObjectDeep;
          lodash2.zipWith = zipWith;
          lodash2.entries = toPairs;
          lodash2.entriesIn = toPairsIn;
          lodash2.extend = assignIn;
          lodash2.extendWith = assignInWith;
          mixin2(lodash2, lodash2);
          lodash2.add = add2;
          lodash2.attempt = attempt;
          lodash2.camelCase = camelCase;
          lodash2.capitalize = capitalize;
          lodash2.ceil = ceil;
          lodash2.clamp = clamp;
          lodash2.clone = clone2;
          lodash2.cloneDeep = cloneDeep;
          lodash2.cloneDeepWith = cloneDeepWith;
          lodash2.cloneWith = cloneWith;
          lodash2.conformsTo = conformsTo;
          lodash2.deburr = deburr;
          lodash2.defaultTo = defaultTo;
          lodash2.divide = divide;
          lodash2.endsWith = endsWith;
          lodash2.eq = eq;
          lodash2.escape = escape2;
          lodash2.escapeRegExp = escapeRegExp;
          lodash2.every = every;
          lodash2.find = find2;
          lodash2.findIndex = findIndex;
          lodash2.findKey = findKey;
          lodash2.findLast = findLast;
          lodash2.findLastIndex = findLastIndex;
          lodash2.findLastKey = findLastKey;
          lodash2.floor = floor;
          lodash2.forEach = forEach2;
          lodash2.forEachRight = forEachRight;
          lodash2.forIn = forIn;
          lodash2.forInRight = forInRight;
          lodash2.forOwn = forOwn;
          lodash2.forOwnRight = forOwnRight;
          lodash2.get = get2;
          lodash2.gt = gt;
          lodash2.gte = gte;
          lodash2.has = has;
          lodash2.hasIn = hasIn;
          lodash2.head = head;
          lodash2.identity = identity;
          lodash2.includes = includes2;
          lodash2.indexOf = indexOf2;
          lodash2.inRange = inRange;
          lodash2.invoke = invoke;
          lodash2.isArguments = isArguments;
          lodash2.isArray = isArray2;
          lodash2.isArrayBuffer = isArrayBuffer2;
          lodash2.isArrayLike = isArrayLike;
          lodash2.isArrayLikeObject = isArrayLikeObject;
          lodash2.isBoolean = isBoolean2;
          lodash2.isBuffer = isBuffer2;
          lodash2.isDate = isDate2;
          lodash2.isElement = isElement;
          lodash2.isEmpty = isEmpty;
          lodash2.isEqual = isEqual;
          lodash2.isEqualWith = isEqualWith;
          lodash2.isError = isError;
          lodash2.isFinite = isFinite2;
          lodash2.isFunction = isFunction2;
          lodash2.isInteger = isInteger;
          lodash2.isLength = isLength;
          lodash2.isMap = isMap;
          lodash2.isMatch = isMatch;
          lodash2.isMatchWith = isMatchWith;
          lodash2.isNaN = isNaN2;
          lodash2.isNative = isNative;
          lodash2.isNil = isNil;
          lodash2.isNull = isNull;
          lodash2.isNumber = isNumber2;
          lodash2.isObject = isObject2;
          lodash2.isObjectLike = isObjectLike;
          lodash2.isPlainObject = isPlainObject2;
          lodash2.isRegExp = isRegExp;
          lodash2.isSafeInteger = isSafeInteger;
          lodash2.isSet = isSet;
          lodash2.isString = isString2;
          lodash2.isSymbol = isSymbol;
          lodash2.isTypedArray = isTypedArray;
          lodash2.isUndefined = isUndefined2;
          lodash2.isWeakMap = isWeakMap;
          lodash2.isWeakSet = isWeakSet;
          lodash2.join = join2;
          lodash2.kebabCase = kebabCase;
          lodash2.last = last;
          lodash2.lastIndexOf = lastIndexOf;
          lodash2.lowerCase = lowerCase;
          lodash2.lowerFirst = lowerFirst;
          lodash2.lt = lt;
          lodash2.lte = lte;
          lodash2.max = max2;
          lodash2.maxBy = maxBy;
          lodash2.mean = mean;
          lodash2.meanBy = meanBy;
          lodash2.min = min2;
          lodash2.minBy = minBy;
          lodash2.stubArray = stubArray;
          lodash2.stubFalse = stubFalse;
          lodash2.stubObject = stubObject;
          lodash2.stubString = stubString;
          lodash2.stubTrue = stubTrue;
          lodash2.multiply = multiply;
          lodash2.nth = nth;
          lodash2.noConflict = noConflict;
          lodash2.noop = noop2;
          lodash2.now = now2;
          lodash2.pad = pad;
          lodash2.padEnd = padEnd;
          lodash2.padStart = padStart;
          lodash2.parseInt = parseInt2;
          lodash2.random = random;
          lodash2.reduce = reduce;
          lodash2.reduceRight = reduceRight;
          lodash2.repeat = repeat2;
          lodash2.replace = replace2;
          lodash2.result = result;
          lodash2.round = round2;
          lodash2.runInContext = runInContext2;
          lodash2.sample = sample;
          lodash2.size = size;
          lodash2.snakeCase = snakeCase;
          lodash2.some = some2;
          lodash2.sortedIndex = sortedIndex;
          lodash2.sortedIndexBy = sortedIndexBy;
          lodash2.sortedIndexOf = sortedIndexOf;
          lodash2.sortedLastIndex = sortedLastIndex;
          lodash2.sortedLastIndexBy = sortedLastIndexBy;
          lodash2.sortedLastIndexOf = sortedLastIndexOf;
          lodash2.startCase = startCase;
          lodash2.startsWith = startsWith;
          lodash2.subtract = subtract2;
          lodash2.sum = sum;
          lodash2.sumBy = sumBy;
          lodash2.template = template;
          lodash2.times = times;
          lodash2.toFinite = toFinite;
          lodash2.toInteger = toInteger;
          lodash2.toLength = toLength;
          lodash2.toLower = toLower;
          lodash2.toNumber = toNumber;
          lodash2.toSafeInteger = toSafeInteger;
          lodash2.toString = toString2;
          lodash2.toUpper = toUpper;
          lodash2.trim = trim2;
          lodash2.trimEnd = trimEnd;
          lodash2.trimStart = trimStart;
          lodash2.truncate = truncate;
          lodash2.unescape = unescape2;
          lodash2.uniqueId = uniqueId2;
          lodash2.upperCase = upperCase;
          lodash2.upperFirst = upperFirst;
          lodash2.each = forEach2;
          lodash2.eachRight = forEachRight;
          lodash2.first = head;
          mixin2(lodash2, function() {
            var source = {};
            baseForOwn(lodash2, function(func, methodName) {
              if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
                source[methodName] = func;
              }
            });
            return source;
          }(), { "chain": false });
          lodash2.VERSION = VERSION;
          arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
            lodash2[methodName].placeholder = lodash2;
          });
          arrayEach(["drop", "take"], function(methodName, index2) {
            LazyWrapper.prototype[methodName] = function(n2) {
              n2 = n2 === undefined$1 ? 1 : nativeMax(toInteger(n2), 0);
              var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
              if (result2.__filtered__) {
                result2.__takeCount__ = nativeMin(n2, result2.__takeCount__);
              } else {
                result2.__views__.push({
                  "size": nativeMin(n2, MAX_ARRAY_LENGTH),
                  "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                });
              }
              return result2;
            };
            LazyWrapper.prototype[methodName + "Right"] = function(n2) {
              return this.reverse()[methodName](n2).reverse();
            };
          });
          arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
            var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function(iteratee2) {
              var result2 = this.clone();
              result2.__iteratees__.push({
                "iteratee": getIteratee(iteratee2, 3),
                "type": type
              });
              result2.__filtered__ = result2.__filtered__ || isFilter;
              return result2;
            };
          });
          arrayEach(["head", "last"], function(methodName, index2) {
            var takeName = "take" + (index2 ? "Right" : "");
            LazyWrapper.prototype[methodName] = function() {
              return this[takeName](1).value()[0];
            };
          });
          arrayEach(["initial", "tail"], function(methodName, index2) {
            var dropName = "drop" + (index2 ? "" : "Right");
            LazyWrapper.prototype[methodName] = function() {
              return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
          });
          LazyWrapper.prototype.compact = function() {
            return this.filter(identity);
          };
          LazyWrapper.prototype.find = function(predicate) {
            return this.filter(predicate).head();
          };
          LazyWrapper.prototype.findLast = function(predicate) {
            return this.reverse().find(predicate);
          };
          LazyWrapper.prototype.invokeMap = baseRest(function(path2, args) {
            if (typeof path2 == "function") {
              return new LazyWrapper(this);
            }
            return this.map(function(value) {
              return baseInvoke(value, path2, args);
            });
          });
          LazyWrapper.prototype.reject = function(predicate) {
            return this.filter(negate(getIteratee(predicate)));
          };
          LazyWrapper.prototype.slice = function(start, end) {
            start = toInteger(start);
            var result2 = this;
            if (result2.__filtered__ && (start > 0 || end < 0)) {
              return new LazyWrapper(result2);
            }
            if (start < 0) {
              result2 = result2.takeRight(-start);
            } else if (start) {
              result2 = result2.drop(start);
            }
            if (end !== undefined$1) {
              end = toInteger(end);
              result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
            }
            return result2;
          };
          LazyWrapper.prototype.takeRightWhile = function(predicate) {
            return this.reverse().takeWhile(predicate).reverse();
          };
          LazyWrapper.prototype.toArray = function() {
            return this.take(MAX_ARRAY_LENGTH);
          };
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
            if (!lodashFunc) {
              return;
            }
            lodash2.prototype[methodName] = function() {
              var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
              var interceptor = function(value2) {
                var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
                return isTaker && chainAll ? result3[0] : result3;
              };
              if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                isLazy = useLazy = false;
              }
              var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
              if (!retUnwrapped && useLazy) {
                value = onlyLazy ? value : new LazyWrapper(this);
                var result2 = func.apply(value, args);
                result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
                return new LodashWrapper(result2, chainAll);
              }
              if (isUnwrapped && onlyLazy) {
                return func.apply(this, args);
              }
              result2 = this.thru(interceptor);
              return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
            };
          });
          arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
            var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash2.prototype[methodName] = function() {
              var args = arguments;
              if (retUnwrapped && !this.__chain__) {
                var value = this.value();
                return func.apply(isArray2(value) ? value : [], args);
              }
              return this[chainName](function(value2) {
                return func.apply(isArray2(value2) ? value2 : [], args);
              });
            };
          });
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash2[methodName];
            if (lodashFunc) {
              var key = lodashFunc.name + "";
              if (!hasOwnProperty2.call(realNames, key)) {
                realNames[key] = [];
              }
              realNames[key].push({ "name": methodName, "func": lodashFunc });
            }
          });
          realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
            "name": "wrapper",
            "func": undefined$1
          }];
          LazyWrapper.prototype.clone = lazyClone;
          LazyWrapper.prototype.reverse = lazyReverse;
          LazyWrapper.prototype.value = lazyValue;
          lodash2.prototype.at = wrapperAt;
          lodash2.prototype.chain = wrapperChain;
          lodash2.prototype.commit = wrapperCommit;
          lodash2.prototype.next = wrapperNext;
          lodash2.prototype.plant = wrapperPlant;
          lodash2.prototype.reverse = wrapperReverse;
          lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
          lodash2.prototype.first = lodash2.prototype.head;
          if (symIterator) {
            lodash2.prototype[symIterator] = wrapperToIterator;
          }
          return lodash2;
        };
        var _2 = runInContext();
        if (freeModule) {
          (freeModule.exports = _2)._ = _2;
          freeExports._ = _2;
        } else {
          root2._ = _2;
        }
      }).call(commonjsGlobal);
    })(lodash, lodash.exports);
    var lodashExports = lodash.exports;
    const _$1 = /* @__PURE__ */ getDefaultExportFromCjs(lodashExports);
    var ViewMode = /* @__PURE__ */ ((ViewMode2) => {
      ViewMode2["Debug"] = "debug";
      ViewMode2["Normal"] = "normal";
      return ViewMode2;
    })(ViewMode || {});
    const CHAT_HISTORY_KEY = "chat_history";
    const appConfigTypeValue = "userPreference";
    const defaultAppContext = {
      appInfo: {},
      setAppInfo: lodashExports.noop,
      appConfig: {},
      setAppConfig: lodashExports.noop,
      currentMessageNavIdRef: { current: "" },
      navList: [],
      setNavList: lodashExports.noop,
      chatStoreName: "",
      isDark: false,
      setIsDark: lodashExports.noop,
      isDisableChatHistory: false,
      setIsDisableChatHistory: lodashExports.noop,
      messages: /* @__PURE__ */ new Map(),
      setMessages: lodashExports.noop,
      isChatHistoryExist: false,
      setIsChatHistoryExist: lodashExports.noop,
      chatHistory: /* @__PURE__ */ new Map(),
      setChatHistory: lodashExports.noop,
      viewMode: ViewMode.Normal,
      setViewMode: lodashExports.noop,
      editMessageHandlerRef: { current: void 0 },
      chatDBRef: { current: void 0 },
      chatStoreRef: { current: void 0 }
    };
    const AppContext = reactExports.createContext(defaultAppContext);
    function useEventCallback(handler) {
      const handlerRef = reactExports.useRef(handler);
      reactExports.useLayoutEffect(() => {
        handlerRef.current = handler;
      });
      return reactExports.useCallback((...args) => {
        const fn = handlerRef.current;
        return fn(...args);
      }, []);
    }
    var ChatMessageFrom = /* @__PURE__ */ ((ChatMessageFrom2) => {
      ChatMessageFrom2["System"] = "system";
      ChatMessageFrom2["ErrorHandler"] = "error";
      ChatMessageFrom2["Chatbot"] = "chatbot";
      ChatMessageFrom2["User"] = "user";
      return ChatMessageFrom2;
    })(ChatMessageFrom || {});
    var ChatMessageType = /* @__PURE__ */ ((ChatMessageType2) => {
      ChatMessageType2["Text"] = "text";
      ChatMessageType2["Typing"] = "typing";
      ChatMessageType2["SessionSplit"] = "session-split";
      return ChatMessageType2;
    })(ChatMessageType || {});
    const useStyles$2 = makeStyles({
      chatBox: {
        ...shorthands.borderRadius("8px"),
        display: "flex",
        flexDirection: "column",
        alignItems: "stretch",
        backgroundColor: tokens$1.colorNeutralBackground1,
        width: "100%",
        height: "100%",
        boxShadow: "0px 6.4px 14.4px rgba(0, 0, 0, 0.132), 0px 1.2px 3.6px rgba(0, 0, 0, 0.108)",
        "::-webkit-scrollbar": {
          width: "4px",
          backgroundColor: tokens$1.colorNeutralBackground1Hover
        },
        "::-webkit-scrollbar-thumb": {
          backgroundColor: tokens$1.colorScrollbarOverlay,
          ...shorthands.border("1px", "solid", tokens$1.colorNeutralBackground1),
          ...shorthands.borderRadius("9999px")
        },
        "::-webkit-scrollbar-thumb:hover": {
          backgroundColor: tokens$1.colorNeutralForeground1Static
        },
        "::-webkit-scrollbar-track": {
          ...shorthands.borderRadius("9999px"),
          backgroundColor: "transparent"
        }
      },
      chatBoxHeader: {
        ...shorthands.flex(0, 0, "auto")
      },
      chatBoxMain: {
        ...shorthands.flex(1, 1, "auto"),
        ...shorthands.padding("0", "16px"),
        ...shorthands.overflow("hidden", "auto")
      },
      chatBoxFooter: {
        ...shorthands.flex(0, 0, "auto"),
        ...shorthands.padding("16px")
      },
      toolbar: {
        ...shorthands.padding("0px", "16px"),
        ...shorthands.borderBottom("1px", "solid", tokens$1.colorNeutralBackground5),
        boxSizing: "border-box",
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        height: "48px"
      },
      toolbarTitle: {
        display: "flex",
        alignItems: "center",
        columnGap: "2px"
      },
      toolbarActions: {
        display: "flex",
        alignItems: "center",
        columnGap: "6px"
      },
      toolbarActionButton: {
        color: tokens$1.colorNeutralForeground2
      },
      inputBoxPastMessagesIncluded: {
        width: "56px"
      },
      messages: {},
      message: {
        ...shorthands.margin("16px", "0"),
        display: "flex",
        alignItems: "flex-end",
        [`&[data-from="${ChatMessageFrom.User}"]`]: {
          flexDirection: "row-reverse"
        },
        "& pre > code": {
          display: "block"
        }
      },
      messageInContextTitle: {
        display: "flex",
        alignItems: "center",
        columnGap: "4px",
        fontSize: "12px"
      },
      messageInContextIndicatorWrapper: {
        ...shorthands.borderRadius("50%"),
        height: "6px",
        width: "6px"
      },
      messageInContextIndicator: {
        backgroundColor: tokens$1.colorPaletteGreenBackground3
      },
      messageOutOfContextIndicator: {
        backgroundColor: tokens$1.colorPaletteYellowBackground3
      },
      messageContent: {
        ...shorthands.padding("16px", "16px"),
        ...shorthands.borderRadius("4px"),
        boxSizing: "border-box",
        width: "calc(100% - 80px)",
        wordBreak: "break-word",
        lineHeight: "22px",
        "> p": {
          ...shorthands.margin(0)
        },
        [`&[data-from="${ChatMessageFrom.Chatbot}"]`]: {
          backgroundColor: tokens$1.colorNeutralBackground4,
          color: tokens$1.colorNeutralForeground1
        },
        [`&[data-from="${ChatMessageFrom.User}"]`]: {
          backgroundColor: tokens$1.colorBrandBackgroundStatic,
          color: tokens$1.colorNeutralForegroundOnBrand
        },
        [`&[data-from="${ChatMessageFrom.ErrorHandler}"]`]: {
          backgroundColor: tokens$1.colorPaletteRedBackground2,
          color: tokens$1.colorNeutralForeground1
        },
        [`&[data-from="${ChatMessageFrom.System}"]`]: {
          display: "flex",
          justifyContent: "center",
          width: "100%",
          color: tokens$1.colorNeutralForeground4
        },
        [`&[data-from="${ChatMessageFrom.User}"] a`]: {
          backgroundColor: tokens$1.colorBrandBackground,
          color: tokens$1.colorNeutralForegroundOnBrand
        }
      },
      errorMessageDetail: {
        marginTop: "8px !important",
        paddingTop: "8px",
        wordBreak: "break-word",
        whiteSpace: "break-spaces",
        ...shorthands.borderTop("1px", "solid", tokens$1.colorPaletteDarkRedBorderActive)
      },
      messageStatus: {
        ...shorthands.margin("10px", "0", "0", "0"),
        ...shorthands.borderTop("1px", "solid", tokens$1.colorPaletteAnchorBackground2),
        fontSize: "12px",
        fontStyle: "italic"
      },
      inputBoxLayout: {
        display: "flex",
        alignItems: "center",
        columnGap: "8px"
      },
      inputBoxClearBtn: {
        height: "32px",
        width: "32px"
      },
      inputBox: {
        ...shorthands.padding("8px", "0px", "8px", "8px"),
        ...shorthands.border("1px", "solid", tokens$1.colorNeutralBackground5),
        ...shorthands.borderRadius("4px"),
        boxSizing: "border-box",
        display: "block",
        width: "100%",
        userSelect: "none",
        position: "relative",
        [`&[data-disabled="true"]`]: {
          backgroundColor: tokens$1.colorNeutralBackgroundDisabled
        }
      },
      inputBoxTextarea: {
        ...shorthands.padding("0px", "28px", "0px", "0px"),
        ...shorthands.overflow("hidden", "auto"),
        ...shorthands.borderWidth(0),
        ...shorthands.outline(0, "solid", "transparent"),
        backgroundColor: "transparent",
        boxSizing: "border-box",
        resize: "none",
        appearance: "none",
        overflowWrap: "break-word",
        lineHeight: "24px",
        height: "24px",
        width: "100%",
        color: tokens$1.colorNeutralForeground1,
        userSelect: "text"
      },
      inputBoxSendBtnWrapper: {
        position: "absolute",
        right: "0px",
        bottom: "0px",
        [`&& button[disabled]`]: {
          color: tokens$1.colorNeutralForegroundDisabled
        }
      },
      inputBoxSendBtn: {
        color: tokens$1.colorNeutralForeground2
      },
      inputCountExceeded: {
        color: tokens$1.colorPaletteRedForeground1
      },
      infoIcon: {
        ...shorthands.margin("0px", "0px", "0px", "4px"),
        cursor: "default",
        userSelect: "none",
        fontSize: "16px"
      },
      dismissIconButton: {
        ...shorthands.margin("0px", "0px", "0px", "4px"),
        cursor: "pointer",
        userSelect: "none",
        fontSize: "16px"
      },
      bottomTip: {
        ...shorthands.border("1px", "solid", tokens$1.colorNeutralBackground5),
        ...shorthands.padding("10px", "6px"),
        ...shorthands.borderRadius("4px"),
        ...shorthands.margin("0px", "0px", "2px", "0px"),
        display: "flex",
        alignItems: "flex-start",
        boxSizing: "border-box",
        width: "100%",
        backgroundColor: tokens$1.colorNeutralBackground3,
        "> :first-child": {
          ...shorthands.flex(0, 0, "auto"),
          ...shorthands.padding("0px", "8px", "0px", "0px")
        },
        "> div": {
          ...shorthands.flex(1, 1, "auto")
        },
        "> :last-child": {
          ...shorthands.flex(0, 0, "auto"),
          ...shorthands.padding("0px", "0px", "0px", "8px")
        }
      }
    });
    const PureChatBottomTip = ({ isBottomTipVisible, LocStrings: LocStrings2, onBottomTipVisibleChange }) => {
      const classes = useStyles$2();
      const onDismiss = reactExports.useCallback(() => {
        onBottomTipVisibleChange(false);
      }, []);
      if (!isBottomTipVisible) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: classes.bottomTip, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: classes.infoIcon, iconName: "InfoSolid" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { role: "alert", children: LocStrings2.Tooltip_Bottom }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            appearance: "transparent",
            icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Dismiss24Regular, {}),
            className: classes.dismissIconButton,
            onClick: onDismiss
          }
        )
      ] });
    };
    const PureChatInputBox = (props) => {
      const [message, setMessage] = reactExports.useState(props.initialTypingMessage ?? "");
      const classes = useStyles$2();
      const textareaRef = reactExports.useRef(null);
      const onSendMessage = useEventCallback(() => {
        setMessage("");
        props.onSendMessage(message);
      });
      const onKeyDown = useEventCallback((e2) => {
        if (e2.key === "Enter" && !e2.shiftKey && !e2.ctrlKey) {
          e2.preventDefault();
          onSendMessage();
        }
      });
      reactExports.useEffect(() => {
        let timeout;
        if (!props.isChatbotTyping) {
          if (timeout !== void 0) {
            clearTimeout(timeout);
          }
          timeout = setTimeout(() => {
            var _a2;
            return (_a2 = textareaRef.current) == null ? void 0 : _a2.focus();
          }, 100);
        }
        return () => {
          if (timeout !== void 0) {
            clearTimeout(timeout);
          }
        };
      }, [props.isChatbotTyping]);
      reactExports.useEffect(() => {
        const textarea = textareaRef.current;
        if (textarea) {
          const onInput = () => {
            const scrollHeight = textarea.scrollHeight;
            if (scrollHeight > 0) {
              textarea.style.height = `${scrollHeight}px`;
            }
          };
          textarea.addEventListener("input", onInput);
          return () => {
            textarea.removeEventListener("input", onInput);
          };
        }
        return void 0;
      }, []);
      const hasValidInput = /\S/.test(message);
      const isSendDisabled = props.isChatbotTyping || !hasValidInput;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          PureChatBottomTip,
          {
            isBottomTipVisible: props.isBottomTipVisible,
            LocStrings: props.LocStrings,
            onBottomTipVisibleChange: props.onBottomTipVisibleChange
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: classes.inputBoxLayout, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { relationship: "description", content: props.LocStrings.ClearButtonTooltip, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              as: "button",
              appearance: "primary",
              shape: "circular",
              size: "medium",
              className: classes.inputBoxClearBtn,
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Broom16Filled, {}),
              disabled: props.isChatbotTyping,
              onClick: props.onClear
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: classes.inputBox, "data-disabled": props.isChatbotTyping, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "textarea",
              {
                ref: textareaRef,
                role: "textbox",
                className: classes.inputBoxTextarea,
                disabled: props.isChatbotTyping || props.inputDisabled,
                placeholder: props.LocStrings.InputPlaceholder,
                value: message,
                onChange: (evt) => {
                  const value = evt.target.value ?? "";
                  setMessage(value);
                },
                onKeyDown
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classes.inputBoxSendBtnWrapper, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                as: "button",
                appearance: "transparent",
                size: "medium",
                title: props.LocStrings.SendButtonLabel,
                className: classes.inputBoxSendBtn,
                icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Send16Filled, {}),
                disabled: isSendDisabled,
                onClick: onSendMessage
              }
            ) })
          ] })
        ] })
      ] });
    };
    const useToggle = (defaultValue = false) => {
      const [isOpen, setIsOpen] = React.useState(defaultValue);
      const toggle = React.useCallback(() => {
        setIsOpen((v2) => !v2);
      }, []);
      return [isOpen, toggle];
    };
    const ErrorDetail = ({ message }) => {
      const classes = useStyles$2();
      return /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: classes.errorMessageDetail, children: message.error });
    };
    const PureChatMessageInner = ({
      message,
      LocStrings: LocStrings2,
      CustomMessageContentRenderer = DefaultMessageContentRenderer
    }) => {
      var _a2;
      const classes = useStyles$2();
      const [showErrorDetail, toggleShowErrorDetail] = useToggle();
      const durationFormat = (_a2 = message == null ? void 0 : message.duration) == null ? void 0 : _a2.toFixed(2).replace(/\.?0*$/, "");
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classes.message, "data-from": message.from, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: classes.messageContent, "data-from": message.from, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CustomMessageContentRenderer, { message }),
        message.error && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { onClick: toggleShowErrorDetail, children: showErrorDetail ? "Hide detail" : "Show detail" }) }),
        showErrorDetail && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorDetail, { message }),
        typeof message.duration === "number" && typeof message.tokens === "number" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: classes.messageStatus, children: [
          message.tokens > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            `${LocStrings2.MessageStatus_Tokens_Desc}: `,
            /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: message.tokens }),
            ` ${LocStrings2.MessageStatus_Tokens_Unit}, `
          ] }),
          `${message.tokens > 0 ? LocStrings2.MessageStatus_TimeSpent_Desc : LocStrings2.MessageStatus_TimeSpent_Desc_Capitalized}: `,
          /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: durationFormat }),
          ` ${LocStrings2.MessageStatus_TimeSpent_Unit}`
        ] })
      ] }) });
    };
    const PureChatMessage = reactExports.memo(PureChatMessageInner);
    const DefaultMessageContentRenderer = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: props.message.content });
    const TypingIndicator = ({ className, message }) => {
      const classes = useStyles$1();
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { horizontal: true, verticalAlign: "center", className, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { overflow: "hidden", width: "1px", height: "1px" }, children: message }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: classes.typing, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classes.typingDot }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classes.typingDot }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classes.typingDot })
        ] })
      ] });
    };
    const useStyles$1 = makeStyles({
      typing: {
        ...shorthands.transition("opacity", "0.1s"),
        display: "flex",
        alignItems: "center",
        height: "22.5px"
      },
      typingDot: {
        ...shorthands.borderRadius("50%"),
        ...shorthands.margin("0", "0", "0", "6px"),
        display: "inline-block",
        width: "6px",
        height: "6px",
        backgroundColor: tokens$1.colorNeutralStroke1,
        animationDuration: "1.5s",
        animationTimingFunction: "linear",
        animationIterationCount: "infinite",
        animationName: {
          "0%": {
            transform: "scale(1)"
          },
          "16.67%": {
            transform: "scale(0)"
          },
          "33.33%": {
            transform: "scale(0)"
          },
          "50%": {
            transform: "scale(0)"
          },
          "66.67%": {
            transform: "scale(1)"
          },
          "83.33%": {
            transform: "scale(1)"
          },
          "100%": {
            transform: "scale(1)"
          }
        },
        "&:nth-child(1)": {
          ...shorthands.margin("0")
        },
        "&:nth-child(2)": {
          animationDelay: "0.18s"
        },
        "&:nth-child(3)": {
          animationDelay: "0.36s"
        }
      }
    });
    const PureChatMessages = ({
      isChatbotTyping,
      typingClassName: typingClassName2,
      messages: messages2,
      LocStrings: LocStrings2,
      CustomMessageContentRenderer
    }) => {
      const classes = useStyles$2();
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: classes.messages, "aria-live": "polite", "data-automation-id": "chat-message-container", children: [
        messages2.map((message) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          PureChatMessage,
          {
            message,
            LocStrings: LocStrings2,
            CustomMessageContentRenderer
          },
          message.id
        )),
        isChatbotTyping && /* @__PURE__ */ jsxRuntimeExports.jsx(TypingIndicator, { message: LocStrings2.LoadingMessage, className: typingClassName2 })
      ] });
    };
    const PureChatToolbar = ({
      title = "Chat",
      isFullScreen,
      containerStyles: containerStyles2,
      LocStrings: LocStrings2,
      customToolbarConfigs,
      customToolbarActions,
      onToggleFullScreen,
      onClose
    }) => {
      const classes = useStyles$2();
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: classes.toolbar, style: containerStyles2, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: classes.toolbarTitle, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { weight: "semibold", children: title }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { content: LocStrings2.Tooltip_Title, relationship: "label", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { as: "button", appearance: "transparent", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Info16Regular, {}) }) }),
          customToolbarConfigs
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center" }, children: [
          customToolbarActions,
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              as: "button",
              appearance: "transparent",
              title: isFullScreen ? LocStrings2.ExitFullScreenButtonLabel : LocStrings2.EnterFullScreenButtonLabel,
              icon: isFullScreen ? /* @__PURE__ */ jsxRuntimeExports.jsx(FullScreenMinimize16Regular, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(FullScreenMaximize16Regular, {}),
              className: classes.toolbarActionButton,
              onClick: onToggleFullScreen
            }
          ),
          onClose && /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              as: "button",
              appearance: "transparent",
              title: LocStrings2.CloseButtonLabel,
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Dismiss16Regular, {}),
              className: classes.toolbarActionButton,
              onClick: onClose
            }
          )
        ] })
      ] });
    };
    function PureChatBox(props) {
      const {
        containerStyles: containerStyles2,
        toolbarContainerStyles,
        chatTitle,
        customInputBox,
        customFooter,
        initialTypingMessage,
        isBottomTipVisible,
        isFullScreen,
        isChatbotTyping,
        typingClassName: typingClassName2,
        LocStrings: LocStrings2,
        inputDisabled,
        messages: messages2,
        CustomMessageContentRenderer,
        CustomChatBoxMainContainer,
        onBottomTipVisibleChange,
        onClear,
        onSendMessage,
        onToggleFullScreen,
        onClose
      } = props;
      const classes = useStyles$2();
      const mainRef = reactExports.useRef(null);
      reactExports.useEffect(() => {
        if (mainRef.current) {
          mainRef.current.scrollTop = mainRef.current.scrollHeight;
        }
      }, [messages2]);
      const chatBoxClass = mergeClasses$2(classes.chatBox, props.containerClassName);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: chatBoxClass, style: containerStyles2, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classes.chatBoxHeader, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          PureChatToolbar,
          {
            containerStyles: toolbarContainerStyles,
            title: chatTitle,
            isFullScreen,
            isChatbotTyping,
            LocStrings: LocStrings2,
            customToolbarActions: props.customToolbarActions,
            onToggleFullScreen,
            onClose
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: mainRef, className: classes.chatBoxMain, children: CustomChatBoxMainContainer ? /* @__PURE__ */ jsxRuntimeExports.jsx(CustomChatBoxMainContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          PureChatMessages,
          {
            isChatbotTyping,
            typingClassName: typingClassName2,
            messages: messages2,
            LocStrings: LocStrings2,
            CustomMessageContentRenderer
          }
        ) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          PureChatMessages,
          {
            isChatbotTyping,
            typingClassName: typingClassName2,
            messages: messages2,
            LocStrings: LocStrings2,
            CustomMessageContentRenderer
          }
        ) }),
        customFooter ? customFooter : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classes.chatBoxFooter, children: customInputBox || /* @__PURE__ */ jsxRuntimeExports.jsx(
          PureChatInputBox,
          {
            initialTypingMessage,
            isBottomTipVisible,
            isChatbotTyping,
            inputDisabled,
            LocStrings: LocStrings2,
            onSendMessage,
            onBottomTipVisibleChange,
            onClear
          }
        ) })
      ] });
    }
    var rngBrowser = { exports: {} };
    var getRandomValues = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof window.msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (getRandomValues) {
      var rnds8 = new Uint8Array(16);
      rngBrowser.exports = function whatwgRNG() {
        getRandomValues(rnds8);
        return rnds8;
      };
    } else {
      var rnds = new Array(16);
      rngBrowser.exports = function mathRNG() {
        for (var i2 = 0, r2; i2 < 16; i2++) {
          if ((i2 & 3) === 0)
            r2 = Math.random() * 4294967296;
          rnds[i2] = r2 >>> ((i2 & 3) << 3) & 255;
        }
        return rnds;
      };
    }
    var rngBrowserExports = rngBrowser.exports;
    var byteToHex = [];
    for (var i = 0; i < 256; ++i) {
      byteToHex[i] = (i + 256).toString(16).substr(1);
    }
    function bytesToUuid$2(buf, offset2) {
      var i2 = offset2 || 0;
      var bth = byteToHex;
      return [
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]]
      ].join("");
    }
    var bytesToUuid_1 = bytesToUuid$2;
    var rng$1 = rngBrowserExports;
    var bytesToUuid$1 = bytesToUuid_1;
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v1$1(options, buf, offset2) {
      var i2 = buf && offset2 || 0;
      var b2 = buf || [];
      options = options || {};
      var node2 = options.node || _nodeId;
      var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node2 == null || clockseq == null) {
        var seedBytes = rng$1();
        if (node2 == null) {
          node2 = _nodeId = [
            seedBytes[0] | 1,
            seedBytes[1],
            seedBytes[2],
            seedBytes[3],
            seedBytes[4],
            seedBytes[5]
          ];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      var msecs = options.msecs !== void 0 ? options.msecs : (/* @__PURE__ */ new Date()).getTime();
      var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b2[i2++] = tl >>> 24 & 255;
      b2[i2++] = tl >>> 16 & 255;
      b2[i2++] = tl >>> 8 & 255;
      b2[i2++] = tl & 255;
      var tmh = msecs / 4294967296 * 1e4 & 268435455;
      b2[i2++] = tmh >>> 8 & 255;
      b2[i2++] = tmh & 255;
      b2[i2++] = tmh >>> 24 & 15 | 16;
      b2[i2++] = tmh >>> 16 & 255;
      b2[i2++] = clockseq >>> 8 | 128;
      b2[i2++] = clockseq & 255;
      for (var n2 = 0; n2 < 6; ++n2) {
        b2[i2 + n2] = node2[n2];
      }
      return buf ? buf : bytesToUuid$1(b2);
    }
    var v1_1 = v1$1;
    var rng = rngBrowserExports;
    var bytesToUuid = bytesToUuid_1;
    function v4$1(options, buf, offset2) {
      var i2 = buf && offset2 || 0;
      if (typeof options == "string") {
        buf = options === "binary" ? new Array(16) : null;
        options = null;
      }
      options = options || {};
      var rnds2 = options.random || (options.rng || rng)();
      rnds2[6] = rnds2[6] & 15 | 64;
      rnds2[8] = rnds2[8] & 63 | 128;
      if (buf) {
        for (var ii2 = 0; ii2 < 16; ++ii2) {
          buf[i2 + ii2] = rnds2[ii2];
        }
      }
      return buf || bytesToUuid(rnds2);
    }
    var v4_1 = v4$1;
    var v1 = v1_1;
    var v4 = v4_1;
    var uuid = v4;
    uuid.v1 = v1;
    uuid.v4 = v4;
    var uuid_1 = uuid;
    async function promisifyRequest(request) {
      return new Promise((resolve, reject) => {
        request.oncomplete = request.onsuccess = () => {
          resolve(request.result);
        };
        request.onabort = request.onerror = () => {
          reject(request.error);
        };
      });
    }
    class Store {
      constructor(store) {
        __publicField(this, "store");
        this.store = store;
      }
      getIndex(indexName) {
        return this.store.index(indexName);
      }
      async get(query) {
        return promisifyRequest(this.store.get(query));
      }
      async getWithField(field) {
        const request = this.store.openCursor();
        return new Promise((resolve, reject) => {
          request.onsuccess = () => {
            const cursor = request.result;
            if (cursor) {
              const isMatched = Object.entries(field).every(([key, value]) => cursor.value[key] === value);
              if (isMatched) {
                resolve(cursor.value);
              } else {
                cursor.continue();
              }
            } else {
              resolve(void 0);
            }
          };
          request.onerror = () => {
            reject(request.error);
          };
        });
      }
      async getWithIndex(indexName, query) {
        const index2 = this.getIndex(indexName);
        return promisifyRequest(index2.get(query));
      }
      async getAll(query, count) {
        return promisifyRequest(this.store.getAll(query, count));
      }
      async getAllWithIndex(indexName, query, count) {
        const index2 = this.getIndex(indexName);
        return promisifyRequest(index2.getAll(query, count));
      }
      async getList(query) {
        try {
          return Promise.all(query.map((key) => promisifyRequest(this.store.get(key))));
        } catch (error) {
          console.error(error);
        }
        return void 0;
      }
      async getMatchedRecords(query, isItemMatched) {
        const records = await this.getList(query);
        const _isItemMatched = isItemMatched || ((r2) => !!r2);
        const unMatchedKeys = [];
        const matchedRecords = {};
        records == null ? void 0 : records.forEach((item, index2) => {
          if (_isItemMatched(item)) {
            matchedRecords[query[index2]] = item;
          } else {
            unMatchedKeys.push(query[index2]);
          }
        });
        return {
          matchedRecords,
          unMatchedKeys
        };
      }
      async put(pair, id2) {
        try {
          const pairs = Array.isArray(pair) ? pair : [pair];
          return Promise.all(pairs.map((item) => promisifyRequest(this.store.put(item, id2))));
        } catch (error) {
          console.error(error);
        }
        return void 0;
      }
      async putWithIndex(pair, indexName, indexValue) {
        const index2 = this.getIndex(indexName);
        const request = index2.openCursor(indexValue);
        return new Promise((resolve, reject) => {
          request.onsuccess = () => {
            const cursor = request.result;
            if (cursor) {
              cursor.update({
                ...cursor.value,
                ...pair
              });
              resolve();
            } else {
              this.store.put(pair);
              resolve();
            }
          };
          request.onerror = () => {
            reject(request.error);
          };
        });
      }
      async putWithField(pair, field) {
        const request = this.store.openCursor();
        return new Promise((resolve, reject) => {
          request.onsuccess = () => {
            const cursor = request.result;
            if (cursor) {
              const isMatched = Object.entries(field).every(([key, value]) => cursor.value[key] === value);
              if (isMatched) {
                cursor.update({
                  ...cursor.value,
                  ...pair
                });
                resolve();
              } else {
                cursor.continue();
              }
            } else {
              this.store.put(pair);
              resolve();
            }
          };
          request.onerror = () => {
            reject(request.error);
          };
        });
      }
      async delete(query) {
        try {
          return promisifyRequest(this.store.delete(query));
        } catch (error) {
          console.error(error);
        }
      }
      async deleteWithField(field) {
        const request = this.store.openCursor();
        return new Promise((resolve, reject) => {
          request.onsuccess = () => {
            const cursor = request.result;
            if (cursor) {
              const isMatched = Object.entries(field).every(([key, value]) => cursor.value[key] === value);
              if (isMatched) {
                cursor.delete();
              }
              cursor.continue();
            } else {
              resolve();
            }
          };
          request.onerror = () => {
            reject(request.error);
          };
        });
      }
      async updateWithField(field, update) {
        const request = this.store.openCursor();
        return new Promise((resolve, reject) => {
          request.onsuccess = () => {
            const cursor = request.result;
            if (cursor) {
              const isMatched = Object.entries(field).every(([key, value]) => cursor.value[key] === value);
              if (isMatched) {
                cursor.update({
                  ...cursor.value,
                  ...update
                });
              }
              cursor.continue();
            } else {
              resolve();
            }
          };
          request.onerror = () => {
            reject(request.error);
          };
        });
      }
      async deleteWithIndex(indexName, query) {
        const request = this.getIndex(indexName).openCursor(query);
        return new Promise((resolve, reject) => {
          request.onsuccess = () => {
            const cursor = request.result;
            if (cursor) {
              cursor.delete();
              cursor.continue();
            } else {
              resolve();
            }
          };
          request.onerror = () => {
            reject(request.error);
          };
        });
      }
      async deleteList(query) {
        try {
          await Promise.all(query.map((key) => this.delete(key)));
        } catch (error) {
          console.error(error);
        }
      }
      async clear() {
        this.store.clear();
      }
    }
    class ChatStore extends Store {
      constructor(store, appInfo) {
        super(store);
        __publicField(this, "appInfo", {});
        this.appInfo = appInfo ?? {};
      }
      setAppInfo(appInfo) {
        this.appInfo.name = appInfo.name ?? this.appInfo.name;
        this.appInfo.version = appInfo.version ?? this.appInfo.version;
      }
      async getAppRecords() {
        const appIndex = "chat_app_index";
        return this.getAllWithIndex(
          appIndex,
          IDBKeyRange.only([this.appInfo.name, this.appInfo.version])
        );
      }
    }
    const defaultDBName = "flow-chat-test-db";
    const chatConfigIndexDBName = "flow-chat-test-config-db";
    const NavIndexName = "chat_nav_index";
    const ChatNavIndex = {
      name: NavIndexName,
      keyPath: "navId",
      options: {
        unique: false
      }
    };
    class ChatIndexedDB {
      constructor(dbName = defaultDBName) {
        __publicField(this, "dbName");
        __publicField(this, "_db");
        __publicField(this, "isDBReady", false);
        this.dbName = dbName;
      }
      static async allDataBase() {
        const databases = await window.indexedDB.databases();
        return databases;
      }
      static async clearAllDataBase(db2) {
        var _a2;
        const databases = await this.allDataBase();
        for (const database of databases) {
          if ((_a2 = database.name) == null ? void 0 : _a2.startsWith("promptflow-db-")) {
            if (database.name === db2.dbName) {
              db2.clear();
            } else {
              window.indexedDB.deleteDatabase(database.name);
            }
          }
        }
      }
      get db() {
        if (!this._db) {
          throw new Error("db is not ready");
        }
        return this._db;
      }
      get allStoreNames() {
        return Array.from(this.db.objectStoreNames);
      }
      getStore(storeName) {
        if (!this.allStoreNames.includes(storeName)) {
          return void 0;
        }
        const transaction = this.db.transaction(storeName, "readwrite");
        transaction.oncomplete = () => {
          console.log("transaction complete");
        };
        return new ChatStore(transaction.objectStore(storeName));
      }
      clear(storeName) {
        const storeNames = storeName ? [storeName] : this.allStoreNames;
        try {
          storeNames.forEach((storeName2) => {
            const store = this.getStore(storeName2);
            store == null ? void 0 : store.clear();
          });
        } catch (error) {
          console.error(error);
        }
      }
      async deleteStore(storeName) {
        if (this.allStoreNames.includes(storeName)) {
          this.db.deleteObjectStore(storeName);
        }
      }
      close() {
        if (this._db) {
          this.db.close();
          this._db = void 0;
          this.isDBReady = false;
        }
      }
      async deleteDB() {
        this.close();
        await promisifyRequest(indexedDB.deleteDatabase(this.dbName));
        this.isDBReady = false;
      }
      async createDB(storeNamesItems) {
        const request = indexedDB.open(this.dbName);
        request.onupgradeneeded = (event) => {
          console.log("happen onupgradeneeded");
          this._db = request.result;
          switch (event.oldVersion) {
            case 0:
              const configStore = this.db.createObjectStore(chatConfigIndexDBName, { keyPath: "id" });
              configStore.createIndex("type", "type", { unique: false });
              break;
          }
          storeNamesItems.forEach((storeNameItem) => {
            if (!this.allStoreNames.includes(storeNameItem.name)) {
              const store = this.db.createObjectStore(storeNameItem.name, this.getStoreParams(storeNameItem));
              if (Array.isArray(storeNameItem.indexes)) {
                for (const indexItem of storeNameItem.indexes) {
                  store.createIndex(indexItem.name, indexItem.keyPath, indexItem.options);
                }
              }
            }
          });
        };
        await promisifyRequest(request);
        console.log("happen onsuccess");
        this._db = request.result;
        this.isDBReady = true;
      }
      getStoreParams(storeNameItem) {
        const params = {};
        if (!storeNameItem) {
          params.autoIncrement = true;
          return params;
        }
        if (typeof storeNameItem.keyPath === "string") {
          params.keyPath = storeNameItem.keyPath;
          return params;
        }
        return params;
      }
      async createStore(storeNameItem) {
        const request = indexedDB.open(this.dbName);
        request.onupgradeneeded = () => {
          this.db.close();
          this._db = request.result;
          if (!this.allStoreNames.includes(storeNameItem.name)) {
            const store = this.db.createObjectStore(storeNameItem.name, this.getStoreParams(storeNameItem));
            if (Array.isArray(storeNameItem.indexes)) {
              for (const indexItem of storeNameItem.indexes) {
                store.createIndex(indexItem.name, indexItem.keyPath, indexItem.options);
              }
            }
          }
        };
        await promisifyRequest(request);
        this._db = request.result;
        this.isDBReady = true;
      }
    }
    const cookMessage = (message, from2, duration) => {
      const content2 = typeof message === "string" ? message : JSON.stringify(message, void 0, 2);
      return {
        id: uuid_1.v4(),
        from: from2,
        type: ChatMessageType.Text,
        content: content2,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        duration
      };
    };
    const cookUserMessage = (message) => {
      return cookMessage(message, ChatMessageFrom.User);
    };
    const cookRobotMessage = (message, duration) => {
      if (typeof message === "string") {
        return cookMessage(message, ChatMessageFrom.Chatbot, duration);
      }
      const msg = JSON.stringify(message, void 0, 2);
      return cookMessage(msg, ChatMessageFrom.Chatbot, duration);
    };
    const parseLocalUserMessage = (message) => {
      const content2 = message.content;
      try {
        return JSON.parse(content2);
      } catch (error) {
        return {};
      }
    };
    const parseLocalRobotMessage = (message) => {
      const content2 = message.content;
      try {
        return JSON.parse(content2);
      } catch (error) {
        return {};
      }
    };
    const getChatStoreName = (name2, version2) => {
      if (name2 && version2) {
        return `${name2}-${version2}`;
      }
      return "";
    };
    const createNavItem = (appInfo, name2, isSelected) => {
      return {
        id: uuid_1.v4(),
        name: name2 ?? "",
        appInfo,
        storeName: getChatStoreName(appInfo.name, appInfo.version),
        isSelected: isSelected ?? false,
        createAt: Date.now(),
        chatUserName: "User",
        type: "chatTab",
        chatUserAvatar: "",
        chatBotName: "Chatbot",
        chatBotAvatar: ""
      };
    };
    const useCreateChatStore = (appInfo) => {
      const { chatDBRef, setMessages, setChatHistory, setNavList, setAppConfig } = reactExports.useContext(AppContext);
      const [isLoading, setIsLoading] = reactExports.useState(true);
      const loadNavSuccessRef = reactExports.useRef(false);
      console.log("useCreateChatStore start", appInfo.name, appInfo.version);
      reactExports.useLayoutEffect(() => {
        if (appInfo.name && appInfo.version) {
          const storeName = getChatStoreName(appInfo.name, appInfo.version);
          const chatDB = new ChatIndexedDB(`promptflow-db-${storeName}`);
          const storeItems = [
            {
              name: storeName,
              keyPath: "id",
              indexes: [ChatNavIndex]
            }
          ];
          chatDB.createDB(storeItems).then(() => {
            console.log("open indexed db success");
            loadNavSuccessRef.current = true;
            chatDBRef.current = chatDB;
            const store = chatDB.getStore(storeName);
            store == null ? void 0 : store.getAll().then((cacheMessages) => {
              const nextMessages = /* @__PURE__ */ new Map();
              cacheMessages.forEach((message) => {
                const navId = message.navId;
                if (navId) {
                  nextMessages.set(navId, [...nextMessages.get(navId) ?? [], message]);
                }
              });
              setMessages(nextMessages);
              const navIds = nextMessages.keys();
              const nextChatHistory = /* @__PURE__ */ new Map();
              for (const navId of navIds) {
                const lastUserMessageIndex = _$1.findLastIndex(
                  nextMessages.get(navId),
                  (d2) => d2.from === ChatMessageFrom.User
                );
                const lastChatBotMessageIndex = _$1.findLastIndex(
                  nextMessages.get(navId),
                  (d2) => d2.from === ChatMessageFrom.Chatbot
                );
                if (lastUserMessageIndex !== -1) {
                  const lastUserMessage = nextMessages.get(navId)[lastUserMessageIndex];
                  const chatHistory = parseLocalUserMessage(lastUserMessage)[CHAT_HISTORY_KEY];
                  if (chatHistory) {
                    if (lastChatBotMessageIndex > lastUserMessageIndex) {
                      const lastChatBotMessage = nextMessages.get(navId)[lastChatBotMessageIndex];
                      const userLocalMessage = parseLocalUserMessage(lastUserMessage);
                      chatHistory.push({
                        id: uuid_1.v4(),
                        inputs: {
                          ...userLocalMessage,
                          [CHAT_HISTORY_KEY]: void 0
                        },
                        outputs: {
                          ...parseLocalRobotMessage(lastChatBotMessage)
                        },
                        duration: lastChatBotMessage.duration,
                        navId
                      });
                    }
                  }
                  nextChatHistory.set(navId, chatHistory ?? []);
                }
              }
              setChatHistory(nextChatHistory);
            });
            const configStore = chatDB.getStore(chatConfigIndexDBName);
            configStore == null ? void 0 : configStore.getAllWithIndex("type", "chatTab").then(
              (items) => {
                console.log("load nav list", items);
                setNavList(() => {
                  if (items == null ? void 0 : items.length) {
                    return items.sort((a2, b2) => b2.createAt - a2.createAt).map((item, index2) => ({
                      ...item,
                      isSelected: index2 === 0
                    }));
                  }
                  return [createNavItem(appInfo, "", true)];
                });
              },
              () => {
                setNavList(() => {
                  return [createNavItem(appInfo, "", true)];
                });
              }
            );
            configStore == null ? void 0 : configStore.getWithIndex("type", appConfigTypeValue).then((config2) => {
              setAppConfig(config2 ?? { type: appConfigTypeValue, appDisplayName: `${appInfo.name}(${appInfo.version})` });
            });
          }).catch((e2) => {
            console.error("create indexed db ", e2);
            setNavList(() => {
              return [createNavItem(appInfo, "", true)];
            });
          }).finally(() => {
            console.error("create indexed finally ");
            setIsLoading(false);
            if (!loadNavSuccessRef.current) {
              setNavList(() => {
                return [createNavItem(appInfo, "", true)];
              });
            }
          });
        }
        return () => {
          var _a2;
          if (appInfo.name && appInfo.version) {
            (_a2 = chatDBRef.current) == null ? void 0 : _a2.close();
          }
        };
      }, [appInfo.name, appInfo.version]);
      return [isLoading];
    };
    const useStoreName = () => {
      const { appInfo } = reactExports.useContext(AppContext);
      return reactExports.useMemo(() => {
        return getChatStoreName(appInfo.name, appInfo.version);
      }, [appInfo.name, appInfo.version]);
    };
    var axios$3 = { exports: {} };
    var bind$2 = function bind2(fn, thisArg) {
      return function wrap2() {
        var args = new Array(arguments.length);
        for (var i2 = 0; i2 < args.length; i2++) {
          args[i2] = arguments[i2];
        }
        return fn.apply(thisArg, args);
      };
    };
    var bind$1 = bind$2;
    var toString$2 = Object.prototype.toString;
    function isArray$2(val) {
      return toString$2.call(val) === "[object Array]";
    }
    function isUndefined$1(val) {
      return typeof val === "undefined";
    }
    function isBuffer$2(val) {
      return val !== null && !isUndefined$1(val) && val.constructor !== null && !isUndefined$1(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    function isArrayBuffer(val) {
      return toString$2.call(val) === "[object ArrayBuffer]";
    }
    function isFormData(val) {
      return typeof FormData !== "undefined" && val instanceof FormData;
    }
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && val.buffer instanceof ArrayBuffer;
      }
      return result;
    }
    function isString$1(val) {
      return typeof val === "string";
    }
    function isNumber$1(val) {
      return typeof val === "number";
    }
    function isObject$1(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject$2(val) {
      if (toString$2.call(val) !== "[object Object]") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    function isDate$1(val) {
      return toString$2.call(val) === "[object Date]";
    }
    function isFile$1(val) {
      return toString$2.call(val) === "[object File]";
    }
    function isBlob(val) {
      return toString$2.call(val) === "[object Blob]";
    }
    function isFunction$1(val) {
      return toString$2.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject$1(val) && isFunction$1(val.pipe);
    }
    function isURLSearchParams(val) {
      return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
    }
    function trim$1(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray$2(obj)) {
        for (var i2 = 0, l2 = obj.length; i2 < l2; i2++) {
          fn.call(null, obj[i2], i2, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge$1() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject$2(result[key]) && isPlainObject$2(val)) {
          result[key] = merge$1(result[key], val);
        } else if (isPlainObject$2(val)) {
          result[key] = merge$1({}, val);
        } else if (isArray$2(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
        forEach(arguments[i2], assignValue);
      }
      return result;
    }
    function extend$3(a2, b2, thisArg) {
      forEach(b2, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a2[key] = bind$1(val, thisArg);
        } else {
          a2[key] = val;
        }
      });
      return a2;
    }
    function stripBOM(content2) {
      if (content2.charCodeAt(0) === 65279) {
        content2 = content2.slice(1);
      }
      return content2;
    }
    var utils$9 = {
      isArray: isArray$2,
      isArrayBuffer,
      isBuffer: isBuffer$2,
      isFormData,
      isArrayBufferView,
      isString: isString$1,
      isNumber: isNumber$1,
      isObject: isObject$1,
      isPlainObject: isPlainObject$2,
      isUndefined: isUndefined$1,
      isDate: isDate$1,
      isFile: isFile$1,
      isBlob,
      isFunction: isFunction$1,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge: merge$1,
      extend: extend$3,
      trim: trim$1,
      stripBOM
    };
    var utils$8 = utils$9;
    function encode$1(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    var buildURL$1 = function buildURL2(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils$8.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils$8.forEach(params, function serialize2(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils$8.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils$8.forEach(val, function parseValue(v2) {
            if (utils$8.isDate(v2)) {
              v2 = v2.toISOString();
            } else if (utils$8.isObject(v2)) {
              v2 = JSON.stringify(v2);
            }
            parts.push(encode$1(key) + "=" + encode$1(v2));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
    var utils$7 = utils$9;
    function InterceptorManager$1() {
      this.handlers = [];
    }
    InterceptorManager$1.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager$1.prototype.eject = function eject(id2) {
      if (this.handlers[id2]) {
        this.handlers[id2] = null;
      }
    };
    InterceptorManager$1.prototype.forEach = function forEach2(fn) {
      utils$7.forEach(this.handlers, function forEachHandler(h2) {
        if (h2 !== null) {
          fn(h2);
        }
      });
    };
    var InterceptorManager_1 = InterceptorManager$1;
    var utils$6 = utils$9;
    var normalizeHeaderName$1 = function normalizeHeaderName2(headers, normalizedName) {
      utils$6.forEach(headers, function processHeader(value, name2) {
        if (name2 !== normalizedName && name2.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name2];
        }
      });
    };
    var enhanceError$1 = function enhanceError2(error, config2, code2, request, response) {
      error.config = config2;
      if (code2) {
        error.code = code2;
      }
      error.request = request;
      error.response = response;
      error.isAxiosError = true;
      error.toJSON = function toJSON2() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code
        };
      };
      return error;
    };
    var createError;
    var hasRequiredCreateError;
    function requireCreateError() {
      if (hasRequiredCreateError)
        return createError;
      hasRequiredCreateError = 1;
      var enhanceError2 = enhanceError$1;
      createError = function createError2(message, config2, code2, request, response) {
        var error = new Error(message);
        return enhanceError2(error, config2, code2, request, response);
      };
      return createError;
    }
    var settle;
    var hasRequiredSettle;
    function requireSettle() {
      if (hasRequiredSettle)
        return settle;
      hasRequiredSettle = 1;
      var createError2 = requireCreateError();
      settle = function settle2(resolve, reject, response) {
        var validateStatus = response.config.validateStatus;
        if (!response.status || !validateStatus || validateStatus(response.status)) {
          resolve(response);
        } else {
          reject(createError2(
            "Request failed with status code " + response.status,
            response.config,
            null,
            response.request,
            response
          ));
        }
      };
      return settle;
    }
    var cookies;
    var hasRequiredCookies;
    function requireCookies() {
      if (hasRequiredCookies)
        return cookies;
      hasRequiredCookies = 1;
      var utils2 = utils$9;
      cookies = utils2.isStandardBrowserEnv() ? (
        // Standard browser envs support document.cookie
        function standardBrowserEnv() {
          return {
            write: function write(name2, value, expires, path2, domain2, secure) {
              var cookie = [];
              cookie.push(name2 + "=" + encodeURIComponent(value));
              if (utils2.isNumber(expires)) {
                cookie.push("expires=" + new Date(expires).toGMTString());
              }
              if (utils2.isString(path2)) {
                cookie.push("path=" + path2);
              }
              if (utils2.isString(domain2)) {
                cookie.push("domain=" + domain2);
              }
              if (secure === true) {
                cookie.push("secure");
              }
              document.cookie = cookie.join("; ");
            },
            read: function read(name2) {
              var match5 = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
              return match5 ? decodeURIComponent(match5[3]) : null;
            },
            remove: function remove(name2) {
              this.write(name2, "", Date.now() - 864e5);
            }
          };
        }()
      ) : (
        // Non standard browser env (web workers, react-native) lack needed support.
        function nonStandardBrowserEnv() {
          return {
            write: function write() {
            },
            read: function read() {
              return null;
            },
            remove: function remove() {
            }
          };
        }()
      );
      return cookies;
    }
    var isAbsoluteURL;
    var hasRequiredIsAbsoluteURL;
    function requireIsAbsoluteURL() {
      if (hasRequiredIsAbsoluteURL)
        return isAbsoluteURL;
      hasRequiredIsAbsoluteURL = 1;
      isAbsoluteURL = function isAbsoluteURL2(url) {
        return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
      };
      return isAbsoluteURL;
    }
    var combineURLs;
    var hasRequiredCombineURLs;
    function requireCombineURLs() {
      if (hasRequiredCombineURLs)
        return combineURLs;
      hasRequiredCombineURLs = 1;
      combineURLs = function combineURLs2(baseURL, relativeURL) {
        return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
      };
      return combineURLs;
    }
    var buildFullPath;
    var hasRequiredBuildFullPath;
    function requireBuildFullPath() {
      if (hasRequiredBuildFullPath)
        return buildFullPath;
      hasRequiredBuildFullPath = 1;
      var isAbsoluteURL2 = requireIsAbsoluteURL();
      var combineURLs2 = requireCombineURLs();
      buildFullPath = function buildFullPath2(baseURL, requestedURL) {
        if (baseURL && !isAbsoluteURL2(requestedURL)) {
          return combineURLs2(baseURL, requestedURL);
        }
        return requestedURL;
      };
      return buildFullPath;
    }
    var parseHeaders;
    var hasRequiredParseHeaders;
    function requireParseHeaders() {
      if (hasRequiredParseHeaders)
        return parseHeaders;
      hasRequiredParseHeaders = 1;
      var utils2 = utils$9;
      var ignoreDuplicateOf = [
        "age",
        "authorization",
        "content-length",
        "content-type",
        "etag",
        "expires",
        "from",
        "host",
        "if-modified-since",
        "if-unmodified-since",
        "last-modified",
        "location",
        "max-forwards",
        "proxy-authorization",
        "referer",
        "retry-after",
        "user-agent"
      ];
      parseHeaders = function parseHeaders2(headers) {
        var parsed = {};
        var key;
        var val;
        var i2;
        if (!headers) {
          return parsed;
        }
        utils2.forEach(headers.split("\n"), function parser2(line2) {
          i2 = line2.indexOf(":");
          key = utils2.trim(line2.substr(0, i2)).toLowerCase();
          val = utils2.trim(line2.substr(i2 + 1));
          if (key) {
            if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
              return;
            }
            if (key === "set-cookie") {
              parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
            } else {
              parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
            }
          }
        });
        return parsed;
      };
      return parseHeaders;
    }
    var isURLSameOrigin;
    var hasRequiredIsURLSameOrigin;
    function requireIsURLSameOrigin() {
      if (hasRequiredIsURLSameOrigin)
        return isURLSameOrigin;
      hasRequiredIsURLSameOrigin = 1;
      var utils2 = utils$9;
      isURLSameOrigin = utils2.isStandardBrowserEnv() ? (
        // Standard browser envs have full support of the APIs needed to test
        // whether the request URL is of the same origin as current location.
        function standardBrowserEnv() {
          var msie = /(msie|trident)/i.test(navigator.userAgent);
          var urlParsingNode = document.createElement("a");
          var originURL;
          function resolveURL(url) {
            var href = url;
            if (msie) {
              urlParsingNode.setAttribute("href", href);
              href = urlParsingNode.href;
            }
            urlParsingNode.setAttribute("href", href);
            return {
              href: urlParsingNode.href,
              protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
              host: urlParsingNode.host,
              search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
              hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
              hostname: urlParsingNode.hostname,
              port: urlParsingNode.port,
              pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
            };
          }
          originURL = resolveURL(window.location.href);
          return function isURLSameOrigin2(requestURL) {
            var parsed = utils2.isString(requestURL) ? resolveURL(requestURL) : requestURL;
            return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
          };
        }()
      ) : (
        // Non standard browser envs (web workers, react-native) lack needed support.
        function nonStandardBrowserEnv() {
          return function isURLSameOrigin2() {
            return true;
          };
        }()
      );
      return isURLSameOrigin;
    }
    var xhr;
    var hasRequiredXhr;
    function requireXhr() {
      if (hasRequiredXhr)
        return xhr;
      hasRequiredXhr = 1;
      var utils2 = utils$9;
      var settle2 = requireSettle();
      var cookies2 = requireCookies();
      var buildURL2 = buildURL$1;
      var buildFullPath2 = requireBuildFullPath();
      var parseHeaders2 = requireParseHeaders();
      var isURLSameOrigin2 = requireIsURLSameOrigin();
      var createError2 = requireCreateError();
      xhr = function xhrAdapter(config2) {
        return new Promise(function dispatchXhrRequest(resolve, reject) {
          var requestData = config2.data;
          var requestHeaders = config2.headers;
          var responseType = config2.responseType;
          if (utils2.isFormData(requestData)) {
            delete requestHeaders["Content-Type"];
          }
          var request = new XMLHttpRequest();
          if (config2.auth) {
            var username = config2.auth.username || "";
            var password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
            requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
          }
          var fullPath = buildFullPath2(config2.baseURL, config2.url);
          request.open(config2.method.toUpperCase(), buildURL2(fullPath, config2.params, config2.paramsSerializer), true);
          request.timeout = config2.timeout;
          function onloadend() {
            if (!request) {
              return;
            }
            var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders2(request.getAllResponseHeaders()) : null;
            var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
            var response = {
              data: responseData,
              status: request.status,
              statusText: request.statusText,
              headers: responseHeaders,
              config: config2,
              request
            };
            settle2(resolve, reject, response);
            request = null;
          }
          if ("onloadend" in request) {
            request.onloadend = onloadend;
          } else {
            request.onreadystatechange = function handleLoad() {
              if (!request || request.readyState !== 4) {
                return;
              }
              if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
                return;
              }
              setTimeout(onloadend);
            };
          }
          request.onabort = function handleAbort() {
            if (!request) {
              return;
            }
            reject(createError2("Request aborted", config2, "ECONNABORTED", request));
            request = null;
          };
          request.onerror = function handleError() {
            reject(createError2("Network Error", config2, null, request));
            request = null;
          };
          request.ontimeout = function handleTimeout() {
            var timeoutErrorMessage = "timeout of " + config2.timeout + "ms exceeded";
            if (config2.timeoutErrorMessage) {
              timeoutErrorMessage = config2.timeoutErrorMessage;
            }
            reject(createError2(
              timeoutErrorMessage,
              config2,
              config2.transitional && config2.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
              request
            ));
            request = null;
          };
          if (utils2.isStandardBrowserEnv()) {
            var xsrfValue = (config2.withCredentials || isURLSameOrigin2(fullPath)) && config2.xsrfCookieName ? cookies2.read(config2.xsrfCookieName) : void 0;
            if (xsrfValue) {
              requestHeaders[config2.xsrfHeaderName] = xsrfValue;
            }
          }
          if ("setRequestHeader" in request) {
            utils2.forEach(requestHeaders, function setRequestHeader(val, key) {
              if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
                delete requestHeaders[key];
              } else {
                request.setRequestHeader(key, val);
              }
            });
          }
          if (!utils2.isUndefined(config2.withCredentials)) {
            request.withCredentials = !!config2.withCredentials;
          }
          if (responseType && responseType !== "json") {
            request.responseType = config2.responseType;
          }
          if (typeof config2.onDownloadProgress === "function") {
            request.addEventListener("progress", config2.onDownloadProgress);
          }
          if (typeof config2.onUploadProgress === "function" && request.upload) {
            request.upload.addEventListener("progress", config2.onUploadProgress);
          }
          if (config2.cancelToken) {
            config2.cancelToken.promise.then(function onCanceled(cancel) {
              if (!request) {
                return;
              }
              request.abort();
              reject(cancel);
              request = null;
            });
          }
          if (!requestData) {
            requestData = null;
          }
          request.send(requestData);
        });
      };
      return xhr;
    }
    var utils$5 = utils$9;
    var normalizeHeaderName = normalizeHeaderName$1;
    var enhanceError = enhanceError$1;
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils$5.isUndefined(headers) && utils$5.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = requireXhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = requireXhr();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser2, encoder) {
      if (utils$5.isString(rawValue)) {
        try {
          (parser2 || JSON.parse)(rawValue);
          return utils$5.trim(rawValue);
        } catch (e2) {
          if (e2.name !== "SyntaxError") {
            throw e2;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults$4 = {
      transitional: {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      },
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils$5.isFormData(data) || utils$5.isArrayBuffer(data) || utils$5.isBuffer(data) || utils$5.isStream(data) || utils$5.isFile(data) || utils$5.isBlob(data)) {
          return data;
        }
        if (utils$5.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils$5.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        if (utils$5.isObject(data) || headers && headers["Content-Type"] === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils$5.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e2) {
            if (strictJSONParsing) {
              if (e2.name === "SyntaxError") {
                throw enhanceError(e2, this, "E_JSON_PARSE");
              }
              throw e2;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      }
    };
    defaults$4.headers = {
      common: {
        "Accept": "application/json, text/plain, */*"
      }
    };
    utils$5.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults$4.headers[method] = {};
    });
    utils$5.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults$4.headers[method] = utils$5.merge(DEFAULT_CONTENT_TYPE);
    });
    var defaults_1 = defaults$4;
    var utils$4 = utils$9;
    var defaults$3 = defaults_1;
    var transformData$1 = function transformData2(data, headers, fns) {
      var context = this || defaults$3;
      utils$4.forEach(fns, function transform2(fn) {
        data = fn.call(context, data, headers);
      });
      return data;
    };
    var isCancel$1;
    var hasRequiredIsCancel;
    function requireIsCancel() {
      if (hasRequiredIsCancel)
        return isCancel$1;
      hasRequiredIsCancel = 1;
      isCancel$1 = function isCancel2(value) {
        return !!(value && value.__CANCEL__);
      };
      return isCancel$1;
    }
    var utils$3 = utils$9;
    var transformData = transformData$1;
    var isCancel = requireIsCancel();
    var defaults$2 = defaults_1;
    function throwIfCancellationRequested(config2) {
      if (config2.cancelToken) {
        config2.cancelToken.throwIfRequested();
      }
    }
    var dispatchRequest$1 = function dispatchRequest2(config2) {
      throwIfCancellationRequested(config2);
      config2.headers = config2.headers || {};
      config2.data = transformData.call(
        config2,
        config2.data,
        config2.headers,
        config2.transformRequest
      );
      config2.headers = utils$3.merge(
        config2.headers.common || {},
        config2.headers[config2.method] || {},
        config2.headers
      );
      utils$3.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        function cleanHeaderConfig(method) {
          delete config2.headers[method];
        }
      );
      var adapter = config2.adapter || defaults$2.adapter;
      return adapter(config2).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config2);
        response.data = transformData.call(
          config2,
          response.data,
          response.headers,
          config2.transformResponse
        );
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config2);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config2,
              reason.response.data,
              reason.response.headers,
              config2.transformResponse
            );
          }
        }
        return Promise.reject(reason);
      });
    };
    var utils$2 = utils$9;
    var mergeConfig$2 = function mergeConfig2(config1, config2) {
      config2 = config2 || {};
      var config3 = {};
      var valueFromConfig2Keys = ["url", "method", "data"];
      var mergeDeepPropertiesKeys = ["headers", "auth", "proxy", "params"];
      var defaultToConfig2Keys = [
        "baseURL",
        "transformRequest",
        "transformResponse",
        "paramsSerializer",
        "timeout",
        "timeoutMessage",
        "withCredentials",
        "adapter",
        "responseType",
        "xsrfCookieName",
        "xsrfHeaderName",
        "onUploadProgress",
        "onDownloadProgress",
        "decompress",
        "maxContentLength",
        "maxBodyLength",
        "maxRedirects",
        "transport",
        "httpAgent",
        "httpsAgent",
        "cancelToken",
        "socketPath",
        "responseEncoding"
      ];
      var directMergeKeys = ["validateStatus"];
      function getMergedValue(target, source) {
        if (utils$2.isPlainObject(target) && utils$2.isPlainObject(source)) {
          return utils$2.merge(target, source);
        } else if (utils$2.isPlainObject(source)) {
          return utils$2.merge({}, source);
        } else if (utils$2.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils$2.isUndefined(config2[prop])) {
          config3[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (!utils$2.isUndefined(config1[prop])) {
          config3[prop] = getMergedValue(void 0, config1[prop]);
        }
      }
      utils$2.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
        if (!utils$2.isUndefined(config2[prop])) {
          config3[prop] = getMergedValue(void 0, config2[prop]);
        }
      });
      utils$2.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
      utils$2.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
        if (!utils$2.isUndefined(config2[prop])) {
          config3[prop] = getMergedValue(void 0, config2[prop]);
        } else if (!utils$2.isUndefined(config1[prop])) {
          config3[prop] = getMergedValue(void 0, config1[prop]);
        }
      });
      utils$2.forEach(directMergeKeys, function merge2(prop) {
        if (prop in config2) {
          config3[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          config3[prop] = getMergedValue(void 0, config1[prop]);
        }
      });
      var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
      var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
        return axiosKeys.indexOf(key) === -1;
      });
      utils$2.forEach(otherKeys, mergeDeepProperties);
      return config3;
    };
    const name = "axios";
    const version = "0.21.4";
    const description = "Promise based HTTP client for the browser and node.js";
    const main$1 = "index.js";
    const scripts = {
      test: "grunt test",
      start: "node ./sandbox/server.js",
      build: "NODE_ENV=production grunt build",
      preversion: "npm test",
      version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
      postversion: "git push && git push --tags",
      examples: "node ./examples/server.js",
      coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
      fix: "eslint --fix lib/**/*.js"
    };
    const repository = {
      type: "git",
      url: "https://github.com/axios/axios.git"
    };
    const keywords = [
      "xhr",
      "http",
      "ajax",
      "promise",
      "node"
    ];
    const author = "Matt Zabriskie";
    const license = "MIT";
    const bugs = {
      url: "https://github.com/axios/axios/issues"
    };
    const homepage = "https://axios-http.com";
    const devDependencies = {
      coveralls: "^3.0.0",
      "es6-promise": "^4.2.4",
      grunt: "^1.3.0",
      "grunt-banner": "^0.6.0",
      "grunt-cli": "^1.2.0",
      "grunt-contrib-clean": "^1.1.0",
      "grunt-contrib-watch": "^1.0.0",
      "grunt-eslint": "^23.0.0",
      "grunt-karma": "^4.0.0",
      "grunt-mocha-test": "^0.13.3",
      "grunt-ts": "^6.0.0-beta.19",
      "grunt-webpack": "^4.0.2",
      "istanbul-instrumenter-loader": "^1.0.0",
      "jasmine-core": "^2.4.1",
      karma: "^6.3.2",
      "karma-chrome-launcher": "^3.1.0",
      "karma-firefox-launcher": "^2.1.0",
      "karma-jasmine": "^1.1.1",
      "karma-jasmine-ajax": "^0.1.13",
      "karma-safari-launcher": "^1.0.0",
      "karma-sauce-launcher": "^4.3.6",
      "karma-sinon": "^1.0.5",
      "karma-sourcemap-loader": "^0.3.8",
      "karma-webpack": "^4.0.2",
      "load-grunt-tasks": "^3.5.2",
      minimist: "^1.2.0",
      mocha: "^8.2.1",
      sinon: "^4.5.0",
      "terser-webpack-plugin": "^4.2.3",
      typescript: "^4.0.5",
      "url-search-params": "^0.10.0",
      webpack: "^4.44.2",
      "webpack-dev-server": "^3.11.0"
    };
    const browser = {
      "./lib/adapters/http.js": "./lib/adapters/xhr.js"
    };
    const jsdelivr = "dist/axios.min.js";
    const unpkg = "dist/axios.min.js";
    const typings = "./index.d.ts";
    const dependencies = {
      "follow-redirects": "^1.14.0"
    };
    const bundlesize = [
      {
        path: "./dist/axios.min.js",
        threshold: "5kB"
      }
    ];
    const require$$0 = {
      name,
      version,
      description,
      main: main$1,
      scripts,
      repository,
      keywords,
      author,
      license,
      bugs,
      homepage,
      devDependencies,
      browser,
      jsdelivr,
      unpkg,
      typings,
      dependencies,
      bundlesize
    };
    var pkg = require$$0;
    var validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i2) {
      validators$1[type] = function validator2(thing) {
        return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    var currentVerArr = pkg.version.split(".");
    function isOlderVersion(version2, thanVersion) {
      var pkgVersionArr = thanVersion ? thanVersion.split(".") : currentVerArr;
      var destVer = version2.split(".");
      for (var i2 = 0; i2 < 3; i2++) {
        if (pkgVersionArr[i2] > destVer[i2]) {
          return true;
        } else if (pkgVersionArr[i2] < destVer[i2]) {
          return false;
        }
      }
      return false;
    }
    validators$1.transitional = function transitional(validator2, version2, message) {
      var isDeprecated = version2 && isOlderVersion(version2);
      function formatMessage(opt, desc) {
        return "[Axios v" + pkg.version + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator2 === false) {
          throw new Error(formatMessage(opt, " has been removed in " + version2));
        }
        if (isDeprecated && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version2 + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new TypeError("options must be an object");
      }
      var keys2 = Object.keys(options);
      var i2 = keys2.length;
      while (i2-- > 0) {
        var opt = keys2[i2];
        var validator2 = schema[opt];
        if (validator2) {
          var value = options[opt];
          var result = value === void 0 || validator2(value, opt, options);
          if (result !== true) {
            throw new TypeError("option " + opt + " must be " + result);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error("Unknown option " + opt);
        }
      }
    }
    var validator$1 = {
      isOlderVersion,
      assertOptions,
      validators: validators$1
    };
    var utils$1 = utils$9;
    var buildURL = buildURL$1;
    var InterceptorManager = InterceptorManager_1;
    var dispatchRequest = dispatchRequest$1;
    var mergeConfig$1 = mergeConfig$2;
    var validator = validator$1;
    var validators = validator.validators;
    function Axios$1(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios$1.prototype.request = function request(config2) {
      if (typeof config2 === "string") {
        config2 = arguments[1] || {};
        config2.url = arguments[0];
      } else {
        config2 = config2 || {};
      }
      config2 = mergeConfig$1(this.defaults, config2);
      if (config2.method) {
        config2.method = config2.method.toLowerCase();
      } else if (this.defaults.method) {
        config2.method = this.defaults.method.toLowerCase();
      } else {
        config2.method = "get";
      }
      var transitional = config2.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
          forcedJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
          clarifyTimeoutError: validators.transitional(validators.boolean, "1.0.0")
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config2);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config2;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios$1.prototype.getUri = function getUri(config2) {
      config2 = mergeConfig$1(this.defaults, config2);
      return buildURL(config2.url, config2.params, config2.paramsSerializer).replace(/^\?/, "");
    };
    utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios$1.prototype[method] = function(url, config2) {
        return this.request(mergeConfig$1(config2 || {}, {
          method,
          url,
          data: (config2 || {}).data
        }));
      };
    });
    utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      Axios$1.prototype[method] = function(url, data, config2) {
        return this.request(mergeConfig$1(config2 || {}, {
          method,
          url,
          data
        }));
      };
    });
    var Axios_1 = Axios$1;
    var Cancel_1;
    var hasRequiredCancel;
    function requireCancel() {
      if (hasRequiredCancel)
        return Cancel_1;
      hasRequiredCancel = 1;
      function Cancel(message) {
        this.message = message;
      }
      Cancel.prototype.toString = function toString2() {
        return "Cancel" + (this.message ? ": " + this.message : "");
      };
      Cancel.prototype.__CANCEL__ = true;
      Cancel_1 = Cancel;
      return Cancel_1;
    }
    var CancelToken_1;
    var hasRequiredCancelToken;
    function requireCancelToken() {
      if (hasRequiredCancelToken)
        return CancelToken_1;
      hasRequiredCancelToken = 1;
      var Cancel = requireCancel();
      function CancelToken(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        var resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        var token2 = this;
        executor(function cancel(message) {
          if (token2.reason) {
            return;
          }
          token2.reason = new Cancel(message);
          resolvePromise(token2.reason);
        });
      }
      CancelToken.prototype.throwIfRequested = function throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      };
      CancelToken.source = function source() {
        var cancel;
        var token2 = new CancelToken(function executor(c2) {
          cancel = c2;
        });
        return {
          token: token2,
          cancel
        };
      };
      CancelToken_1 = CancelToken;
      return CancelToken_1;
    }
    var spread;
    var hasRequiredSpread;
    function requireSpread() {
      if (hasRequiredSpread)
        return spread;
      hasRequiredSpread = 1;
      spread = function spread2(callback) {
        return function wrap2(arr) {
          return callback.apply(null, arr);
        };
      };
      return spread;
    }
    var isAxiosError;
    var hasRequiredIsAxiosError;
    function requireIsAxiosError() {
      if (hasRequiredIsAxiosError)
        return isAxiosError;
      hasRequiredIsAxiosError = 1;
      isAxiosError = function isAxiosError2(payload) {
        return typeof payload === "object" && payload.isAxiosError === true;
      };
      return isAxiosError;
    }
    var utils = utils$9;
    var bind = bind$2;
    var Axios = Axios_1;
    var mergeConfig = mergeConfig$2;
    var defaults$1 = defaults_1;
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind(Axios.prototype.request, context);
      utils.extend(instance, Axios.prototype, context);
      utils.extend(instance, context);
      return instance;
    }
    var axios$2 = createInstance(defaults$1);
    axios$2.Axios = Axios;
    axios$2.create = function create2(instanceConfig) {
      return createInstance(mergeConfig(axios$2.defaults, instanceConfig));
    };
    axios$2.Cancel = requireCancel();
    axios$2.CancelToken = requireCancelToken();
    axios$2.isCancel = requireIsCancel();
    axios$2.all = function all2(promises) {
      return Promise.all(promises);
    };
    axios$2.spread = requireSpread();
    axios$2.isAxiosError = requireIsAxiosError();
    axios$3.exports = axios$2;
    axios$3.exports.default = axios$2;
    var axiosExports = axios$3.exports;
    var axios = axiosExports;
    const axios$1 = /* @__PURE__ */ getDefaultExportFromCjs(axios);
    const startLoggerInterceptor = (config2) => {
      const { method, url, data, params } = config2;
      if (!config2.metaData) {
        config2.metaData = {};
      }
      config2.metaData.startTime = performance.now();
      console.log(`[axios] ${method == null ? void 0 : method.toUpperCase()} ${url}`);
      if (data) {
        console.log(`[axios] data: ${JSON.stringify(data)}`);
      }
      if (params) {
        console.log(`[axios] params: ${JSON.stringify(params)}`);
      }
      return config2;
    };
    const endLoggerInterceptor = (response) => {
      const { config: config2 } = response;
      const { method, url } = config2;
      const startTime = config2.metaData.startTime;
      const duration = (performance.now() - startTime) / 1e3;
      config2.metaData.duration = duration;
      console.log(`[axios] ${method == null ? void 0 : method.toUpperCase()} ${url} ${duration}s`);
      return response;
    };
    const requestInterceptors = [startLoggerInterceptor];
    const responseInterceptors = [endLoggerInterceptor];
    const BASE_URL_PREFIX = "";
    const defaultHttpClientConfig = {
      headers: {
        "x-ms-client-user-type": "Promptflow vscode local server"
      },
      baseURL: BASE_URL_PREFIX,
      timeout: 6e4 * 6
      // 6 minutes
    };
    const createHttpClient = (config2) => {
      const instance = axios$1.create(config2);
      requestInterceptors.forEach((interceptor) => {
        instance.interceptors.request.use(interceptor);
      });
      responseInterceptors.forEach((interceptor) => {
        instance.interceptors.response.use(interceptor);
      });
      return instance;
    };
    const GlobalHttpClient = createHttpClient(defaultHttpClientConfig);
    const getQueryKey = (config2) => {
      const { cacheKey, ...axiosConfig } = config2;
      if (cacheKey) {
        return cacheKey;
      }
      const params = axiosConfig.params ? JSON.stringify(axiosConfig.params) : "";
      const headers = axiosConfig.headers ? JSON.stringify(axiosConfig.headers) : "";
      return cacheKey ? cacheKey : `${config2.method}-${config2.url}-${params}-${headers}`;
    };
    const queryFn = async (config2) => {
      const response = await GlobalHttpClient.request(config2);
      return response;
    };
    function useQuery(config2) {
      return useQuery$1({
        queryKey: getQueryKey(config2),
        queryFn: async () => {
          return queryFn(config2);
        },
        notifyOnChangeProps: "tracked"
      });
    }
    function useMutation(config2, callbacks) {
      return useMutation$1({
        mutationKey: getQueryKey(config2),
        mutationFn: async (payload) => {
          config2.data = payload;
          return queryFn(config2);
        },
        onSuccess: async (data, payload) => {
          var _a2;
          (_a2 = callbacks == null ? void 0 : callbacks.onSuccess) == null ? void 0 : _a2.call(callbacks, data, payload);
        },
        onError: async (error, payload) => {
          var _a2;
          (_a2 = callbacks == null ? void 0 : callbacks.onError) == null ? void 0 : _a2.call(callbacks, error, payload);
        },
        onSettled: async (data, error, payload) => {
          var _a2;
          (_a2 = callbacks == null ? void 0 : callbacks.onSettled) == null ? void 0 : _a2.call(callbacks, data, error, payload);
        }
      });
    }
    const parseScoreInputsFromSwaggerJson = (data) => {
      var _a2, _b, _c, _d, _e;
      const result = {};
      const bodyContent = (_d = (_c = (_b = (_a2 = data.paths["/score"]) == null ? void 0 : _a2.post) == null ? void 0 : _b.requestBody) == null ? void 0 : _c.content) == null ? void 0 : _d["application/json"];
      const properties = (_e = bodyContent == null ? void 0 : bodyContent.schema) == null ? void 0 : _e.properties;
      if (!properties || Object.keys(properties).length === 0) {
        return { inputs: result, isChatHistoryExist: false };
      }
      const isChatHistoryExist = Object.keys(properties).includes(CHAT_HISTORY_KEY);
      Object.keys(properties).filter((key) => key !== CHAT_HISTORY_KEY).forEach((key) => {
        var _a3, _b2;
        result[key] = {
          type: properties[key].type,
          sample: (_a3 = bodyContent == null ? void 0 : bodyContent.example) == null ? void 0 : _a3[key],
          value: ((_b2 = bodyContent == null ? void 0 : bodyContent.example) == null ? void 0 : _b2[key]) ?? ""
          // default value is sample
        };
      });
      return { inputs: result, isChatHistoryExist };
    };
    const useScoreInputs = () => {
      const { isLoading, data } = useQuery({
        url: "/swagger.json",
        method: "GET"
      });
      const { inputs, isChatHistoryExist } = reactExports.useMemo(() => {
        return (data == null ? void 0 : data.data) ? parseScoreInputsFromSwaggerJson(data.data) : { inputs: {}, isChatHistoryExist: false };
      }, [data]);
      const appInfo = reactExports.useMemo(() => {
        var _a2;
        const info = ((_a2 = data == null ? void 0 : data.data) == null ? void 0 : _a2["info"]) ?? {};
        return { name: info["x-flow-name"] ?? "Prompt flow", version: info.version ?? "" };
      }, [data]);
      return { isLoading, inputs, appInfo, isChatHistoryExist };
    };
    var shim = { exports: {} };
    var useSyncExternalStoreShim_production_min = {};
    /**
     * @license React
     * use-sync-external-store-shim.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var e$1 = reactExports;
    function h$2(a2, b2) {
      return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
    }
    var k$1 = "function" === typeof Object.is ? Object.is : h$2, l$2 = e$1.useState, m$1 = e$1.useEffect, n$1 = e$1.useLayoutEffect, p$1 = e$1.useDebugValue;
    function q$1(a2, b2) {
      var d2 = b2(), f2 = l$2({ inst: { value: d2, getSnapshot: b2 } }), c2 = f2[0].inst, g2 = f2[1];
      n$1(function() {
        c2.value = d2;
        c2.getSnapshot = b2;
        r$2(c2) && g2({ inst: c2 });
      }, [a2, d2, b2]);
      m$1(function() {
        r$2(c2) && g2({ inst: c2 });
        return a2(function() {
          r$2(c2) && g2({ inst: c2 });
        });
      }, [a2]);
      p$1(d2);
      return d2;
    }
    function r$2(a2) {
      var b2 = a2.getSnapshot;
      a2 = a2.value;
      try {
        var d2 = b2();
        return !k$1(a2, d2);
      } catch (f2) {
        return true;
      }
    }
    function t$1(a2, b2) {
      return b2();
    }
    var u$1 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? t$1 : q$1;
    useSyncExternalStoreShim_production_min.useSyncExternalStore = void 0 !== e$1.useSyncExternalStore ? e$1.useSyncExternalStore : u$1;
    {
      shim.exports = useSyncExternalStoreShim_production_min;
    }
    var shimExports = shim.exports;
    function subscribe(callback) {
      document.addEventListener("fullscreenchange", callback);
      return () => {
        document.removeEventListener("fullscreenchange", callback);
      };
    }
    const useFullScreen = () => {
      return shimExports.useSyncExternalStore(subscribe, () => !!document.fullscreenElement);
    };
    const useToggleFullScreen = () => {
      const isFullScreen = useFullScreen();
      const onToggleFullScreen = reactExports.useCallback(() => {
        try {
          if (isFullScreen) {
            document.exitFullscreen();
          } else {
            document.documentElement.requestFullscreen();
          }
        } catch (error) {
          console.error(error);
        }
      }, [isFullScreen]);
      return onToggleFullScreen;
    };
    const useMessageActions = () => {
      const { setMessages, chatDBRef, navList, currentMessageNavIdRef } = reactExports.useContext(AppContext);
      const storeName = useStoreName();
      const { id: navId } = navList.find((item) => item.isSelected) ?? {};
      const setAddMessage = reactExports.useCallback(
        (message) => {
          var _a2, _b;
          const _navId = currentMessageNavIdRef.current;
          if (!_navId) {
            return;
          }
          const _message = { ...message, navId: _navId };
          (_b = (_a2 = chatDBRef.current) == null ? void 0 : _a2.getStore(storeName)) == null ? void 0 : _b.put({
            ..._message,
            id: Date.now()
          });
          setMessages((pre) => {
            const nextMessages = new Map(pre);
            nextMessages.set(_navId, [...nextMessages.get(_navId) ?? [], _message]);
            return nextMessages;
          });
        },
        [storeName]
      );
      const setRemoveMessage = reactExports.useCallback(
        (id2) => {
          if (!navId) {
            return;
          }
          setMessages((pre) => {
            var _a2;
            const nextMessages = new Map(pre);
            const index2 = ((_a2 = nextMessages.get(navId)) == null ? void 0 : _a2.findIndex((d2) => d2.id === id2)) ?? -1;
            if (index2 === -1) {
              return pre;
            }
            return nextMessages.set(navId, [...nextMessages.get(navId) ?? []].splice(index2, 1));
          });
        },
        [navId]
      );
      const setResetAtIdAndRemoveAfterId = reactExports.useCallback(
        (id2, message) => {
          if (!navId) {
            return;
          }
          setMessages((pre) => {
            var _a2;
            const nextMessages = new Map(pre);
            const index2 = ((_a2 = nextMessages.get(navId)) == null ? void 0 : _a2.findIndex((d2) => d2.id === id2)) ?? -1;
            if (index2 === -1) {
              return pre;
            }
            return nextMessages.set(navId, [...(nextMessages.get(navId) ?? []).slice(0, index2), message]);
          });
        },
        [navId]
      );
      return { setAddMessage, setRemoveMessage, setResetAtIdAndRemoveAfterId };
    };
    const useMessages = (from2, navId) => {
      const { messages: messages2, navList } = reactExports.useContext(AppContext);
      const { id: defaultNavId } = navList.find((item) => item.isSelected) ?? {};
      const _navId = navId ?? defaultNavId;
      return reactExports.useMemo(() => {
        if (!_navId) {
          return [];
        }
        const _messages = messages2.get(_navId) ?? [];
        return from2 ? _messages.filter((d2) => d2.from === from2) : _messages;
      }, [from2, messages2, _navId]);
    };
    const useIsLastMessage = (id2, from2, navId) => {
      const messages2 = useMessages(from2, navId);
      return messages2.length > 0 && messages2[messages2.length - 1].id === id2;
    };
    const useNavList = () => {
      const { navList, setNavList } = reactExports.useContext(AppContext);
      return [navList, setNavList];
    };
    const useNewNavItem = (name2) => {
      const { appInfo } = reactExports.useContext(AppContext);
      return createNavItem(appInfo, name2);
    };
    const useCreateNavItem = () => {
      const navItem = useNewNavItem();
      const [, setNavList] = useNavList();
      return () => {
        const newNavItem = {
          ...navItem,
          isSelected: true,
          createAt: Date.now()
        };
        setNavList((pre) => {
          const nextNavList = pre.map((item) => ({
            ...item,
            isSelected: false
          }));
          return [newNavItem, ...nextNavList];
        });
      };
    };
    const useSelectNavItem = () => {
      const [, setNavList] = useNavList();
      return reactExports.useCallback((id2) => {
        if (typeof id2 === "string") {
          setNavList((pre) => {
            return pre.filter((item) => !!item.name).map((item) => ({
              ...item,
              isSelected: item.id === id2
            }));
          });
        } else {
          if (id2 >= 0) {
            setNavList((pre) => {
              return pre.filter((item) => !!item.name).map((item, index2) => ({
                ...item,
                isSelected: index2 === id2
              }));
            });
          }
        }
      }, []);
    };
    const useSelectedNavItem = () => {
      const [navList] = useNavList();
      return navList.find((item) => item.isSelected);
    };
    const useEnableCreateNavItem = () => {
      const [navList] = useNavList();
      return navList.findIndex((item) => item.name === "") === -1;
    };
    const useSetNewNavItemName = () => {
      const { chatDBRef } = reactExports.useContext(AppContext);
      const [, setNavList] = useNavList();
      const selectedNavItem = useSelectedNavItem();
      return reactExports.useCallback(
        (name2) => {
          var _a2, _b;
          if ((selectedNavItem == null ? void 0 : selectedNavItem.name) === "") {
            (_b = (_a2 = chatDBRef.current) == null ? void 0 : _a2.getStore(chatConfigIndexDBName)) == null ? void 0 : _b.put({
              ...selectedNavItem,
              name: name2
            });
            setNavList(
              (pre) => pre.map((item) => ({
                ...item,
                name: item.name ? item.name : name2
              }))
            );
          }
        },
        [selectedNavItem, chatDBRef]
      );
    };
    const useEditNavItem = () => {
      const { chatDBRef } = reactExports.useContext(AppContext);
      const [, setNavList] = useNavList();
      return reactExports.useCallback((nextNavItem) => {
        var _a2, _b;
        (_b = (_a2 = chatDBRef.current) == null ? void 0 : _a2.getStore(chatConfigIndexDBName)) == null ? void 0 : _b.updateWithField({ id: nextNavItem.id }, nextNavItem);
        setNavList(
          (pre) => pre.map((item) => {
            if (item.id === nextNavItem.id) {
              return {
                ...item,
                ...nextNavItem
              };
            }
            return item;
          })
        );
      }, []);
    };
    const useEditSelectedNavItem = () => {
      const { id: navId = "" } = useSelectedNavItem() || {};
      const editNavItem = useEditNavItem();
      return reactExports.useCallback(
        (nextNavItem) => {
          editNavItem({
            ...nextNavItem,
            id: navId
          });
        },
        [navId, editNavItem]
      );
    };
    const useDeleteNavItem = (id2) => {
      const { chatDBRef, appInfo } = reactExports.useContext(AppContext);
      const [, setNavList] = useNavList();
      return reactExports.useCallback(() => {
        var _a2, _b, _c, _d;
        setNavList((pre) => {
          if (pre.length === 1) {
            return [createNavItem(appInfo, "", true)];
          } else {
            return pre.filter((item) => item.id !== id2);
          }
        });
        (_b = (_a2 = chatDBRef.current) == null ? void 0 : _a2.getStore(chatConfigIndexDBName)) == null ? void 0 : _b.deleteWithField({ id: id2 });
        (_d = (_c = chatDBRef.current) == null ? void 0 : _c.getStore(getChatStoreName(appInfo.name, appInfo.version))) == null ? void 0 : _d.deleteWithField({ navId: id2 });
      }, [appInfo.name, appInfo.version, chatDBRef, id2]);
    };
    const useDeleteSelectedNavItem = () => {
      const { id: navId = "" } = useSelectedNavItem() || {};
      const deleteNavItem = useDeleteNavItem(navId);
      return reactExports.useCallback(() => {
        deleteNavItem();
      }, [deleteNavItem]);
    };
    const useChatHistoryActions = () => {
      const { setChatHistory, currentMessageNavIdRef } = reactExports.useContext(AppContext);
      const setAddChatHistory = reactExports.useCallback(
        (inputs, outputs, duration) => {
          const navId = currentMessageNavIdRef.current;
          if (!navId) {
            return;
          }
          const newHistory = {
            id: uuid_1.v4(),
            inputs: {
              ...inputs
            },
            outputs: {
              ...outputs
            },
            duration,
            navId
          };
          setChatHistory((prev2) => {
            const nextChatHistory = new Map(prev2);
            const nextHistory = _$1.set(_$1.cloneDeep(newHistory), `inputs.${CHAT_HISTORY_KEY}`, void 0);
            nextChatHistory.set(navId, [...nextChatHistory.get(navId) ?? [], nextHistory]);
            return nextChatHistory;
          });
        },
        []
      );
      return { setAddChatHistory };
    };
    const useCurrentChatHistory = () => {
      const { chatHistory } = reactExports.useContext(AppContext);
      const { id: navId } = useSelectedNavItem() ?? {};
      const currentChatHistory = reactExports.useMemo(() => {
        return navId ? chatHistory.get(navId) ?? [] : [];
      }, [chatHistory, navId]);
      return currentChatHistory;
    };
    const useDisplayMessages = () => {
      const { messages: messages2, viewMode } = reactExports.useContext(AppContext);
      const { id: navId } = useSelectedNavItem() ?? {};
      const navMessages = reactExports.useMemo(() => {
        return navId ? messages2.get(navId) ?? [] : [];
      }, [messages2, navId]);
      const displayMessages = reactExports.useMemo(() => {
        if (viewMode === ViewMode.Debug) {
          return navMessages;
        }
        return navMessages.map((message) => {
          if (message.from !== ChatMessageFrom.User || typeof message.content !== "string") {
            return message;
          }
          const content2 = message.content;
          try {
            const o2 = JSON.parse(content2);
            const keys2 = Object.keys(o2).filter((key) => key !== CHAT_HISTORY_KEY);
            return keys2.length === 1 ? { ...message, content: String(o2[keys2[0]]) } : message;
          } catch (error) {
            return message;
          }
        });
      }, [navMessages, viewMode]);
      return displayMessages;
    };
    const LocStrings = {
      HeaderTitle: "Chat",
      InputPlaceholder: "Input anything to test...",
      Tooltip_Bottom: "Only default variants will be used for chat, if you want to test variants please try batch run. For chatbot and test app bot, it will only show the chat output.",
      Tooltip_Title: "chat",
      Tooltip_TotalTokens: "Total tokens",
      MessageStatus_TimeSpent_Desc: "time spent",
      MessageStatus_TimeSpent_Desc_Capitalized: "Time spent",
      MessageStatus_TimeSpent_Unit: "sec",
      MessageStatus_Tokens_Desc: "Total tokens for generating this",
      MessageStatus_Tokens_Unit: "tokens",
      ClearButtonTooltip: "Click to clear all chat histories",
      Settings: {
        tooltip: "Settings",
        useDarkTheme: "Dark theme",
        useLightTheme: "Light theme"
      },
      ViewMode: {
        Debug: "Debug"
      },
      ClearHistoryTooltip: "Clear chat history",
      LoadingMessage: "Generating chat output for you",
      EnterFullScreenButtonLabel: "",
      ExitFullScreenButtonLabel: "",
      CloseButtonLabel: "",
      SendButtonLabel: ""
    };
    const parseObject = (value) => {
      try {
        return JSON.parse(value);
      } catch (error) {
        console.error(error);
      }
      return value;
    };
    const convertStringToValueType = (value, type) => {
      switch (type) {
        case "integer":
          return parseInt(value, 10);
        case "number":
          return parseFloat(value);
        case "boolean":
          return value === "true";
        case "string":
          return value;
        case "array":
          return parseObject(value) || [];
        case "object":
          return parseObject(value) || {};
        default:
          return value;
      }
    };
    const convertInputsToPayload = (inputs, chatHistory, isChatHistoryExist, isDisableChatHistory) => {
      const payload = {};
      Object.keys(inputs).forEach((key) => {
        payload[key] = convertStringToValueType(inputs[key].value ?? "", inputs[key].type);
      });
      if (isChatHistoryExist) {
        payload[CHAT_HISTORY_KEY] = isDisableChatHistory ? [] : chatHistory;
      }
      return payload;
    };
    var toggleSelection = function() {
      var selection = document.getSelection();
      if (!selection.rangeCount) {
        return function() {
        };
      }
      var active = document.activeElement;
      var ranges = [];
      for (var i2 = 0; i2 < selection.rangeCount; i2++) {
        ranges.push(selection.getRangeAt(i2));
      }
      switch (active.tagName.toUpperCase()) {
        case "INPUT":
        case "TEXTAREA":
          active.blur();
          break;
        default:
          active = null;
          break;
      }
      selection.removeAllRanges();
      return function() {
        selection.type === "Caret" && selection.removeAllRanges();
        if (!selection.rangeCount) {
          ranges.forEach(function(range) {
            selection.addRange(range);
          });
        }
        active && active.focus();
      };
    };
    var deselectCurrent = toggleSelection;
    var clipboardToIE11Formatting = {
      "text/plain": "Text",
      "text/html": "Url",
      "default": "Text"
    };
    var defaultMessage = "Copy to clipboard: #{key}, Enter";
    function format$1(message) {
      var copyKey = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
      return message.replace(/#{\s*key\s*}/g, copyKey);
    }
    function copy(text2, options) {
      var debug, message, reselectPrevious, range, selection, mark2, success = false;
      if (!options) {
        options = {};
      }
      debug = options.debug || false;
      try {
        reselectPrevious = deselectCurrent();
        range = document.createRange();
        selection = document.getSelection();
        mark2 = document.createElement("span");
        mark2.textContent = text2;
        mark2.ariaHidden = "true";
        mark2.style.all = "unset";
        mark2.style.position = "fixed";
        mark2.style.top = 0;
        mark2.style.clip = "rect(0, 0, 0, 0)";
        mark2.style.whiteSpace = "pre";
        mark2.style.webkitUserSelect = "text";
        mark2.style.MozUserSelect = "text";
        mark2.style.msUserSelect = "text";
        mark2.style.userSelect = "text";
        mark2.addEventListener("copy", function(e2) {
          e2.stopPropagation();
          if (options.format) {
            e2.preventDefault();
            if (typeof e2.clipboardData === "undefined") {
              debug && console.warn("unable to use e.clipboardData");
              debug && console.warn("trying IE specific stuff");
              window.clipboardData.clearData();
              var format2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
              window.clipboardData.setData(format2, text2);
            } else {
              e2.clipboardData.clearData();
              e2.clipboardData.setData(options.format, text2);
            }
          }
          if (options.onCopy) {
            e2.preventDefault();
            options.onCopy(e2.clipboardData);
          }
        });
        document.body.appendChild(mark2);
        range.selectNodeContents(mark2);
        selection.addRange(range);
        var successful = document.execCommand("copy");
        if (!successful) {
          throw new Error("copy command was unsuccessful");
        }
        success = true;
      } catch (err) {
        debug && console.error("unable to copy using execCommand: ", err);
        debug && console.warn("trying IE specific stuff");
        try {
          window.clipboardData.setData(options.format || "text", text2);
          options.onCopy && options.onCopy(window.clipboardData);
          success = true;
        } catch (err2) {
          debug && console.error("unable to copy using clipboardData: ", err2);
          debug && console.error("falling back to prompt");
          message = format$1("message" in options ? options.message : defaultMessage);
          window.prompt(message, text2);
        }
      } finally {
        if (selection) {
          if (typeof selection.removeRange == "function") {
            selection.removeRange(range);
          } else {
            selection.removeAllRanges();
          }
        }
        if (mark2) {
          document.body.removeChild(mark2);
        }
        reselectPrevious();
      }
      return success;
    }
    var copyToClipboard = copy;
    const copy$1 = /* @__PURE__ */ getDefaultExportFromCjs(copyToClipboard);
    //! moment.js
    //! version : 2.29.4
    //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
    //! license : MIT
    //! momentjs.com
    var hookCallback;
    function hooks() {
      return hookCallback.apply(null, arguments);
    }
    function setHookCallback(callback) {
      hookCallback = callback;
    }
    function isArray$1(input) {
      return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
    }
    function isObject(input) {
      return input != null && Object.prototype.toString.call(input) === "[object Object]";
    }
    function hasOwnProp(a2, b2) {
      return Object.prototype.hasOwnProperty.call(a2, b2);
    }
    function isObjectEmpty(obj) {
      if (Object.getOwnPropertyNames) {
        return Object.getOwnPropertyNames(obj).length === 0;
      } else {
        var k2;
        for (k2 in obj) {
          if (hasOwnProp(obj, k2)) {
            return false;
          }
        }
        return true;
      }
    }
    function isUndefined(input) {
      return input === void 0;
    }
    function isNumber(input) {
      return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
    }
    function isDate(input) {
      return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
    }
    function map$1(arr, fn) {
      var res2 = [], i2, arrLen = arr.length;
      for (i2 = 0; i2 < arrLen; ++i2) {
        res2.push(fn(arr[i2], i2));
      }
      return res2;
    }
    function extend$2(a2, b2) {
      for (var i2 in b2) {
        if (hasOwnProp(b2, i2)) {
          a2[i2] = b2[i2];
        }
      }
      if (hasOwnProp(b2, "toString")) {
        a2.toString = b2.toString;
      }
      if (hasOwnProp(b2, "valueOf")) {
        a2.valueOf = b2.valueOf;
      }
      return a2;
    }
    function createUTC(input, format2, locale2, strict) {
      return createLocalOrUTC(input, format2, locale2, strict, true).utc();
    }
    function defaultParsingFlags() {
      return {
        empty: false,
        unusedTokens: [],
        unusedInput: [],
        overflow: -2,
        charsLeftOver: 0,
        nullInput: false,
        invalidEra: null,
        invalidMonth: null,
        invalidFormat: false,
        userInvalidated: false,
        iso: false,
        parsedDateParts: [],
        era: null,
        meridiem: null,
        rfc2822: false,
        weekdayMismatch: false
      };
    }
    function getParsingFlags(m2) {
      if (m2._pf == null) {
        m2._pf = defaultParsingFlags();
      }
      return m2._pf;
    }
    var some;
    if (Array.prototype.some) {
      some = Array.prototype.some;
    } else {
      some = function(fun) {
        var t2 = Object(this), len = t2.length >>> 0, i2;
        for (i2 = 0; i2 < len; i2++) {
          if (i2 in t2 && fun.call(this, t2[i2], i2, t2)) {
            return true;
          }
        }
        return false;
      };
    }
    function isValid(m2) {
      if (m2._isValid == null) {
        var flags = getParsingFlags(m2), parsedParts = some.call(flags.parsedDateParts, function(i2) {
          return i2 != null;
        }), isNowValid = !isNaN(m2._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
        if (m2._strict) {
          isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
        }
        if (Object.isFrozen == null || !Object.isFrozen(m2)) {
          m2._isValid = isNowValid;
        } else {
          return isNowValid;
        }
      }
      return m2._isValid;
    }
    function createInvalid(flags) {
      var m2 = createUTC(NaN);
      if (flags != null) {
        extend$2(getParsingFlags(m2), flags);
      } else {
        getParsingFlags(m2).userInvalidated = true;
      }
      return m2;
    }
    var momentProperties = hooks.momentProperties = [], updateInProgress = false;
    function copyConfig(to2, from2) {
      var i2, prop, val, momentPropertiesLen = momentProperties.length;
      if (!isUndefined(from2._isAMomentObject)) {
        to2._isAMomentObject = from2._isAMomentObject;
      }
      if (!isUndefined(from2._i)) {
        to2._i = from2._i;
      }
      if (!isUndefined(from2._f)) {
        to2._f = from2._f;
      }
      if (!isUndefined(from2._l)) {
        to2._l = from2._l;
      }
      if (!isUndefined(from2._strict)) {
        to2._strict = from2._strict;
      }
      if (!isUndefined(from2._tzm)) {
        to2._tzm = from2._tzm;
      }
      if (!isUndefined(from2._isUTC)) {
        to2._isUTC = from2._isUTC;
      }
      if (!isUndefined(from2._offset)) {
        to2._offset = from2._offset;
      }
      if (!isUndefined(from2._pf)) {
        to2._pf = getParsingFlags(from2);
      }
      if (!isUndefined(from2._locale)) {
        to2._locale = from2._locale;
      }
      if (momentPropertiesLen > 0) {
        for (i2 = 0; i2 < momentPropertiesLen; i2++) {
          prop = momentProperties[i2];
          val = from2[prop];
          if (!isUndefined(val)) {
            to2[prop] = val;
          }
        }
      }
      return to2;
    }
    function Moment(config2) {
      copyConfig(this, config2);
      this._d = new Date(config2._d != null ? config2._d.getTime() : NaN);
      if (!this.isValid()) {
        this._d = /* @__PURE__ */ new Date(NaN);
      }
      if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
      }
    }
    function isMoment(obj) {
      return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
    }
    function warn(msg) {
      if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
        console.warn("Deprecation warning: " + msg);
      }
    }
    function deprecate(msg, fn) {
      var firstTime = true;
      return extend$2(function() {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
          var args = [], arg, i2, key, argLen = arguments.length;
          for (i2 = 0; i2 < argLen; i2++) {
            arg = "";
            if (typeof arguments[i2] === "object") {
              arg += "\n[" + i2 + "] ";
              for (key in arguments[0]) {
                if (hasOwnProp(arguments[0], key)) {
                  arg += key + ": " + arguments[0][key] + ", ";
                }
              }
              arg = arg.slice(0, -2);
            } else {
              arg = arguments[i2];
            }
            args.push(arg);
          }
          warn(
            msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
          );
          firstTime = false;
        }
        return fn.apply(this, arguments);
      }, fn);
    }
    var deprecations = {};
    function deprecateSimple(name2, msg) {
      if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name2, msg);
      }
      if (!deprecations[name2]) {
        warn(msg);
        deprecations[name2] = true;
      }
    }
    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;
    function isFunction(input) {
      return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
    }
    function set(config2) {
      var prop, i2;
      for (i2 in config2) {
        if (hasOwnProp(config2, i2)) {
          prop = config2[i2];
          if (isFunction(prop)) {
            this[i2] = prop;
          } else {
            this["_" + i2] = prop;
          }
        }
      }
      this._config = config2;
      this._dayOfMonthOrdinalParseLenient = new RegExp(
        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
      );
    }
    function mergeConfigs(parentConfig, childConfig) {
      var res2 = extend$2({}, parentConfig), prop;
      for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
          if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
            res2[prop] = {};
            extend$2(res2[prop], parentConfig[prop]);
            extend$2(res2[prop], childConfig[prop]);
          } else if (childConfig[prop] != null) {
            res2[prop] = childConfig[prop];
          } else {
            delete res2[prop];
          }
        }
      }
      for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
          res2[prop] = extend$2({}, res2[prop]);
        }
      }
      return res2;
    }
    function Locale(config2) {
      if (config2 != null) {
        this.set(config2);
      }
    }
    var keys$1;
    if (Object.keys) {
      keys$1 = Object.keys;
    } else {
      keys$1 = function(obj) {
        var i2, res2 = [];
        for (i2 in obj) {
          if (hasOwnProp(obj, i2)) {
            res2.push(i2);
          }
        }
        return res2;
      };
    }
    var defaultCalendar = {
      sameDay: "[Today at] LT",
      nextDay: "[Tomorrow at] LT",
      nextWeek: "dddd [at] LT",
      lastDay: "[Yesterday at] LT",
      lastWeek: "[Last] dddd [at] LT",
      sameElse: "L"
    };
    function calendar(key, mom, now2) {
      var output = this._calendar[key] || this._calendar["sameElse"];
      return isFunction(output) ? output.call(mom, now2) : output;
    }
    function zeroFill(number2, targetLength, forceSign) {
      var absNumber = "" + Math.abs(number2), zerosToFill = targetLength - absNumber.length, sign2 = number2 >= 0;
      return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }
    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
    function addFormatToken(token2, padded, ordinal2, callback) {
      var func = callback;
      if (typeof callback === "string") {
        func = function() {
          return this[callback]();
        };
      }
      if (token2) {
        formatTokenFunctions[token2] = func;
      }
      if (padded) {
        formatTokenFunctions[padded[0]] = function() {
          return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
      }
      if (ordinal2) {
        formatTokenFunctions[ordinal2] = function() {
          return this.localeData().ordinal(
            func.apply(this, arguments),
            token2
          );
        };
      }
    }
    function removeFormattingTokens(input) {
      if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, "");
      }
      return input.replace(/\\/g, "");
    }
    function makeFormatFunction(format2) {
      var array = format2.match(formattingTokens), i2, length2;
      for (i2 = 0, length2 = array.length; i2 < length2; i2++) {
        if (formatTokenFunctions[array[i2]]) {
          array[i2] = formatTokenFunctions[array[i2]];
        } else {
          array[i2] = removeFormattingTokens(array[i2]);
        }
      }
      return function(mom) {
        var output = "", i3;
        for (i3 = 0; i3 < length2; i3++) {
          output += isFunction(array[i3]) ? array[i3].call(mom, format2) : array[i3];
        }
        return output;
      };
    }
    function formatMoment(m2, format2) {
      if (!m2.isValid()) {
        return m2.localeData().invalidDate();
      }
      format2 = expandFormat(format2, m2.localeData());
      formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
      return formatFunctions[format2](m2);
    }
    function expandFormat(format2, locale2) {
      var i2 = 5;
      function replaceLongDateFormatTokens(input) {
        return locale2.longDateFormat(input) || input;
      }
      localFormattingTokens.lastIndex = 0;
      while (i2 >= 0 && localFormattingTokens.test(format2)) {
        format2 = format2.replace(
          localFormattingTokens,
          replaceLongDateFormatTokens
        );
        localFormattingTokens.lastIndex = 0;
        i2 -= 1;
      }
      return format2;
    }
    var defaultLongDateFormat = {
      LTS: "h:mm:ss A",
      LT: "h:mm A",
      L: "MM/DD/YYYY",
      LL: "MMMM D, YYYY",
      LLL: "MMMM D, YYYY h:mm A",
      LLLL: "dddd, MMMM D, YYYY h:mm A"
    };
    function longDateFormat(key) {
      var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
      if (format2 || !formatUpper) {
        return format2;
      }
      this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
        if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
          return tok.slice(1);
        }
        return tok;
      }).join("");
      return this._longDateFormat[key];
    }
    var defaultInvalidDate = "Invalid date";
    function invalidDate() {
      return this._invalidDate;
    }
    var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
    function ordinal(number2) {
      return this._ordinal.replace("%d", number2);
    }
    var defaultRelativeTime = {
      future: "in %s",
      past: "%s ago",
      s: "a few seconds",
      ss: "%d seconds",
      m: "a minute",
      mm: "%d minutes",
      h: "an hour",
      hh: "%d hours",
      d: "a day",
      dd: "%d days",
      w: "a week",
      ww: "%d weeks",
      M: "a month",
      MM: "%d months",
      y: "a year",
      yy: "%d years"
    };
    function relativeTime(number2, withoutSuffix, string2, isFuture) {
      var output = this._relativeTime[string2];
      return isFunction(output) ? output(number2, withoutSuffix, string2, isFuture) : output.replace(/%d/i, number2);
    }
    function pastFuture(diff2, output) {
      var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
      return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
    }
    var aliases = {};
    function addUnitAlias(unit, shorthand) {
      var lowerCase = unit.toLowerCase();
      aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
    }
    function normalizeUnits(units) {
      return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
    }
    function normalizeObjectUnits(inputObject) {
      var normalizedInput = {}, normalizedProp, prop;
      for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
          normalizedProp = normalizeUnits(prop);
          if (normalizedProp) {
            normalizedInput[normalizedProp] = inputObject[prop];
          }
        }
      }
      return normalizedInput;
    }
    var priorities = {};
    function addUnitPriority(unit, priority) {
      priorities[unit] = priority;
    }
    function getPrioritizedUnits(unitsObj) {
      var units = [], u2;
      for (u2 in unitsObj) {
        if (hasOwnProp(unitsObj, u2)) {
          units.push({ unit: u2, priority: priorities[u2] });
        }
      }
      units.sort(function(a2, b2) {
        return a2.priority - b2.priority;
      });
      return units;
    }
    function isLeapYear(year) {
      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
    function absFloor(number2) {
      if (number2 < 0) {
        return Math.ceil(number2) || 0;
      } else {
        return Math.floor(number2);
      }
    }
    function toInt(argumentForCoercion) {
      var coercedNumber = +argumentForCoercion, value = 0;
      if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
      }
      return value;
    }
    function makeGetSet(unit, keepTime) {
      return function(value) {
        if (value != null) {
          set$1(this, unit, value);
          hooks.updateOffset(this, keepTime);
          return this;
        } else {
          return get(this, unit);
        }
      };
    }
    function get(mom, unit) {
      return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
    }
    function set$1(mom, unit, value) {
      if (mom.isValid() && !isNaN(value)) {
        if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
          value = toInt(value);
          mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
            value,
            mom.month(),
            daysInMonth(value, mom.month())
          );
        } else {
          mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
        }
      }
    }
    function stringGet(units) {
      units = normalizeUnits(units);
      if (isFunction(this[units])) {
        return this[units]();
      }
      return this;
    }
    function stringSet(units, value) {
      if (typeof units === "object") {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units), i2, prioritizedLen = prioritized.length;
        for (i2 = 0; i2 < prioritizedLen; i2++) {
          this[prioritized[i2].unit](units[prioritized[i2].unit]);
        }
      } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units](value);
        }
      }
      return this;
    }
    var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
    regexes = {};
    function addRegexToken(token2, regex2, strictRegex) {
      regexes[token2] = isFunction(regex2) ? regex2 : function(isStrict, localeData2) {
        return isStrict && strictRegex ? strictRegex : regex2;
      };
    }
    function getParseRegexForToken(token2, config2) {
      if (!hasOwnProp(regexes, token2)) {
        return new RegExp(unescapeFormat(token2));
      }
      return regexes[token2](config2._strict, config2._locale);
    }
    function unescapeFormat(s2) {
      return regexEscape(
        s2.replace("\\", "").replace(
          /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
          function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
          }
        )
      );
    }
    function regexEscape(s2) {
      return s2.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    var tokens = {};
    function addParseToken(token2, callback) {
      var i2, func = callback, tokenLen;
      if (typeof token2 === "string") {
        token2 = [token2];
      }
      if (isNumber(callback)) {
        func = function(input, array) {
          array[callback] = toInt(input);
        };
      }
      tokenLen = token2.length;
      for (i2 = 0; i2 < tokenLen; i2++) {
        tokens[token2[i2]] = func;
      }
    }
    function addWeekParseToken(token2, callback) {
      addParseToken(token2, function(input, array, config2, token3) {
        config2._w = config2._w || {};
        callback(input, config2._w, config2, token3);
      });
    }
    function addTimeToArrayFromToken(token2, input, config2) {
      if (input != null && hasOwnProp(tokens, token2)) {
        tokens[token2](input, config2._a, config2, token2);
      }
    }
    var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
    function mod(n2, x2) {
      return (n2 % x2 + x2) % x2;
    }
    var indexOf;
    if (Array.prototype.indexOf) {
      indexOf = Array.prototype.indexOf;
    } else {
      indexOf = function(o2) {
        var i2;
        for (i2 = 0; i2 < this.length; ++i2) {
          if (this[i2] === o2) {
            return i2;
          }
        }
        return -1;
      };
    }
    function daysInMonth(year, month) {
      if (isNaN(year) || isNaN(month)) {
        return NaN;
      }
      var modMonth = mod(month, 12);
      year += (month - modMonth) / 12;
      return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
    }
    addFormatToken("M", ["MM", 2], "Mo", function() {
      return this.month() + 1;
    });
    addFormatToken("MMM", 0, 0, function(format2) {
      return this.localeData().monthsShort(this, format2);
    });
    addFormatToken("MMMM", 0, 0, function(format2) {
      return this.localeData().months(this, format2);
    });
    addUnitAlias("month", "M");
    addUnitPriority("month", 8);
    addRegexToken("M", match1to2);
    addRegexToken("MM", match1to2, match2);
    addRegexToken("MMM", function(isStrict, locale2) {
      return locale2.monthsShortRegex(isStrict);
    });
    addRegexToken("MMMM", function(isStrict, locale2) {
      return locale2.monthsRegex(isStrict);
    });
    addParseToken(["M", "MM"], function(input, array) {
      array[MONTH] = toInt(input) - 1;
    });
    addParseToken(["MMM", "MMMM"], function(input, array, config2, token2) {
      var month = config2._locale.monthsParse(input, token2, config2._strict);
      if (month != null) {
        array[MONTH] = month;
      } else {
        getParsingFlags(config2).invalidMonth = input;
      }
    });
    var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
      "_"
    ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
    function localeMonths(m2, format2) {
      if (!m2) {
        return isArray$1(this._months) ? this._months : this._months["standalone"];
      }
      return isArray$1(this._months) ? this._months[m2.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m2.month()];
    }
    function localeMonthsShort(m2, format2) {
      if (!m2) {
        return isArray$1(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
      }
      return isArray$1(this._monthsShort) ? this._monthsShort[m2.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m2.month()];
    }
    function handleStrictParse(monthName, format2, strict) {
      var i2, ii2, mom, llc = monthName.toLocaleLowerCase();
      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i2 = 0; i2 < 12; ++i2) {
          mom = createUTC([2e3, i2]);
          this._shortMonthsParse[i2] = this.monthsShort(
            mom,
            ""
          ).toLocaleLowerCase();
          this._longMonthsParse[i2] = this.months(mom, "").toLocaleLowerCase();
        }
      }
      if (strict) {
        if (format2 === "MMM") {
          ii2 = indexOf.call(this._shortMonthsParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else {
          ii2 = indexOf.call(this._longMonthsParse, llc);
          return ii2 !== -1 ? ii2 : null;
        }
      } else {
        if (format2 === "MMM") {
          ii2 = indexOf.call(this._shortMonthsParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._longMonthsParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else {
          ii2 = indexOf.call(this._longMonthsParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._shortMonthsParse, llc);
          return ii2 !== -1 ? ii2 : null;
        }
      }
    }
    function localeMonthsParse(monthName, format2, strict) {
      var i2, mom, regex2;
      if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format2, strict);
      }
      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
      }
      for (i2 = 0; i2 < 12; i2++) {
        mom = createUTC([2e3, i2]);
        if (strict && !this._longMonthsParse[i2]) {
          this._longMonthsParse[i2] = new RegExp(
            "^" + this.months(mom, "").replace(".", "") + "$",
            "i"
          );
          this._shortMonthsParse[i2] = new RegExp(
            "^" + this.monthsShort(mom, "").replace(".", "") + "$",
            "i"
          );
        }
        if (!strict && !this._monthsParse[i2]) {
          regex2 = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
          this._monthsParse[i2] = new RegExp(regex2.replace(".", ""), "i");
        }
        if (strict && format2 === "MMMM" && this._longMonthsParse[i2].test(monthName)) {
          return i2;
        } else if (strict && format2 === "MMM" && this._shortMonthsParse[i2].test(monthName)) {
          return i2;
        } else if (!strict && this._monthsParse[i2].test(monthName)) {
          return i2;
        }
      }
    }
    function setMonth(mom, value) {
      var dayOfMonth;
      if (!mom.isValid()) {
        return mom;
      }
      if (typeof value === "string") {
        if (/^\d+$/.test(value)) {
          value = toInt(value);
        } else {
          value = mom.localeData().monthsParse(value);
          if (!isNumber(value)) {
            return mom;
          }
        }
      }
      dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
      mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
      return mom;
    }
    function getSetMonth(value) {
      if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
      } else {
        return get(this, "Month");
      }
    }
    function getDaysInMonth() {
      return daysInMonth(this.year(), this.month());
    }
    function monthsShortRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, "_monthsRegex")) {
          computeMonthsParse.call(this);
        }
        if (isStrict) {
          return this._monthsShortStrictRegex;
        } else {
          return this._monthsShortRegex;
        }
      } else {
        if (!hasOwnProp(this, "_monthsShortRegex")) {
          this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
      }
    }
    function monthsRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, "_monthsRegex")) {
          computeMonthsParse.call(this);
        }
        if (isStrict) {
          return this._monthsStrictRegex;
        } else {
          return this._monthsRegex;
        }
      } else {
        if (!hasOwnProp(this, "_monthsRegex")) {
          this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
      }
    }
    function computeMonthsParse() {
      function cmpLenRev(a2, b2) {
        return b2.length - a2.length;
      }
      var shortPieces = [], longPieces = [], mixedPieces = [], i2, mom;
      for (i2 = 0; i2 < 12; i2++) {
        mom = createUTC([2e3, i2]);
        shortPieces.push(this.monthsShort(mom, ""));
        longPieces.push(this.months(mom, ""));
        mixedPieces.push(this.months(mom, ""));
        mixedPieces.push(this.monthsShort(mom, ""));
      }
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);
      for (i2 = 0; i2 < 12; i2++) {
        shortPieces[i2] = regexEscape(shortPieces[i2]);
        longPieces[i2] = regexEscape(longPieces[i2]);
      }
      for (i2 = 0; i2 < 24; i2++) {
        mixedPieces[i2] = regexEscape(mixedPieces[i2]);
      }
      this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._monthsShortRegex = this._monthsRegex;
      this._monthsStrictRegex = new RegExp(
        "^(" + longPieces.join("|") + ")",
        "i"
      );
      this._monthsShortStrictRegex = new RegExp(
        "^(" + shortPieces.join("|") + ")",
        "i"
      );
    }
    addFormatToken("Y", 0, 0, function() {
      var y2 = this.year();
      return y2 <= 9999 ? zeroFill(y2, 4) : "+" + y2;
    });
    addFormatToken(0, ["YY", 2], 0, function() {
      return this.year() % 100;
    });
    addFormatToken(0, ["YYYY", 4], 0, "year");
    addFormatToken(0, ["YYYYY", 5], 0, "year");
    addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
    addUnitAlias("year", "y");
    addUnitPriority("year", 1);
    addRegexToken("Y", matchSigned);
    addRegexToken("YY", match1to2, match2);
    addRegexToken("YYYY", match1to4, match4);
    addRegexToken("YYYYY", match1to6, match6);
    addRegexToken("YYYYYY", match1to6, match6);
    addParseToken(["YYYYY", "YYYYYY"], YEAR);
    addParseToken("YYYY", function(input, array) {
      array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken("YY", function(input, array) {
      array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken("Y", function(input, array) {
      array[YEAR] = parseInt(input, 10);
    });
    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }
    hooks.parseTwoDigitYear = function(input) {
      return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
    };
    var getSetYear = makeGetSet("FullYear", true);
    function getIsLeapYear() {
      return isLeapYear(this.year());
    }
    function createDate(y2, m2, d2, h2, M2, s2, ms) {
      var date;
      if (y2 < 100 && y2 >= 0) {
        date = new Date(y2 + 400, m2, d2, h2, M2, s2, ms);
        if (isFinite(date.getFullYear())) {
          date.setFullYear(y2);
        }
      } else {
        date = new Date(y2, m2, d2, h2, M2, s2, ms);
      }
      return date;
    }
    function createUTCDate(y2) {
      var date, args;
      if (y2 < 100 && y2 >= 0) {
        args = Array.prototype.slice.call(arguments);
        args[0] = y2 + 400;
        date = new Date(Date.UTC.apply(null, args));
        if (isFinite(date.getUTCFullYear())) {
          date.setUTCFullYear(y2);
        }
      } else {
        date = new Date(Date.UTC.apply(null, arguments));
      }
      return date;
    }
    function firstWeekOffset(year, dow, doy) {
      var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
      return -fwdlw + fwd - 1;
    }
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
      var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
      if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
      } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
      } else {
        resYear = year;
        resDayOfYear = dayOfYear;
      }
      return {
        year: resYear,
        dayOfYear: resDayOfYear
      };
    }
    function weekOfYear(mom, dow, doy) {
      var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
      if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
      } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
      } else {
        resYear = mom.year();
        resWeek = week;
      }
      return {
        week: resWeek,
        year: resYear
      };
    }
    function weeksInYear(year, dow, doy) {
      var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
      return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }
    addFormatToken("w", ["ww", 2], "wo", "week");
    addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
    addUnitAlias("week", "w");
    addUnitAlias("isoWeek", "W");
    addUnitPriority("week", 5);
    addUnitPriority("isoWeek", 5);
    addRegexToken("w", match1to2);
    addRegexToken("ww", match1to2, match2);
    addRegexToken("W", match1to2);
    addRegexToken("WW", match1to2, match2);
    addWeekParseToken(
      ["w", "ww", "W", "WW"],
      function(input, week, config2, token2) {
        week[token2.substr(0, 1)] = toInt(input);
      }
    );
    function localeWeek(mom) {
      return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }
    var defaultLocaleWeek = {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6
      // The week that contains Jan 6th is the first week of the year.
    };
    function localeFirstDayOfWeek() {
      return this._week.dow;
    }
    function localeFirstDayOfYear() {
      return this._week.doy;
    }
    function getSetWeek(input) {
      var week = this.localeData().week(this);
      return input == null ? week : this.add((input - week) * 7, "d");
    }
    function getSetISOWeek(input) {
      var week = weekOfYear(this, 1, 4).week;
      return input == null ? week : this.add((input - week) * 7, "d");
    }
    addFormatToken("d", 0, "do", "day");
    addFormatToken("dd", 0, 0, function(format2) {
      return this.localeData().weekdaysMin(this, format2);
    });
    addFormatToken("ddd", 0, 0, function(format2) {
      return this.localeData().weekdaysShort(this, format2);
    });
    addFormatToken("dddd", 0, 0, function(format2) {
      return this.localeData().weekdays(this, format2);
    });
    addFormatToken("e", 0, 0, "weekday");
    addFormatToken("E", 0, 0, "isoWeekday");
    addUnitAlias("day", "d");
    addUnitAlias("weekday", "e");
    addUnitAlias("isoWeekday", "E");
    addUnitPriority("day", 11);
    addUnitPriority("weekday", 11);
    addUnitPriority("isoWeekday", 11);
    addRegexToken("d", match1to2);
    addRegexToken("e", match1to2);
    addRegexToken("E", match1to2);
    addRegexToken("dd", function(isStrict, locale2) {
      return locale2.weekdaysMinRegex(isStrict);
    });
    addRegexToken("ddd", function(isStrict, locale2) {
      return locale2.weekdaysShortRegex(isStrict);
    });
    addRegexToken("dddd", function(isStrict, locale2) {
      return locale2.weekdaysRegex(isStrict);
    });
    addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config2, token2) {
      var weekday = config2._locale.weekdaysParse(input, token2, config2._strict);
      if (weekday != null) {
        week.d = weekday;
      } else {
        getParsingFlags(config2).invalidWeekday = input;
      }
    });
    addWeekParseToken(["d", "e", "E"], function(input, week, config2, token2) {
      week[token2] = toInt(input);
    });
    function parseWeekday(input, locale2) {
      if (typeof input !== "string") {
        return input;
      }
      if (!isNaN(input)) {
        return parseInt(input, 10);
      }
      input = locale2.weekdaysParse(input);
      if (typeof input === "number") {
        return input;
      }
      return null;
    }
    function parseIsoWeekday(input, locale2) {
      if (typeof input === "string") {
        return locale2.weekdaysParse(input) % 7 || 7;
      }
      return isNaN(input) ? null : input;
    }
    function shiftWeekdays(ws, n2) {
      return ws.slice(n2, 7).concat(ws.slice(0, n2));
    }
    var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
    function localeWeekdays(m2, format2) {
      var weekdays = isArray$1(this._weekdays) ? this._weekdays : this._weekdays[m2 && m2 !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
      return m2 === true ? shiftWeekdays(weekdays, this._week.dow) : m2 ? weekdays[m2.day()] : weekdays;
    }
    function localeWeekdaysShort(m2) {
      return m2 === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m2 ? this._weekdaysShort[m2.day()] : this._weekdaysShort;
    }
    function localeWeekdaysMin(m2) {
      return m2 === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m2 ? this._weekdaysMin[m2.day()] : this._weekdaysMin;
    }
    function handleStrictParse$1(weekdayName, format2, strict) {
      var i2, ii2, mom, llc = weekdayName.toLocaleLowerCase();
      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];
        for (i2 = 0; i2 < 7; ++i2) {
          mom = createUTC([2e3, 1]).day(i2);
          this._minWeekdaysParse[i2] = this.weekdaysMin(
            mom,
            ""
          ).toLocaleLowerCase();
          this._shortWeekdaysParse[i2] = this.weekdaysShort(
            mom,
            ""
          ).toLocaleLowerCase();
          this._weekdaysParse[i2] = this.weekdays(mom, "").toLocaleLowerCase();
        }
      }
      if (strict) {
        if (format2 === "dddd") {
          ii2 = indexOf.call(this._weekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else if (format2 === "ddd") {
          ii2 = indexOf.call(this._shortWeekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else {
          ii2 = indexOf.call(this._minWeekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        }
      } else {
        if (format2 === "dddd") {
          ii2 = indexOf.call(this._weekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._shortWeekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._minWeekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else if (format2 === "ddd") {
          ii2 = indexOf.call(this._shortWeekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._weekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._minWeekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        } else {
          ii2 = indexOf.call(this._minWeekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._weekdaysParse, llc);
          if (ii2 !== -1) {
            return ii2;
          }
          ii2 = indexOf.call(this._shortWeekdaysParse, llc);
          return ii2 !== -1 ? ii2 : null;
        }
      }
    }
    function localeWeekdaysParse(weekdayName, format2, strict) {
      var i2, mom, regex2;
      if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format2, strict);
      }
      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
      }
      for (i2 = 0; i2 < 7; i2++) {
        mom = createUTC([2e3, 1]).day(i2);
        if (strict && !this._fullWeekdaysParse[i2]) {
          this._fullWeekdaysParse[i2] = new RegExp(
            "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
            "i"
          );
          this._shortWeekdaysParse[i2] = new RegExp(
            "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
            "i"
          );
          this._minWeekdaysParse[i2] = new RegExp(
            "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
            "i"
          );
        }
        if (!this._weekdaysParse[i2]) {
          regex2 = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
          this._weekdaysParse[i2] = new RegExp(regex2.replace(".", ""), "i");
        }
        if (strict && format2 === "dddd" && this._fullWeekdaysParse[i2].test(weekdayName)) {
          return i2;
        } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i2].test(weekdayName)) {
          return i2;
        } else if (strict && format2 === "dd" && this._minWeekdaysParse[i2].test(weekdayName)) {
          return i2;
        } else if (!strict && this._weekdaysParse[i2].test(weekdayName)) {
          return i2;
        }
      }
    }
    function getSetDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
      if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, "d");
      } else {
        return day;
      }
    }
    function getSetLocaleDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
      return input == null ? weekday : this.add(input - weekday, "d");
    }
    function getSetISODayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
      } else {
        return this.day() || 7;
      }
    }
    function weekdaysRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysStrictRegex;
        } else {
          return this._weekdaysRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
      }
    }
    function weekdaysShortRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysShortStrictRegex;
        } else {
          return this._weekdaysShortRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysShortRegex")) {
          this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
      }
    }
    function weekdaysMinRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysMinStrictRegex;
        } else {
          return this._weekdaysMinRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysMinRegex")) {
          this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
      }
    }
    function computeWeekdaysParse() {
      function cmpLenRev(a2, b2) {
        return b2.length - a2.length;
      }
      var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i2, mom, minp, shortp, longp;
      for (i2 = 0; i2 < 7; i2++) {
        mom = createUTC([2e3, 1]).day(i2);
        minp = regexEscape(this.weekdaysMin(mom, ""));
        shortp = regexEscape(this.weekdaysShort(mom, ""));
        longp = regexEscape(this.weekdays(mom, ""));
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
      }
      minPieces.sort(cmpLenRev);
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);
      this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._weekdaysShortRegex = this._weekdaysRegex;
      this._weekdaysMinRegex = this._weekdaysRegex;
      this._weekdaysStrictRegex = new RegExp(
        "^(" + longPieces.join("|") + ")",
        "i"
      );
      this._weekdaysShortStrictRegex = new RegExp(
        "^(" + shortPieces.join("|") + ")",
        "i"
      );
      this._weekdaysMinStrictRegex = new RegExp(
        "^(" + minPieces.join("|") + ")",
        "i"
      );
    }
    function hFormat() {
      return this.hours() % 12 || 12;
    }
    function kFormat() {
      return this.hours() || 24;
    }
    addFormatToken("H", ["HH", 2], 0, "hour");
    addFormatToken("h", ["hh", 2], 0, hFormat);
    addFormatToken("k", ["kk", 2], 0, kFormat);
    addFormatToken("hmm", 0, 0, function() {
      return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });
    addFormatToken("hmmss", 0, 0, function() {
      return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    addFormatToken("Hmm", 0, 0, function() {
      return "" + this.hours() + zeroFill(this.minutes(), 2);
    });
    addFormatToken("Hmmss", 0, 0, function() {
      return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    function meridiem(token2, lowercase) {
      addFormatToken(token2, 0, 0, function() {
        return this.localeData().meridiem(
          this.hours(),
          this.minutes(),
          lowercase
        );
      });
    }
    meridiem("a", true);
    meridiem("A", false);
    addUnitAlias("hour", "h");
    addUnitPriority("hour", 13);
    function matchMeridiem(isStrict, locale2) {
      return locale2._meridiemParse;
    }
    addRegexToken("a", matchMeridiem);
    addRegexToken("A", matchMeridiem);
    addRegexToken("H", match1to2);
    addRegexToken("h", match1to2);
    addRegexToken("k", match1to2);
    addRegexToken("HH", match1to2, match2);
    addRegexToken("hh", match1to2, match2);
    addRegexToken("kk", match1to2, match2);
    addRegexToken("hmm", match3to4);
    addRegexToken("hmmss", match5to6);
    addRegexToken("Hmm", match3to4);
    addRegexToken("Hmmss", match5to6);
    addParseToken(["H", "HH"], HOUR);
    addParseToken(["k", "kk"], function(input, array, config2) {
      var kInput = toInt(input);
      array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(["a", "A"], function(input, array, config2) {
      config2._isPm = config2._locale.isPM(input);
      config2._meridiem = input;
    });
    addParseToken(["h", "hh"], function(input, array, config2) {
      array[HOUR] = toInt(input);
      getParsingFlags(config2).bigHour = true;
    });
    addParseToken("hmm", function(input, array, config2) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
      getParsingFlags(config2).bigHour = true;
    });
    addParseToken("hmmss", function(input, array, config2) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
      getParsingFlags(config2).bigHour = true;
    });
    addParseToken("Hmm", function(input, array, config2) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken("Hmmss", function(input, array, config2) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
    });
    function localeIsPM(input) {
      return (input + "").toLowerCase().charAt(0) === "p";
    }
    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
    function localeMeridiem(hours2, minutes2, isLower) {
      if (hours2 > 11) {
        return isLower ? "pm" : "PM";
      } else {
        return isLower ? "am" : "AM";
      }
    }
    var baseConfig = {
      calendar: defaultCalendar,
      longDateFormat: defaultLongDateFormat,
      invalidDate: defaultInvalidDate,
      ordinal: defaultOrdinal,
      dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
      relativeTime: defaultRelativeTime,
      months: defaultLocaleMonths,
      monthsShort: defaultLocaleMonthsShort,
      week: defaultLocaleWeek,
      weekdays: defaultLocaleWeekdays,
      weekdaysMin: defaultLocaleWeekdaysMin,
      weekdaysShort: defaultLocaleWeekdaysShort,
      meridiemParse: defaultLocaleMeridiemParse
    };
    var locales = {}, localeFamilies = {}, globalLocale;
    function commonPrefix(arr1, arr2) {
      var i2, minl = Math.min(arr1.length, arr2.length);
      for (i2 = 0; i2 < minl; i2 += 1) {
        if (arr1[i2] !== arr2[i2]) {
          return i2;
        }
      }
      return minl;
    }
    function normalizeLocale(key) {
      return key ? key.toLowerCase().replace("_", "-") : key;
    }
    function chooseLocale(names) {
      var i2 = 0, j, next2, locale2, split;
      while (i2 < names.length) {
        split = normalizeLocale(names[i2]).split("-");
        j = split.length;
        next2 = normalizeLocale(names[i2 + 1]);
        next2 = next2 ? next2.split("-") : null;
        while (j > 0) {
          locale2 = loadLocale(split.slice(0, j).join("-"));
          if (locale2) {
            return locale2;
          }
          if (next2 && next2.length >= j && commonPrefix(split, next2) >= j - 1) {
            break;
          }
          j--;
        }
        i2++;
      }
      return globalLocale;
    }
    function isLocaleNameSane(name2) {
      return name2.match("^[^/\\\\]*$") != null;
    }
    function loadLocale(name2) {
      var oldLocale = null, aliasedRequire;
      if (locales[name2] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name2)) {
        try {
          oldLocale = globalLocale._abbr;
          aliasedRequire = require;
          aliasedRequire("./locale/" + name2);
          getSetGlobalLocale(oldLocale);
        } catch (e2) {
          locales[name2] = null;
        }
      }
      return locales[name2];
    }
    function getSetGlobalLocale(key, values) {
      var data;
      if (key) {
        if (isUndefined(values)) {
          data = getLocale(key);
        } else {
          data = defineLocale(key, values);
        }
        if (data) {
          globalLocale = data;
        } else {
          if (typeof console !== "undefined" && console.warn) {
            console.warn(
              "Locale " + key + " not found. Did you forget to load it?"
            );
          }
        }
      }
      return globalLocale._abbr;
    }
    function defineLocale(name2, config2) {
      if (config2 !== null) {
        var locale2, parentConfig = baseConfig;
        config2.abbr = name2;
        if (locales[name2] != null) {
          deprecateSimple(
            "defineLocaleOverride",
            "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
          );
          parentConfig = locales[name2]._config;
        } else if (config2.parentLocale != null) {
          if (locales[config2.parentLocale] != null) {
            parentConfig = locales[config2.parentLocale]._config;
          } else {
            locale2 = loadLocale(config2.parentLocale);
            if (locale2 != null) {
              parentConfig = locale2._config;
            } else {
              if (!localeFamilies[config2.parentLocale]) {
                localeFamilies[config2.parentLocale] = [];
              }
              localeFamilies[config2.parentLocale].push({
                name: name2,
                config: config2
              });
              return null;
            }
          }
        }
        locales[name2] = new Locale(mergeConfigs(parentConfig, config2));
        if (localeFamilies[name2]) {
          localeFamilies[name2].forEach(function(x2) {
            defineLocale(x2.name, x2.config);
          });
        }
        getSetGlobalLocale(name2);
        return locales[name2];
      } else {
        delete locales[name2];
        return null;
      }
    }
    function updateLocale(name2, config2) {
      if (config2 != null) {
        var locale2, tmpLocale, parentConfig = baseConfig;
        if (locales[name2] != null && locales[name2].parentLocale != null) {
          locales[name2].set(mergeConfigs(locales[name2]._config, config2));
        } else {
          tmpLocale = loadLocale(name2);
          if (tmpLocale != null) {
            parentConfig = tmpLocale._config;
          }
          config2 = mergeConfigs(parentConfig, config2);
          if (tmpLocale == null) {
            config2.abbr = name2;
          }
          locale2 = new Locale(config2);
          locale2.parentLocale = locales[name2];
          locales[name2] = locale2;
        }
        getSetGlobalLocale(name2);
      } else {
        if (locales[name2] != null) {
          if (locales[name2].parentLocale != null) {
            locales[name2] = locales[name2].parentLocale;
            if (name2 === getSetGlobalLocale()) {
              getSetGlobalLocale(name2);
            }
          } else if (locales[name2] != null) {
            delete locales[name2];
          }
        }
      }
      return locales[name2];
    }
    function getLocale(key) {
      var locale2;
      if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
      }
      if (!key) {
        return globalLocale;
      }
      if (!isArray$1(key)) {
        locale2 = loadLocale(key);
        if (locale2) {
          return locale2;
        }
        key = [key];
      }
      return chooseLocale(key);
    }
    function listLocales() {
      return keys$1(locales);
    }
    function checkOverflow(m2) {
      var overflow2, a2 = m2._a;
      if (a2 && getParsingFlags(m2).overflow === -2) {
        overflow2 = a2[MONTH] < 0 || a2[MONTH] > 11 ? MONTH : a2[DATE] < 1 || a2[DATE] > daysInMonth(a2[YEAR], a2[MONTH]) ? DATE : a2[HOUR] < 0 || a2[HOUR] > 24 || a2[HOUR] === 24 && (a2[MINUTE] !== 0 || a2[SECOND] !== 0 || a2[MILLISECOND] !== 0) ? HOUR : a2[MINUTE] < 0 || a2[MINUTE] > 59 ? MINUTE : a2[SECOND] < 0 || a2[SECOND] > 59 ? SECOND : a2[MILLISECOND] < 0 || a2[MILLISECOND] > 999 ? MILLISECOND : -1;
        if (getParsingFlags(m2)._overflowDayOfYear && (overflow2 < YEAR || overflow2 > DATE)) {
          overflow2 = DATE;
        }
        if (getParsingFlags(m2)._overflowWeeks && overflow2 === -1) {
          overflow2 = WEEK;
        }
        if (getParsingFlags(m2)._overflowWeekday && overflow2 === -1) {
          overflow2 = WEEKDAY;
        }
        getParsingFlags(m2).overflow = overflow2;
      }
      return m2;
    }
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
      ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
      ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
      ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
      ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
      ["YYYY-DDD", /\d{4}-\d{3}/],
      ["YYYY-MM", /\d{4}-\d\d/, false],
      ["YYYYYYMMDD", /[+-]\d{10}/],
      ["YYYYMMDD", /\d{8}/],
      ["GGGG[W]WWE", /\d{4}W\d{3}/],
      ["GGGG[W]WW", /\d{4}W\d{2}/, false],
      ["YYYYDDD", /\d{7}/],
      ["YYYYMM", /\d{6}/, false],
      ["YYYY", /\d{4}/, false]
    ], isoTimes = [
      ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
      ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
      ["HH:mm:ss", /\d\d:\d\d:\d\d/],
      ["HH:mm", /\d\d:\d\d/],
      ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
      ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
      ["HHmmss", /\d\d\d\d\d\d/],
      ["HHmm", /\d\d\d\d/],
      ["HH", /\d\d/]
    ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
      UT: 0,
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };
    function configFromISO(config2) {
      var i2, l2, string2 = config2._i, match5 = extendedIsoRegex.exec(string2) || basicIsoRegex.exec(string2), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
      if (match5) {
        getParsingFlags(config2).iso = true;
        for (i2 = 0, l2 = isoDatesLen; i2 < l2; i2++) {
          if (isoDates[i2][1].exec(match5[1])) {
            dateFormat = isoDates[i2][0];
            allowTime = isoDates[i2][2] !== false;
            break;
          }
        }
        if (dateFormat == null) {
          config2._isValid = false;
          return;
        }
        if (match5[3]) {
          for (i2 = 0, l2 = isoTimesLen; i2 < l2; i2++) {
            if (isoTimes[i2][1].exec(match5[3])) {
              timeFormat = (match5[2] || " ") + isoTimes[i2][0];
              break;
            }
          }
          if (timeFormat == null) {
            config2._isValid = false;
            return;
          }
        }
        if (!allowTime && timeFormat != null) {
          config2._isValid = false;
          return;
        }
        if (match5[4]) {
          if (tzRegex.exec(match5[4])) {
            tzFormat = "Z";
          } else {
            config2._isValid = false;
            return;
          }
        }
        config2._f = dateFormat + (timeFormat || "") + (tzFormat || "");
        configFromStringAndFormat(config2);
      } else {
        config2._isValid = false;
      }
    }
    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      var result = [
        untruncateYear(yearStr),
        defaultLocaleMonthsShort.indexOf(monthStr),
        parseInt(dayStr, 10),
        parseInt(hourStr, 10),
        parseInt(minuteStr, 10)
      ];
      if (secondStr) {
        result.push(parseInt(secondStr, 10));
      }
      return result;
    }
    function untruncateYear(yearStr) {
      var year = parseInt(yearStr, 10);
      if (year <= 49) {
        return 2e3 + year;
      } else if (year <= 999) {
        return 1900 + year;
      }
      return year;
    }
    function preprocessRFC2822(s2) {
      return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
    }
    function checkWeekday(weekdayStr, parsedInput, config2) {
      if (weekdayStr) {
        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
          parsedInput[0],
          parsedInput[1],
          parsedInput[2]
        ).getDay();
        if (weekdayProvided !== weekdayActual) {
          getParsingFlags(config2).weekdayMismatch = true;
          config2._isValid = false;
          return false;
        }
      }
      return true;
    }
    function calculateOffset(obsOffset, militaryOffset, numOffset) {
      if (obsOffset) {
        return obsOffsets[obsOffset];
      } else if (militaryOffset) {
        return 0;
      } else {
        var hm = parseInt(numOffset, 10), m2 = hm % 100, h2 = (hm - m2) / 100;
        return h2 * 60 + m2;
      }
    }
    function configFromRFC2822(config2) {
      var match5 = rfc2822.exec(preprocessRFC2822(config2._i)), parsedArray;
      if (match5) {
        parsedArray = extractFromRFC2822Strings(
          match5[4],
          match5[3],
          match5[2],
          match5[5],
          match5[6],
          match5[7]
        );
        if (!checkWeekday(match5[1], parsedArray, config2)) {
          return;
        }
        config2._a = parsedArray;
        config2._tzm = calculateOffset(match5[8], match5[9], match5[10]);
        config2._d = createUTCDate.apply(null, config2._a);
        config2._d.setUTCMinutes(config2._d.getUTCMinutes() - config2._tzm);
        getParsingFlags(config2).rfc2822 = true;
      } else {
        config2._isValid = false;
      }
    }
    function configFromString(config2) {
      var matched = aspNetJsonRegex.exec(config2._i);
      if (matched !== null) {
        config2._d = /* @__PURE__ */ new Date(+matched[1]);
        return;
      }
      configFromISO(config2);
      if (config2._isValid === false) {
        delete config2._isValid;
      } else {
        return;
      }
      configFromRFC2822(config2);
      if (config2._isValid === false) {
        delete config2._isValid;
      } else {
        return;
      }
      if (config2._strict) {
        config2._isValid = false;
      } else {
        hooks.createFromInputFallback(config2);
      }
    }
    hooks.createFromInputFallback = deprecate(
      "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
      function(config2) {
        config2._d = /* @__PURE__ */ new Date(config2._i + (config2._useUTC ? " UTC" : ""));
      }
    );
    function defaults(a2, b2, c2) {
      if (a2 != null) {
        return a2;
      }
      if (b2 != null) {
        return b2;
      }
      return c2;
    }
    function currentDateArray(config2) {
      var nowValue = new Date(hooks.now());
      if (config2._useUTC) {
        return [
          nowValue.getUTCFullYear(),
          nowValue.getUTCMonth(),
          nowValue.getUTCDate()
        ];
      }
      return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }
    function configFromArray(config2) {
      var i2, date, input = [], currentDate, expectedWeekday, yearToUse;
      if (config2._d) {
        return;
      }
      currentDate = currentDateArray(config2);
      if (config2._w && config2._a[DATE] == null && config2._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config2);
      }
      if (config2._dayOfYear != null) {
        yearToUse = defaults(config2._a[YEAR], currentDate[YEAR]);
        if (config2._dayOfYear > daysInYear(yearToUse) || config2._dayOfYear === 0) {
          getParsingFlags(config2)._overflowDayOfYear = true;
        }
        date = createUTCDate(yearToUse, 0, config2._dayOfYear);
        config2._a[MONTH] = date.getUTCMonth();
        config2._a[DATE] = date.getUTCDate();
      }
      for (i2 = 0; i2 < 3 && config2._a[i2] == null; ++i2) {
        config2._a[i2] = input[i2] = currentDate[i2];
      }
      for (; i2 < 7; i2++) {
        config2._a[i2] = input[i2] = config2._a[i2] == null ? i2 === 2 ? 1 : 0 : config2._a[i2];
      }
      if (config2._a[HOUR] === 24 && config2._a[MINUTE] === 0 && config2._a[SECOND] === 0 && config2._a[MILLISECOND] === 0) {
        config2._nextDay = true;
        config2._a[HOUR] = 0;
      }
      config2._d = (config2._useUTC ? createUTCDate : createDate).apply(
        null,
        input
      );
      expectedWeekday = config2._useUTC ? config2._d.getUTCDay() : config2._d.getDay();
      if (config2._tzm != null) {
        config2._d.setUTCMinutes(config2._d.getUTCMinutes() - config2._tzm);
      }
      if (config2._nextDay) {
        config2._a[HOUR] = 24;
      }
      if (config2._w && typeof config2._w.d !== "undefined" && config2._w.d !== expectedWeekday) {
        getParsingFlags(config2).weekdayMismatch = true;
      }
    }
    function dayOfYearFromWeekInfo(config2) {
      var w2, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
      w2 = config2._w;
      if (w2.GG != null || w2.W != null || w2.E != null) {
        dow = 1;
        doy = 4;
        weekYear = defaults(
          w2.GG,
          config2._a[YEAR],
          weekOfYear(createLocal(), 1, 4).year
        );
        week = defaults(w2.W, 1);
        weekday = defaults(w2.E, 1);
        if (weekday < 1 || weekday > 7) {
          weekdayOverflow = true;
        }
      } else {
        dow = config2._locale._week.dow;
        doy = config2._locale._week.doy;
        curWeek = weekOfYear(createLocal(), dow, doy);
        weekYear = defaults(w2.gg, config2._a[YEAR], curWeek.year);
        week = defaults(w2.w, curWeek.week);
        if (w2.d != null) {
          weekday = w2.d;
          if (weekday < 0 || weekday > 6) {
            weekdayOverflow = true;
          }
        } else if (w2.e != null) {
          weekday = w2.e + dow;
          if (w2.e < 0 || w2.e > 6) {
            weekdayOverflow = true;
          }
        } else {
          weekday = dow;
        }
      }
      if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config2)._overflowWeeks = true;
      } else if (weekdayOverflow != null) {
        getParsingFlags(config2)._overflowWeekday = true;
      } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config2._a[YEAR] = temp.year;
        config2._dayOfYear = temp.dayOfYear;
      }
    }
    hooks.ISO_8601 = function() {
    };
    hooks.RFC_2822 = function() {
    };
    function configFromStringAndFormat(config2) {
      if (config2._f === hooks.ISO_8601) {
        configFromISO(config2);
        return;
      }
      if (config2._f === hooks.RFC_2822) {
        configFromRFC2822(config2);
        return;
      }
      config2._a = [];
      getParsingFlags(config2).empty = true;
      var string2 = "" + config2._i, i2, parsedInput, tokens2, token2, skipped, stringLength = string2.length, totalParsedInputLength = 0, era, tokenLen;
      tokens2 = expandFormat(config2._f, config2._locale).match(formattingTokens) || [];
      tokenLen = tokens2.length;
      for (i2 = 0; i2 < tokenLen; i2++) {
        token2 = tokens2[i2];
        parsedInput = (string2.match(getParseRegexForToken(token2, config2)) || [])[0];
        if (parsedInput) {
          skipped = string2.substr(0, string2.indexOf(parsedInput));
          if (skipped.length > 0) {
            getParsingFlags(config2).unusedInput.push(skipped);
          }
          string2 = string2.slice(
            string2.indexOf(parsedInput) + parsedInput.length
          );
          totalParsedInputLength += parsedInput.length;
        }
        if (formatTokenFunctions[token2]) {
          if (parsedInput) {
            getParsingFlags(config2).empty = false;
          } else {
            getParsingFlags(config2).unusedTokens.push(token2);
          }
          addTimeToArrayFromToken(token2, parsedInput, config2);
        } else if (config2._strict && !parsedInput) {
          getParsingFlags(config2).unusedTokens.push(token2);
        }
      }
      getParsingFlags(config2).charsLeftOver = stringLength - totalParsedInputLength;
      if (string2.length > 0) {
        getParsingFlags(config2).unusedInput.push(string2);
      }
      if (config2._a[HOUR] <= 12 && getParsingFlags(config2).bigHour === true && config2._a[HOUR] > 0) {
        getParsingFlags(config2).bigHour = void 0;
      }
      getParsingFlags(config2).parsedDateParts = config2._a.slice(0);
      getParsingFlags(config2).meridiem = config2._meridiem;
      config2._a[HOUR] = meridiemFixWrap(
        config2._locale,
        config2._a[HOUR],
        config2._meridiem
      );
      era = getParsingFlags(config2).era;
      if (era !== null) {
        config2._a[YEAR] = config2._locale.erasConvertYear(era, config2._a[YEAR]);
      }
      configFromArray(config2);
      checkOverflow(config2);
    }
    function meridiemFixWrap(locale2, hour, meridiem2) {
      var isPm;
      if (meridiem2 == null) {
        return hour;
      }
      if (locale2.meridiemHour != null) {
        return locale2.meridiemHour(hour, meridiem2);
      } else if (locale2.isPM != null) {
        isPm = locale2.isPM(meridiem2);
        if (isPm && hour < 12) {
          hour += 12;
        }
        if (!isPm && hour === 12) {
          hour = 0;
        }
        return hour;
      } else {
        return hour;
      }
    }
    function configFromStringAndArray(config2) {
      var tempConfig, bestMoment, scoreToBeat, i2, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config2._f.length;
      if (configfLen === 0) {
        getParsingFlags(config2).invalidFormat = true;
        config2._d = /* @__PURE__ */ new Date(NaN);
        return;
      }
      for (i2 = 0; i2 < configfLen; i2++) {
        currentScore = 0;
        validFormatFound = false;
        tempConfig = copyConfig({}, config2);
        if (config2._useUTC != null) {
          tempConfig._useUTC = config2._useUTC;
        }
        tempConfig._f = config2._f[i2];
        configFromStringAndFormat(tempConfig);
        if (isValid(tempConfig)) {
          validFormatFound = true;
        }
        currentScore += getParsingFlags(tempConfig).charsLeftOver;
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
        getParsingFlags(tempConfig).score = currentScore;
        if (!bestFormatIsValid) {
          if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
            if (validFormatFound) {
              bestFormatIsValid = true;
            }
          }
        } else {
          if (currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
          }
        }
      }
      extend$2(config2, bestMoment || tempConfig);
    }
    function configFromObject(config2) {
      if (config2._d) {
        return;
      }
      var i2 = normalizeObjectUnits(config2._i), dayOrDate = i2.day === void 0 ? i2.date : i2.day;
      config2._a = map$1(
        [i2.year, i2.month, dayOrDate, i2.hour, i2.minute, i2.second, i2.millisecond],
        function(obj) {
          return obj && parseInt(obj, 10);
        }
      );
      configFromArray(config2);
    }
    function createFromConfig(config2) {
      var res2 = new Moment(checkOverflow(prepareConfig(config2)));
      if (res2._nextDay) {
        res2.add(1, "d");
        res2._nextDay = void 0;
      }
      return res2;
    }
    function prepareConfig(config2) {
      var input = config2._i, format2 = config2._f;
      config2._locale = config2._locale || getLocale(config2._l);
      if (input === null || format2 === void 0 && input === "") {
        return createInvalid({ nullInput: true });
      }
      if (typeof input === "string") {
        config2._i = input = config2._locale.preparse(input);
      }
      if (isMoment(input)) {
        return new Moment(checkOverflow(input));
      } else if (isDate(input)) {
        config2._d = input;
      } else if (isArray$1(format2)) {
        configFromStringAndArray(config2);
      } else if (format2) {
        configFromStringAndFormat(config2);
      } else {
        configFromInput(config2);
      }
      if (!isValid(config2)) {
        config2._d = null;
      }
      return config2;
    }
    function configFromInput(config2) {
      var input = config2._i;
      if (isUndefined(input)) {
        config2._d = new Date(hooks.now());
      } else if (isDate(input)) {
        config2._d = new Date(input.valueOf());
      } else if (typeof input === "string") {
        configFromString(config2);
      } else if (isArray$1(input)) {
        config2._a = map$1(input.slice(0), function(obj) {
          return parseInt(obj, 10);
        });
        configFromArray(config2);
      } else if (isObject(input)) {
        configFromObject(config2);
      } else if (isNumber(input)) {
        config2._d = new Date(input);
      } else {
        hooks.createFromInputFallback(config2);
      }
    }
    function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
      var c2 = {};
      if (format2 === true || format2 === false) {
        strict = format2;
        format2 = void 0;
      }
      if (locale2 === true || locale2 === false) {
        strict = locale2;
        locale2 = void 0;
      }
      if (isObject(input) && isObjectEmpty(input) || isArray$1(input) && input.length === 0) {
        input = void 0;
      }
      c2._isAMomentObject = true;
      c2._useUTC = c2._isUTC = isUTC;
      c2._l = locale2;
      c2._i = input;
      c2._f = format2;
      c2._strict = strict;
      return createFromConfig(c2);
    }
    function createLocal(input, format2, locale2, strict) {
      return createLocalOrUTC(input, format2, locale2, strict, false);
    }
    var prototypeMin = deprecate(
      "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
      function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other < this ? this : other;
        } else {
          return createInvalid();
        }
      }
    ), prototypeMax = deprecate(
      "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
      function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other > this ? this : other;
        } else {
          return createInvalid();
        }
      }
    );
    function pickBy(fn, moments) {
      var res2, i2;
      if (moments.length === 1 && isArray$1(moments[0])) {
        moments = moments[0];
      }
      if (!moments.length) {
        return createLocal();
      }
      res2 = moments[0];
      for (i2 = 1; i2 < moments.length; ++i2) {
        if (!moments[i2].isValid() || moments[i2][fn](res2)) {
          res2 = moments[i2];
        }
      }
      return res2;
    }
    function min() {
      var args = [].slice.call(arguments, 0);
      return pickBy("isBefore", args);
    }
    function max() {
      var args = [].slice.call(arguments, 0);
      return pickBy("isAfter", args);
    }
    var now = function() {
      return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
    };
    var ordering = [
      "year",
      "quarter",
      "month",
      "week",
      "day",
      "hour",
      "minute",
      "second",
      "millisecond"
    ];
    function isDurationValid(m2) {
      var key, unitHasDecimal = false, i2, orderLen = ordering.length;
      for (key in m2) {
        if (hasOwnProp(m2, key) && !(indexOf.call(ordering, key) !== -1 && (m2[key] == null || !isNaN(m2[key])))) {
          return false;
        }
      }
      for (i2 = 0; i2 < orderLen; ++i2) {
        if (m2[ordering[i2]]) {
          if (unitHasDecimal) {
            return false;
          }
          if (parseFloat(m2[ordering[i2]]) !== toInt(m2[ordering[i2]])) {
            unitHasDecimal = true;
          }
        }
      }
      return true;
    }
    function isValid$1() {
      return this._isValid;
    }
    function createInvalid$1() {
      return createDuration(NaN);
    }
    function Duration(duration) {
      var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
      this._isValid = isDurationValid(normalizedInput);
      this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
      minutes2 * 6e4 + // 1000 * 60
      hours2 * 1e3 * 60 * 60;
      this._days = +days2 + weeks2 * 7;
      this._months = +months2 + quarters * 3 + years2 * 12;
      this._data = {};
      this._locale = getLocale();
      this._bubble();
    }
    function isDuration(obj) {
      return obj instanceof Duration;
    }
    function absRound(number2) {
      if (number2 < 0) {
        return Math.round(-1 * number2) * -1;
      } else {
        return Math.round(number2);
      }
    }
    function compareArrays(array1, array2, dontConvert) {
      var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i2;
      for (i2 = 0; i2 < len; i2++) {
        if (dontConvert && array1[i2] !== array2[i2] || !dontConvert && toInt(array1[i2]) !== toInt(array2[i2])) {
          diffs++;
        }
      }
      return diffs + lengthDiff;
    }
    function offset(token2, separator) {
      addFormatToken(token2, 0, 0, function() {
        var offset2 = this.utcOffset(), sign2 = "+";
        if (offset2 < 0) {
          offset2 = -offset2;
          sign2 = "-";
        }
        return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
      });
    }
    offset("Z", ":");
    offset("ZZ", "");
    addRegexToken("Z", matchShortOffset);
    addRegexToken("ZZ", matchShortOffset);
    addParseToken(["Z", "ZZ"], function(input, array, config2) {
      config2._useUTC = true;
      config2._tzm = offsetFromString(matchShortOffset, input);
    });
    var chunkOffset = /([\+\-]|\d\d)/gi;
    function offsetFromString(matcher, string2) {
      var matches = (string2 || "").match(matcher), chunk, parts, minutes2;
      if (matches === null) {
        return null;
      }
      chunk = matches[matches.length - 1] || [];
      parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
      minutes2 = +(parts[1] * 60) + toInt(parts[2]);
      return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
    }
    function cloneWithOffset(input, model) {
      var res2, diff2;
      if (model._isUTC) {
        res2 = model.clone();
        diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res2.valueOf();
        res2._d.setTime(res2._d.valueOf() + diff2);
        hooks.updateOffset(res2, false);
        return res2;
      } else {
        return createLocal(input).local();
      }
    }
    function getDateOffset(m2) {
      return -Math.round(m2._d.getTimezoneOffset());
    }
    hooks.updateOffset = function() {
    };
    function getSetOffset(input, keepLocalTime, keepMinutes) {
      var offset2 = this._offset || 0, localAdjust;
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      if (input != null) {
        if (typeof input === "string") {
          input = offsetFromString(matchShortOffset, input);
          if (input === null) {
            return this;
          }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
          input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
          localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
          this.add(localAdjust, "m");
        }
        if (offset2 !== input) {
          if (!keepLocalTime || this._changeInProgress) {
            addSubtract(
              this,
              createDuration(input - offset2, "m"),
              1,
              false
            );
          } else if (!this._changeInProgress) {
            this._changeInProgress = true;
            hooks.updateOffset(this, true);
            this._changeInProgress = null;
          }
        }
        return this;
      } else {
        return this._isUTC ? offset2 : getDateOffset(this);
      }
    }
    function getSetZone(input, keepLocalTime) {
      if (input != null) {
        if (typeof input !== "string") {
          input = -input;
        }
        this.utcOffset(input, keepLocalTime);
        return this;
      } else {
        return -this.utcOffset();
      }
    }
    function setOffsetToUTC(keepLocalTime) {
      return this.utcOffset(0, keepLocalTime);
    }
    function setOffsetToLocal(keepLocalTime) {
      if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;
        if (keepLocalTime) {
          this.subtract(getDateOffset(this), "m");
        }
      }
      return this;
    }
    function setOffsetToParsedOffset() {
      if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
      } else if (typeof this._i === "string") {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
          this.utcOffset(tZone);
        } else {
          this.utcOffset(0, true);
        }
      }
      return this;
    }
    function hasAlignedHourOffset(input) {
      if (!this.isValid()) {
        return false;
      }
      input = input ? createLocal(input).utcOffset() : 0;
      return (this.utcOffset() - input) % 60 === 0;
    }
    function isDaylightSavingTime() {
      return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }
    function isDaylightSavingTimeShifted() {
      if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
      }
      var c2 = {}, other;
      copyConfig(c2, this);
      c2 = prepareConfig(c2);
      if (c2._a) {
        other = c2._isUTC ? createUTC(c2._a) : createLocal(c2._a);
        this._isDSTShifted = this.isValid() && compareArrays(c2._a, other.toArray()) > 0;
      } else {
        this._isDSTShifted = false;
      }
      return this._isDSTShifted;
    }
    function isLocal() {
      return this.isValid() ? !this._isUTC : false;
    }
    function isUtcOffset() {
      return this.isValid() ? this._isUTC : false;
    }
    function isUtc() {
      return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }
    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
    function createDuration(input, key) {
      var duration = input, match5 = null, sign2, ret, diffRes;
      if (isDuration(input)) {
        duration = {
          ms: input._milliseconds,
          d: input._days,
          M: input._months
        };
      } else if (isNumber(input) || !isNaN(+input)) {
        duration = {};
        if (key) {
          duration[key] = +input;
        } else {
          duration.milliseconds = +input;
        }
      } else if (match5 = aspNetRegex.exec(input)) {
        sign2 = match5[1] === "-" ? -1 : 1;
        duration = {
          y: 0,
          d: toInt(match5[DATE]) * sign2,
          h: toInt(match5[HOUR]) * sign2,
          m: toInt(match5[MINUTE]) * sign2,
          s: toInt(match5[SECOND]) * sign2,
          ms: toInt(absRound(match5[MILLISECOND] * 1e3)) * sign2
          // the millisecond decimal point is included in the match
        };
      } else if (match5 = isoRegex.exec(input)) {
        sign2 = match5[1] === "-" ? -1 : 1;
        duration = {
          y: parseIso(match5[2], sign2),
          M: parseIso(match5[3], sign2),
          w: parseIso(match5[4], sign2),
          d: parseIso(match5[5], sign2),
          h: parseIso(match5[6], sign2),
          m: parseIso(match5[7], sign2),
          s: parseIso(match5[8], sign2)
        };
      } else if (duration == null) {
        duration = {};
      } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
        diffRes = momentsDifference(
          createLocal(duration.from),
          createLocal(duration.to)
        );
        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
      }
      ret = new Duration(duration);
      if (isDuration(input) && hasOwnProp(input, "_locale")) {
        ret._locale = input._locale;
      }
      if (isDuration(input) && hasOwnProp(input, "_isValid")) {
        ret._isValid = input._isValid;
      }
      return ret;
    }
    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;
    function parseIso(inp, sign2) {
      var res2 = inp && parseFloat(inp.replace(",", "."));
      return (isNaN(res2) ? 0 : res2) * sign2;
    }
    function positiveMomentsDifference(base2, other) {
      var res2 = {};
      res2.months = other.month() - base2.month() + (other.year() - base2.year()) * 12;
      if (base2.clone().add(res2.months, "M").isAfter(other)) {
        --res2.months;
      }
      res2.milliseconds = +other - +base2.clone().add(res2.months, "M");
      return res2;
    }
    function momentsDifference(base2, other) {
      var res2;
      if (!(base2.isValid() && other.isValid())) {
        return { milliseconds: 0, months: 0 };
      }
      other = cloneWithOffset(other, base2);
      if (base2.isBefore(other)) {
        res2 = positiveMomentsDifference(base2, other);
      } else {
        res2 = positiveMomentsDifference(other, base2);
        res2.milliseconds = -res2.milliseconds;
        res2.months = -res2.months;
      }
      return res2;
    }
    function createAdder(direction, name2) {
      return function(val, period) {
        var dur, tmp;
        if (period !== null && !isNaN(+period)) {
          deprecateSimple(
            name2,
            "moment()." + name2 + "(period, number) is deprecated. Please use moment()." + name2 + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
          );
          tmp = val;
          val = period;
          period = tmp;
        }
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
      };
    }
    function addSubtract(mom, duration, isAdding, updateOffset) {
      var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
      if (!mom.isValid()) {
        return;
      }
      updateOffset = updateOffset == null ? true : updateOffset;
      if (months2) {
        setMonth(mom, get(mom, "Month") + months2 * isAdding);
      }
      if (days2) {
        set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
      }
      if (milliseconds2) {
        mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
      }
      if (updateOffset) {
        hooks.updateOffset(mom, days2 || months2);
      }
    }
    var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
    function isString(input) {
      return typeof input === "string" || input instanceof String;
    }
    function isMomentInput(input) {
      return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
    }
    function isMomentInputObject(input) {
      var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
        "years",
        "year",
        "y",
        "months",
        "month",
        "M",
        "days",
        "day",
        "d",
        "dates",
        "date",
        "D",
        "hours",
        "hour",
        "h",
        "minutes",
        "minute",
        "m",
        "seconds",
        "second",
        "s",
        "milliseconds",
        "millisecond",
        "ms"
      ], i2, property, propertyLen = properties.length;
      for (i2 = 0; i2 < propertyLen; i2 += 1) {
        property = properties[i2];
        propertyTest = propertyTest || hasOwnProp(input, property);
      }
      return objectTest && propertyTest;
    }
    function isNumberOrStringArray(input) {
      var arrayTest = isArray$1(input), dataTypeTest = false;
      if (arrayTest) {
        dataTypeTest = input.filter(function(item) {
          return !isNumber(item) && isString(input);
        }).length === 0;
      }
      return arrayTest && dataTypeTest;
    }
    function isCalendarSpec(input) {
      var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
        "sameDay",
        "nextDay",
        "lastDay",
        "nextWeek",
        "lastWeek",
        "sameElse"
      ], i2, property;
      for (i2 = 0; i2 < properties.length; i2 += 1) {
        property = properties[i2];
        propertyTest = propertyTest || hasOwnProp(input, property);
      }
      return objectTest && propertyTest;
    }
    function getCalendarFormat(myMoment, now2) {
      var diff2 = myMoment.diff(now2, "days", true);
      return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
    }
    function calendar$1(time, formats) {
      if (arguments.length === 1) {
        if (!arguments[0]) {
          time = void 0;
          formats = void 0;
        } else if (isMomentInput(arguments[0])) {
          time = arguments[0];
          formats = void 0;
        } else if (isCalendarSpec(arguments[0])) {
          formats = arguments[0];
          time = void 0;
        }
      }
      var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
      return this.format(
        output || this.localeData().calendar(format2, this, createLocal(now2))
      );
    }
    function clone() {
      return new Moment(this);
    }
    function isAfter(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() > localInput.valueOf();
      } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
      }
    }
    function isBefore(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() < localInput.valueOf();
      } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
      }
    }
    function isBetween(from2, to2, units, inclusivity) {
      var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
      if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
        return false;
      }
      inclusivity = inclusivity || "()";
      return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }
    function isSame(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input), inputMs;
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() === localInput.valueOf();
      } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
      }
    }
    function isSameOrAfter(input, units) {
      return this.isSame(input, units) || this.isAfter(input, units);
    }
    function isSameOrBefore(input, units) {
      return this.isSame(input, units) || this.isBefore(input, units);
    }
    function diff$1(input, units, asFloat) {
      var that, zoneDelta, output;
      if (!this.isValid()) {
        return NaN;
      }
      that = cloneWithOffset(input, this);
      if (!that.isValid()) {
        return NaN;
      }
      zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
      units = normalizeUnits(units);
      switch (units) {
        case "year":
          output = monthDiff(this, that) / 12;
          break;
        case "month":
          output = monthDiff(this, that);
          break;
        case "quarter":
          output = monthDiff(this, that) / 3;
          break;
        case "second":
          output = (this - that) / 1e3;
          break;
        case "minute":
          output = (this - that) / 6e4;
          break;
        case "hour":
          output = (this - that) / 36e5;
          break;
        case "day":
          output = (this - that - zoneDelta) / 864e5;
          break;
        case "week":
          output = (this - that - zoneDelta) / 6048e5;
          break;
        default:
          output = this - that;
      }
      return asFloat ? output : absFloor(output);
    }
    function monthDiff(a2, b2) {
      if (a2.date() < b2.date()) {
        return -monthDiff(b2, a2);
      }
      var wholeMonthDiff = (b2.year() - a2.year()) * 12 + (b2.month() - a2.month()), anchor2 = a2.clone().add(wholeMonthDiff, "months"), anchor22, adjust;
      if (b2 - anchor2 < 0) {
        anchor22 = a2.clone().add(wholeMonthDiff - 1, "months");
        adjust = (b2 - anchor2) / (anchor2 - anchor22);
      } else {
        anchor22 = a2.clone().add(wholeMonthDiff + 1, "months");
        adjust = (b2 - anchor2) / (anchor22 - anchor2);
      }
      return -(wholeMonthDiff + adjust) || 0;
    }
    hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
    hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
    function toString$1() {
      return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
    }
    function toISOString(keepOffset) {
      if (!this.isValid()) {
        return null;
      }
      var utc = keepOffset !== true, m2 = utc ? this.clone().utc() : this;
      if (m2.year() < 0 || m2.year() > 9999) {
        return formatMoment(
          m2,
          utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
        );
      }
      if (isFunction(Date.prototype.toISOString)) {
        if (utc) {
          return this.toDate().toISOString();
        } else {
          return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m2, "Z"));
        }
      }
      return formatMoment(
        m2,
        utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
      );
    }
    function inspect() {
      if (!this.isValid()) {
        return "moment.invalid(/* " + this._i + " */)";
      }
      var func = "moment", zone = "", prefix2, year, datetime, suffix;
      if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
        zone = "Z";
      }
      prefix2 = "[" + func + '("]';
      year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
      datetime = "-MM-DD[T]HH:mm:ss.SSS";
      suffix = zone + '[")]';
      return this.format(prefix2 + year + datetime + suffix);
    }
    function format(inputString) {
      if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
      }
      var output = formatMoment(this, inputString);
      return this.localeData().postformat(output);
    }
    function from(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }
    function fromNow(withoutSuffix) {
      return this.from(createLocal(), withoutSuffix);
    }
    function to(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }
    function toNow(withoutSuffix) {
      return this.to(createLocal(), withoutSuffix);
    }
    function locale(key) {
      var newLocaleData;
      if (key === void 0) {
        return this._locale._abbr;
      } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
          this._locale = newLocaleData;
        }
        return this;
      }
    }
    var lang = deprecate(
      "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
      function(key) {
        if (key === void 0) {
          return this.localeData();
        } else {
          return this.locale(key);
        }
      }
    );
    function localeData() {
      return this._locale;
    }
    var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
    function mod$1(dividend, divisor) {
      return (dividend % divisor + divisor) % divisor;
    }
    function localStartOfDate(y2, m2, d2) {
      if (y2 < 100 && y2 >= 0) {
        return new Date(y2 + 400, m2, d2) - MS_PER_400_YEARS;
      } else {
        return new Date(y2, m2, d2).valueOf();
      }
    }
    function utcStartOfDate(y2, m2, d2) {
      if (y2 < 100 && y2 >= 0) {
        return Date.UTC(y2 + 400, m2, d2) - MS_PER_400_YEARS;
      } else {
        return Date.UTC(y2, m2, d2);
      }
    }
    function startOf(units) {
      var time, startOfDate;
      units = normalizeUnits(units);
      if (units === void 0 || units === "millisecond" || !this.isValid()) {
        return this;
      }
      startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
      switch (units) {
        case "year":
          time = startOfDate(this.year(), 0, 1);
          break;
        case "quarter":
          time = startOfDate(
            this.year(),
            this.month() - this.month() % 3,
            1
          );
          break;
        case "month":
          time = startOfDate(this.year(), this.month(), 1);
          break;
        case "week":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - this.weekday()
          );
          break;
        case "isoWeek":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - (this.isoWeekday() - 1)
          );
          break;
        case "day":
        case "date":
          time = startOfDate(this.year(), this.month(), this.date());
          break;
        case "hour":
          time = this._d.valueOf();
          time -= mod$1(
            time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
            MS_PER_HOUR
          );
          break;
        case "minute":
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_MINUTE);
          break;
        case "second":
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_SECOND);
          break;
      }
      this._d.setTime(time);
      hooks.updateOffset(this, true);
      return this;
    }
    function endOf(units) {
      var time, startOfDate;
      units = normalizeUnits(units);
      if (units === void 0 || units === "millisecond" || !this.isValid()) {
        return this;
      }
      startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
      switch (units) {
        case "year":
          time = startOfDate(this.year() + 1, 0, 1) - 1;
          break;
        case "quarter":
          time = startOfDate(
            this.year(),
            this.month() - this.month() % 3 + 3,
            1
          ) - 1;
          break;
        case "month":
          time = startOfDate(this.year(), this.month() + 1, 1) - 1;
          break;
        case "week":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - this.weekday() + 7
          ) - 1;
          break;
        case "isoWeek":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - (this.isoWeekday() - 1) + 7
          ) - 1;
          break;
        case "day":
        case "date":
          time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
          break;
        case "hour":
          time = this._d.valueOf();
          time += MS_PER_HOUR - mod$1(
            time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
            MS_PER_HOUR
          ) - 1;
          break;
        case "minute":
          time = this._d.valueOf();
          time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
          break;
        case "second":
          time = this._d.valueOf();
          time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
          break;
      }
      this._d.setTime(time);
      hooks.updateOffset(this, true);
      return this;
    }
    function valueOf() {
      return this._d.valueOf() - (this._offset || 0) * 6e4;
    }
    function unix() {
      return Math.floor(this.valueOf() / 1e3);
    }
    function toDate() {
      return new Date(this.valueOf());
    }
    function toArray$1() {
      var m2 = this;
      return [
        m2.year(),
        m2.month(),
        m2.date(),
        m2.hour(),
        m2.minute(),
        m2.second(),
        m2.millisecond()
      ];
    }
    function toObject() {
      var m2 = this;
      return {
        years: m2.year(),
        months: m2.month(),
        date: m2.date(),
        hours: m2.hours(),
        minutes: m2.minutes(),
        seconds: m2.seconds(),
        milliseconds: m2.milliseconds()
      };
    }
    function toJSON() {
      return this.isValid() ? this.toISOString() : null;
    }
    function isValid$2() {
      return isValid(this);
    }
    function parsingFlags() {
      return extend$2({}, getParsingFlags(this));
    }
    function invalidAt() {
      return getParsingFlags(this).overflow;
    }
    function creationData() {
      return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
      };
    }
    addFormatToken("N", 0, 0, "eraAbbr");
    addFormatToken("NN", 0, 0, "eraAbbr");
    addFormatToken("NNN", 0, 0, "eraAbbr");
    addFormatToken("NNNN", 0, 0, "eraName");
    addFormatToken("NNNNN", 0, 0, "eraNarrow");
    addFormatToken("y", ["y", 1], "yo", "eraYear");
    addFormatToken("y", ["yy", 2], 0, "eraYear");
    addFormatToken("y", ["yyy", 3], 0, "eraYear");
    addFormatToken("y", ["yyyy", 4], 0, "eraYear");
    addRegexToken("N", matchEraAbbr);
    addRegexToken("NN", matchEraAbbr);
    addRegexToken("NNN", matchEraAbbr);
    addRegexToken("NNNN", matchEraName);
    addRegexToken("NNNNN", matchEraNarrow);
    addParseToken(
      ["N", "NN", "NNN", "NNNN", "NNNNN"],
      function(input, array, config2, token2) {
        var era = config2._locale.erasParse(input, token2, config2._strict);
        if (era) {
          getParsingFlags(config2).era = era;
        } else {
          getParsingFlags(config2).invalidEra = input;
        }
      }
    );
    addRegexToken("y", matchUnsigned);
    addRegexToken("yy", matchUnsigned);
    addRegexToken("yyy", matchUnsigned);
    addRegexToken("yyyy", matchUnsigned);
    addRegexToken("yo", matchEraYearOrdinal);
    addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
    addParseToken(["yo"], function(input, array, config2, token2) {
      var match5;
      if (config2._locale._eraYearOrdinalRegex) {
        match5 = input.match(config2._locale._eraYearOrdinalRegex);
      }
      if (config2._locale.eraYearOrdinalParse) {
        array[YEAR] = config2._locale.eraYearOrdinalParse(input, match5);
      } else {
        array[YEAR] = parseInt(input, 10);
      }
    });
    function localeEras(m2, format2) {
      var i2, l2, date, eras = this._eras || getLocale("en")._eras;
      for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
        switch (typeof eras[i2].since) {
          case "string":
            date = hooks(eras[i2].since).startOf("day");
            eras[i2].since = date.valueOf();
            break;
        }
        switch (typeof eras[i2].until) {
          case "undefined":
            eras[i2].until = Infinity;
            break;
          case "string":
            date = hooks(eras[i2].until).startOf("day").valueOf();
            eras[i2].until = date.valueOf();
            break;
        }
      }
      return eras;
    }
    function localeErasParse(eraName, format2, strict) {
      var i2, l2, eras = this.eras(), name2, abbr, narrow;
      eraName = eraName.toUpperCase();
      for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
        name2 = eras[i2].name.toUpperCase();
        abbr = eras[i2].abbr.toUpperCase();
        narrow = eras[i2].narrow.toUpperCase();
        if (strict) {
          switch (format2) {
            case "N":
            case "NN":
            case "NNN":
              if (abbr === eraName) {
                return eras[i2];
              }
              break;
            case "NNNN":
              if (name2 === eraName) {
                return eras[i2];
              }
              break;
            case "NNNNN":
              if (narrow === eraName) {
                return eras[i2];
              }
              break;
          }
        } else if ([name2, abbr, narrow].indexOf(eraName) >= 0) {
          return eras[i2];
        }
      }
    }
    function localeErasConvertYear(era, year) {
      var dir = era.since <= era.until ? 1 : -1;
      if (year === void 0) {
        return hooks(era.since).year();
      } else {
        return hooks(era.since).year() + (year - era.offset) * dir;
      }
    }
    function getEraName() {
      var i2, l2, val, eras = this.localeData().eras();
      for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i2].since <= val && val <= eras[i2].until) {
          return eras[i2].name;
        }
        if (eras[i2].until <= val && val <= eras[i2].since) {
          return eras[i2].name;
        }
      }
      return "";
    }
    function getEraNarrow() {
      var i2, l2, val, eras = this.localeData().eras();
      for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i2].since <= val && val <= eras[i2].until) {
          return eras[i2].narrow;
        }
        if (eras[i2].until <= val && val <= eras[i2].since) {
          return eras[i2].narrow;
        }
      }
      return "";
    }
    function getEraAbbr() {
      var i2, l2, val, eras = this.localeData().eras();
      for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i2].since <= val && val <= eras[i2].until) {
          return eras[i2].abbr;
        }
        if (eras[i2].until <= val && val <= eras[i2].since) {
          return eras[i2].abbr;
        }
      }
      return "";
    }
    function getEraYear() {
      var i2, l2, dir, val, eras = this.localeData().eras();
      for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
        dir = eras[i2].since <= eras[i2].until ? 1 : -1;
        val = this.clone().startOf("day").valueOf();
        if (eras[i2].since <= val && val <= eras[i2].until || eras[i2].until <= val && val <= eras[i2].since) {
          return (this.year() - hooks(eras[i2].since).year()) * dir + eras[i2].offset;
        }
      }
      return this.year();
    }
    function erasNameRegex(isStrict) {
      if (!hasOwnProp(this, "_erasNameRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasNameRegex : this._erasRegex;
    }
    function erasAbbrRegex(isStrict) {
      if (!hasOwnProp(this, "_erasAbbrRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasAbbrRegex : this._erasRegex;
    }
    function erasNarrowRegex(isStrict) {
      if (!hasOwnProp(this, "_erasNarrowRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasNarrowRegex : this._erasRegex;
    }
    function matchEraAbbr(isStrict, locale2) {
      return locale2.erasAbbrRegex(isStrict);
    }
    function matchEraName(isStrict, locale2) {
      return locale2.erasNameRegex(isStrict);
    }
    function matchEraNarrow(isStrict, locale2) {
      return locale2.erasNarrowRegex(isStrict);
    }
    function matchEraYearOrdinal(isStrict, locale2) {
      return locale2._eraYearOrdinalRegex || matchUnsigned;
    }
    function computeErasParse() {
      var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i2, l2, eras = this.eras();
      for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
        namePieces.push(regexEscape(eras[i2].name));
        abbrPieces.push(regexEscape(eras[i2].abbr));
        narrowPieces.push(regexEscape(eras[i2].narrow));
        mixedPieces.push(regexEscape(eras[i2].name));
        mixedPieces.push(regexEscape(eras[i2].abbr));
        mixedPieces.push(regexEscape(eras[i2].narrow));
      }
      this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
      this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
      this._erasNarrowRegex = new RegExp(
        "^(" + narrowPieces.join("|") + ")",
        "i"
      );
    }
    addFormatToken(0, ["gg", 2], 0, function() {
      return this.weekYear() % 100;
    });
    addFormatToken(0, ["GG", 2], 0, function() {
      return this.isoWeekYear() % 100;
    });
    function addWeekYearFormatToken(token2, getter) {
      addFormatToken(0, [token2, token2.length], 0, getter);
    }
    addWeekYearFormatToken("gggg", "weekYear");
    addWeekYearFormatToken("ggggg", "weekYear");
    addWeekYearFormatToken("GGGG", "isoWeekYear");
    addWeekYearFormatToken("GGGGG", "isoWeekYear");
    addUnitAlias("weekYear", "gg");
    addUnitAlias("isoWeekYear", "GG");
    addUnitPriority("weekYear", 1);
    addUnitPriority("isoWeekYear", 1);
    addRegexToken("G", matchSigned);
    addRegexToken("g", matchSigned);
    addRegexToken("GG", match1to2, match2);
    addRegexToken("gg", match1to2, match2);
    addRegexToken("GGGG", match1to4, match4);
    addRegexToken("gggg", match1to4, match4);
    addRegexToken("GGGGG", match1to6, match6);
    addRegexToken("ggggg", match1to6, match6);
    addWeekParseToken(
      ["gggg", "ggggg", "GGGG", "GGGGG"],
      function(input, week, config2, token2) {
        week[token2.substr(0, 2)] = toInt(input);
      }
    );
    addWeekParseToken(["gg", "GG"], function(input, week, config2, token2) {
      week[token2] = hooks.parseTwoDigitYear(input);
    });
    function getSetWeekYear(input) {
      return getSetWeekYearHelper.call(
        this,
        input,
        this.week(),
        this.weekday(),
        this.localeData()._week.dow,
        this.localeData()._week.doy
      );
    }
    function getSetISOWeekYear(input) {
      return getSetWeekYearHelper.call(
        this,
        input,
        this.isoWeek(),
        this.isoWeekday(),
        1,
        4
      );
    }
    function getISOWeeksInYear() {
      return weeksInYear(this.year(), 1, 4);
    }
    function getISOWeeksInISOWeekYear() {
      return weeksInYear(this.isoWeekYear(), 1, 4);
    }
    function getWeeksInYear() {
      var weekInfo = this.localeData()._week;
      return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }
    function getWeeksInWeekYear() {
      var weekInfo = this.localeData()._week;
      return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
    }
    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
      var weeksTarget;
      if (input == null) {
        return weekOfYear(this, dow, doy).year;
      } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
          week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
      }
    }
    function setWeekAll(weekYear, week, weekday, dow, doy) {
      var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
      this.year(date.getUTCFullYear());
      this.month(date.getUTCMonth());
      this.date(date.getUTCDate());
      return this;
    }
    addFormatToken("Q", 0, "Qo", "quarter");
    addUnitAlias("quarter", "Q");
    addUnitPriority("quarter", 7);
    addRegexToken("Q", match1);
    addParseToken("Q", function(input, array) {
      array[MONTH] = (toInt(input) - 1) * 3;
    });
    function getSetQuarter(input) {
      return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }
    addFormatToken("D", ["DD", 2], "Do", "date");
    addUnitAlias("date", "D");
    addUnitPriority("date", 9);
    addRegexToken("D", match1to2);
    addRegexToken("DD", match1to2, match2);
    addRegexToken("Do", function(isStrict, locale2) {
      return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
    });
    addParseToken(["D", "DD"], DATE);
    addParseToken("Do", function(input, array) {
      array[DATE] = toInt(input.match(match1to2)[0]);
    });
    var getSetDayOfMonth = makeGetSet("Date", true);
    addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
    addUnitAlias("dayOfYear", "DDD");
    addUnitPriority("dayOfYear", 4);
    addRegexToken("DDD", match1to3);
    addRegexToken("DDDD", match3);
    addParseToken(["DDD", "DDDD"], function(input, array, config2) {
      config2._dayOfYear = toInt(input);
    });
    function getSetDayOfYear(input) {
      var dayOfYear = Math.round(
        (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
      ) + 1;
      return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
    }
    addFormatToken("m", ["mm", 2], 0, "minute");
    addUnitAlias("minute", "m");
    addUnitPriority("minute", 14);
    addRegexToken("m", match1to2);
    addRegexToken("mm", match1to2, match2);
    addParseToken(["m", "mm"], MINUTE);
    var getSetMinute = makeGetSet("Minutes", false);
    addFormatToken("s", ["ss", 2], 0, "second");
    addUnitAlias("second", "s");
    addUnitPriority("second", 15);
    addRegexToken("s", match1to2);
    addRegexToken("ss", match1to2, match2);
    addParseToken(["s", "ss"], SECOND);
    var getSetSecond = makeGetSet("Seconds", false);
    addFormatToken("S", 0, 0, function() {
      return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, ["SS", 2], 0, function() {
      return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, ["SSS", 3], 0, "millisecond");
    addFormatToken(0, ["SSSS", 4], 0, function() {
      return this.millisecond() * 10;
    });
    addFormatToken(0, ["SSSSS", 5], 0, function() {
      return this.millisecond() * 100;
    });
    addFormatToken(0, ["SSSSSS", 6], 0, function() {
      return this.millisecond() * 1e3;
    });
    addFormatToken(0, ["SSSSSSS", 7], 0, function() {
      return this.millisecond() * 1e4;
    });
    addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
      return this.millisecond() * 1e5;
    });
    addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
      return this.millisecond() * 1e6;
    });
    addUnitAlias("millisecond", "ms");
    addUnitPriority("millisecond", 16);
    addRegexToken("S", match1to3, match1);
    addRegexToken("SS", match1to3, match2);
    addRegexToken("SSS", match1to3, match3);
    var token, getSetMillisecond;
    for (token = "SSSS"; token.length <= 9; token += "S") {
      addRegexToken(token, matchUnsigned);
    }
    function parseMs(input, array) {
      array[MILLISECOND] = toInt(("0." + input) * 1e3);
    }
    for (token = "S"; token.length <= 9; token += "S") {
      addParseToken(token, parseMs);
    }
    getSetMillisecond = makeGetSet("Milliseconds", false);
    addFormatToken("z", 0, 0, "zoneAbbr");
    addFormatToken("zz", 0, 0, "zoneName");
    function getZoneAbbr() {
      return this._isUTC ? "UTC" : "";
    }
    function getZoneName() {
      return this._isUTC ? "Coordinated Universal Time" : "";
    }
    var proto = Moment.prototype;
    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff$1;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray$1;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    if (typeof Symbol !== "undefined" && Symbol.for != null) {
      proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
        return "Moment<" + this.format() + ">";
      };
    }
    proto.toJSON = toJSON;
    proto.toString = toString$1;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.eraName = getEraName;
    proto.eraNarrow = getEraNarrow;
    proto.eraAbbr = getEraAbbr;
    proto.eraYear = getEraYear;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.weeksInWeekYear = getWeeksInWeekYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate(
      "dates accessor is deprecated. Use date instead.",
      getSetDayOfMonth
    );
    proto.months = deprecate(
      "months accessor is deprecated. Use month instead",
      getSetMonth
    );
    proto.years = deprecate(
      "years accessor is deprecated. Use year instead",
      getSetYear
    );
    proto.zone = deprecate(
      "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
      getSetZone
    );
    proto.isDSTShifted = deprecate(
      "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
      isDaylightSavingTimeShifted
    );
    function createUnix(input) {
      return createLocal(input * 1e3);
    }
    function createInZone() {
      return createLocal.apply(null, arguments).parseZone();
    }
    function preParsePostFormat(string2) {
      return string2;
    }
    var proto$1 = Locale.prototype;
    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;
    proto$1.eras = localeEras;
    proto$1.erasParse = localeErasParse;
    proto$1.erasConvertYear = localeErasConvertYear;
    proto$1.erasAbbrRegex = erasAbbrRegex;
    proto$1.erasNameRegex = erasNameRegex;
    proto$1.erasNarrowRegex = erasNarrowRegex;
    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;
    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;
    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;
    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;
    function get$1(format2, index2, field, setter) {
      var locale2 = getLocale(), utc = createUTC().set(setter, index2);
      return locale2[field](utc, format2);
    }
    function listMonthsImpl(format2, index2, field) {
      if (isNumber(format2)) {
        index2 = format2;
        format2 = void 0;
      }
      format2 = format2 || "";
      if (index2 != null) {
        return get$1(format2, index2, field, "month");
      }
      var i2, out = [];
      for (i2 = 0; i2 < 12; i2++) {
        out[i2] = get$1(format2, i2, field, "month");
      }
      return out;
    }
    function listWeekdaysImpl(localeSorted, format2, index2, field) {
      if (typeof localeSorted === "boolean") {
        if (isNumber(format2)) {
          index2 = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
      } else {
        format2 = localeSorted;
        index2 = format2;
        localeSorted = false;
        if (isNumber(format2)) {
          index2 = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
      }
      var locale2 = getLocale(), shift2 = localeSorted ? locale2._week.dow : 0, i2, out = [];
      if (index2 != null) {
        return get$1(format2, (index2 + shift2) % 7, field, "day");
      }
      for (i2 = 0; i2 < 7; i2++) {
        out[i2] = get$1(format2, (i2 + shift2) % 7, field, "day");
      }
      return out;
    }
    function listMonths(format2, index2) {
      return listMonthsImpl(format2, index2, "months");
    }
    function listMonthsShort(format2, index2) {
      return listMonthsImpl(format2, index2, "monthsShort");
    }
    function listWeekdays(localeSorted, format2, index2) {
      return listWeekdaysImpl(localeSorted, format2, index2, "weekdays");
    }
    function listWeekdaysShort(localeSorted, format2, index2) {
      return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysShort");
    }
    function listWeekdaysMin(localeSorted, format2, index2) {
      return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysMin");
    }
    getSetGlobalLocale("en", {
      eras: [
        {
          since: "0001-01-01",
          until: Infinity,
          offset: 1,
          name: "Anno Domini",
          narrow: "AD",
          abbr: "AD"
        },
        {
          since: "0000-12-31",
          until: -Infinity,
          offset: 1,
          name: "Before Christ",
          narrow: "BC",
          abbr: "BC"
        }
      ],
      dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function(number2) {
        var b2 = number2 % 10, output = toInt(number2 % 100 / 10) === 1 ? "th" : b2 === 1 ? "st" : b2 === 2 ? "nd" : b2 === 3 ? "rd" : "th";
        return number2 + output;
      }
    });
    hooks.lang = deprecate(
      "moment.lang is deprecated. Use moment.locale instead.",
      getSetGlobalLocale
    );
    hooks.langData = deprecate(
      "moment.langData is deprecated. Use moment.localeData instead.",
      getLocale
    );
    var mathAbs = Math.abs;
    function abs() {
      var data = this._data;
      this._milliseconds = mathAbs(this._milliseconds);
      this._days = mathAbs(this._days);
      this._months = mathAbs(this._months);
      data.milliseconds = mathAbs(data.milliseconds);
      data.seconds = mathAbs(data.seconds);
      data.minutes = mathAbs(data.minutes);
      data.hours = mathAbs(data.hours);
      data.months = mathAbs(data.months);
      data.years = mathAbs(data.years);
      return this;
    }
    function addSubtract$1(duration, input, value, direction) {
      var other = createDuration(input, value);
      duration._milliseconds += direction * other._milliseconds;
      duration._days += direction * other._days;
      duration._months += direction * other._months;
      return duration._bubble();
    }
    function add$1(input, value) {
      return addSubtract$1(this, input, value, 1);
    }
    function subtract$1(input, value) {
      return addSubtract$1(this, input, value, -1);
    }
    function absCeil(number2) {
      if (number2 < 0) {
        return Math.floor(number2);
      } else {
        return Math.ceil(number2);
      }
    }
    function bubble() {
      var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
      if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
        milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
        days2 = 0;
        months2 = 0;
      }
      data.milliseconds = milliseconds2 % 1e3;
      seconds2 = absFloor(milliseconds2 / 1e3);
      data.seconds = seconds2 % 60;
      minutes2 = absFloor(seconds2 / 60);
      data.minutes = minutes2 % 60;
      hours2 = absFloor(minutes2 / 60);
      data.hours = hours2 % 24;
      days2 += absFloor(hours2 / 24);
      monthsFromDays = absFloor(daysToMonths(days2));
      months2 += monthsFromDays;
      days2 -= absCeil(monthsToDays(monthsFromDays));
      years2 = absFloor(months2 / 12);
      months2 %= 12;
      data.days = days2;
      data.months = months2;
      data.years = years2;
      return this;
    }
    function daysToMonths(days2) {
      return days2 * 4800 / 146097;
    }
    function monthsToDays(months2) {
      return months2 * 146097 / 4800;
    }
    function as(units) {
      if (!this.isValid()) {
        return NaN;
      }
      var days2, months2, milliseconds2 = this._milliseconds;
      units = normalizeUnits(units);
      if (units === "month" || units === "quarter" || units === "year") {
        days2 = this._days + milliseconds2 / 864e5;
        months2 = this._months + daysToMonths(days2);
        switch (units) {
          case "month":
            return months2;
          case "quarter":
            return months2 / 3;
          case "year":
            return months2 / 12;
        }
      } else {
        days2 = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
          case "week":
            return days2 / 7 + milliseconds2 / 6048e5;
          case "day":
            return days2 + milliseconds2 / 864e5;
          case "hour":
            return days2 * 24 + milliseconds2 / 36e5;
          case "minute":
            return days2 * 1440 + milliseconds2 / 6e4;
          case "second":
            return days2 * 86400 + milliseconds2 / 1e3;
          case "millisecond":
            return Math.floor(days2 * 864e5) + milliseconds2;
          default:
            throw new Error("Unknown unit " + units);
        }
      }
    }
    function valueOf$1() {
      if (!this.isValid()) {
        return NaN;
      }
      return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
    }
    function makeAs(alias2) {
      return function() {
        return this.as(alias2);
      };
    }
    var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
    function clone$1() {
      return createDuration(this);
    }
    function get$2(units) {
      units = normalizeUnits(units);
      return this.isValid() ? this[units + "s"]() : NaN;
    }
    function makeGetter(name2) {
      return function() {
        return this.isValid() ? this._data[name2] : NaN;
      };
    }
    var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
    function weeks() {
      return absFloor(this.days() / 7);
    }
    var round = Math.round, thresholds = {
      ss: 44,
      // a few seconds to seconds
      s: 45,
      // seconds to minute
      m: 45,
      // minutes to hour
      h: 22,
      // hours to day
      d: 26,
      // days to month/week
      w: null,
      // weeks to month
      M: 11
      // months to year
    };
    function substituteTimeAgo(string2, number2, withoutSuffix, isFuture, locale2) {
      return locale2.relativeTime(number2 || 1, !!withoutSuffix, string2, isFuture);
    }
    function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
      var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a2 = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
      if (thresholds2.w != null) {
        a2 = a2 || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
      }
      a2 = a2 || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
      a2[2] = withoutSuffix;
      a2[3] = +posNegDuration > 0;
      a2[4] = locale2;
      return substituteTimeAgo.apply(null, a2);
    }
    function getSetRelativeTimeRounding(roundingFunction) {
      if (roundingFunction === void 0) {
        return round;
      }
      if (typeof roundingFunction === "function") {
        round = roundingFunction;
        return true;
      }
      return false;
    }
    function getSetRelativeTimeThreshold(threshold, limit) {
      if (thresholds[threshold] === void 0) {
        return false;
      }
      if (limit === void 0) {
        return thresholds[threshold];
      }
      thresholds[threshold] = limit;
      if (threshold === "s") {
        thresholds.ss = limit - 1;
      }
      return true;
    }
    function humanize(argWithSuffix, argThresholds) {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }
      var withSuffix = false, th2 = thresholds, locale2, output;
      if (typeof argWithSuffix === "object") {
        argThresholds = argWithSuffix;
        argWithSuffix = false;
      }
      if (typeof argWithSuffix === "boolean") {
        withSuffix = argWithSuffix;
      }
      if (typeof argThresholds === "object") {
        th2 = Object.assign({}, thresholds, argThresholds);
        if (argThresholds.s != null && argThresholds.ss == null) {
          th2.ss = argThresholds.s - 1;
        }
      }
      locale2 = this.localeData();
      output = relativeTime$1(this, !withSuffix, th2, locale2);
      if (withSuffix) {
        output = locale2.pastFuture(+this, output);
      }
      return locale2.postformat(output);
    }
    var abs$1 = Math.abs;
    function sign(x2) {
      return (x2 > 0) - (x2 < 0) || +x2;
    }
    function toISOString$1() {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }
      var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s2, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
      if (!total) {
        return "P0D";
      }
      minutes2 = absFloor(seconds2 / 60);
      hours2 = absFloor(minutes2 / 60);
      seconds2 %= 60;
      minutes2 %= 60;
      years2 = absFloor(months2 / 12);
      months2 %= 12;
      s2 = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
      totalSign = total < 0 ? "-" : "";
      ymSign = sign(this._months) !== sign(total) ? "-" : "";
      daysSign = sign(this._days) !== sign(total) ? "-" : "";
      hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
      return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s2 + "S" : "");
    }
    var proto$2 = Duration.prototype;
    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;
    proto$2.toIsoString = deprecate(
      "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
      toISOString$1
    );
    proto$2.lang = lang;
    addFormatToken("X", 0, 0, "unix");
    addFormatToken("x", 0, 0, "valueOf");
    addRegexToken("x", matchSigned);
    addRegexToken("X", matchTimestamp);
    addParseToken("X", function(input, array, config2) {
      config2._d = new Date(parseFloat(input) * 1e3);
    });
    addParseToken("x", function(input, array, config2) {
      config2._d = new Date(toInt(input));
    });
    //! moment.js
    hooks.version = "2.29.4";
    setHookCallback(createLocal);
    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto;
    hooks.HTML5_FMT = {
      DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
      // <input type="datetime-local" />
      DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
      // <input type="datetime-local" step="1" />
      DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
      // <input type="datetime-local" step="0.001" />
      DATE: "YYYY-MM-DD",
      // <input type="date" />
      TIME: "HH:mm",
      // <input type="time" />
      TIME_SECONDS: "HH:mm:ss",
      // <input type="time" step="1" />
      TIME_MS: "HH:mm:ss.SSS",
      // <input type="time" step="0.001" />
      WEEK: "GGGG-[W]WW",
      // <input type="week" />
      MONTH: "YYYY-MM"
      // <input type="month" />
    };
    const useAppContext = () => {
      return reactExports.useContext(AppContext);
    };
    const parseJSON = (jsonString) => {
      try {
        const o2 = JSON.parse(jsonString);
        return o2;
      } catch (e2) {
        console.error(e2);
      }
      return {};
    };
    const PortalCompatContext = reactExports.createContext(void 0);
    const PortalCompatContextProvider = PortalCompatContext.Provider;
    const CLASS_NAME_REGEX = new RegExp(`([^\\s]*${fluentProviderClassNames.root}\\w+)`, "g");
    function useProviderThemeClasses() {
      const themeClassName = useThemeClassName();
      const cssVariablesClasses = reactExports.useMemo(
        // "themeClassName" may contain multiple classes while we want to add only classes that host CSS variables
        // Keep in sync with "packages/react-provider/src/components/FluentProvider/useFluentProviderThemeStyleTag.ts"
        () => {
          var _themeClassName_match;
          return (_themeClassName_match = themeClassName.match(CLASS_NAME_REGEX)) !== null && _themeClassName_match !== void 0 ? _themeClassName_match : [];
        },
        [
          themeClassName
        ]
      );
      return cssVariablesClasses;
    }
    const PortalCompatProvider = (props) => {
      const { children } = props;
      const cssVariablesClasses = useProviderThemeClasses();
      const registerPortalEl = reactExports.useCallback((element2) => {
        let disposeFocusVisiblePolyfill = () => void 0;
        element2.classList.add(...cssVariablesClasses);
        if (element2.ownerDocument.defaultView) {
          disposeFocusVisiblePolyfill = applyFocusVisiblePolyfill(element2, element2.ownerDocument.defaultView);
        }
        return () => {
          element2.classList.remove(...cssVariablesClasses);
          disposeFocusVisiblePolyfill();
        };
      }, [
        cssVariablesClasses
      ]);
      return /* @__PURE__ */ reactExports.createElement(PortalCompatContextProvider, {
        value: registerPortalEl
      }, children);
    };
    const protocols = ["http", "https", "mailto", "tel"];
    function uriTransformer(uri) {
      const url = (uri || "").trim();
      const first = url.charAt(0);
      if (first === "#" || first === "/") {
        return url;
      }
      const colon2 = url.indexOf(":");
      if (colon2 === -1) {
        return url;
      }
      let index2 = -1;
      while (++index2 < protocols.length) {
        const protocol = protocols[index2];
        if (colon2 === protocol.length && url.slice(0, protocol.length).toLowerCase() === protocol) {
          return url;
        }
      }
      index2 = url.indexOf("?");
      if (index2 !== -1 && colon2 > index2) {
        return url;
      }
      index2 = url.indexOf("#");
      if (index2 !== -1 && colon2 > index2) {
        return url;
      }
      return "javascript:void(0)";
    }
    /*!
     * Determine if an object is a Buffer
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     */
    var isBuffer = function isBuffer2(obj) {
      return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    };
    const isBuffer$1 = /* @__PURE__ */ getDefaultExportFromCjs(isBuffer);
    var own$g = {}.hasOwnProperty;
    function stringifyPosition$1(value) {
      if (!value || typeof value !== "object") {
        return "";
      }
      if (own$g.call(value, "position") || own$g.call(value, "type")) {
        return position$3(value.position);
      }
      if (own$g.call(value, "start") || own$g.call(value, "end")) {
        return position$3(value);
      }
      if (own$g.call(value, "line") || own$g.call(value, "column")) {
        return point$3(value);
      }
      return "";
    }
    function point$3(point2) {
      return index$1(point2 && point2.line) + ":" + index$1(point2 && point2.column);
    }
    function position$3(pos) {
      return point$3(pos && pos.start) + "-" + point$3(pos && pos.end);
    }
    function index$1(value) {
      return value && typeof value === "number" ? value : 1;
    }
    class VFileMessage extends Error {
      /**
       * Constructor of a message for `reason` at `place` from `origin`.
       * When an error is passed in as `reason`, copies the `stack`.
       *
       * @param {string|Error} reason Reason for message (`string` or `Error`). Uses the stack and message of the error if given.
       * @param {Node|Position|Point} [place] Place at which the message occurred in a file (`Node`, `Position`, or `Point`, optional).
       * @param {string} [origin] Place in code the message originates from (`string`, optional).
       */
      constructor(reason, place, origin) {
        var parts = [null, null];
        var position2 = {
          start: { line: null, column: null },
          end: { line: null, column: null }
        };
        var index2;
        super();
        if (typeof place === "string") {
          origin = place;
          place = null;
        }
        if (typeof origin === "string") {
          index2 = origin.indexOf(":");
          if (index2 === -1) {
            parts[1] = origin;
          } else {
            parts[0] = origin.slice(0, index2);
            parts[1] = origin.slice(index2 + 1);
          }
        }
        if (place) {
          if ("type" in place || "position" in place) {
            if (place.position) {
              position2 = place.position;
            }
          } else if ("start" in place || "end" in place) {
            position2 = place;
          } else if ("line" in place || "column" in place) {
            position2.start = place;
          }
        }
        this.name = stringifyPosition$1(place) || "1:1";
        this.message = typeof reason === "object" ? reason.message : reason;
        this.stack = typeof reason === "object" ? reason.stack : "";
        this.reason = this.message;
        this.line = position2.start.line;
        this.column = position2.start.column;
        this.source = parts[0];
        this.ruleId = parts[1];
        this.position = position2;
        this.file;
        this.fatal;
        this.url;
        this.note;
      }
    }
    VFileMessage.prototype.file = "";
    VFileMessage.prototype.name = "";
    VFileMessage.prototype.reason = "";
    VFileMessage.prototype.message = "";
    VFileMessage.prototype.stack = "";
    VFileMessage.prototype.fatal = null;
    VFileMessage.prototype.column = null;
    VFileMessage.prototype.line = null;
    VFileMessage.prototype.source = null;
    VFileMessage.prototype.ruleId = null;
    VFileMessage.prototype.position = null;
    const path$1 = { basename, dirname, extname, join, sep: "/" };
    function basename(path2, ext) {
      if (ext !== void 0 && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
      }
      assertPath$1(path2);
      let start = 0;
      let end = -1;
      let index2 = path2.length;
      let seenNonSlash;
      if (ext === void 0 || ext.length === 0 || ext.length > path2.length) {
        while (index2--) {
          if (path2.charCodeAt(index2) === 47) {
            if (seenNonSlash) {
              start = index2 + 1;
              break;
            }
          } else if (end < 0) {
            seenNonSlash = true;
            end = index2 + 1;
          }
        }
        return end < 0 ? "" : path2.slice(start, end);
      }
      if (ext === path2) {
        return "";
      }
      let firstNonSlashEnd = -1;
      let extIndex = ext.length - 1;
      while (index2--) {
        if (path2.charCodeAt(index2) === 47) {
          if (seenNonSlash) {
            start = index2 + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd < 0) {
            seenNonSlash = true;
            firstNonSlashEnd = index2 + 1;
          }
          if (extIndex > -1) {
            if (path2.charCodeAt(index2) === ext.charCodeAt(extIndex--)) {
              if (extIndex < 0) {
                end = index2;
              }
            } else {
              extIndex = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }
      if (start === end) {
        end = firstNonSlashEnd;
      } else if (end < 0) {
        end = path2.length;
      }
      return path2.slice(start, end);
    }
    function dirname(path2) {
      assertPath$1(path2);
      if (path2.length === 0) {
        return ".";
      }
      let end = -1;
      let index2 = path2.length;
      let unmatchedSlash;
      while (--index2) {
        if (path2.charCodeAt(index2) === 47) {
          if (unmatchedSlash) {
            end = index2;
            break;
          }
        } else if (!unmatchedSlash) {
          unmatchedSlash = true;
        }
      }
      return end < 0 ? path2.charCodeAt(0) === 47 ? "/" : "." : end === 1 && path2.charCodeAt(0) === 47 ? "//" : path2.slice(0, end);
    }
    function extname(path2) {
      assertPath$1(path2);
      let index2 = path2.length;
      let end = -1;
      let startPart = 0;
      let startDot = -1;
      let preDotState = 0;
      let unmatchedSlash;
      while (index2--) {
        const code2 = path2.charCodeAt(index2);
        if (code2 === 47) {
          if (unmatchedSlash) {
            startPart = index2 + 1;
            break;
          }
          continue;
        }
        if (end < 0) {
          unmatchedSlash = true;
          end = index2 + 1;
        }
        if (code2 === 46) {
          if (startDot < 0) {
            startDot = index2;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot > -1) {
          preDotState = -1;
        }
      }
      if (startDot < 0 || end < 0 || // We saw a non-dot character immediately before the dot.
      preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path2.slice(startDot, end);
    }
    function join(...segments) {
      let index2 = -1;
      let joined;
      while (++index2 < segments.length) {
        assertPath$1(segments[index2]);
        if (segments[index2]) {
          joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
        }
      }
      return joined === void 0 ? "." : normalize$1(joined);
    }
    function normalize$1(path2) {
      assertPath$1(path2);
      const absolute = path2.charCodeAt(0) === 47;
      let value = normalizeString(path2, !absolute);
      if (value.length === 0 && !absolute) {
        value = ".";
      }
      if (value.length > 0 && path2.charCodeAt(path2.length - 1) === 47) {
        value += "/";
      }
      return absolute ? "/" + value : value;
    }
    function normalizeString(path2, allowAboveRoot) {
      let result = "";
      let lastSegmentLength = 0;
      let lastSlash = -1;
      let dots = 0;
      let index2 = -1;
      let code2;
      let lastSlashIndex;
      while (++index2 <= path2.length) {
        if (index2 < path2.length) {
          code2 = path2.charCodeAt(index2);
        } else if (code2 === 47) {
          break;
        } else {
          code2 = 47;
        }
        if (code2 === 47) {
          if (lastSlash === index2 - 1 || dots === 1)
            ;
          else if (lastSlash !== index2 - 1 && dots === 2) {
            if (result.length < 2 || lastSegmentLength !== 2 || result.charCodeAt(result.length - 1) !== 46 || result.charCodeAt(result.length - 2) !== 46) {
              if (result.length > 2) {
                lastSlashIndex = result.lastIndexOf("/");
                if (lastSlashIndex !== result.length - 1) {
                  if (lastSlashIndex < 0) {
                    result = "";
                    lastSegmentLength = 0;
                  } else {
                    result = result.slice(0, lastSlashIndex);
                    lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
                  }
                  lastSlash = index2;
                  dots = 0;
                  continue;
                }
              } else if (result.length > 0) {
                result = "";
                lastSegmentLength = 0;
                lastSlash = index2;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              result = result.length > 0 ? result + "/.." : "..";
              lastSegmentLength = 2;
            }
          } else {
            if (result.length > 0) {
              result += "/" + path2.slice(lastSlash + 1, index2);
            } else {
              result = path2.slice(lastSlash + 1, index2);
            }
            lastSegmentLength = index2 - lastSlash - 1;
          }
          lastSlash = index2;
          dots = 0;
        } else if (code2 === 46 && dots > -1) {
          dots++;
        } else {
          dots = -1;
        }
      }
      return result;
    }
    function assertPath$1(path2) {
      if (typeof path2 !== "string") {
        throw new TypeError(
          "Path must be a string. Received " + JSON.stringify(path2)
        );
      }
    }
    const proc = { cwd };
    function cwd() {
      return "/";
    }
    function isUrl(fileURLOrPath) {
      return fileURLOrPath !== null && typeof fileURLOrPath === "object" && // @ts-expect-error: indexable.
      fileURLOrPath.href && // @ts-expect-error: indexable.
      fileURLOrPath.origin;
    }
    function urlToPath(path2) {
      if (typeof path2 === "string") {
        path2 = new URL(path2);
      } else if (!isUrl(path2)) {
        const error = new TypeError(
          'The "path" argument must be of type string or an instance of URL. Received `' + path2 + "`"
        );
        error.code = "ERR_INVALID_ARG_TYPE";
        throw error;
      }
      if (path2.protocol !== "file:") {
        const error = new TypeError("The URL must be of scheme file");
        error.code = "ERR_INVALID_URL_SCHEME";
        throw error;
      }
      return getPathFromURLPosix(path2);
    }
    function getPathFromURLPosix(url) {
      if (url.hostname !== "") {
        const error = new TypeError(
          'File URL host must be "localhost" or empty on darwin'
        );
        error.code = "ERR_INVALID_FILE_URL_HOST";
        throw error;
      }
      const pathname = url.pathname;
      let index2 = -1;
      while (++index2 < pathname.length) {
        if (pathname.charCodeAt(index2) === 37 && pathname.charCodeAt(index2 + 1) === 50) {
          const third = pathname.charCodeAt(index2 + 2);
          if (third === 70 || third === 102) {
            const error = new TypeError(
              "File URL path must not include encoded / characters"
            );
            error.code = "ERR_INVALID_FILE_URL_PATH";
            throw error;
          }
        }
      }
      return decodeURIComponent(pathname);
    }
    const order = ["history", "path", "basename", "stem", "extname", "dirname"];
    class VFile {
      /**
       * Create a new virtual file.
       *
       * If `options` is `string` or `Buffer`, treats it as `{value: options}`.
       * If `options` is a `VFile`, shallow copies its data over to the new file.
       * All other given fields are set on the newly created `VFile`.
       *
       * Path related properties are set in the following order (least specific to
       * most specific): `history`, `path`, `basename`, `stem`, `extname`,
       * `dirname`.
       *
       * It’s not possible to set either `dirname` or `extname` without setting
       * either `history`, `path`, `basename`, or `stem` as well.
       *
       * @param {VFileCompatible} [value]
       */
      constructor(value) {
        let options;
        if (!value) {
          options = {};
        } else if (typeof value === "string" || isBuffer$1(value)) {
          options = { value };
        } else if (isUrl(value)) {
          options = { path: value };
        } else {
          options = value;
        }
        this.data = {};
        this.messages = [];
        this.history = [];
        this.cwd = proc.cwd();
        this.value;
        this.stored;
        this.result;
        this.map;
        let index2 = -1;
        while (++index2 < order.length) {
          const prop2 = order[index2];
          if (prop2 in options && options[prop2] !== void 0) {
            this[prop2] = prop2 === "history" ? [...options[prop2]] : options[prop2];
          }
        }
        let prop;
        for (prop in options) {
          if (!order.includes(prop))
            this[prop] = options[prop];
        }
      }
      /**
       * Access full path (`~/index.min.js`).
       *
       * @returns {string}
       */
      get path() {
        return this.history[this.history.length - 1];
      }
      /**
       * Set full path (`~/index.min.js`).
       * Cannot be nullified.
       *
       * @param {string|URL} path
       */
      set path(path2) {
        if (isUrl(path2)) {
          path2 = urlToPath(path2);
        }
        assertNonEmpty(path2, "path");
        if (this.path !== path2) {
          this.history.push(path2);
        }
      }
      /**
       * Access parent path (`~`).
       */
      get dirname() {
        return typeof this.path === "string" ? path$1.dirname(this.path) : void 0;
      }
      /**
       * Set parent path (`~`).
       * Cannot be set if there's no `path` yet.
       */
      set dirname(dirname2) {
        assertPath(this.basename, "dirname");
        this.path = path$1.join(dirname2 || "", this.basename);
      }
      /**
       * Access basename (including extname) (`index.min.js`).
       */
      get basename() {
        return typeof this.path === "string" ? path$1.basename(this.path) : void 0;
      }
      /**
       * Set basename (`index.min.js`).
       * Cannot contain path separators.
       * Cannot be nullified either (use `file.path = file.dirname` instead).
       */
      set basename(basename2) {
        assertNonEmpty(basename2, "basename");
        assertPart(basename2, "basename");
        this.path = path$1.join(this.dirname || "", basename2);
      }
      /**
       * Access extname (including dot) (`.js`).
       */
      get extname() {
        return typeof this.path === "string" ? path$1.extname(this.path) : void 0;
      }
      /**
       * Set extname (including dot) (`.js`).
       * Cannot be set if there's no `path` yet and cannot contain path separators.
       */
      set extname(extname2) {
        assertPart(extname2, "extname");
        assertPath(this.dirname, "extname");
        if (extname2) {
          if (extname2.charCodeAt(0) !== 46) {
            throw new Error("`extname` must start with `.`");
          }
          if (extname2.includes(".", 1)) {
            throw new Error("`extname` cannot contain multiple dots");
          }
        }
        this.path = path$1.join(this.dirname, this.stem + (extname2 || ""));
      }
      /**
       * Access stem (w/o extname) (`index.min`).
       */
      get stem() {
        return typeof this.path === "string" ? path$1.basename(this.path, this.extname) : void 0;
      }
      /**
       * Set stem (w/o extname) (`index.min`).
       * Cannot be nullified, and cannot contain path separators.
       */
      set stem(stem) {
        assertNonEmpty(stem, "stem");
        assertPart(stem, "stem");
        this.path = path$1.join(this.dirname || "", stem + (this.extname || ""));
      }
      /**
       * Serialize the file.
       *
       * @param {BufferEncoding} [encoding='utf8'] If `file.value` is a buffer, `encoding` is used to serialize buffers.
       * @returns {string}
       */
      toString(encoding) {
        return (this.value || "").toString(encoding);
      }
      /**
       * Create a message and associates it w/ the file.
       *
       * @param {string|Error} reason Reason for message (`string` or `Error`). Uses the stack and message of the error if given.
       * @param {Node|Position|Point} [place] Place at which the message occurred in a file (`Node`, `Position`, or `Point`, optional).
       * @param {string} [origin] Place in code the message originates from (`string`, optional).
       * @returns {VFileMessage}
       */
      message(reason, place, origin) {
        const message = new VFileMessage(reason, place, origin);
        if (this.path) {
          message.name = this.path + ":" + message.name;
          message.file = this.path;
        }
        message.fatal = false;
        this.messages.push(message);
        return message;
      }
      /**
       * Info: create a message, associate it with the file, and mark the fatality
       * as `null`.
       * Calls `message()` internally.
       *
       * @param {string|Error} reason Reason for message (`string` or `Error`). Uses the stack and message of the error if given.
       * @param {Node|Position|Point} [place] Place at which the message occurred in a file (`Node`, `Position`, or `Point`, optional).
       * @param {string} [origin] Place in code the message originates from (`string`, optional).
       * @returns {VFileMessage}
       */
      info(reason, place, origin) {
        const message = this.message(reason, place, origin);
        message.fatal = null;
        return message;
      }
      /**
       * Fail: create a message, associate it with the file, mark the fatality as
       * `true`.
       * Note: fatal errors mean a file is no longer processable.
       * Calls `message()` internally.
       *
       * @param {string|Error} reason Reason for message (`string` or `Error`). Uses the stack and message of the error if given.
       * @param {Node|Position|Point} [place] Place at which the message occurred in a file (`Node`, `Position`, or `Point`, optional).
       * @param {string} [origin] Place in code the message originates from (`string`, optional).
       * @returns {never}
       */
      fail(reason, place, origin) {
        const message = this.message(reason, place, origin);
        message.fatal = true;
        throw message;
      }
    }
    function assertPart(part, name2) {
      if (part && part.includes(path$1.sep)) {
        throw new Error(
          "`" + name2 + "` cannot be a path: did not expect `" + path$1.sep + "`"
        );
      }
    }
    function assertNonEmpty(part, name2) {
      if (!part) {
        throw new Error("`" + name2 + "` cannot be empty");
      }
    }
    function assertPath(path2, name2) {
      if (!path2) {
        throw new Error("Setting `" + name2 + "` requires `path` to be set too");
      }
    }
    function bail(error) {
      if (error) {
        throw error;
      }
    }
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty$1 = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray = function isArray2(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    };
    var isPlainObject$1 = function isPlainObject2(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key;
      for (key in obj) {
      }
      return typeof key === "undefined" || hasOwn.call(obj, key);
    };
    var setProperty = function setProperty2(target, options) {
      if (defineProperty$1 && options.name === "__proto__") {
        defineProperty$1(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name2) {
      if (name2 === "__proto__") {
        if (!hasOwn.call(obj, name2)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name2).value;
        }
      }
      return obj[name2];
    };
    var extend = function extend2() {
      var options, name2, src, copy2, copyIsArray, clone2;
      var target = arguments[0];
      var i2 = 1;
      var length2 = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i2 = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i2 < length2; ++i2) {
        options = arguments[i2];
        if (options != null) {
          for (name2 in options) {
            src = getProperty(target, name2);
            copy2 = getProperty(options, name2);
            if (target !== copy2) {
              if (deep && copy2 && (isPlainObject$1(copy2) || (copyIsArray = isArray(copy2)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone2 = src && isArray(src) ? src : [];
                } else {
                  clone2 = src && isPlainObject$1(src) ? src : {};
                }
                setProperty(target, { name: name2, newValue: extend2(deep, clone2, copy2) });
              } else if (typeof copy2 !== "undefined") {
                setProperty(target, { name: name2, newValue: copy2 });
              }
            }
          }
        }
      }
      return target;
    };
    const extend$1 = /* @__PURE__ */ getDefaultExportFromCjs(extend);
    function isPlainObject(value) {
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
      }
      const prototype = Object.getPrototypeOf(value);
      return prototype === null || prototype === Object.prototype;
    }
    function trough() {
      const fns = [];
      const pipeline = { run, use };
      return pipeline;
      function run(...values) {
        let middlewareIndex = -1;
        const callback = values.pop();
        if (typeof callback !== "function") {
          throw new TypeError("Expected function as last argument, not " + callback);
        }
        next2(null, ...values);
        function next2(error, ...output) {
          const fn = fns[++middlewareIndex];
          let index2 = -1;
          if (error) {
            callback(error);
            return;
          }
          while (++index2 < values.length) {
            if (output[index2] === null || output[index2] === void 0) {
              output[index2] = values[index2];
            }
          }
          values = output;
          if (fn) {
            wrap$1(fn, next2)(...output);
          } else {
            callback(null, ...output);
          }
        }
      }
      function use(middelware) {
        if (typeof middelware !== "function") {
          throw new TypeError(
            "Expected `middelware` to be a function, not " + middelware
          );
        }
        fns.push(middelware);
        return pipeline;
      }
    }
    function wrap$1(middleware2, callback) {
      let called;
      return wrapped;
      function wrapped(...parameters) {
        const fnExpectsCallback = middleware2.length > parameters.length;
        let result;
        if (fnExpectsCallback) {
          parameters.push(done);
        }
        try {
          result = middleware2(...parameters);
        } catch (error) {
          const exception = error;
          if (fnExpectsCallback && called) {
            throw exception;
          }
          return done(exception);
        }
        if (!fnExpectsCallback) {
          if (result instanceof Promise) {
            result.then(then, done);
          } else if (result instanceof Error) {
            done(result);
          } else {
            then(result);
          }
        }
      }
      function done(error, ...output) {
        if (!called) {
          called = true;
          callback(error, ...output);
        }
      }
      function then(value) {
        done(null, value);
      }
    }
    const unified = base().freeze();
    const own$f = {}.hasOwnProperty;
    function base() {
      const transformers = trough();
      const attachers = [];
      let namespace = {};
      let frozen;
      let freezeIndex = -1;
      processor.data = data;
      processor.Parser = void 0;
      processor.Compiler = void 0;
      processor.freeze = freeze;
      processor.attachers = attachers;
      processor.use = use;
      processor.parse = parse2;
      processor.stringify = stringify2;
      processor.run = run;
      processor.runSync = runSync;
      processor.process = process2;
      processor.processSync = processSync;
      return processor;
      function processor() {
        const destination = base();
        let index2 = -1;
        while (++index2 < attachers.length) {
          destination.use(...attachers[index2]);
        }
        destination.data(extend$1(true, {}, namespace));
        return destination;
      }
      function data(key, value) {
        if (typeof key === "string") {
          if (arguments.length === 2) {
            assertUnfrozen("data", frozen);
            namespace[key] = value;
            return processor;
          }
          return own$f.call(namespace, key) && namespace[key] || null;
        }
        if (key) {
          assertUnfrozen("data", frozen);
          namespace = key;
          return processor;
        }
        return namespace;
      }
      function freeze() {
        if (frozen) {
          return processor;
        }
        while (++freezeIndex < attachers.length) {
          const [attacher, ...options] = attachers[freezeIndex];
          if (options[0] === false) {
            continue;
          }
          if (options[0] === true) {
            options[1] = void 0;
          }
          const transformer = attacher.call(processor, ...options);
          if (typeof transformer === "function") {
            transformers.use(transformer);
          }
        }
        frozen = true;
        freezeIndex = Number.POSITIVE_INFINITY;
        return processor;
      }
      function use(value, ...options) {
        let settings;
        assertUnfrozen("use", frozen);
        if (value === null || value === void 0)
          ;
        else if (typeof value === "function") {
          addPlugin(value, ...options);
        } else if (typeof value === "object") {
          if (Array.isArray(value)) {
            addList(value);
          } else {
            addPreset(value);
          }
        } else {
          throw new TypeError("Expected usable value, not `" + value + "`");
        }
        if (settings) {
          namespace.settings = Object.assign(namespace.settings || {}, settings);
        }
        return processor;
        function add2(value2) {
          if (typeof value2 === "function") {
            addPlugin(value2);
          } else if (typeof value2 === "object") {
            if (Array.isArray(value2)) {
              const [plugin, ...options2] = value2;
              addPlugin(plugin, ...options2);
            } else {
              addPreset(value2);
            }
          } else {
            throw new TypeError("Expected usable value, not `" + value2 + "`");
          }
        }
        function addPreset(result) {
          addList(result.plugins);
          if (result.settings) {
            settings = Object.assign(settings || {}, result.settings);
          }
        }
        function addList(plugins) {
          let index2 = -1;
          if (plugins === null || plugins === void 0)
            ;
          else if (Array.isArray(plugins)) {
            while (++index2 < plugins.length) {
              const thing = plugins[index2];
              add2(thing);
            }
          } else {
            throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
          }
        }
        function addPlugin(plugin, value2) {
          let index2 = -1;
          let entry;
          while (++index2 < attachers.length) {
            if (attachers[index2][0] === plugin) {
              entry = attachers[index2];
              break;
            }
          }
          if (entry) {
            if (isPlainObject(entry[1]) && isPlainObject(value2)) {
              value2 = extend$1(true, entry[1], value2);
            }
            entry[1] = value2;
          } else {
            attachers.push([...arguments]);
          }
        }
      }
      function parse2(doc) {
        processor.freeze();
        const file = vfile(doc);
        const Parser2 = processor.Parser;
        assertParser("parse", Parser2);
        if (newable(Parser2, "parse")) {
          return new Parser2(String(file), file).parse();
        }
        return Parser2(String(file), file);
      }
      function stringify2(node2, doc) {
        processor.freeze();
        const file = vfile(doc);
        const Compiler = processor.Compiler;
        assertCompiler("stringify", Compiler);
        assertNode(node2);
        if (newable(Compiler, "compile")) {
          return new Compiler(node2, file).compile();
        }
        return Compiler(node2, file);
      }
      function run(node2, doc, callback) {
        assertNode(node2);
        processor.freeze();
        if (!callback && typeof doc === "function") {
          callback = doc;
          doc = void 0;
        }
        if (!callback) {
          return new Promise(executor);
        }
        executor(null, callback);
        function executor(resolve, reject) {
          transformers.run(node2, vfile(doc), done);
          function done(error, tree, file) {
            tree = tree || node2;
            if (error) {
              reject(error);
            } else if (resolve) {
              resolve(tree);
            } else {
              callback(null, tree, file);
            }
          }
        }
      }
      function runSync(node2, file) {
        let result;
        let complete;
        processor.run(node2, file, done);
        assertDone("runSync", "run", complete);
        return result;
        function done(error, tree) {
          bail(error);
          result = tree;
          complete = true;
        }
      }
      function process2(doc, callback) {
        processor.freeze();
        assertParser("process", processor.Parser);
        assertCompiler("process", processor.Compiler);
        if (!callback) {
          return new Promise(executor);
        }
        executor(null, callback);
        function executor(resolve, reject) {
          const file = vfile(doc);
          processor.run(processor.parse(file), file, (error, tree, file2) => {
            if (error || !tree || !file2) {
              done(error);
            } else {
              const result = processor.stringify(tree, file2);
              if (result === void 0 || result === null)
                ;
              else if (looksLikeAVFileValue(result)) {
                file2.value = result;
              } else {
                file2.result = result;
              }
              done(error, file2);
            }
          });
          function done(error, file2) {
            if (error || !file2) {
              reject(error);
            } else if (resolve) {
              resolve(file2);
            } else {
              callback(null, file2);
            }
          }
        }
      }
      function processSync(doc) {
        let complete;
        processor.freeze();
        assertParser("processSync", processor.Parser);
        assertCompiler("processSync", processor.Compiler);
        const file = vfile(doc);
        processor.process(file, done);
        assertDone("processSync", "process", complete);
        return file;
        function done(error) {
          complete = true;
          bail(error);
        }
      }
    }
    function newable(value, name2) {
      return typeof value === "function" && // Prototypes do exist.
      // type-coverage:ignore-next-line
      value.prototype && // A function with keys in its prototype is probably a constructor.
      // Classes’ prototype methods are not enumerable, so we check if some value
      // exists in the prototype.
      // type-coverage:ignore-next-line
      (keys(value.prototype) || name2 in value.prototype);
    }
    function keys(value) {
      let key;
      for (key in value) {
        if (own$f.call(value, key)) {
          return true;
        }
      }
      return false;
    }
    function assertParser(name2, value) {
      if (typeof value !== "function") {
        throw new TypeError("Cannot `" + name2 + "` without `Parser`");
      }
    }
    function assertCompiler(name2, value) {
      if (typeof value !== "function") {
        throw new TypeError("Cannot `" + name2 + "` without `Compiler`");
      }
    }
    function assertUnfrozen(name2, frozen) {
      if (frozen) {
        throw new Error(
          "Cannot call `" + name2 + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
        );
      }
    }
    function assertNode(node2) {
      if (!isPlainObject(node2) || typeof node2.type !== "string") {
        throw new TypeError("Expected node, got `" + node2 + "`");
      }
    }
    function assertDone(name2, asyncName, complete) {
      if (!complete) {
        throw new Error(
          "`" + name2 + "` finished async. Use `" + asyncName + "` instead"
        );
      }
    }
    function vfile(value) {
      return looksLikeAVFile(value) ? value : new VFile(value);
    }
    function looksLikeAVFile(value) {
      return Boolean(
        value && typeof value === "object" && "message" in value && "messages" in value
      );
    }
    function looksLikeAVFileValue(value) {
      return typeof value === "string" || isBuffer$1(value);
    }
    function toString(node2, options) {
      var { includeImageAlt = true } = options || {};
      return one$2(node2, includeImageAlt);
    }
    function one$2(node2, includeImageAlt) {
      return node2 && typeof node2 === "object" && // @ts-ignore looks like a literal.
      (node2.value || // @ts-ignore looks like an image.
      (includeImageAlt ? node2.alt : "") || // @ts-ignore looks like a parent.
      "children" in node2 && all$2(node2.children, includeImageAlt) || Array.isArray(node2) && all$2(node2, includeImageAlt)) || "";
    }
    function all$2(values, includeImageAlt) {
      var result = [];
      var index2 = -1;
      while (++index2 < values.length) {
        result[index2] = one$2(values[index2], includeImageAlt);
      }
      return result.join("");
    }
    function splice(list2, start, remove, items) {
      const end = list2.length;
      let chunkStart = 0;
      let parameters;
      if (start < 0) {
        start = -start > end ? 0 : end + start;
      } else {
        start = start > end ? end : start;
      }
      remove = remove > 0 ? remove : 0;
      if (items.length < 1e4) {
        parameters = Array.from(items);
        parameters.unshift(start, remove);
        [].splice.apply(list2, parameters);
      } else {
        if (remove)
          [].splice.apply(list2, [start, remove]);
        while (chunkStart < items.length) {
          parameters = items.slice(chunkStart, chunkStart + 1e4);
          parameters.unshift(start, 0);
          [].splice.apply(list2, parameters);
          chunkStart += 1e4;
          start += 1e4;
        }
      }
    }
    function push(list2, items) {
      if (list2.length > 0) {
        splice(list2, list2.length, 0, items);
        return list2;
      }
      return items;
    }
    const hasOwnProperty$1 = {}.hasOwnProperty;
    function combineExtensions$1(extensions) {
      const all2 = {};
      let index2 = -1;
      while (++index2 < extensions.length) {
        syntaxExtension(all2, extensions[index2]);
      }
      return all2;
    }
    function syntaxExtension(all2, extension2) {
      let hook;
      for (hook in extension2) {
        const maybe = hasOwnProperty$1.call(all2, hook) ? all2[hook] : void 0;
        const left = maybe || (all2[hook] = {});
        const right = extension2[hook];
        let code2;
        for (code2 in right) {
          if (!hasOwnProperty$1.call(left, code2))
            left[code2] = [];
          const value = right[code2];
          constructs$1(
            // @ts-expect-error Looks like a list.
            left[code2],
            Array.isArray(value) ? value : value ? [value] : []
          );
        }
      }
    }
    function constructs$1(existing, list2) {
      let index2 = -1;
      const before = [];
      while (++index2 < list2.length) {
        (list2[index2].add === "after" ? existing : before).push(list2[index2]);
      }
      splice(existing, 0, 0, before);
    }
    const unicodePunctuationRegex$1 = /[!-/:-@[-`{-~\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
    const asciiAlpha$2 = regexCheck$1(/[A-Za-z]/);
    const asciiDigit = regexCheck$1(/\d/);
    const asciiHexDigit = regexCheck$1(/[\dA-Fa-f]/);
    const asciiAlphanumeric$2 = regexCheck$1(/[\dA-Za-z]/);
    const asciiPunctuation = regexCheck$1(/[!-/:-@[-`{-~]/);
    const asciiAtext = regexCheck$1(/[#-'*+\--9=?A-Z^-~]/);
    function asciiControl(code2) {
      return (
        // Special whitespace codes (which have negative values), C0 and Control
        // character DEL
        code2 !== null && (code2 < 32 || code2 === 127)
      );
    }
    function markdownLineEndingOrSpace$3(code2) {
      return code2 !== null && (code2 < 0 || code2 === 32);
    }
    function markdownLineEnding(code2) {
      return code2 !== null && code2 < -2;
    }
    function markdownSpace$2(code2) {
      return code2 === -2 || code2 === -1 || code2 === 32;
    }
    const unicodeWhitespace$2 = regexCheck$1(/\s/);
    const unicodePunctuation$2 = regexCheck$1(unicodePunctuationRegex$1);
    function regexCheck$1(regex2) {
      return check2;
      function check2(code2) {
        return code2 !== null && regex2.test(String.fromCharCode(code2));
      }
    }
    function factorySpace$1(effects, ok2, type, max2) {
      const limit = max2 ? max2 - 1 : Number.POSITIVE_INFINITY;
      let size = 0;
      return start;
      function start(code2) {
        if (markdownSpace$2(code2)) {
          effects.enter(type);
          return prefix2(code2);
        }
        return ok2(code2);
      }
      function prefix2(code2) {
        if (markdownSpace$2(code2) && size++ < limit) {
          effects.consume(code2);
          return prefix2;
        }
        effects.exit(type);
        return ok2(code2);
      }
    }
    const content$1 = {
      tokenize: initializeContent
    };
    function initializeContent(effects) {
      const contentStart = effects.attempt(
        this.parser.constructs.contentInitial,
        afterContentStartConstruct,
        paragraphInitial
      );
      let previous2;
      return contentStart;
      function afterContentStartConstruct(code2) {
        if (code2 === null) {
          effects.consume(code2);
          return;
        }
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return factorySpace$1(effects, contentStart, "linePrefix");
      }
      function paragraphInitial(code2) {
        effects.enter("paragraph");
        return lineStart(code2);
      }
      function lineStart(code2) {
        const token2 = effects.enter("chunkText", {
          contentType: "text",
          previous: previous2
        });
        if (previous2) {
          previous2.next = token2;
        }
        previous2 = token2;
        return data(code2);
      }
      function data(code2) {
        if (code2 === null) {
          effects.exit("chunkText");
          effects.exit("paragraph");
          effects.consume(code2);
          return;
        }
        if (markdownLineEnding(code2)) {
          effects.consume(code2);
          effects.exit("chunkText");
          return lineStart;
        }
        effects.consume(code2);
        return data;
      }
    }
    const document$2 = {
      tokenize: initializeDocument
    };
    const containerConstruct = {
      tokenize: tokenizeContainer
    };
    function initializeDocument(effects) {
      const self2 = this;
      const stack = [];
      let continued = 0;
      let childFlow;
      let childToken;
      let lineStartOffset;
      return start;
      function start(code2) {
        if (continued < stack.length) {
          const item = stack[continued];
          self2.containerState = item[1];
          return effects.attempt(
            item[0].continuation,
            documentContinue,
            checkNewContainers
          )(code2);
        }
        return checkNewContainers(code2);
      }
      function documentContinue(code2) {
        continued++;
        if (self2.containerState._closeFlow) {
          self2.containerState._closeFlow = void 0;
          if (childFlow) {
            closeFlow();
          }
          const indexBeforeExits = self2.events.length;
          let indexBeforeFlow = indexBeforeExits;
          let point2;
          while (indexBeforeFlow--) {
            if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
              point2 = self2.events[indexBeforeFlow][1].end;
              break;
            }
          }
          exitContainers(continued);
          let index2 = indexBeforeExits;
          while (index2 < self2.events.length) {
            self2.events[index2][1].end = Object.assign({}, point2);
            index2++;
          }
          splice(
            self2.events,
            indexBeforeFlow + 1,
            0,
            self2.events.slice(indexBeforeExits)
          );
          self2.events.length = index2;
          return checkNewContainers(code2);
        }
        return start(code2);
      }
      function checkNewContainers(code2) {
        if (continued === stack.length) {
          if (!childFlow) {
            return documentContinued(code2);
          }
          if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
            return flowStart(code2);
          }
          self2.interrupt = Boolean(
            childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack
          );
        }
        self2.containerState = {};
        return effects.check(
          containerConstruct,
          thereIsANewContainer,
          thereIsNoNewContainer
        )(code2);
      }
      function thereIsANewContainer(code2) {
        if (childFlow)
          closeFlow();
        exitContainers(continued);
        return documentContinued(code2);
      }
      function thereIsNoNewContainer(code2) {
        self2.parser.lazy[self2.now().line] = continued !== stack.length;
        lineStartOffset = self2.now().offset;
        return flowStart(code2);
      }
      function documentContinued(code2) {
        self2.containerState = {};
        return effects.attempt(
          containerConstruct,
          containerContinue,
          flowStart
        )(code2);
      }
      function containerContinue(code2) {
        continued++;
        stack.push([self2.currentConstruct, self2.containerState]);
        return documentContinued(code2);
      }
      function flowStart(code2) {
        if (code2 === null) {
          if (childFlow)
            closeFlow();
          exitContainers(0);
          effects.consume(code2);
          return;
        }
        childFlow = childFlow || self2.parser.flow(self2.now());
        effects.enter("chunkFlow", {
          contentType: "flow",
          previous: childToken,
          _tokenizer: childFlow
        });
        return flowContinue(code2);
      }
      function flowContinue(code2) {
        if (code2 === null) {
          writeToChild(effects.exit("chunkFlow"), true);
          exitContainers(0);
          effects.consume(code2);
          return;
        }
        if (markdownLineEnding(code2)) {
          effects.consume(code2);
          writeToChild(effects.exit("chunkFlow"));
          continued = 0;
          self2.interrupt = void 0;
          return start;
        }
        effects.consume(code2);
        return flowContinue;
      }
      function writeToChild(token2, eof) {
        const stream = self2.sliceStream(token2);
        if (eof)
          stream.push(null);
        token2.previous = childToken;
        if (childToken)
          childToken.next = token2;
        childToken = token2;
        childFlow.defineSkip(token2.start);
        childFlow.write(stream);
        if (self2.parser.lazy[token2.start.line]) {
          let index2 = childFlow.events.length;
          while (index2--) {
            if (
              // The token starts before the line ending…
              childFlow.events[index2][1].start.offset < lineStartOffset && // …and either is not ended yet…
              (!childFlow.events[index2][1].end || // …or ends after it.
              childFlow.events[index2][1].end.offset > lineStartOffset)
            ) {
              return;
            }
          }
          const indexBeforeExits = self2.events.length;
          let indexBeforeFlow = indexBeforeExits;
          let seen;
          let point2;
          while (indexBeforeFlow--) {
            if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
              if (seen) {
                point2 = self2.events[indexBeforeFlow][1].end;
                break;
              }
              seen = true;
            }
          }
          exitContainers(continued);
          index2 = indexBeforeExits;
          while (index2 < self2.events.length) {
            self2.events[index2][1].end = Object.assign({}, point2);
            index2++;
          }
          splice(
            self2.events,
            indexBeforeFlow + 1,
            0,
            self2.events.slice(indexBeforeExits)
          );
          self2.events.length = index2;
        }
      }
      function exitContainers(size) {
        let index2 = stack.length;
        while (index2-- > size) {
          const entry = stack[index2];
          self2.containerState = entry[1];
          entry[0].exit.call(self2, effects);
        }
        stack.length = size;
      }
      function closeFlow() {
        childFlow.write([null]);
        childToken = void 0;
        childFlow = void 0;
        self2.containerState._closeFlow = void 0;
      }
    }
    function tokenizeContainer(effects, ok2, nok) {
      return factorySpace$1(
        effects,
        effects.attempt(this.parser.constructs.document, ok2, nok),
        "linePrefix",
        this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      );
    }
    function classifyCharacter$2(code2) {
      if (code2 === null || markdownLineEndingOrSpace$3(code2) || unicodeWhitespace$2(code2)) {
        return 1;
      }
      if (unicodePunctuation$2(code2)) {
        return 2;
      }
    }
    function resolveAll$2(constructs2, events, context) {
      const called = [];
      let index2 = -1;
      while (++index2 < constructs2.length) {
        const resolve = constructs2[index2].resolveAll;
        if (resolve && !called.includes(resolve)) {
          events = resolve(events, context);
          called.push(resolve);
        }
      }
      return events;
    }
    const attention = {
      name: "attention",
      tokenize: tokenizeAttention,
      resolveAll: resolveAllAttention
    };
    function resolveAllAttention(events, context) {
      let index2 = -1;
      let open;
      let group;
      let text2;
      let openingSequence;
      let closingSequence;
      let use;
      let nextEvents;
      let offset2;
      while (++index2 < events.length) {
        if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
          open = index2;
          while (open--) {
            if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && // If the markers are the same:
            context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index2][1]).charCodeAt(0)) {
              if ((events[open][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {
                continue;
              }
              use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
              const start = Object.assign({}, events[open][1].end);
              const end = Object.assign({}, events[index2][1].start);
              movePoint(start, -use);
              movePoint(end, use);
              openingSequence = {
                type: use > 1 ? "strongSequence" : "emphasisSequence",
                start,
                end: Object.assign({}, events[open][1].end)
              };
              closingSequence = {
                type: use > 1 ? "strongSequence" : "emphasisSequence",
                start: Object.assign({}, events[index2][1].start),
                end
              };
              text2 = {
                type: use > 1 ? "strongText" : "emphasisText",
                start: Object.assign({}, events[open][1].end),
                end: Object.assign({}, events[index2][1].start)
              };
              group = {
                type: use > 1 ? "strong" : "emphasis",
                start: Object.assign({}, openingSequence.start),
                end: Object.assign({}, closingSequence.end)
              };
              events[open][1].end = Object.assign({}, openingSequence.start);
              events[index2][1].start = Object.assign({}, closingSequence.end);
              nextEvents = [];
              if (events[open][1].end.offset - events[open][1].start.offset) {
                nextEvents = push(nextEvents, [
                  ["enter", events[open][1], context],
                  ["exit", events[open][1], context]
                ]);
              }
              nextEvents = push(nextEvents, [
                ["enter", group, context],
                ["enter", openingSequence, context],
                ["exit", openingSequence, context],
                ["enter", text2, context]
              ]);
              nextEvents = push(
                nextEvents,
                resolveAll$2(
                  context.parser.constructs.insideSpan.null,
                  events.slice(open + 1, index2),
                  context
                )
              );
              nextEvents = push(nextEvents, [
                ["exit", text2, context],
                ["enter", closingSequence, context],
                ["exit", closingSequence, context],
                ["exit", group, context]
              ]);
              if (events[index2][1].end.offset - events[index2][1].start.offset) {
                offset2 = 2;
                nextEvents = push(nextEvents, [
                  ["enter", events[index2][1], context],
                  ["exit", events[index2][1], context]
                ]);
              } else {
                offset2 = 0;
              }
              splice(events, open - 1, index2 - open + 3, nextEvents);
              index2 = open + nextEvents.length - offset2 - 2;
              break;
            }
          }
        }
      }
      index2 = -1;
      while (++index2 < events.length) {
        if (events[index2][1].type === "attentionSequence") {
          events[index2][1].type = "data";
        }
      }
      return events;
    }
    function tokenizeAttention(effects, ok2) {
      const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
      const previous2 = this.previous;
      const before = classifyCharacter$2(previous2);
      let marker;
      return start;
      function start(code2) {
        effects.enter("attentionSequence");
        marker = code2;
        return sequence(code2);
      }
      function sequence(code2) {
        if (code2 === marker) {
          effects.consume(code2);
          return sequence;
        }
        const token2 = effects.exit("attentionSequence");
        const after = classifyCharacter$2(code2);
        const open = !after || after === 2 && before || attentionMarkers2.includes(code2);
        const close = !before || before === 2 && after || attentionMarkers2.includes(previous2);
        token2._open = Boolean(marker === 42 ? open : open && (before || !close));
        token2._close = Boolean(marker === 42 ? close : close && (after || !open));
        return ok2(code2);
      }
    }
    function movePoint(point2, offset2) {
      point2.column += offset2;
      point2.offset += offset2;
      point2._bufferIndex += offset2;
    }
    const autolink$1 = {
      name: "autolink",
      tokenize: tokenizeAutolink
    };
    function tokenizeAutolink(effects, ok2, nok) {
      let size = 1;
      return start;
      function start(code2) {
        effects.enter("autolink");
        effects.enter("autolinkMarker");
        effects.consume(code2);
        effects.exit("autolinkMarker");
        effects.enter("autolinkProtocol");
        return open;
      }
      function open(code2) {
        if (asciiAlpha$2(code2)) {
          effects.consume(code2);
          return schemeOrEmailAtext;
        }
        return asciiAtext(code2) ? emailAtext(code2) : nok(code2);
      }
      function schemeOrEmailAtext(code2) {
        return code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric$2(code2) ? schemeInsideOrEmailAtext(code2) : emailAtext(code2);
      }
      function schemeInsideOrEmailAtext(code2) {
        if (code2 === 58) {
          effects.consume(code2);
          return urlInside;
        }
        if ((code2 === 43 || code2 === 45 || code2 === 46 || asciiAlphanumeric$2(code2)) && size++ < 32) {
          effects.consume(code2);
          return schemeInsideOrEmailAtext;
        }
        return emailAtext(code2);
      }
      function urlInside(code2) {
        if (code2 === 62) {
          effects.exit("autolinkProtocol");
          return end(code2);
        }
        if (code2 === null || code2 === 32 || code2 === 60 || asciiControl(code2)) {
          return nok(code2);
        }
        effects.consume(code2);
        return urlInside;
      }
      function emailAtext(code2) {
        if (code2 === 64) {
          effects.consume(code2);
          size = 0;
          return emailAtSignOrDot;
        }
        if (asciiAtext(code2)) {
          effects.consume(code2);
          return emailAtext;
        }
        return nok(code2);
      }
      function emailAtSignOrDot(code2) {
        return asciiAlphanumeric$2(code2) ? emailLabel(code2) : nok(code2);
      }
      function emailLabel(code2) {
        if (code2 === 46) {
          effects.consume(code2);
          size = 0;
          return emailAtSignOrDot;
        }
        if (code2 === 62) {
          effects.exit("autolinkProtocol").type = "autolinkEmail";
          return end(code2);
        }
        return emailValue(code2);
      }
      function emailValue(code2) {
        if ((code2 === 45 || asciiAlphanumeric$2(code2)) && size++ < 63) {
          effects.consume(code2);
          return code2 === 45 ? emailValue : emailLabel;
        }
        return nok(code2);
      }
      function end(code2) {
        effects.enter("autolinkMarker");
        effects.consume(code2);
        effects.exit("autolinkMarker");
        effects.exit("autolink");
        return ok2;
      }
    }
    const blankLine = {
      tokenize: tokenizeBlankLine,
      partial: true
    };
    function tokenizeBlankLine(effects, ok2, nok) {
      return factorySpace$1(effects, afterWhitespace, "linePrefix");
      function afterWhitespace(code2) {
        return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
      }
    }
    const blockQuote = {
      name: "blockQuote",
      tokenize: tokenizeBlockQuoteStart,
      continuation: {
        tokenize: tokenizeBlockQuoteContinuation
      },
      exit: exit$1
    };
    function tokenizeBlockQuoteStart(effects, ok2, nok) {
      const self2 = this;
      return start;
      function start(code2) {
        if (code2 === 62) {
          const state = self2.containerState;
          if (!state.open) {
            effects.enter("blockQuote", {
              _container: true
            });
            state.open = true;
          }
          effects.enter("blockQuotePrefix");
          effects.enter("blockQuoteMarker");
          effects.consume(code2);
          effects.exit("blockQuoteMarker");
          return after;
        }
        return nok(code2);
      }
      function after(code2) {
        if (markdownSpace$2(code2)) {
          effects.enter("blockQuotePrefixWhitespace");
          effects.consume(code2);
          effects.exit("blockQuotePrefixWhitespace");
          effects.exit("blockQuotePrefix");
          return ok2;
        }
        effects.exit("blockQuotePrefix");
        return ok2(code2);
      }
    }
    function tokenizeBlockQuoteContinuation(effects, ok2, nok) {
      return factorySpace$1(
        effects,
        effects.attempt(blockQuote, ok2, nok),
        "linePrefix",
        this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      );
    }
    function exit$1(effects) {
      effects.exit("blockQuote");
    }
    const characterEscape = {
      name: "characterEscape",
      tokenize: tokenizeCharacterEscape
    };
    function tokenizeCharacterEscape(effects, ok2, nok) {
      return start;
      function start(code2) {
        effects.enter("characterEscape");
        effects.enter("escapeMarker");
        effects.consume(code2);
        effects.exit("escapeMarker");
        return open;
      }
      function open(code2) {
        if (asciiPunctuation(code2)) {
          effects.enter("characterEscapeValue");
          effects.consume(code2);
          effects.exit("characterEscapeValue");
          effects.exit("characterEscape");
          return ok2;
        }
        return nok(code2);
      }
    }
    const element$3 = document.createElement("i");
    function decodeNamedCharacterReference(value) {
      const characterReference2 = "&" + value + ";";
      element$3.innerHTML = characterReference2;
      const char2 = element$3.textContent;
      if (char2.charCodeAt(char2.length - 1) === 59 && value !== "semi") {
        return false;
      }
      return char2 === characterReference2 ? false : char2;
    }
    const characterReference = {
      name: "characterReference",
      tokenize: tokenizeCharacterReference
    };
    function tokenizeCharacterReference(effects, ok2, nok) {
      const self2 = this;
      let size = 0;
      let max2;
      let test;
      return start;
      function start(code2) {
        effects.enter("characterReference");
        effects.enter("characterReferenceMarker");
        effects.consume(code2);
        effects.exit("characterReferenceMarker");
        return open;
      }
      function open(code2) {
        if (code2 === 35) {
          effects.enter("characterReferenceMarkerNumeric");
          effects.consume(code2);
          effects.exit("characterReferenceMarkerNumeric");
          return numeric;
        }
        effects.enter("characterReferenceValue");
        max2 = 31;
        test = asciiAlphanumeric$2;
        return value(code2);
      }
      function numeric(code2) {
        if (code2 === 88 || code2 === 120) {
          effects.enter("characterReferenceMarkerHexadecimal");
          effects.consume(code2);
          effects.exit("characterReferenceMarkerHexadecimal");
          effects.enter("characterReferenceValue");
          max2 = 6;
          test = asciiHexDigit;
          return value;
        }
        effects.enter("characterReferenceValue");
        max2 = 7;
        test = asciiDigit;
        return value(code2);
      }
      function value(code2) {
        let token2;
        if (code2 === 59 && size) {
          token2 = effects.exit("characterReferenceValue");
          if (test === asciiAlphanumeric$2 && !decodeNamedCharacterReference(self2.sliceSerialize(token2))) {
            return nok(code2);
          }
          effects.enter("characterReferenceMarker");
          effects.consume(code2);
          effects.exit("characterReferenceMarker");
          effects.exit("characterReference");
          return ok2;
        }
        if (test(code2) && size++ < max2) {
          effects.consume(code2);
          return value;
        }
        return nok(code2);
      }
    }
    const codeFenced = {
      name: "codeFenced",
      tokenize: tokenizeCodeFenced,
      concrete: true
    };
    function tokenizeCodeFenced(effects, ok2, nok) {
      const self2 = this;
      const closingFenceConstruct = {
        tokenize: tokenizeClosingFence,
        partial: true
      };
      const nonLazyLine = {
        tokenize: tokenizeNonLazyLine,
        partial: true
      };
      const tail = this.events[this.events.length - 1];
      const initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
      let sizeOpen = 0;
      let marker;
      return start;
      function start(code2) {
        effects.enter("codeFenced");
        effects.enter("codeFencedFence");
        effects.enter("codeFencedFenceSequence");
        marker = code2;
        return sequenceOpen(code2);
      }
      function sequenceOpen(code2) {
        if (code2 === marker) {
          effects.consume(code2);
          sizeOpen++;
          return sequenceOpen;
        }
        effects.exit("codeFencedFenceSequence");
        return sizeOpen < 3 ? nok(code2) : factorySpace$1(effects, infoOpen, "whitespace")(code2);
      }
      function infoOpen(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          return openAfter(code2);
        }
        effects.enter("codeFencedFenceInfo");
        effects.enter("chunkString", {
          contentType: "string"
        });
        return info(code2);
      }
      function info(code2) {
        if (code2 === null || markdownLineEndingOrSpace$3(code2)) {
          effects.exit("chunkString");
          effects.exit("codeFencedFenceInfo");
          return factorySpace$1(effects, infoAfter, "whitespace")(code2);
        }
        if (code2 === 96 && code2 === marker)
          return nok(code2);
        effects.consume(code2);
        return info;
      }
      function infoAfter(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          return openAfter(code2);
        }
        effects.enter("codeFencedFenceMeta");
        effects.enter("chunkString", {
          contentType: "string"
        });
        return meta(code2);
      }
      function meta(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          effects.exit("chunkString");
          effects.exit("codeFencedFenceMeta");
          return openAfter(code2);
        }
        if (code2 === 96 && code2 === marker)
          return nok(code2);
        effects.consume(code2);
        return meta;
      }
      function openAfter(code2) {
        effects.exit("codeFencedFence");
        return self2.interrupt ? ok2(code2) : contentStart(code2);
      }
      function contentStart(code2) {
        if (code2 === null) {
          return after(code2);
        }
        if (markdownLineEnding(code2)) {
          return effects.attempt(
            nonLazyLine,
            effects.attempt(
              closingFenceConstruct,
              after,
              initialPrefix ? factorySpace$1(
                effects,
                contentStart,
                "linePrefix",
                initialPrefix + 1
              ) : contentStart
            ),
            after
          )(code2);
        }
        effects.enter("codeFlowValue");
        return contentContinue(code2);
      }
      function contentContinue(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          effects.exit("codeFlowValue");
          return contentStart(code2);
        }
        effects.consume(code2);
        return contentContinue;
      }
      function after(code2) {
        effects.exit("codeFenced");
        return ok2(code2);
      }
      function tokenizeNonLazyLine(effects2, ok3, nok2) {
        const self3 = this;
        return start2;
        function start2(code2) {
          effects2.enter("lineEnding");
          effects2.consume(code2);
          effects2.exit("lineEnding");
          return lineStart;
        }
        function lineStart(code2) {
          return self3.parser.lazy[self3.now().line] ? nok2(code2) : ok3(code2);
        }
      }
      function tokenizeClosingFence(effects2, ok3, nok2) {
        let size = 0;
        return factorySpace$1(
          effects2,
          closingSequenceStart,
          "linePrefix",
          this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
        );
        function closingSequenceStart(code2) {
          effects2.enter("codeFencedFence");
          effects2.enter("codeFencedFenceSequence");
          return closingSequence(code2);
        }
        function closingSequence(code2) {
          if (code2 === marker) {
            effects2.consume(code2);
            size++;
            return closingSequence;
          }
          if (size < sizeOpen)
            return nok2(code2);
          effects2.exit("codeFencedFenceSequence");
          return factorySpace$1(effects2, closingSequenceEnd, "whitespace")(code2);
        }
        function closingSequenceEnd(code2) {
          if (code2 === null || markdownLineEnding(code2)) {
            effects2.exit("codeFencedFence");
            return ok3(code2);
          }
          return nok2(code2);
        }
      }
    }
    const codeIndented = {
      name: "codeIndented",
      tokenize: tokenizeCodeIndented
    };
    const indentedContent = {
      tokenize: tokenizeIndentedContent,
      partial: true
    };
    function tokenizeCodeIndented(effects, ok2, nok) {
      const self2 = this;
      return start;
      function start(code2) {
        effects.enter("codeIndented");
        return factorySpace$1(effects, afterStartPrefix, "linePrefix", 4 + 1)(code2);
      }
      function afterStartPrefix(code2) {
        const tail = self2.events[self2.events.length - 1];
        return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? afterPrefix(code2) : nok(code2);
      }
      function afterPrefix(code2) {
        if (code2 === null) {
          return after(code2);
        }
        if (markdownLineEnding(code2)) {
          return effects.attempt(indentedContent, afterPrefix, after)(code2);
        }
        effects.enter("codeFlowValue");
        return content2(code2);
      }
      function content2(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          effects.exit("codeFlowValue");
          return afterPrefix(code2);
        }
        effects.consume(code2);
        return content2;
      }
      function after(code2) {
        effects.exit("codeIndented");
        return ok2(code2);
      }
    }
    function tokenizeIndentedContent(effects, ok2, nok) {
      const self2 = this;
      return start;
      function start(code2) {
        if (self2.parser.lazy[self2.now().line]) {
          return nok(code2);
        }
        if (markdownLineEnding(code2)) {
          effects.enter("lineEnding");
          effects.consume(code2);
          effects.exit("lineEnding");
          return start;
        }
        return factorySpace$1(effects, afterPrefix, "linePrefix", 4 + 1)(code2);
      }
      function afterPrefix(code2) {
        const tail = self2.events[self2.events.length - 1];
        return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok2(code2) : markdownLineEnding(code2) ? start(code2) : nok(code2);
      }
    }
    const codeText = {
      name: "codeText",
      tokenize: tokenizeCodeText,
      resolve: resolveCodeText,
      previous: previous$1
    };
    function resolveCodeText(events) {
      let tailExitIndex = events.length - 4;
      let headEnterIndex = 3;
      let index2;
      let enter;
      if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
        index2 = headEnterIndex;
        while (++index2 < tailExitIndex) {
          if (events[index2][1].type === "codeTextData") {
            events[headEnterIndex][1].type = "codeTextPadding";
            events[tailExitIndex][1].type = "codeTextPadding";
            headEnterIndex += 2;
            tailExitIndex -= 2;
            break;
          }
        }
      }
      index2 = headEnterIndex - 1;
      tailExitIndex++;
      while (++index2 <= tailExitIndex) {
        if (enter === void 0) {
          if (index2 !== tailExitIndex && events[index2][1].type !== "lineEnding") {
            enter = index2;
          }
        } else if (index2 === tailExitIndex || events[index2][1].type === "lineEnding") {
          events[enter][1].type = "codeTextData";
          if (index2 !== enter + 2) {
            events[enter][1].end = events[index2 - 1][1].end;
            events.splice(enter + 2, index2 - enter - 2);
            tailExitIndex -= index2 - enter - 2;
            index2 = enter + 2;
          }
          enter = void 0;
        }
      }
      return events;
    }
    function previous$1(code2) {
      return code2 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
    }
    function tokenizeCodeText(effects, ok2, nok) {
      let sizeOpen = 0;
      let size;
      let token2;
      return start;
      function start(code2) {
        effects.enter("codeText");
        effects.enter("codeTextSequence");
        return openingSequence(code2);
      }
      function openingSequence(code2) {
        if (code2 === 96) {
          effects.consume(code2);
          sizeOpen++;
          return openingSequence;
        }
        effects.exit("codeTextSequence");
        return gap2(code2);
      }
      function gap2(code2) {
        if (code2 === null) {
          return nok(code2);
        }
        if (code2 === 96) {
          token2 = effects.enter("codeTextSequence");
          size = 0;
          return closingSequence(code2);
        }
        if (code2 === 32) {
          effects.enter("space");
          effects.consume(code2);
          effects.exit("space");
          return gap2;
        }
        if (markdownLineEnding(code2)) {
          effects.enter("lineEnding");
          effects.consume(code2);
          effects.exit("lineEnding");
          return gap2;
        }
        effects.enter("codeTextData");
        return data(code2);
      }
      function data(code2) {
        if (code2 === null || code2 === 32 || code2 === 96 || markdownLineEnding(code2)) {
          effects.exit("codeTextData");
          return gap2(code2);
        }
        effects.consume(code2);
        return data;
      }
      function closingSequence(code2) {
        if (code2 === 96) {
          effects.consume(code2);
          size++;
          return closingSequence;
        }
        if (size === sizeOpen) {
          effects.exit("codeTextSequence");
          effects.exit("codeText");
          return ok2(code2);
        }
        token2.type = "codeTextData";
        return data(code2);
      }
    }
    function subtokenize(events) {
      const jumps = {};
      let index2 = -1;
      let event;
      let lineIndex;
      let otherIndex;
      let otherEvent;
      let parameters;
      let subevents;
      let more;
      while (++index2 < events.length) {
        while (index2 in jumps) {
          index2 = jumps[index2];
        }
        event = events[index2];
        if (index2 && event[1].type === "chunkFlow" && events[index2 - 1][1].type === "listItemPrefix") {
          subevents = event[1]._tokenizer.events;
          otherIndex = 0;
          if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
            otherIndex += 2;
          }
          if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
            while (++otherIndex < subevents.length) {
              if (subevents[otherIndex][1].type === "content") {
                break;
              }
              if (subevents[otherIndex][1].type === "chunkText") {
                subevents[otherIndex][1]._isInFirstContentOfListItem = true;
                otherIndex++;
              }
            }
          }
        }
        if (event[0] === "enter") {
          if (event[1].contentType) {
            Object.assign(jumps, subcontent(events, index2));
            index2 = jumps[index2];
            more = true;
          }
        } else if (event[1]._container) {
          otherIndex = index2;
          lineIndex = void 0;
          while (otherIndex--) {
            otherEvent = events[otherIndex];
            if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
              if (otherEvent[0] === "enter") {
                if (lineIndex) {
                  events[lineIndex][1].type = "lineEndingBlank";
                }
                otherEvent[1].type = "lineEnding";
                lineIndex = otherIndex;
              }
            } else {
              break;
            }
          }
          if (lineIndex) {
            event[1].end = Object.assign({}, events[lineIndex][1].start);
            parameters = events.slice(lineIndex, index2);
            parameters.unshift(event);
            splice(events, lineIndex, index2 - lineIndex + 1, parameters);
          }
        }
      }
      return !more;
    }
    function subcontent(events, eventIndex) {
      const token2 = events[eventIndex][1];
      const context = events[eventIndex][2];
      let startPosition = eventIndex - 1;
      const startPositions = [];
      const tokenizer2 = token2._tokenizer || context.parser[token2.contentType](token2.start);
      const childEvents = tokenizer2.events;
      const jumps = [];
      const gaps = {};
      let stream;
      let previous2;
      let index2 = -1;
      let current = token2;
      let adjust = 0;
      let start = 0;
      const breaks = [start];
      while (current) {
        while (events[++startPosition][1] !== current) {
        }
        startPositions.push(startPosition);
        if (!current._tokenizer) {
          stream = context.sliceStream(current);
          if (!current.next) {
            stream.push(null);
          }
          if (previous2) {
            tokenizer2.defineSkip(current.start);
          }
          if (current._isInFirstContentOfListItem) {
            tokenizer2._gfmTasklistFirstContentOfListItem = true;
          }
          tokenizer2.write(stream);
          if (current._isInFirstContentOfListItem) {
            tokenizer2._gfmTasklistFirstContentOfListItem = void 0;
          }
        }
        previous2 = current;
        current = current.next;
      }
      current = token2;
      while (++index2 < childEvents.length) {
        if (
          // Find a void token that includes a break.
          childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line
        ) {
          start = index2 + 1;
          breaks.push(start);
          current._tokenizer = void 0;
          current.previous = void 0;
          current = current.next;
        }
      }
      tokenizer2.events = [];
      if (current) {
        current._tokenizer = void 0;
        current.previous = void 0;
      } else {
        breaks.pop();
      }
      index2 = breaks.length;
      while (index2--) {
        const slice2 = childEvents.slice(breaks[index2], breaks[index2 + 1]);
        const start2 = startPositions.pop();
        jumps.unshift([start2, start2 + slice2.length - 1]);
        splice(events, start2, 2, slice2);
      }
      index2 = -1;
      while (++index2 < jumps.length) {
        gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
        adjust += jumps[index2][1] - jumps[index2][0] - 1;
      }
      return gaps;
    }
    const content = {
      tokenize: tokenizeContent,
      resolve: resolveContent
    };
    const continuationConstruct = {
      tokenize: tokenizeContinuation,
      partial: true
    };
    function resolveContent(events) {
      subtokenize(events);
      return events;
    }
    function tokenizeContent(effects, ok2) {
      let previous2;
      return start;
      function start(code2) {
        effects.enter("content");
        previous2 = effects.enter("chunkContent", {
          contentType: "content"
        });
        return data(code2);
      }
      function data(code2) {
        if (code2 === null) {
          return contentEnd(code2);
        }
        if (markdownLineEnding(code2)) {
          return effects.check(
            continuationConstruct,
            contentContinue,
            contentEnd
          )(code2);
        }
        effects.consume(code2);
        return data;
      }
      function contentEnd(code2) {
        effects.exit("chunkContent");
        effects.exit("content");
        return ok2(code2);
      }
      function contentContinue(code2) {
        effects.consume(code2);
        effects.exit("chunkContent");
        previous2.next = effects.enter("chunkContent", {
          contentType: "content",
          previous: previous2
        });
        previous2 = previous2.next;
        return data;
      }
    }
    function tokenizeContinuation(effects, ok2, nok) {
      const self2 = this;
      return startLookahead;
      function startLookahead(code2) {
        effects.exit("chunkContent");
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return factorySpace$1(effects, prefixed, "linePrefix");
      }
      function prefixed(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          return nok(code2);
        }
        const tail = self2.events[self2.events.length - 1];
        if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
          return ok2(code2);
        }
        return effects.interrupt(self2.parser.constructs.flow, nok, ok2)(code2);
      }
    }
    function factoryDestination(effects, ok2, nok, type, literalType, literalMarkerType, rawType, stringType, max2) {
      const limit = max2 || Number.POSITIVE_INFINITY;
      let balance = 0;
      return start;
      function start(code2) {
        if (code2 === 60) {
          effects.enter(type);
          effects.enter(literalType);
          effects.enter(literalMarkerType);
          effects.consume(code2);
          effects.exit(literalMarkerType);
          return destinationEnclosedBefore;
        }
        if (code2 === null || code2 === 41 || asciiControl(code2)) {
          return nok(code2);
        }
        effects.enter(type);
        effects.enter(rawType);
        effects.enter(stringType);
        effects.enter("chunkString", {
          contentType: "string"
        });
        return destinationRaw(code2);
      }
      function destinationEnclosedBefore(code2) {
        if (code2 === 62) {
          effects.enter(literalMarkerType);
          effects.consume(code2);
          effects.exit(literalMarkerType);
          effects.exit(literalType);
          effects.exit(type);
          return ok2;
        }
        effects.enter(stringType);
        effects.enter("chunkString", {
          contentType: "string"
        });
        return destinationEnclosed(code2);
      }
      function destinationEnclosed(code2) {
        if (code2 === 62) {
          effects.exit("chunkString");
          effects.exit(stringType);
          return destinationEnclosedBefore(code2);
        }
        if (code2 === null || code2 === 60 || markdownLineEnding(code2)) {
          return nok(code2);
        }
        effects.consume(code2);
        return code2 === 92 ? destinationEnclosedEscape : destinationEnclosed;
      }
      function destinationEnclosedEscape(code2) {
        if (code2 === 60 || code2 === 62 || code2 === 92) {
          effects.consume(code2);
          return destinationEnclosed;
        }
        return destinationEnclosed(code2);
      }
      function destinationRaw(code2) {
        if (code2 === 40) {
          if (++balance > limit)
            return nok(code2);
          effects.consume(code2);
          return destinationRaw;
        }
        if (code2 === 41) {
          if (!balance--) {
            effects.exit("chunkString");
            effects.exit(stringType);
            effects.exit(rawType);
            effects.exit(type);
            return ok2(code2);
          }
          effects.consume(code2);
          return destinationRaw;
        }
        if (code2 === null || markdownLineEndingOrSpace$3(code2)) {
          if (balance)
            return nok(code2);
          effects.exit("chunkString");
          effects.exit(stringType);
          effects.exit(rawType);
          effects.exit(type);
          return ok2(code2);
        }
        if (asciiControl(code2))
          return nok(code2);
        effects.consume(code2);
        return code2 === 92 ? destinationRawEscape : destinationRaw;
      }
      function destinationRawEscape(code2) {
        if (code2 === 40 || code2 === 41 || code2 === 92) {
          effects.consume(code2);
          return destinationRaw;
        }
        return destinationRaw(code2);
      }
    }
    function factoryLabel(effects, ok2, nok, type, markerType, stringType) {
      const self2 = this;
      let size = 0;
      let data;
      return start;
      function start(code2) {
        effects.enter(type);
        effects.enter(markerType);
        effects.consume(code2);
        effects.exit(markerType);
        effects.enter(stringType);
        return atBreak;
      }
      function atBreak(code2) {
        if (code2 === null || code2 === 91 || code2 === 93 && !data || /* To do: remove in the future once we’ve switched from
         * `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
         * which doesn’t need this */
        /* Hidden footnotes hook */
        /* c8 ignore next 3 */
        code2 === 94 && !size && "_hiddenFootnoteSupport" in self2.parser.constructs || size > 999) {
          return nok(code2);
        }
        if (code2 === 93) {
          effects.exit(stringType);
          effects.enter(markerType);
          effects.consume(code2);
          effects.exit(markerType);
          effects.exit(type);
          return ok2;
        }
        if (markdownLineEnding(code2)) {
          effects.enter("lineEnding");
          effects.consume(code2);
          effects.exit("lineEnding");
          return atBreak;
        }
        effects.enter("chunkString", {
          contentType: "string"
        });
        return label(code2);
      }
      function label(code2) {
        if (code2 === null || code2 === 91 || code2 === 93 || markdownLineEnding(code2) || size++ > 999) {
          effects.exit("chunkString");
          return atBreak(code2);
        }
        effects.consume(code2);
        data = data || !markdownSpace$2(code2);
        return code2 === 92 ? labelEscape : label;
      }
      function labelEscape(code2) {
        if (code2 === 91 || code2 === 92 || code2 === 93) {
          effects.consume(code2);
          size++;
          return label;
        }
        return label(code2);
      }
    }
    function factoryTitle(effects, ok2, nok, type, markerType, stringType) {
      let marker;
      return start;
      function start(code2) {
        effects.enter(type);
        effects.enter(markerType);
        effects.consume(code2);
        effects.exit(markerType);
        marker = code2 === 40 ? 41 : code2;
        return atFirstTitleBreak;
      }
      function atFirstTitleBreak(code2) {
        if (code2 === marker) {
          effects.enter(markerType);
          effects.consume(code2);
          effects.exit(markerType);
          effects.exit(type);
          return ok2;
        }
        effects.enter(stringType);
        return atTitleBreak(code2);
      }
      function atTitleBreak(code2) {
        if (code2 === marker) {
          effects.exit(stringType);
          return atFirstTitleBreak(marker);
        }
        if (code2 === null) {
          return nok(code2);
        }
        if (markdownLineEnding(code2)) {
          effects.enter("lineEnding");
          effects.consume(code2);
          effects.exit("lineEnding");
          return factorySpace$1(effects, atTitleBreak, "linePrefix");
        }
        effects.enter("chunkString", {
          contentType: "string"
        });
        return title(code2);
      }
      function title(code2) {
        if (code2 === marker || code2 === null || markdownLineEnding(code2)) {
          effects.exit("chunkString");
          return atTitleBreak(code2);
        }
        effects.consume(code2);
        return code2 === 92 ? titleEscape : title;
      }
      function titleEscape(code2) {
        if (code2 === marker || code2 === 92) {
          effects.consume(code2);
          return title;
        }
        return title(code2);
      }
    }
    function factoryWhitespace(effects, ok2) {
      let seen;
      return start;
      function start(code2) {
        if (markdownLineEnding(code2)) {
          effects.enter("lineEnding");
          effects.consume(code2);
          effects.exit("lineEnding");
          seen = true;
          return start;
        }
        if (markdownSpace$2(code2)) {
          return factorySpace$1(
            effects,
            start,
            seen ? "linePrefix" : "lineSuffix"
          )(code2);
        }
        return ok2(code2);
      }
    }
    function normalizeIdentifier(value) {
      return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
    }
    const definition = {
      name: "definition",
      tokenize: tokenizeDefinition
    };
    const titleConstruct = {
      tokenize: tokenizeTitle,
      partial: true
    };
    function tokenizeDefinition(effects, ok2, nok) {
      const self2 = this;
      let identifier2;
      return start;
      function start(code2) {
        effects.enter("definition");
        return factoryLabel.call(
          self2,
          effects,
          labelAfter,
          nok,
          "definitionLabel",
          "definitionLabelMarker",
          "definitionLabelString"
        )(code2);
      }
      function labelAfter(code2) {
        identifier2 = normalizeIdentifier(
          self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
        );
        if (code2 === 58) {
          effects.enter("definitionMarker");
          effects.consume(code2);
          effects.exit("definitionMarker");
          return factoryWhitespace(
            effects,
            factoryDestination(
              effects,
              effects.attempt(
                titleConstruct,
                factorySpace$1(effects, after, "whitespace"),
                factorySpace$1(effects, after, "whitespace")
              ),
              nok,
              "definitionDestination",
              "definitionDestinationLiteral",
              "definitionDestinationLiteralMarker",
              "definitionDestinationRaw",
              "definitionDestinationString"
            )
          );
        }
        return nok(code2);
      }
      function after(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          effects.exit("definition");
          if (!self2.parser.defined.includes(identifier2)) {
            self2.parser.defined.push(identifier2);
          }
          return ok2(code2);
        }
        return nok(code2);
      }
    }
    function tokenizeTitle(effects, ok2, nok) {
      return start;
      function start(code2) {
        return markdownLineEndingOrSpace$3(code2) ? factoryWhitespace(effects, before)(code2) : nok(code2);
      }
      function before(code2) {
        if (code2 === 34 || code2 === 39 || code2 === 40) {
          return factoryTitle(
            effects,
            factorySpace$1(effects, after, "whitespace"),
            nok,
            "definitionTitle",
            "definitionTitleMarker",
            "definitionTitleString"
          )(code2);
        }
        return nok(code2);
      }
      function after(code2) {
        return code2 === null || markdownLineEnding(code2) ? ok2(code2) : nok(code2);
      }
    }
    const hardBreakEscape = {
      name: "hardBreakEscape",
      tokenize: tokenizeHardBreakEscape
    };
    function tokenizeHardBreakEscape(effects, ok2, nok) {
      return start;
      function start(code2) {
        effects.enter("hardBreakEscape");
        effects.enter("escapeMarker");
        effects.consume(code2);
        return open;
      }
      function open(code2) {
        if (markdownLineEnding(code2)) {
          effects.exit("escapeMarker");
          effects.exit("hardBreakEscape");
          return ok2(code2);
        }
        return nok(code2);
      }
    }
    const headingAtx = {
      name: "headingAtx",
      tokenize: tokenizeHeadingAtx,
      resolve: resolveHeadingAtx
    };
    function resolveHeadingAtx(events, context) {
      let contentEnd = events.length - 2;
      let contentStart = 3;
      let content2;
      let text2;
      if (events[contentStart][1].type === "whitespace") {
        contentStart += 2;
      }
      if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
        contentEnd -= 2;
      }
      if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
        contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
      }
      if (contentEnd > contentStart) {
        content2 = {
          type: "atxHeadingText",
          start: events[contentStart][1].start,
          end: events[contentEnd][1].end
        };
        text2 = {
          type: "chunkText",
          start: events[contentStart][1].start,
          end: events[contentEnd][1].end,
          // @ts-expect-error Constants are fine to assign.
          contentType: "text"
        };
        splice(events, contentStart, contentEnd - contentStart + 1, [
          ["enter", content2, context],
          ["enter", text2, context],
          ["exit", text2, context],
          ["exit", content2, context]
        ]);
      }
      return events;
    }
    function tokenizeHeadingAtx(effects, ok2, nok) {
      const self2 = this;
      let size = 0;
      return start;
      function start(code2) {
        effects.enter("atxHeading");
        effects.enter("atxHeadingSequence");
        return fenceOpenInside(code2);
      }
      function fenceOpenInside(code2) {
        if (code2 === 35 && size++ < 6) {
          effects.consume(code2);
          return fenceOpenInside;
        }
        if (code2 === null || markdownLineEndingOrSpace$3(code2)) {
          effects.exit("atxHeadingSequence");
          return self2.interrupt ? ok2(code2) : headingBreak(code2);
        }
        return nok(code2);
      }
      function headingBreak(code2) {
        if (code2 === 35) {
          effects.enter("atxHeadingSequence");
          return sequence(code2);
        }
        if (code2 === null || markdownLineEnding(code2)) {
          effects.exit("atxHeading");
          return ok2(code2);
        }
        if (markdownSpace$2(code2)) {
          return factorySpace$1(effects, headingBreak, "whitespace")(code2);
        }
        effects.enter("atxHeadingText");
        return data(code2);
      }
      function sequence(code2) {
        if (code2 === 35) {
          effects.consume(code2);
          return sequence;
        }
        effects.exit("atxHeadingSequence");
        return headingBreak(code2);
      }
      function data(code2) {
        if (code2 === null || code2 === 35 || markdownLineEndingOrSpace$3(code2)) {
          effects.exit("atxHeadingText");
          return headingBreak(code2);
        }
        effects.consume(code2);
        return data;
      }
    }
    const htmlBlockNames = [
      "address",
      "article",
      "aside",
      "base",
      "basefont",
      "blockquote",
      "body",
      "caption",
      "center",
      "col",
      "colgroup",
      "dd",
      "details",
      "dialog",
      "dir",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "frame",
      "frameset",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hr",
      "html",
      "iframe",
      "legend",
      "li",
      "link",
      "main",
      "menu",
      "menuitem",
      "nav",
      "noframes",
      "ol",
      "optgroup",
      "option",
      "p",
      "param",
      "section",
      "source",
      "summary",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "title",
      "tr",
      "track",
      "ul"
    ];
    const htmlRawNames = ["pre", "script", "style", "textarea"];
    const htmlFlow = {
      name: "htmlFlow",
      tokenize: tokenizeHtmlFlow,
      resolveTo: resolveToHtmlFlow,
      concrete: true
    };
    const nextBlankConstruct = {
      tokenize: tokenizeNextBlank,
      partial: true
    };
    function resolveToHtmlFlow(events) {
      let index2 = events.length;
      while (index2--) {
        if (events[index2][0] === "enter" && events[index2][1].type === "htmlFlow") {
          break;
        }
      }
      if (index2 > 1 && events[index2 - 2][1].type === "linePrefix") {
        events[index2][1].start = events[index2 - 2][1].start;
        events[index2 + 1][1].start = events[index2 - 2][1].start;
        events.splice(index2 - 2, 2);
      }
      return events;
    }
    function tokenizeHtmlFlow(effects, ok2, nok) {
      const self2 = this;
      let kind;
      let startTag2;
      let buffer;
      let index2;
      let marker;
      return start;
      function start(code2) {
        effects.enter("htmlFlow");
        effects.enter("htmlFlowData");
        effects.consume(code2);
        return open;
      }
      function open(code2) {
        if (code2 === 33) {
          effects.consume(code2);
          return declarationStart;
        }
        if (code2 === 47) {
          effects.consume(code2);
          return tagCloseStart;
        }
        if (code2 === 63) {
          effects.consume(code2);
          kind = 3;
          return self2.interrupt ? ok2 : continuationDeclarationInside;
        }
        if (asciiAlpha$2(code2)) {
          effects.consume(code2);
          buffer = String.fromCharCode(code2);
          startTag2 = true;
          return tagName;
        }
        return nok(code2);
      }
      function declarationStart(code2) {
        if (code2 === 45) {
          effects.consume(code2);
          kind = 2;
          return commentOpenInside;
        }
        if (code2 === 91) {
          effects.consume(code2);
          kind = 5;
          buffer = "CDATA[";
          index2 = 0;
          return cdataOpenInside;
        }
        if (asciiAlpha$2(code2)) {
          effects.consume(code2);
          kind = 4;
          return self2.interrupt ? ok2 : continuationDeclarationInside;
        }
        return nok(code2);
      }
      function commentOpenInside(code2) {
        if (code2 === 45) {
          effects.consume(code2);
          return self2.interrupt ? ok2 : continuationDeclarationInside;
        }
        return nok(code2);
      }
      function cdataOpenInside(code2) {
        if (code2 === buffer.charCodeAt(index2++)) {
          effects.consume(code2);
          return index2 === buffer.length ? self2.interrupt ? ok2 : continuation : cdataOpenInside;
        }
        return nok(code2);
      }
      function tagCloseStart(code2) {
        if (asciiAlpha$2(code2)) {
          effects.consume(code2);
          buffer = String.fromCharCode(code2);
          return tagName;
        }
        return nok(code2);
      }
      function tagName(code2) {
        if (code2 === null || code2 === 47 || code2 === 62 || markdownLineEndingOrSpace$3(code2)) {
          if (code2 !== 47 && startTag2 && htmlRawNames.includes(buffer.toLowerCase())) {
            kind = 1;
            return self2.interrupt ? ok2(code2) : continuation(code2);
          }
          if (htmlBlockNames.includes(buffer.toLowerCase())) {
            kind = 6;
            if (code2 === 47) {
              effects.consume(code2);
              return basicSelfClosing;
            }
            return self2.interrupt ? ok2(code2) : continuation(code2);
          }
          kind = 7;
          return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code2) : startTag2 ? completeAttributeNameBefore(code2) : completeClosingTagAfter(code2);
        }
        if (code2 === 45 || asciiAlphanumeric$2(code2)) {
          effects.consume(code2);
          buffer += String.fromCharCode(code2);
          return tagName;
        }
        return nok(code2);
      }
      function basicSelfClosing(code2) {
        if (code2 === 62) {
          effects.consume(code2);
          return self2.interrupt ? ok2 : continuation;
        }
        return nok(code2);
      }
      function completeClosingTagAfter(code2) {
        if (markdownSpace$2(code2)) {
          effects.consume(code2);
          return completeClosingTagAfter;
        }
        return completeEnd(code2);
      }
      function completeAttributeNameBefore(code2) {
        if (code2 === 47) {
          effects.consume(code2);
          return completeEnd;
        }
        if (code2 === 58 || code2 === 95 || asciiAlpha$2(code2)) {
          effects.consume(code2);
          return completeAttributeName;
        }
        if (markdownSpace$2(code2)) {
          effects.consume(code2);
          return completeAttributeNameBefore;
        }
        return completeEnd(code2);
      }
      function completeAttributeName(code2) {
        if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric$2(code2)) {
          effects.consume(code2);
          return completeAttributeName;
        }
        return completeAttributeNameAfter(code2);
      }
      function completeAttributeNameAfter(code2) {
        if (code2 === 61) {
          effects.consume(code2);
          return completeAttributeValueBefore;
        }
        if (markdownSpace$2(code2)) {
          effects.consume(code2);
          return completeAttributeNameAfter;
        }
        return completeAttributeNameBefore(code2);
      }
      function completeAttributeValueBefore(code2) {
        if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
          return nok(code2);
        }
        if (code2 === 34 || code2 === 39) {
          effects.consume(code2);
          marker = code2;
          return completeAttributeValueQuoted;
        }
        if (markdownSpace$2(code2)) {
          effects.consume(code2);
          return completeAttributeValueBefore;
        }
        marker = null;
        return completeAttributeValueUnquoted(code2);
      }
      function completeAttributeValueQuoted(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          return nok(code2);
        }
        if (code2 === marker) {
          effects.consume(code2);
          return completeAttributeValueQuotedAfter;
        }
        effects.consume(code2);
        return completeAttributeValueQuoted;
      }
      function completeAttributeValueUnquoted(code2) {
        if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96 || markdownLineEndingOrSpace$3(code2)) {
          return completeAttributeNameAfter(code2);
        }
        effects.consume(code2);
        return completeAttributeValueUnquoted;
      }
      function completeAttributeValueQuotedAfter(code2) {
        if (code2 === 47 || code2 === 62 || markdownSpace$2(code2)) {
          return completeAttributeNameBefore(code2);
        }
        return nok(code2);
      }
      function completeEnd(code2) {
        if (code2 === 62) {
          effects.consume(code2);
          return completeAfter;
        }
        return nok(code2);
      }
      function completeAfter(code2) {
        if (markdownSpace$2(code2)) {
          effects.consume(code2);
          return completeAfter;
        }
        return code2 === null || markdownLineEnding(code2) ? continuation(code2) : nok(code2);
      }
      function continuation(code2) {
        if (code2 === 45 && kind === 2) {
          effects.consume(code2);
          return continuationCommentInside;
        }
        if (code2 === 60 && kind === 1) {
          effects.consume(code2);
          return continuationRawTagOpen;
        }
        if (code2 === 62 && kind === 4) {
          effects.consume(code2);
          return continuationClose;
        }
        if (code2 === 63 && kind === 3) {
          effects.consume(code2);
          return continuationDeclarationInside;
        }
        if (code2 === 93 && kind === 5) {
          effects.consume(code2);
          return continuationCharacterDataInside;
        }
        if (markdownLineEnding(code2) && (kind === 6 || kind === 7)) {
          return effects.check(
            nextBlankConstruct,
            continuationClose,
            continuationAtLineEnding
          )(code2);
        }
        if (code2 === null || markdownLineEnding(code2)) {
          return continuationAtLineEnding(code2);
        }
        effects.consume(code2);
        return continuation;
      }
      function continuationAtLineEnding(code2) {
        effects.exit("htmlFlowData");
        return htmlContinueStart(code2);
      }
      function htmlContinueStart(code2) {
        if (code2 === null) {
          return done(code2);
        }
        if (markdownLineEnding(code2)) {
          return effects.attempt(
            {
              tokenize: htmlLineEnd,
              partial: true
            },
            htmlContinueStart,
            done
          )(code2);
        }
        effects.enter("htmlFlowData");
        return continuation(code2);
      }
      function htmlLineEnd(effects2, ok3, nok2) {
        return start2;
        function start2(code2) {
          effects2.enter("lineEnding");
          effects2.consume(code2);
          effects2.exit("lineEnding");
          return lineStart;
        }
        function lineStart(code2) {
          return self2.parser.lazy[self2.now().line] ? nok2(code2) : ok3(code2);
        }
      }
      function continuationCommentInside(code2) {
        if (code2 === 45) {
          effects.consume(code2);
          return continuationDeclarationInside;
        }
        return continuation(code2);
      }
      function continuationRawTagOpen(code2) {
        if (code2 === 47) {
          effects.consume(code2);
          buffer = "";
          return continuationRawEndTag;
        }
        return continuation(code2);
      }
      function continuationRawEndTag(code2) {
        if (code2 === 62 && htmlRawNames.includes(buffer.toLowerCase())) {
          effects.consume(code2);
          return continuationClose;
        }
        if (asciiAlpha$2(code2) && buffer.length < 8) {
          effects.consume(code2);
          buffer += String.fromCharCode(code2);
          return continuationRawEndTag;
        }
        return continuation(code2);
      }
      function continuationCharacterDataInside(code2) {
        if (code2 === 93) {
          effects.consume(code2);
          return continuationDeclarationInside;
        }
        return continuation(code2);
      }
      function continuationDeclarationInside(code2) {
        if (code2 === 62) {
          effects.consume(code2);
          return continuationClose;
        }
        if (code2 === 45 && kind === 2) {
          effects.consume(code2);
          return continuationDeclarationInside;
        }
        return continuation(code2);
      }
      function continuationClose(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          effects.exit("htmlFlowData");
          return done(code2);
        }
        effects.consume(code2);
        return continuationClose;
      }
      function done(code2) {
        effects.exit("htmlFlow");
        return ok2(code2);
      }
    }
    function tokenizeNextBlank(effects, ok2, nok) {
      return start;
      function start(code2) {
        effects.exit("htmlFlowData");
        effects.enter("lineEndingBlank");
        effects.consume(code2);
        effects.exit("lineEndingBlank");
        return effects.attempt(blankLine, ok2, nok);
      }
    }
    const htmlText = {
      name: "htmlText",
      tokenize: tokenizeHtmlText
    };
    function tokenizeHtmlText(effects, ok2, nok) {
      const self2 = this;
      let marker;
      let buffer;
      let index2;
      let returnState;
      return start;
      function start(code2) {
        effects.enter("htmlText");
        effects.enter("htmlTextData");
        effects.consume(code2);
        return open;
      }
      function open(code2) {
        if (code2 === 33) {
          effects.consume(code2);
          return declarationOpen;
        }
        if (code2 === 47) {
          effects.consume(code2);
          return tagCloseStart;
        }
        if (code2 === 63) {
          effects.consume(code2);
          return instruction;
        }
        if (asciiAlpha$2(code2)) {
          effects.consume(code2);
          return tagOpen;
        }
        return nok(code2);
      }
      function declarationOpen(code2) {
        if (code2 === 45) {
          effects.consume(code2);
          return commentOpen;
        }
        if (code2 === 91) {
          effects.consume(code2);
          buffer = "CDATA[";
          index2 = 0;
          return cdataOpen;
        }
        if (asciiAlpha$2(code2)) {
          effects.consume(code2);
          return declaration2;
        }
        return nok(code2);
      }
      function commentOpen(code2) {
        if (code2 === 45) {
          effects.consume(code2);
          return commentStart;
        }
        return nok(code2);
      }
      function commentStart(code2) {
        if (code2 === null || code2 === 62) {
          return nok(code2);
        }
        if (code2 === 45) {
          effects.consume(code2);
          return commentStartDash;
        }
        return comment2(code2);
      }
      function commentStartDash(code2) {
        if (code2 === null || code2 === 62) {
          return nok(code2);
        }
        return comment2(code2);
      }
      function comment2(code2) {
        if (code2 === null) {
          return nok(code2);
        }
        if (code2 === 45) {
          effects.consume(code2);
          return commentClose;
        }
        if (markdownLineEnding(code2)) {
          returnState = comment2;
          return atLineEnding(code2);
        }
        effects.consume(code2);
        return comment2;
      }
      function commentClose(code2) {
        if (code2 === 45) {
          effects.consume(code2);
          return end;
        }
        return comment2(code2);
      }
      function cdataOpen(code2) {
        if (code2 === buffer.charCodeAt(index2++)) {
          effects.consume(code2);
          return index2 === buffer.length ? cdata : cdataOpen;
        }
        return nok(code2);
      }
      function cdata(code2) {
        if (code2 === null) {
          return nok(code2);
        }
        if (code2 === 93) {
          effects.consume(code2);
          return cdataClose;
        }
        if (markdownLineEnding(code2)) {
          returnState = cdata;
          return atLineEnding(code2);
        }
        effects.consume(code2);
        return cdata;
      }
      function cdataClose(code2) {
        if (code2 === 93) {
          effects.consume(code2);
          return cdataEnd;
        }
        return cdata(code2);
      }
      function cdataEnd(code2) {
        if (code2 === 62) {
          return end(code2);
        }
        if (code2 === 93) {
          effects.consume(code2);
          return cdataEnd;
        }
        return cdata(code2);
      }
      function declaration2(code2) {
        if (code2 === null || code2 === 62) {
          return end(code2);
        }
        if (markdownLineEnding(code2)) {
          returnState = declaration2;
          return atLineEnding(code2);
        }
        effects.consume(code2);
        return declaration2;
      }
      function instruction(code2) {
        if (code2 === null) {
          return nok(code2);
        }
        if (code2 === 63) {
          effects.consume(code2);
          return instructionClose;
        }
        if (markdownLineEnding(code2)) {
          returnState = instruction;
          return atLineEnding(code2);
        }
        effects.consume(code2);
        return instruction;
      }
      function instructionClose(code2) {
        return code2 === 62 ? end(code2) : instruction(code2);
      }
      function tagCloseStart(code2) {
        if (asciiAlpha$2(code2)) {
          effects.consume(code2);
          return tagClose;
        }
        return nok(code2);
      }
      function tagClose(code2) {
        if (code2 === 45 || asciiAlphanumeric$2(code2)) {
          effects.consume(code2);
          return tagClose;
        }
        return tagCloseBetween(code2);
      }
      function tagCloseBetween(code2) {
        if (markdownLineEnding(code2)) {
          returnState = tagCloseBetween;
          return atLineEnding(code2);
        }
        if (markdownSpace$2(code2)) {
          effects.consume(code2);
          return tagCloseBetween;
        }
        return end(code2);
      }
      function tagOpen(code2) {
        if (code2 === 45 || asciiAlphanumeric$2(code2)) {
          effects.consume(code2);
          return tagOpen;
        }
        if (code2 === 47 || code2 === 62 || markdownLineEndingOrSpace$3(code2)) {
          return tagOpenBetween(code2);
        }
        return nok(code2);
      }
      function tagOpenBetween(code2) {
        if (code2 === 47) {
          effects.consume(code2);
          return end;
        }
        if (code2 === 58 || code2 === 95 || asciiAlpha$2(code2)) {
          effects.consume(code2);
          return tagOpenAttributeName;
        }
        if (markdownLineEnding(code2)) {
          returnState = tagOpenBetween;
          return atLineEnding(code2);
        }
        if (markdownSpace$2(code2)) {
          effects.consume(code2);
          return tagOpenBetween;
        }
        return end(code2);
      }
      function tagOpenAttributeName(code2) {
        if (code2 === 45 || code2 === 46 || code2 === 58 || code2 === 95 || asciiAlphanumeric$2(code2)) {
          effects.consume(code2);
          return tagOpenAttributeName;
        }
        return tagOpenAttributeNameAfter(code2);
      }
      function tagOpenAttributeNameAfter(code2) {
        if (code2 === 61) {
          effects.consume(code2);
          return tagOpenAttributeValueBefore;
        }
        if (markdownLineEnding(code2)) {
          returnState = tagOpenAttributeNameAfter;
          return atLineEnding(code2);
        }
        if (markdownSpace$2(code2)) {
          effects.consume(code2);
          return tagOpenAttributeNameAfter;
        }
        return tagOpenBetween(code2);
      }
      function tagOpenAttributeValueBefore(code2) {
        if (code2 === null || code2 === 60 || code2 === 61 || code2 === 62 || code2 === 96) {
          return nok(code2);
        }
        if (code2 === 34 || code2 === 39) {
          effects.consume(code2);
          marker = code2;
          return tagOpenAttributeValueQuoted;
        }
        if (markdownLineEnding(code2)) {
          returnState = tagOpenAttributeValueBefore;
          return atLineEnding(code2);
        }
        if (markdownSpace$2(code2)) {
          effects.consume(code2);
          return tagOpenAttributeValueBefore;
        }
        effects.consume(code2);
        marker = void 0;
        return tagOpenAttributeValueUnquoted;
      }
      function tagOpenAttributeValueQuoted(code2) {
        if (code2 === marker) {
          effects.consume(code2);
          return tagOpenAttributeValueQuotedAfter;
        }
        if (code2 === null) {
          return nok(code2);
        }
        if (markdownLineEnding(code2)) {
          returnState = tagOpenAttributeValueQuoted;
          return atLineEnding(code2);
        }
        effects.consume(code2);
        return tagOpenAttributeValueQuoted;
      }
      function tagOpenAttributeValueQuotedAfter(code2) {
        if (code2 === 62 || code2 === 47 || markdownLineEndingOrSpace$3(code2)) {
          return tagOpenBetween(code2);
        }
        return nok(code2);
      }
      function tagOpenAttributeValueUnquoted(code2) {
        if (code2 === null || code2 === 34 || code2 === 39 || code2 === 60 || code2 === 61 || code2 === 96) {
          return nok(code2);
        }
        if (code2 === 62 || markdownLineEndingOrSpace$3(code2)) {
          return tagOpenBetween(code2);
        }
        effects.consume(code2);
        return tagOpenAttributeValueUnquoted;
      }
      function atLineEnding(code2) {
        effects.exit("htmlTextData");
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return factorySpace$1(
          effects,
          afterPrefix,
          "linePrefix",
          self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
        );
      }
      function afterPrefix(code2) {
        effects.enter("htmlTextData");
        return returnState(code2);
      }
      function end(code2) {
        if (code2 === 62) {
          effects.consume(code2);
          effects.exit("htmlTextData");
          effects.exit("htmlText");
          return ok2;
        }
        return nok(code2);
      }
    }
    const labelEnd = {
      name: "labelEnd",
      tokenize: tokenizeLabelEnd,
      resolveTo: resolveToLabelEnd,
      resolveAll: resolveAllLabelEnd
    };
    const resourceConstruct = {
      tokenize: tokenizeResource
    };
    const fullReferenceConstruct = {
      tokenize: tokenizeFullReference
    };
    const collapsedReferenceConstruct = {
      tokenize: tokenizeCollapsedReference
    };
    function resolveAllLabelEnd(events) {
      let index2 = -1;
      let token2;
      while (++index2 < events.length) {
        token2 = events[index2][1];
        if (token2.type === "labelImage" || token2.type === "labelLink" || token2.type === "labelEnd") {
          events.splice(index2 + 1, token2.type === "labelImage" ? 4 : 2);
          token2.type = "data";
          index2++;
        }
      }
      return events;
    }
    function resolveToLabelEnd(events, context) {
      let index2 = events.length;
      let offset2 = 0;
      let token2;
      let open;
      let close;
      let media;
      while (index2--) {
        token2 = events[index2][1];
        if (open) {
          if (token2.type === "link" || token2.type === "labelLink" && token2._inactive) {
            break;
          }
          if (events[index2][0] === "enter" && token2.type === "labelLink") {
            token2._inactive = true;
          }
        } else if (close) {
          if (events[index2][0] === "enter" && (token2.type === "labelImage" || token2.type === "labelLink") && !token2._balanced) {
            open = index2;
            if (token2.type !== "labelLink") {
              offset2 = 2;
              break;
            }
          }
        } else if (token2.type === "labelEnd") {
          close = index2;
        }
      }
      const group = {
        type: events[open][1].type === "labelLink" ? "link" : "image",
        start: Object.assign({}, events[open][1].start),
        end: Object.assign({}, events[events.length - 1][1].end)
      };
      const label = {
        type: "label",
        start: Object.assign({}, events[open][1].start),
        end: Object.assign({}, events[close][1].end)
      };
      const text2 = {
        type: "labelText",
        start: Object.assign({}, events[open + offset2 + 2][1].end),
        end: Object.assign({}, events[close - 2][1].start)
      };
      media = [
        ["enter", group, context],
        ["enter", label, context]
      ];
      media = push(media, events.slice(open + 1, open + offset2 + 3));
      media = push(media, [["enter", text2, context]]);
      media = push(
        media,
        resolveAll$2(
          context.parser.constructs.insideSpan.null,
          events.slice(open + offset2 + 4, close - 3),
          context
        )
      );
      media = push(media, [
        ["exit", text2, context],
        events[close - 2],
        events[close - 1],
        ["exit", label, context]
      ]);
      media = push(media, events.slice(close + 1));
      media = push(media, [["exit", group, context]]);
      splice(events, open, events.length, media);
      return events;
    }
    function tokenizeLabelEnd(effects, ok2, nok) {
      const self2 = this;
      let index2 = self2.events.length;
      let labelStart;
      let defined;
      while (index2--) {
        if ((self2.events[index2][1].type === "labelImage" || self2.events[index2][1].type === "labelLink") && !self2.events[index2][1]._balanced) {
          labelStart = self2.events[index2][1];
          break;
        }
      }
      return start;
      function start(code2) {
        if (!labelStart) {
          return nok(code2);
        }
        if (labelStart._inactive)
          return balanced(code2);
        defined = self2.parser.defined.includes(
          normalizeIdentifier(
            self2.sliceSerialize({
              start: labelStart.end,
              end: self2.now()
            })
          )
        );
        effects.enter("labelEnd");
        effects.enter("labelMarker");
        effects.consume(code2);
        effects.exit("labelMarker");
        effects.exit("labelEnd");
        return afterLabelEnd;
      }
      function afterLabelEnd(code2) {
        if (code2 === 40) {
          return effects.attempt(
            resourceConstruct,
            ok2,
            defined ? ok2 : balanced
          )(code2);
        }
        if (code2 === 91) {
          return effects.attempt(
            fullReferenceConstruct,
            ok2,
            defined ? effects.attempt(collapsedReferenceConstruct, ok2, balanced) : balanced
          )(code2);
        }
        return defined ? ok2(code2) : balanced(code2);
      }
      function balanced(code2) {
        labelStart._balanced = true;
        return nok(code2);
      }
    }
    function tokenizeResource(effects, ok2, nok) {
      return start;
      function start(code2) {
        effects.enter("resource");
        effects.enter("resourceMarker");
        effects.consume(code2);
        effects.exit("resourceMarker");
        return factoryWhitespace(effects, open);
      }
      function open(code2) {
        if (code2 === 41) {
          return end(code2);
        }
        return factoryDestination(
          effects,
          destinationAfter,
          nok,
          "resourceDestination",
          "resourceDestinationLiteral",
          "resourceDestinationLiteralMarker",
          "resourceDestinationRaw",
          "resourceDestinationString",
          32
        )(code2);
      }
      function destinationAfter(code2) {
        return markdownLineEndingOrSpace$3(code2) ? factoryWhitespace(effects, between)(code2) : end(code2);
      }
      function between(code2) {
        if (code2 === 34 || code2 === 39 || code2 === 40) {
          return factoryTitle(
            effects,
            factoryWhitespace(effects, end),
            nok,
            "resourceTitle",
            "resourceTitleMarker",
            "resourceTitleString"
          )(code2);
        }
        return end(code2);
      }
      function end(code2) {
        if (code2 === 41) {
          effects.enter("resourceMarker");
          effects.consume(code2);
          effects.exit("resourceMarker");
          effects.exit("resource");
          return ok2;
        }
        return nok(code2);
      }
    }
    function tokenizeFullReference(effects, ok2, nok) {
      const self2 = this;
      return start;
      function start(code2) {
        return factoryLabel.call(
          self2,
          effects,
          afterLabel,
          nok,
          "reference",
          "referenceMarker",
          "referenceString"
        )(code2);
      }
      function afterLabel(code2) {
        return self2.parser.defined.includes(
          normalizeIdentifier(
            self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
          )
        ) ? ok2(code2) : nok(code2);
      }
    }
    function tokenizeCollapsedReference(effects, ok2, nok) {
      return start;
      function start(code2) {
        effects.enter("reference");
        effects.enter("referenceMarker");
        effects.consume(code2);
        effects.exit("referenceMarker");
        return open;
      }
      function open(code2) {
        if (code2 === 93) {
          effects.enter("referenceMarker");
          effects.consume(code2);
          effects.exit("referenceMarker");
          effects.exit("reference");
          return ok2;
        }
        return nok(code2);
      }
    }
    const labelStartImage = {
      name: "labelStartImage",
      tokenize: tokenizeLabelStartImage,
      resolveAll: labelEnd.resolveAll
    };
    function tokenizeLabelStartImage(effects, ok2, nok) {
      const self2 = this;
      return start;
      function start(code2) {
        effects.enter("labelImage");
        effects.enter("labelImageMarker");
        effects.consume(code2);
        effects.exit("labelImageMarker");
        return open;
      }
      function open(code2) {
        if (code2 === 91) {
          effects.enter("labelMarker");
          effects.consume(code2);
          effects.exit("labelMarker");
          effects.exit("labelImage");
          return after;
        }
        return nok(code2);
      }
      function after(code2) {
        return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
      }
    }
    const labelStartLink = {
      name: "labelStartLink",
      tokenize: tokenizeLabelStartLink,
      resolveAll: labelEnd.resolveAll
    };
    function tokenizeLabelStartLink(effects, ok2, nok) {
      const self2 = this;
      return start;
      function start(code2) {
        effects.enter("labelLink");
        effects.enter("labelMarker");
        effects.consume(code2);
        effects.exit("labelMarker");
        effects.exit("labelLink");
        return after;
      }
      function after(code2) {
        return code2 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code2) : ok2(code2);
      }
    }
    const lineEnding = {
      name: "lineEnding",
      tokenize: tokenizeLineEnding
    };
    function tokenizeLineEnding(effects, ok2) {
      return start;
      function start(code2) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return factorySpace$1(effects, ok2, "linePrefix");
      }
    }
    const thematicBreak$1 = {
      name: "thematicBreak",
      tokenize: tokenizeThematicBreak
    };
    function tokenizeThematicBreak(effects, ok2, nok) {
      let size = 0;
      let marker;
      return start;
      function start(code2) {
        effects.enter("thematicBreak");
        marker = code2;
        return atBreak(code2);
      }
      function atBreak(code2) {
        if (code2 === marker) {
          effects.enter("thematicBreakSequence");
          return sequence(code2);
        }
        if (markdownSpace$2(code2)) {
          return factorySpace$1(effects, atBreak, "whitespace")(code2);
        }
        if (size < 3 || code2 !== null && !markdownLineEnding(code2)) {
          return nok(code2);
        }
        effects.exit("thematicBreak");
        return ok2(code2);
      }
      function sequence(code2) {
        if (code2 === marker) {
          effects.consume(code2);
          size++;
          return sequence;
        }
        effects.exit("thematicBreakSequence");
        return atBreak(code2);
      }
    }
    const list$1 = {
      name: "list",
      tokenize: tokenizeListStart,
      continuation: {
        tokenize: tokenizeListContinuation
      },
      exit: tokenizeListEnd
    };
    const listItemPrefixWhitespaceConstruct = {
      tokenize: tokenizeListItemPrefixWhitespace,
      partial: true
    };
    const indentConstruct = {
      tokenize: tokenizeIndent,
      partial: true
    };
    function tokenizeListStart(effects, ok2, nok) {
      const self2 = this;
      const tail = self2.events[self2.events.length - 1];
      let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
      let size = 0;
      return start;
      function start(code2) {
        const kind = self2.containerState.type || (code2 === 42 || code2 === 43 || code2 === 45 ? "listUnordered" : "listOrdered");
        if (kind === "listUnordered" ? !self2.containerState.marker || code2 === self2.containerState.marker : asciiDigit(code2)) {
          if (!self2.containerState.type) {
            self2.containerState.type = kind;
            effects.enter(kind, {
              _container: true
            });
          }
          if (kind === "listUnordered") {
            effects.enter("listItemPrefix");
            return code2 === 42 || code2 === 45 ? effects.check(thematicBreak$1, nok, atMarker)(code2) : atMarker(code2);
          }
          if (!self2.interrupt || code2 === 49) {
            effects.enter("listItemPrefix");
            effects.enter("listItemValue");
            return inside(code2);
          }
        }
        return nok(code2);
      }
      function inside(code2) {
        if (asciiDigit(code2) && ++size < 10) {
          effects.consume(code2);
          return inside;
        }
        if ((!self2.interrupt || size < 2) && (self2.containerState.marker ? code2 === self2.containerState.marker : code2 === 41 || code2 === 46)) {
          effects.exit("listItemValue");
          return atMarker(code2);
        }
        return nok(code2);
      }
      function atMarker(code2) {
        effects.enter("listItemMarker");
        effects.consume(code2);
        effects.exit("listItemMarker");
        self2.containerState.marker = self2.containerState.marker || code2;
        return effects.check(
          blankLine,
          // Can’t be empty when interrupting.
          self2.interrupt ? nok : onBlank,
          effects.attempt(
            listItemPrefixWhitespaceConstruct,
            endOfPrefix,
            otherPrefix
          )
        );
      }
      function onBlank(code2) {
        self2.containerState.initialBlankLine = true;
        initialSize++;
        return endOfPrefix(code2);
      }
      function otherPrefix(code2) {
        if (markdownSpace$2(code2)) {
          effects.enter("listItemPrefixWhitespace");
          effects.consume(code2);
          effects.exit("listItemPrefixWhitespace");
          return endOfPrefix;
        }
        return nok(code2);
      }
      function endOfPrefix(code2) {
        self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit("listItemPrefix"), true).length;
        return ok2(code2);
      }
    }
    function tokenizeListContinuation(effects, ok2, nok) {
      const self2 = this;
      self2.containerState._closeFlow = void 0;
      return effects.check(blankLine, onBlank, notBlank);
      function onBlank(code2) {
        self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
        return factorySpace$1(
          effects,
          ok2,
          "listItemIndent",
          self2.containerState.size + 1
        )(code2);
      }
      function notBlank(code2) {
        if (self2.containerState.furtherBlankLines || !markdownSpace$2(code2)) {
          self2.containerState.furtherBlankLines = void 0;
          self2.containerState.initialBlankLine = void 0;
          return notInCurrentItem(code2);
        }
        self2.containerState.furtherBlankLines = void 0;
        self2.containerState.initialBlankLine = void 0;
        return effects.attempt(indentConstruct, ok2, notInCurrentItem)(code2);
      }
      function notInCurrentItem(code2) {
        self2.containerState._closeFlow = true;
        self2.interrupt = void 0;
        return factorySpace$1(
          effects,
          effects.attempt(list$1, ok2, nok),
          "linePrefix",
          self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
        )(code2);
      }
    }
    function tokenizeIndent(effects, ok2, nok) {
      const self2 = this;
      return factorySpace$1(
        effects,
        afterPrefix,
        "listItemIndent",
        self2.containerState.size + 1
      );
      function afterPrefix(code2) {
        const tail = self2.events[self2.events.length - 1];
        return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok2(code2) : nok(code2);
      }
    }
    function tokenizeListEnd(effects) {
      effects.exit(this.containerState.type);
    }
    function tokenizeListItemPrefixWhitespace(effects, ok2, nok) {
      const self2 = this;
      return factorySpace$1(
        effects,
        afterPrefix,
        "listItemPrefixWhitespace",
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1
      );
      function afterPrefix(code2) {
        const tail = self2.events[self2.events.length - 1];
        return !markdownSpace$2(code2) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok2(code2) : nok(code2);
      }
    }
    const setextUnderline = {
      name: "setextUnderline",
      tokenize: tokenizeSetextUnderline,
      resolveTo: resolveToSetextUnderline
    };
    function resolveToSetextUnderline(events, context) {
      let index2 = events.length;
      let content2;
      let text2;
      let definition2;
      while (index2--) {
        if (events[index2][0] === "enter") {
          if (events[index2][1].type === "content") {
            content2 = index2;
            break;
          }
          if (events[index2][1].type === "paragraph") {
            text2 = index2;
          }
        } else {
          if (events[index2][1].type === "content") {
            events.splice(index2, 1);
          }
          if (!definition2 && events[index2][1].type === "definition") {
            definition2 = index2;
          }
        }
      }
      const heading2 = {
        type: "setextHeading",
        start: Object.assign({}, events[text2][1].start),
        end: Object.assign({}, events[events.length - 1][1].end)
      };
      events[text2][1].type = "setextHeadingText";
      if (definition2) {
        events.splice(text2, 0, ["enter", heading2, context]);
        events.splice(definition2 + 1, 0, ["exit", events[content2][1], context]);
        events[content2][1].end = Object.assign({}, events[definition2][1].end);
      } else {
        events[content2][1] = heading2;
      }
      events.push(["exit", heading2, context]);
      return events;
    }
    function tokenizeSetextUnderline(effects, ok2, nok) {
      const self2 = this;
      let index2 = self2.events.length;
      let marker;
      let paragraph2;
      while (index2--) {
        if (self2.events[index2][1].type !== "lineEnding" && self2.events[index2][1].type !== "linePrefix" && self2.events[index2][1].type !== "content") {
          paragraph2 = self2.events[index2][1].type === "paragraph";
          break;
        }
      }
      return start;
      function start(code2) {
        if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph2)) {
          effects.enter("setextHeadingLine");
          effects.enter("setextHeadingLineSequence");
          marker = code2;
          return closingSequence(code2);
        }
        return nok(code2);
      }
      function closingSequence(code2) {
        if (code2 === marker) {
          effects.consume(code2);
          return closingSequence;
        }
        effects.exit("setextHeadingLineSequence");
        return factorySpace$1(effects, closingSequenceEnd, "lineSuffix")(code2);
      }
      function closingSequenceEnd(code2) {
        if (code2 === null || markdownLineEnding(code2)) {
          effects.exit("setextHeadingLine");
          return ok2(code2);
        }
        return nok(code2);
      }
    }
    const flow$3 = {
      tokenize: initializeFlow
    };
    function initializeFlow(effects) {
      const self2 = this;
      const initial = effects.attempt(
        // Try to parse a blank line.
        blankLine,
        atBlankEnding,
        // Try to parse initial flow (essentially, only code).
        effects.attempt(
          this.parser.constructs.flowInitial,
          afterConstruct,
          factorySpace$1(
            effects,
            effects.attempt(
              this.parser.constructs.flow,
              afterConstruct,
              effects.attempt(content, afterConstruct)
            ),
            "linePrefix"
          )
        )
      );
      return initial;
      function atBlankEnding(code2) {
        if (code2 === null) {
          effects.consume(code2);
          return;
        }
        effects.enter("lineEndingBlank");
        effects.consume(code2);
        effects.exit("lineEndingBlank");
        self2.currentConstruct = void 0;
        return initial;
      }
      function afterConstruct(code2) {
        if (code2 === null) {
          effects.consume(code2);
          return;
        }
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        self2.currentConstruct = void 0;
        return initial;
      }
    }
    const resolver = {
      resolveAll: createResolver()
    };
    const string$1 = initializeFactory("string");
    const text$6 = initializeFactory("text");
    function initializeFactory(field) {
      return {
        tokenize: initializeText,
        resolveAll: createResolver(
          field === "text" ? resolveAllLineSuffixes : void 0
        )
      };
      function initializeText(effects) {
        const self2 = this;
        const constructs2 = this.parser.constructs[field];
        const text2 = effects.attempt(constructs2, start, notText);
        return start;
        function start(code2) {
          return atBreak(code2) ? text2(code2) : notText(code2);
        }
        function notText(code2) {
          if (code2 === null) {
            effects.consume(code2);
            return;
          }
          effects.enter("data");
          effects.consume(code2);
          return data;
        }
        function data(code2) {
          if (atBreak(code2)) {
            effects.exit("data");
            return text2(code2);
          }
          effects.consume(code2);
          return data;
        }
        function atBreak(code2) {
          if (code2 === null) {
            return true;
          }
          const list2 = constructs2[code2];
          let index2 = -1;
          if (list2) {
            while (++index2 < list2.length) {
              const item = list2[index2];
              if (!item.previous || item.previous.call(self2, self2.previous)) {
                return true;
              }
            }
          }
          return false;
        }
      }
    }
    function createResolver(extraResolver) {
      return resolveAllText;
      function resolveAllText(events, context) {
        let index2 = -1;
        let enter;
        while (++index2 <= events.length) {
          if (enter === void 0) {
            if (events[index2] && events[index2][1].type === "data") {
              enter = index2;
              index2++;
            }
          } else if (!events[index2] || events[index2][1].type !== "data") {
            if (index2 !== enter + 2) {
              events[enter][1].end = events[index2 - 1][1].end;
              events.splice(enter + 2, index2 - enter - 2);
              index2 = enter + 2;
            }
            enter = void 0;
          }
        }
        return extraResolver ? extraResolver(events, context) : events;
      }
    }
    function resolveAllLineSuffixes(events, context) {
      let eventIndex = 0;
      while (++eventIndex <= events.length) {
        if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
          const data = events[eventIndex - 1][1];
          const chunks = context.sliceStream(data);
          let index2 = chunks.length;
          let bufferIndex = -1;
          let size = 0;
          let tabs;
          while (index2--) {
            const chunk = chunks[index2];
            if (typeof chunk === "string") {
              bufferIndex = chunk.length;
              while (chunk.charCodeAt(bufferIndex - 1) === 32) {
                size++;
                bufferIndex--;
              }
              if (bufferIndex)
                break;
              bufferIndex = -1;
            } else if (chunk === -2) {
              tabs = true;
              size++;
            } else if (chunk === -1)
              ;
            else {
              index2++;
              break;
            }
          }
          if (size) {
            const token2 = {
              type: eventIndex === events.length || tabs || size < 2 ? "lineSuffix" : "hardBreakTrailing",
              start: {
                line: data.end.line,
                column: data.end.column - size,
                offset: data.end.offset - size,
                _index: data.start._index + index2,
                _bufferIndex: index2 ? bufferIndex : data.start._bufferIndex + bufferIndex
              },
              end: Object.assign({}, data.end)
            };
            data.end = Object.assign({}, token2.start);
            if (data.start.offset === data.end.offset) {
              Object.assign(data, token2);
            } else {
              events.splice(
                eventIndex,
                0,
                ["enter", token2, context],
                ["exit", token2, context]
              );
              eventIndex += 2;
            }
          }
          eventIndex++;
        }
      }
      return events;
    }
    function createTokenizer(parser2, initialize, from2) {
      let point2 = Object.assign(
        from2 ? Object.assign({}, from2) : {
          line: 1,
          column: 1,
          offset: 0
        },
        {
          _index: 0,
          _bufferIndex: -1
        }
      );
      const columnStart = {};
      const resolveAllConstructs = [];
      let chunks = [];
      let stack = [];
      const effects = {
        consume,
        enter,
        exit: exit2,
        attempt: constructFactory(onsuccessfulconstruct),
        check: constructFactory(onsuccessfulcheck),
        interrupt: constructFactory(onsuccessfulcheck, {
          interrupt: true
        })
      };
      const context = {
        previous: null,
        code: null,
        containerState: {},
        events: [],
        parser: parser2,
        sliceStream,
        sliceSerialize,
        now: now2,
        defineSkip,
        write
      };
      let state = initialize.tokenize.call(context, effects);
      if (initialize.resolveAll) {
        resolveAllConstructs.push(initialize);
      }
      return context;
      function write(slice2) {
        chunks = push(chunks, slice2);
        main2();
        if (chunks[chunks.length - 1] !== null) {
          return [];
        }
        addResult(initialize, 0);
        context.events = resolveAll$2(resolveAllConstructs, context.events, context);
        return context.events;
      }
      function sliceSerialize(token2, expandTabs) {
        return serializeChunks(sliceStream(token2), expandTabs);
      }
      function sliceStream(token2) {
        return sliceChunks(chunks, token2);
      }
      function now2() {
        return Object.assign({}, point2);
      }
      function defineSkip(value) {
        columnStart[value.line] = value.column;
        accountForPotentialSkip();
      }
      function main2() {
        let chunkIndex;
        while (point2._index < chunks.length) {
          const chunk = chunks[point2._index];
          if (typeof chunk === "string") {
            chunkIndex = point2._index;
            if (point2._bufferIndex < 0) {
              point2._bufferIndex = 0;
            }
            while (point2._index === chunkIndex && point2._bufferIndex < chunk.length) {
              go2(chunk.charCodeAt(point2._bufferIndex));
            }
          } else {
            go2(chunk);
          }
        }
      }
      function go2(code2) {
        state = state(code2);
      }
      function consume(code2) {
        if (markdownLineEnding(code2)) {
          point2.line++;
          point2.column = 1;
          point2.offset += code2 === -3 ? 2 : 1;
          accountForPotentialSkip();
        } else if (code2 !== -1) {
          point2.column++;
          point2.offset++;
        }
        if (point2._bufferIndex < 0) {
          point2._index++;
        } else {
          point2._bufferIndex++;
          if (point2._bufferIndex === chunks[point2._index].length) {
            point2._bufferIndex = -1;
            point2._index++;
          }
        }
        context.previous = code2;
      }
      function enter(type, fields) {
        const token2 = fields || {};
        token2.type = type;
        token2.start = now2();
        context.events.push(["enter", token2, context]);
        stack.push(token2);
        return token2;
      }
      function exit2(type) {
        const token2 = stack.pop();
        token2.end = now2();
        context.events.push(["exit", token2, context]);
        return token2;
      }
      function onsuccessfulconstruct(construct, info) {
        addResult(construct, info.from);
      }
      function onsuccessfulcheck(_2, info) {
        info.restore();
      }
      function constructFactory(onreturn, fields) {
        return hook;
        function hook(constructs2, returnState, bogusState) {
          let listOfConstructs;
          let constructIndex;
          let currentConstruct;
          let info;
          return Array.isArray(constructs2) ? (
            /* c8 ignore next 1 */
            handleListOfConstructs(constructs2)
          ) : "tokenize" in constructs2 ? handleListOfConstructs([constructs2]) : handleMapOfConstructs(constructs2);
          function handleMapOfConstructs(map2) {
            return start;
            function start(code2) {
              const def = code2 !== null && map2[code2];
              const all2 = code2 !== null && map2.null;
              const list2 = [
                // To do: add more extension tests.
                /* c8 ignore next 2 */
                ...Array.isArray(def) ? def : def ? [def] : [],
                ...Array.isArray(all2) ? all2 : all2 ? [all2] : []
              ];
              return handleListOfConstructs(list2)(code2);
            }
          }
          function handleListOfConstructs(list2) {
            listOfConstructs = list2;
            constructIndex = 0;
            if (list2.length === 0) {
              return bogusState;
            }
            return handleConstruct(list2[constructIndex]);
          }
          function handleConstruct(construct) {
            return start;
            function start(code2) {
              info = store();
              currentConstruct = construct;
              if (!construct.partial) {
                context.currentConstruct = construct;
              }
              if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
                return nok();
              }
              return construct.tokenize.call(
                // If we do have fields, create an object w/ `context` as its
                // prototype.
                // This allows a “live binding”, which is needed for `interrupt`.
                fields ? Object.assign(Object.create(context), fields) : context,
                effects,
                ok2,
                nok
              )(code2);
            }
          }
          function ok2(code2) {
            onreturn(currentConstruct, info);
            return returnState;
          }
          function nok(code2) {
            info.restore();
            if (++constructIndex < listOfConstructs.length) {
              return handleConstruct(listOfConstructs[constructIndex]);
            }
            return bogusState;
          }
        }
      }
      function addResult(construct, from3) {
        if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
          resolveAllConstructs.push(construct);
        }
        if (construct.resolve) {
          splice(
            context.events,
            from3,
            context.events.length - from3,
            construct.resolve(context.events.slice(from3), context)
          );
        }
        if (construct.resolveTo) {
          context.events = construct.resolveTo(context.events, context);
        }
      }
      function store() {
        const startPoint = now2();
        const startPrevious = context.previous;
        const startCurrentConstruct = context.currentConstruct;
        const startEventsIndex = context.events.length;
        const startStack = Array.from(stack);
        return {
          restore,
          from: startEventsIndex
        };
        function restore() {
          point2 = startPoint;
          context.previous = startPrevious;
          context.currentConstruct = startCurrentConstruct;
          context.events.length = startEventsIndex;
          stack = startStack;
          accountForPotentialSkip();
        }
      }
      function accountForPotentialSkip() {
        if (point2.line in columnStart && point2.column < 2) {
          point2.column = columnStart[point2.line];
          point2.offset += columnStart[point2.line] - 1;
        }
      }
    }
    function sliceChunks(chunks, token2) {
      const startIndex = token2.start._index;
      const startBufferIndex = token2.start._bufferIndex;
      const endIndex = token2.end._index;
      const endBufferIndex = token2.end._bufferIndex;
      let view;
      if (startIndex === endIndex) {
        view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
      } else {
        view = chunks.slice(startIndex, endIndex);
        if (startBufferIndex > -1) {
          view[0] = view[0].slice(startBufferIndex);
        }
        if (endBufferIndex > 0) {
          view.push(chunks[endIndex].slice(0, endBufferIndex));
        }
      }
      return view;
    }
    function serializeChunks(chunks, expandTabs) {
      let index2 = -1;
      const result = [];
      let atTab;
      while (++index2 < chunks.length) {
        const chunk = chunks[index2];
        let value;
        if (typeof chunk === "string") {
          value = chunk;
        } else
          switch (chunk) {
            case -5: {
              value = "\r";
              break;
            }
            case -4: {
              value = "\n";
              break;
            }
            case -3: {
              value = "\r\n";
              break;
            }
            case -2: {
              value = expandTabs ? " " : "	";
              break;
            }
            case -1: {
              if (!expandTabs && atTab)
                continue;
              value = " ";
              break;
            }
            default: {
              value = String.fromCharCode(chunk);
            }
          }
        atTab = chunk === -2;
        result.push(value);
      }
      return result.join("");
    }
    const document$1 = {
      [42]: list$1,
      [43]: list$1,
      [45]: list$1,
      [48]: list$1,
      [49]: list$1,
      [50]: list$1,
      [51]: list$1,
      [52]: list$1,
      [53]: list$1,
      [54]: list$1,
      [55]: list$1,
      [56]: list$1,
      [57]: list$1,
      [62]: blockQuote
    };
    const contentInitial = {
      [91]: definition
    };
    const flowInitial = {
      [-2]: codeIndented,
      [-1]: codeIndented,
      [32]: codeIndented
    };
    const flow$2 = {
      [35]: headingAtx,
      [42]: thematicBreak$1,
      [45]: [setextUnderline, thematicBreak$1],
      [60]: htmlFlow,
      [61]: setextUnderline,
      [95]: thematicBreak$1,
      [96]: codeFenced,
      [126]: codeFenced
    };
    const string = {
      [38]: characterReference,
      [92]: characterEscape
    };
    const text$5 = {
      [-5]: lineEnding,
      [-4]: lineEnding,
      [-3]: lineEnding,
      [33]: labelStartImage,
      [38]: characterReference,
      [42]: attention,
      [60]: [autolink$1, htmlText],
      [91]: labelStartLink,
      [92]: [hardBreakEscape, characterEscape],
      [93]: labelEnd,
      [95]: attention,
      [96]: codeText
    };
    const insideSpan = {
      null: [attention, resolver]
    };
    const attentionMarkers = {
      null: [42, 95]
    };
    const disable = {
      null: []
    };
    const defaultConstructs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      attentionMarkers,
      contentInitial,
      disable,
      document: document$1,
      flow: flow$2,
      flowInitial,
      insideSpan,
      string,
      text: text$5
    }, Symbol.toStringTag, { value: "Module" }));
    function parse$4(options = {}) {
      const constructs2 = combineExtensions$1(
        // @ts-expect-error Same as above.
        [defaultConstructs].concat(options.extensions || [])
      );
      const parser2 = {
        defined: [],
        lazy: {},
        constructs: constructs2,
        content: create2(content$1),
        document: create2(document$2),
        flow: create2(flow$3),
        string: create2(string$1),
        text: create2(text$6)
      };
      return parser2;
      function create2(initial) {
        return creator;
        function creator(from2) {
          return createTokenizer(parser2, initial, from2);
        }
      }
    }
    const search$1 = /[\0\t\n\r]/g;
    function preprocess() {
      let column2 = 1;
      let buffer = "";
      let start = true;
      let atCarriageReturn;
      return preprocessor2;
      function preprocessor2(value, encoding, end) {
        const chunks = [];
        let match5;
        let next2;
        let startPosition;
        let endPosition;
        let code2;
        value = buffer + value.toString(encoding);
        startPosition = 0;
        buffer = "";
        if (start) {
          if (value.charCodeAt(0) === 65279) {
            startPosition++;
          }
          start = void 0;
        }
        while (startPosition < value.length) {
          search$1.lastIndex = startPosition;
          match5 = search$1.exec(value);
          endPosition = match5 && match5.index !== void 0 ? match5.index : value.length;
          code2 = value.charCodeAt(endPosition);
          if (!match5) {
            buffer = value.slice(startPosition);
            break;
          }
          if (code2 === 10 && startPosition === endPosition && atCarriageReturn) {
            chunks.push(-3);
            atCarriageReturn = void 0;
          } else {
            if (atCarriageReturn) {
              chunks.push(-5);
              atCarriageReturn = void 0;
            }
            if (startPosition < endPosition) {
              chunks.push(value.slice(startPosition, endPosition));
              column2 += endPosition - startPosition;
            }
            switch (code2) {
              case 0: {
                chunks.push(65533);
                column2++;
                break;
              }
              case 9: {
                next2 = Math.ceil(column2 / 4) * 4;
                chunks.push(-2);
                while (column2++ < next2)
                  chunks.push(-1);
                break;
              }
              case 10: {
                chunks.push(-4);
                column2 = 1;
                break;
              }
              default: {
                atCarriageReturn = true;
                column2 = 1;
              }
            }
          }
          startPosition = endPosition + 1;
        }
        if (end) {
          if (atCarriageReturn)
            chunks.push(-5);
          if (buffer)
            chunks.push(buffer);
          chunks.push(null);
        }
        return chunks;
      }
    }
    function postprocess(events) {
      while (!subtokenize(events)) {
      }
      return events;
    }
    function decodeNumericCharacterReference(value, base2) {
      const code2 = Number.parseInt(value, base2);
      if (
        // C0 except for HT, LF, FF, CR, space
        code2 < 9 || code2 === 11 || code2 > 13 && code2 < 32 || // Control character (DEL) of the basic block and C1 controls.
        code2 > 126 && code2 < 160 || // Lone high surrogates and low surrogates.
        code2 > 55295 && code2 < 57344 || // Noncharacters.
        code2 > 64975 && code2 < 65008 || (code2 & 65535) === 65535 || (code2 & 65535) === 65534 || // Out of range
        code2 > 1114111
      ) {
        return "�";
      }
      return String.fromCharCode(code2);
    }
    const characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
    function decodeString(value) {
      return value.replace(characterEscapeOrReference, decode);
    }
    function decode($0, $1, $2) {
      if ($1) {
        return $1;
      }
      const head = $2.charCodeAt(0);
      if (head === 35) {
        const head2 = $2.charCodeAt(1);
        const hex = head2 === 120 || head2 === 88;
        return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10);
      }
      return decodeNamedCharacterReference($2) || $0;
    }
    var own$e = {}.hasOwnProperty;
    function stringifyPosition(value) {
      if (!value || typeof value !== "object") {
        return "";
      }
      if (own$e.call(value, "position") || own$e.call(value, "type")) {
        return position$2(value.position);
      }
      if (own$e.call(value, "start") || own$e.call(value, "end")) {
        return position$2(value);
      }
      if (own$e.call(value, "line") || own$e.call(value, "column")) {
        return point$2(value);
      }
      return "";
    }
    function point$2(point2) {
      return index(point2 && point2.line) + ":" + index(point2 && point2.column);
    }
    function position$2(pos) {
      return point$2(pos && pos.start) + "-" + point$2(pos && pos.end);
    }
    function index(value) {
      return value && typeof value === "number" ? value : 1;
    }
    const own$d = {}.hasOwnProperty;
    const fromMarkdown$6 = (
      /**
       * @type {(
       *   ((value: Value, encoding: Encoding, options?: Options) => Root) &
       *   ((value: Value, options?: Options) => Root)
       * )}
       */
      /**
       * @param {Value} value
       * @param {Encoding} [encoding]
       * @param {Options} [options]
       * @returns {Root}
       */
      function(value, encoding, options) {
        if (typeof encoding !== "string") {
          options = encoding;
          encoding = void 0;
        }
        return compiler(options)(
          postprocess(
            parse$4(options).document().write(preprocess()(value, encoding, true))
          )
        );
      }
    );
    function compiler(options = {}) {
      const config2 = configure$1(
        {
          transforms: [],
          canContainEols: [
            "emphasis",
            "fragment",
            "heading",
            "paragraph",
            "strong"
          ],
          enter: {
            autolink: opener(link2),
            autolinkProtocol: onenterdata,
            autolinkEmail: onenterdata,
            atxHeading: opener(heading2),
            blockQuote: opener(blockQuote2),
            characterEscape: onenterdata,
            characterReference: onenterdata,
            codeFenced: opener(codeFlow),
            codeFencedFenceInfo: buffer,
            codeFencedFenceMeta: buffer,
            codeIndented: opener(codeFlow, buffer),
            codeText: opener(codeText2, buffer),
            codeTextData: onenterdata,
            data: onenterdata,
            codeFlowValue: onenterdata,
            definition: opener(definition2),
            definitionDestinationString: buffer,
            definitionLabelString: buffer,
            definitionTitleString: buffer,
            emphasis: opener(emphasis2),
            hardBreakEscape: opener(hardBreak2),
            hardBreakTrailing: opener(hardBreak2),
            htmlFlow: opener(html2, buffer),
            htmlFlowData: onenterdata,
            htmlText: opener(html2, buffer),
            htmlTextData: onenterdata,
            image: opener(image2),
            label: buffer,
            link: opener(link2),
            listItem: opener(listItem2),
            listItemValue: onenterlistitemvalue,
            listOrdered: opener(list2, onenterlistordered),
            listUnordered: opener(list2),
            paragraph: opener(paragraph2),
            reference: onenterreference,
            referenceString: buffer,
            resourceDestinationString: buffer,
            resourceTitleString: buffer,
            setextHeading: opener(heading2),
            strong: opener(strong2),
            thematicBreak: opener(thematicBreak2)
          },
          exit: {
            atxHeading: closer(),
            atxHeadingSequence: onexitatxheadingsequence,
            autolink: closer(),
            autolinkEmail: onexitautolinkemail,
            autolinkProtocol: onexitautolinkprotocol,
            blockQuote: closer(),
            characterEscapeValue: onexitdata,
            characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
            characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
            characterReferenceValue: onexitcharacterreferencevalue,
            codeFenced: closer(onexitcodefenced),
            codeFencedFence: onexitcodefencedfence,
            codeFencedFenceInfo: onexitcodefencedfenceinfo,
            codeFencedFenceMeta: onexitcodefencedfencemeta,
            codeFlowValue: onexitdata,
            codeIndented: closer(onexitcodeindented),
            codeText: closer(onexitcodetext),
            codeTextData: onexitdata,
            data: onexitdata,
            definition: closer(),
            definitionDestinationString: onexitdefinitiondestinationstring,
            definitionLabelString: onexitdefinitionlabelstring,
            definitionTitleString: onexitdefinitiontitlestring,
            emphasis: closer(),
            hardBreakEscape: closer(onexithardbreak),
            hardBreakTrailing: closer(onexithardbreak),
            htmlFlow: closer(onexithtmlflow),
            htmlFlowData: onexitdata,
            htmlText: closer(onexithtmltext),
            htmlTextData: onexitdata,
            image: closer(onexitimage),
            label: onexitlabel,
            labelText: onexitlabeltext,
            lineEnding: onexitlineending,
            link: closer(onexitlink),
            listItem: closer(),
            listOrdered: closer(),
            listUnordered: closer(),
            paragraph: closer(),
            referenceString: onexitreferencestring,
            resourceDestinationString: onexitresourcedestinationstring,
            resourceTitleString: onexitresourcetitlestring,
            resource: onexitresource,
            setextHeading: closer(onexitsetextheading),
            setextHeadingLineSequence: onexitsetextheadinglinesequence,
            setextHeadingText: onexitsetextheadingtext,
            strong: closer(),
            thematicBreak: closer()
          }
        },
        options.mdastExtensions || []
      );
      const data = {};
      return compile2;
      function compile2(events) {
        let tree = {
          type: "root",
          children: []
        };
        const stack = [tree];
        const tokenStack = [];
        const listStack = [];
        const context = {
          stack,
          tokenStack,
          config: config2,
          enter,
          exit: exit2,
          buffer,
          resume,
          setData,
          getData
        };
        let index2 = -1;
        while (++index2 < events.length) {
          if (events[index2][1].type === "listOrdered" || events[index2][1].type === "listUnordered") {
            if (events[index2][0] === "enter") {
              listStack.push(index2);
            } else {
              const tail = listStack.pop();
              index2 = prepareList(events, tail, index2);
            }
          }
        }
        index2 = -1;
        while (++index2 < events.length) {
          const handler = config2[events[index2][0]];
          if (own$d.call(handler, events[index2][1].type)) {
            handler[events[index2][1].type].call(
              Object.assign(
                {
                  sliceSerialize: events[index2][2].sliceSerialize
                },
                context
              ),
              events[index2][1]
            );
          }
        }
        if (tokenStack.length > 0) {
          const tail = tokenStack[tokenStack.length - 1];
          const handler = tail[1] || defaultOnError;
          handler.call(context, void 0, tail[0]);
        }
        tree.position = {
          start: point2(
            events.length > 0 ? events[0][1].start : {
              line: 1,
              column: 1,
              offset: 0
            }
          ),
          end: point2(
            events.length > 0 ? events[events.length - 2][1].end : {
              line: 1,
              column: 1,
              offset: 0
            }
          )
        };
        index2 = -1;
        while (++index2 < config2.transforms.length) {
          tree = config2.transforms[index2](tree) || tree;
        }
        return tree;
      }
      function prepareList(events, start, length2) {
        let index2 = start - 1;
        let containerBalance = -1;
        let listSpread = false;
        let listItem3;
        let lineIndex;
        let firstBlankLineIndex;
        let atMarker;
        while (++index2 <= length2) {
          const event = events[index2];
          if (event[1].type === "listUnordered" || event[1].type === "listOrdered" || event[1].type === "blockQuote") {
            if (event[0] === "enter") {
              containerBalance++;
            } else {
              containerBalance--;
            }
            atMarker = void 0;
          } else if (event[1].type === "lineEndingBlank") {
            if (event[0] === "enter") {
              if (listItem3 && !atMarker && !containerBalance && !firstBlankLineIndex) {
                firstBlankLineIndex = index2;
              }
              atMarker = void 0;
            }
          } else if (event[1].type === "linePrefix" || event[1].type === "listItemValue" || event[1].type === "listItemMarker" || event[1].type === "listItemPrefix" || event[1].type === "listItemPrefixWhitespace")
            ;
          else {
            atMarker = void 0;
          }
          if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
            if (listItem3) {
              let tailIndex = index2;
              lineIndex = void 0;
              while (tailIndex--) {
                const tailEvent = events[tailIndex];
                if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
                  if (tailEvent[0] === "exit")
                    continue;
                  if (lineIndex) {
                    events[lineIndex][1].type = "lineEndingBlank";
                    listSpread = true;
                  }
                  tailEvent[1].type = "lineEnding";
                  lineIndex = tailIndex;
                } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent")
                  ;
                else {
                  break;
                }
              }
              if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
                listItem3._spread = true;
              }
              listItem3.end = Object.assign(
                {},
                lineIndex ? events[lineIndex][1].start : event[1].end
              );
              events.splice(lineIndex || index2, 0, ["exit", listItem3, event[2]]);
              index2++;
              length2++;
            }
            if (event[1].type === "listItemPrefix") {
              listItem3 = {
                type: "listItem",
                // @ts-expect-error Patched
                _spread: false,
                start: Object.assign({}, event[1].start)
              };
              events.splice(index2, 0, ["enter", listItem3, event[2]]);
              index2++;
              length2++;
              firstBlankLineIndex = void 0;
              atMarker = true;
            }
          }
        }
        events[start][1]._spread = listSpread;
        return length2;
      }
      function setData(key, value) {
        data[key] = value;
      }
      function getData(key) {
        return data[key];
      }
      function point2(d2) {
        return {
          line: d2.line,
          column: d2.column,
          offset: d2.offset
        };
      }
      function opener(create2, and) {
        return open;
        function open(token2) {
          enter.call(this, create2(token2), token2);
          if (and)
            and.call(this, token2);
        }
      }
      function buffer() {
        this.stack.push({
          type: "fragment",
          children: []
        });
      }
      function enter(node2, token2, errorHandler) {
        const parent = this.stack[this.stack.length - 1];
        parent.children.push(node2);
        this.stack.push(node2);
        this.tokenStack.push([token2, errorHandler]);
        node2.position = {
          start: point2(token2.start)
        };
        return node2;
      }
      function closer(and) {
        return close;
        function close(token2) {
          if (and)
            and.call(this, token2);
          exit2.call(this, token2);
        }
      }
      function exit2(token2, onExitError) {
        const node2 = this.stack.pop();
        const open = this.tokenStack.pop();
        if (!open) {
          throw new Error(
            "Cannot close `" + token2.type + "` (" + stringifyPosition({
              start: token2.start,
              end: token2.end
            }) + "): it’s not open"
          );
        } else if (open[0].type !== token2.type) {
          if (onExitError) {
            onExitError.call(this, token2, open[0]);
          } else {
            const handler = open[1] || defaultOnError;
            handler.call(this, token2, open[0]);
          }
        }
        node2.position.end = point2(token2.end);
        return node2;
      }
      function resume() {
        return toString(this.stack.pop());
      }
      function onenterlistordered() {
        setData("expectingFirstListItemValue", true);
      }
      function onenterlistitemvalue(token2) {
        if (getData("expectingFirstListItemValue")) {
          const ancestor = (
            /** @type {List} */
            this.stack[this.stack.length - 2]
          );
          ancestor.start = Number.parseInt(this.sliceSerialize(token2), 10);
          setData("expectingFirstListItemValue");
        }
      }
      function onexitcodefencedfenceinfo() {
        const data2 = this.resume();
        const node2 = (
          /** @type {Code} */
          this.stack[this.stack.length - 1]
        );
        node2.lang = data2;
      }
      function onexitcodefencedfencemeta() {
        const data2 = this.resume();
        const node2 = (
          /** @type {Code} */
          this.stack[this.stack.length - 1]
        );
        node2.meta = data2;
      }
      function onexitcodefencedfence() {
        if (getData("flowCodeInside"))
          return;
        this.buffer();
        setData("flowCodeInside", true);
      }
      function onexitcodefenced() {
        const data2 = this.resume();
        const node2 = (
          /** @type {Code} */
          this.stack[this.stack.length - 1]
        );
        node2.value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
        setData("flowCodeInside");
      }
      function onexitcodeindented() {
        const data2 = this.resume();
        const node2 = (
          /** @type {Code} */
          this.stack[this.stack.length - 1]
        );
        node2.value = data2.replace(/(\r?\n|\r)$/g, "");
      }
      function onexitdefinitionlabelstring(token2) {
        const label = this.resume();
        const node2 = (
          /** @type {Definition} */
          this.stack[this.stack.length - 1]
        );
        node2.label = label;
        node2.identifier = normalizeIdentifier(
          this.sliceSerialize(token2)
        ).toLowerCase();
      }
      function onexitdefinitiontitlestring() {
        const data2 = this.resume();
        const node2 = (
          /** @type {Definition} */
          this.stack[this.stack.length - 1]
        );
        node2.title = data2;
      }
      function onexitdefinitiondestinationstring() {
        const data2 = this.resume();
        const node2 = (
          /** @type {Definition} */
          this.stack[this.stack.length - 1]
        );
        node2.url = data2;
      }
      function onexitatxheadingsequence(token2) {
        const node2 = (
          /** @type {Heading} */
          this.stack[this.stack.length - 1]
        );
        if (!node2.depth) {
          const depth = this.sliceSerialize(token2).length;
          node2.depth = depth;
        }
      }
      function onexitsetextheadingtext() {
        setData("setextHeadingSlurpLineEnding", true);
      }
      function onexitsetextheadinglinesequence(token2) {
        const node2 = (
          /** @type {Heading} */
          this.stack[this.stack.length - 1]
        );
        node2.depth = this.sliceSerialize(token2).charCodeAt(0) === 61 ? 1 : 2;
      }
      function onexitsetextheading() {
        setData("setextHeadingSlurpLineEnding");
      }
      function onenterdata(token2) {
        const parent = (
          /** @type {Parent} */
          this.stack[this.stack.length - 1]
        );
        let tail = parent.children[parent.children.length - 1];
        if (!tail || tail.type !== "text") {
          tail = text2();
          tail.position = {
            start: point2(token2.start)
          };
          parent.children.push(tail);
        }
        this.stack.push(tail);
      }
      function onexitdata(token2) {
        const tail = this.stack.pop();
        tail.value += this.sliceSerialize(token2);
        tail.position.end = point2(token2.end);
      }
      function onexitlineending(token2) {
        const context = this.stack[this.stack.length - 1];
        if (getData("atHardBreak")) {
          const tail = context.children[context.children.length - 1];
          tail.position.end = point2(token2.end);
          setData("atHardBreak");
          return;
        }
        if (!getData("setextHeadingSlurpLineEnding") && config2.canContainEols.includes(context.type)) {
          onenterdata.call(this, token2);
          onexitdata.call(this, token2);
        }
      }
      function onexithardbreak() {
        setData("atHardBreak", true);
      }
      function onexithtmlflow() {
        const data2 = this.resume();
        const node2 = (
          /** @type {HTML} */
          this.stack[this.stack.length - 1]
        );
        node2.value = data2;
      }
      function onexithtmltext() {
        const data2 = this.resume();
        const node2 = (
          /** @type {HTML} */
          this.stack[this.stack.length - 1]
        );
        node2.value = data2;
      }
      function onexitcodetext() {
        const data2 = this.resume();
        const node2 = (
          /** @type {InlineCode} */
          this.stack[this.stack.length - 1]
        );
        node2.value = data2;
      }
      function onexitlink() {
        const context = (
          /** @type {Link & {identifier: string, label: string}} */
          this.stack[this.stack.length - 1]
        );
        if (getData("inReference")) {
          context.type += "Reference";
          context.referenceType = getData("referenceType") || "shortcut";
          delete context.url;
          delete context.title;
        } else {
          delete context.identifier;
          delete context.label;
        }
        setData("referenceType");
      }
      function onexitimage() {
        const context = (
          /** @type {Image & {identifier: string, label: string}} */
          this.stack[this.stack.length - 1]
        );
        if (getData("inReference")) {
          context.type += "Reference";
          context.referenceType = getData("referenceType") || "shortcut";
          delete context.url;
          delete context.title;
        } else {
          delete context.identifier;
          delete context.label;
        }
        setData("referenceType");
      }
      function onexitlabeltext(token2) {
        const ancestor = (
          /** @type {(Link|Image) & {identifier: string, label: string}} */
          this.stack[this.stack.length - 2]
        );
        const string2 = this.sliceSerialize(token2);
        ancestor.label = decodeString(string2);
        ancestor.identifier = normalizeIdentifier(string2).toLowerCase();
      }
      function onexitlabel() {
        const fragment2 = (
          /** @type {Fragment} */
          this.stack[this.stack.length - 1]
        );
        const value = this.resume();
        const node2 = (
          /** @type {(Link|Image) & {identifier: string, label: string}} */
          this.stack[this.stack.length - 1]
        );
        setData("inReference", true);
        if (node2.type === "link") {
          node2.children = fragment2.children;
        } else {
          node2.alt = value;
        }
      }
      function onexitresourcedestinationstring() {
        const data2 = this.resume();
        const node2 = (
          /** @type {Link|Image} */
          this.stack[this.stack.length - 1]
        );
        node2.url = data2;
      }
      function onexitresourcetitlestring() {
        const data2 = this.resume();
        const node2 = (
          /** @type {Link|Image} */
          this.stack[this.stack.length - 1]
        );
        node2.title = data2;
      }
      function onexitresource() {
        setData("inReference");
      }
      function onenterreference() {
        setData("referenceType", "collapsed");
      }
      function onexitreferencestring(token2) {
        const label = this.resume();
        const node2 = (
          /** @type {LinkReference|ImageReference} */
          this.stack[this.stack.length - 1]
        );
        node2.label = label;
        node2.identifier = normalizeIdentifier(
          this.sliceSerialize(token2)
        ).toLowerCase();
        setData("referenceType", "full");
      }
      function onexitcharacterreferencemarker(token2) {
        setData("characterReferenceType", token2.type);
      }
      function onexitcharacterreferencevalue(token2) {
        const data2 = this.sliceSerialize(token2);
        const type = getData("characterReferenceType");
        let value;
        if (type) {
          value = decodeNumericCharacterReference(
            data2,
            type === "characterReferenceMarkerNumeric" ? 10 : 16
          );
          setData("characterReferenceType");
        } else {
          value = decodeNamedCharacterReference(data2);
        }
        const tail = this.stack.pop();
        tail.value += value;
        tail.position.end = point2(token2.end);
      }
      function onexitautolinkprotocol(token2) {
        onexitdata.call(this, token2);
        const node2 = (
          /** @type {Link} */
          this.stack[this.stack.length - 1]
        );
        node2.url = this.sliceSerialize(token2);
      }
      function onexitautolinkemail(token2) {
        onexitdata.call(this, token2);
        const node2 = (
          /** @type {Link} */
          this.stack[this.stack.length - 1]
        );
        node2.url = "mailto:" + this.sliceSerialize(token2);
      }
      function blockQuote2() {
        return {
          type: "blockquote",
          children: []
        };
      }
      function codeFlow() {
        return {
          type: "code",
          lang: null,
          meta: null,
          value: ""
        };
      }
      function codeText2() {
        return {
          type: "inlineCode",
          value: ""
        };
      }
      function definition2() {
        return {
          type: "definition",
          identifier: "",
          label: null,
          title: null,
          url: ""
        };
      }
      function emphasis2() {
        return {
          type: "emphasis",
          children: []
        };
      }
      function heading2() {
        return {
          type: "heading",
          depth: void 0,
          children: []
        };
      }
      function hardBreak2() {
        return {
          type: "break"
        };
      }
      function html2() {
        return {
          type: "html",
          value: ""
        };
      }
      function image2() {
        return {
          type: "image",
          title: null,
          url: "",
          alt: null
        };
      }
      function link2() {
        return {
          type: "link",
          title: null,
          url: "",
          children: []
        };
      }
      function list2(token2) {
        return {
          type: "list",
          ordered: token2.type === "listOrdered",
          start: null,
          // @ts-expect-error Patched.
          spread: token2._spread,
          children: []
        };
      }
      function listItem2(token2) {
        return {
          type: "listItem",
          // @ts-expect-error Patched.
          spread: token2._spread,
          checked: null,
          children: []
        };
      }
      function paragraph2() {
        return {
          type: "paragraph",
          children: []
        };
      }
      function strong2() {
        return {
          type: "strong",
          children: []
        };
      }
      function text2() {
        return {
          type: "text",
          value: ""
        };
      }
      function thematicBreak2() {
        return {
          type: "thematicBreak"
        };
      }
    }
    function configure$1(combined, extensions) {
      let index2 = -1;
      while (++index2 < extensions.length) {
        const value = extensions[index2];
        if (Array.isArray(value)) {
          configure$1(combined, value);
        } else {
          extension$2(combined, value);
        }
      }
      return combined;
    }
    function extension$2(combined, extension2) {
      let key;
      for (key in extension2) {
        if (own$d.call(extension2, key)) {
          const list2 = key === "canContainEols" || key === "transforms";
          const maybe = own$d.call(combined, key) ? combined[key] : void 0;
          const left = maybe || (combined[key] = list2 ? [] : {});
          const right = extension2[key];
          if (right) {
            if (list2) {
              combined[key] = [...left, ...right];
            } else {
              Object.assign(left, right);
            }
          }
        }
      }
    }
    function defaultOnError(left, right) {
      if (left) {
        throw new Error(
          "Cannot close `" + left.type + "` (" + stringifyPosition({
            start: left.start,
            end: left.end
          }) + "): a different token (`" + right.type + "`, " + stringifyPosition({
            start: right.start,
            end: right.end
          }) + ") is open"
        );
      } else {
        throw new Error(
          "Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({
            start: right.start,
            end: right.end
          }) + ") is still open"
        );
      }
    }
    function remarkParse(options) {
      const parser2 = (doc) => {
        const settings = (
          /** @type {Options} */
          this.data("settings")
        );
        return fromMarkdown$6(
          doc,
          Object.assign({}, settings, options, {
            // Note: these options are not in the readme.
            // The goal is for them to be set by plugins on `data` instead of being
            // passed by users.
            extensions: this.data("micromarkExtensions") || [],
            mdastExtensions: this.data("fromMarkdownExtensions") || []
          })
        );
      };
      Object.assign(this, { Parser: parser2 });
    }
    function blockquote(state, node2) {
      const result = {
        type: "element",
        tagName: "blockquote",
        properties: {},
        children: state.wrap(state.all(node2), true)
      };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function hardBreak(state, node2) {
      const result = { type: "element", tagName: "br", properties: {}, children: [] };
      state.patch(node2, result);
      return [state.applyData(node2, result), { type: "text", value: "\n" }];
    }
    function code$1(state, node2) {
      const value = node2.value ? node2.value + "\n" : "";
      const lang2 = node2.lang ? node2.lang.match(/^[^ \t]+(?=[ \t]|$)/) : null;
      const properties = {};
      if (lang2) {
        properties.className = ["language-" + lang2];
      }
      let result = {
        type: "element",
        tagName: "code",
        properties,
        children: [{ type: "text", value }]
      };
      if (node2.meta) {
        result.data = { meta: node2.meta };
      }
      state.patch(node2, result);
      result = state.applyData(node2, result);
      result = { type: "element", tagName: "pre", properties: {}, children: [result] };
      state.patch(node2, result);
      return result;
    }
    function strikethrough$3(state, node2) {
      const result = {
        type: "element",
        tagName: "del",
        properties: {},
        children: state.all(node2)
      };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function emphasis(state, node2) {
      const result = {
        type: "element",
        tagName: "em",
        properties: {},
        children: state.all(node2)
      };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function normalizeUri(value) {
      const result = [];
      let index2 = -1;
      let start = 0;
      let skip = 0;
      while (++index2 < value.length) {
        const code2 = value.charCodeAt(index2);
        let replace2 = "";
        if (code2 === 37 && asciiAlphanumeric$2(value.charCodeAt(index2 + 1)) && asciiAlphanumeric$2(value.charCodeAt(index2 + 2))) {
          skip = 2;
        } else if (code2 < 128) {
          if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code2))) {
            replace2 = String.fromCharCode(code2);
          }
        } else if (code2 > 55295 && code2 < 57344) {
          const next2 = value.charCodeAt(index2 + 1);
          if (code2 < 56320 && next2 > 56319 && next2 < 57344) {
            replace2 = String.fromCharCode(code2, next2);
            skip = 1;
          } else {
            replace2 = "�";
          }
        } else {
          replace2 = String.fromCharCode(code2);
        }
        if (replace2) {
          result.push(value.slice(start, index2), encodeURIComponent(replace2));
          start = index2 + skip + 1;
          replace2 = "";
        }
        if (skip) {
          index2 += skip;
          skip = 0;
        }
      }
      return result.join("") + value.slice(start);
    }
    function footnoteReference(state, node2) {
      const id2 = String(node2.identifier).toUpperCase();
      const safeId = normalizeUri(id2.toLowerCase());
      const index2 = state.footnoteOrder.indexOf(id2);
      let counter;
      if (index2 === -1) {
        state.footnoteOrder.push(id2);
        state.footnoteCounts[id2] = 1;
        counter = state.footnoteOrder.length;
      } else {
        state.footnoteCounts[id2]++;
        counter = index2 + 1;
      }
      const reuseCounter = state.footnoteCounts[id2];
      const link2 = {
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + state.clobberPrefix + "fn-" + safeId,
          id: state.clobberPrefix + "fnref-" + safeId + (reuseCounter > 1 ? "-" + reuseCounter : ""),
          dataFootnoteRef: true,
          ariaDescribedBy: ["footnote-label"]
        },
        children: [{ type: "text", value: String(counter) }]
      };
      state.patch(node2, link2);
      const sup = {
        type: "element",
        tagName: "sup",
        properties: {},
        children: [link2]
      };
      state.patch(node2, sup);
      return state.applyData(node2, sup);
    }
    function footnote(state, node2) {
      const footnoteById = state.footnoteById;
      let no = 1;
      while (no in footnoteById)
        no++;
      const identifier2 = String(no);
      footnoteById[identifier2] = {
        type: "footnoteDefinition",
        identifier: identifier2,
        children: [{ type: "paragraph", children: node2.children }],
        position: node2.position
      };
      return footnoteReference(state, {
        type: "footnoteReference",
        identifier: identifier2,
        position: node2.position
      });
    }
    function heading(state, node2) {
      const result = {
        type: "element",
        tagName: "h" + node2.depth,
        properties: {},
        children: state.all(node2)
      };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function html$3(state, node2) {
      if (state.dangerous) {
        const result = { type: "raw", value: node2.value };
        state.patch(node2, result);
        return state.applyData(node2, result);
      }
      return null;
    }
    function revert(state, node2) {
      const subtype = node2.referenceType;
      let suffix = "]";
      if (subtype === "collapsed") {
        suffix += "[]";
      } else if (subtype === "full") {
        suffix += "[" + (node2.label || node2.identifier) + "]";
      }
      if (node2.type === "imageReference") {
        return { type: "text", value: "![" + node2.alt + suffix };
      }
      const contents = state.all(node2);
      const head = contents[0];
      if (head && head.type === "text") {
        head.value = "[" + head.value;
      } else {
        contents.unshift({ type: "text", value: "[" });
      }
      const tail = contents[contents.length - 1];
      if (tail && tail.type === "text") {
        tail.value += suffix;
      } else {
        contents.push({ type: "text", value: suffix });
      }
      return contents;
    }
    function imageReference(state, node2) {
      const def = state.definition(node2.identifier);
      if (!def) {
        return revert(state, node2);
      }
      const properties = { src: normalizeUri(def.url || ""), alt: node2.alt };
      if (def.title !== null && def.title !== void 0) {
        properties.title = def.title;
      }
      const result = { type: "element", tagName: "img", properties, children: [] };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function image(state, node2) {
      const properties = { src: normalizeUri(node2.url) };
      if (node2.alt !== null && node2.alt !== void 0) {
        properties.alt = node2.alt;
      }
      if (node2.title !== null && node2.title !== void 0) {
        properties.title = node2.title;
      }
      const result = { type: "element", tagName: "img", properties, children: [] };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function inlineCode$1(state, node2) {
      const text2 = { type: "text", value: node2.value.replace(/\r?\n|\r/g, " ") };
      state.patch(node2, text2);
      const result = {
        type: "element",
        tagName: "code",
        properties: {},
        children: [text2]
      };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function linkReference(state, node2) {
      const def = state.definition(node2.identifier);
      if (!def) {
        return revert(state, node2);
      }
      const properties = { href: normalizeUri(def.url || "") };
      if (def.title !== null && def.title !== void 0) {
        properties.title = def.title;
      }
      const result = {
        type: "element",
        tagName: "a",
        properties,
        children: state.all(node2)
      };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function link(state, node2) {
      const properties = { href: normalizeUri(node2.url) };
      if (node2.title !== null && node2.title !== void 0) {
        properties.title = node2.title;
      }
      const result = {
        type: "element",
        tagName: "a",
        properties,
        children: state.all(node2)
      };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function listItem$1(state, node2, parent) {
      const results = state.all(node2);
      const loose = parent ? listLoose(parent) : listItemLoose(node2);
      const properties = {};
      const children = [];
      if (typeof node2.checked === "boolean") {
        const head = results[0];
        let paragraph2;
        if (head && head.type === "element" && head.tagName === "p") {
          paragraph2 = head;
        } else {
          paragraph2 = { type: "element", tagName: "p", properties: {}, children: [] };
          results.unshift(paragraph2);
        }
        if (paragraph2.children.length > 0) {
          paragraph2.children.unshift({ type: "text", value: " " });
        }
        paragraph2.children.unshift({
          type: "element",
          tagName: "input",
          properties: { type: "checkbox", checked: node2.checked, disabled: true },
          children: []
        });
        properties.className = ["task-list-item"];
      }
      let index2 = -1;
      while (++index2 < results.length) {
        const child = results[index2];
        if (loose || index2 !== 0 || child.type !== "element" || child.tagName !== "p") {
          children.push({ type: "text", value: "\n" });
        }
        if (child.type === "element" && child.tagName === "p" && !loose) {
          children.push(...child.children);
        } else {
          children.push(child);
        }
      }
      const tail = results[results.length - 1];
      if (tail && (loose || tail.type !== "element" || tail.tagName !== "p")) {
        children.push({ type: "text", value: "\n" });
      }
      const result = { type: "element", tagName: "li", properties, children };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function listLoose(node2) {
      let loose = false;
      if (node2.type === "list") {
        loose = node2.spread || false;
        const children = node2.children;
        let index2 = -1;
        while (!loose && ++index2 < children.length) {
          loose = listItemLoose(children[index2]);
        }
      }
      return loose;
    }
    function listItemLoose(node2) {
      const spread2 = node2.spread;
      return spread2 === void 0 || spread2 === null ? node2.children.length > 1 : spread2;
    }
    function list(state, node2) {
      const properties = {};
      const results = state.all(node2);
      let index2 = -1;
      if (typeof node2.start === "number" && node2.start !== 1) {
        properties.start = node2.start;
      }
      while (++index2 < results.length) {
        const child = results[index2];
        if (child.type === "element" && child.tagName === "li" && child.properties && Array.isArray(child.properties.className) && child.properties.className.includes("task-list-item")) {
          properties.className = ["contains-task-list"];
          break;
        }
      }
      const result = {
        type: "element",
        tagName: node2.ordered ? "ol" : "ul",
        properties,
        children: state.wrap(results, true)
      };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function paragraph(state, node2) {
      const result = {
        type: "element",
        tagName: "p",
        properties: {},
        children: state.all(node2)
      };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function root$3(state, node2) {
      const result = { type: "root", children: state.wrap(state.all(node2)) };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function strong(state, node2) {
      const result = {
        type: "element",
        tagName: "strong",
        properties: {},
        children: state.all(node2)
      };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    var pointStart = point$1("start");
    var pointEnd = point$1("end");
    function position$1(node2) {
      return { start: pointStart(node2), end: pointEnd(node2) };
    }
    function point$1(type) {
      return point2;
      function point2(node2) {
        var point3 = node2 && node2.position && node2.position[type] || {};
        return {
          line: point3.line || null,
          column: point3.column || null,
          offset: point3.offset > -1 ? point3.offset : null
        };
      }
    }
    function table$3(state, node2) {
      const rows = state.all(node2);
      const firstRow = rows.shift();
      const tableContent = [];
      if (firstRow) {
        const head = {
          type: "element",
          tagName: "thead",
          properties: {},
          children: state.wrap([firstRow], true)
        };
        state.patch(node2.children[0], head);
        tableContent.push(head);
      }
      if (rows.length > 0) {
        const body = {
          type: "element",
          tagName: "tbody",
          properties: {},
          children: state.wrap(rows, true)
        };
        const start = pointStart(node2.children[1]);
        const end = pointEnd(node2.children[node2.children.length - 1]);
        if (start.line && end.line)
          body.position = { start, end };
        tableContent.push(body);
      }
      const result = {
        type: "element",
        tagName: "table",
        properties: {},
        children: state.wrap(tableContent, true)
      };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function tableRow(state, node2, parent) {
      const siblings = parent ? parent.children : void 0;
      const rowIndex = siblings ? siblings.indexOf(node2) : 1;
      const tagName = rowIndex === 0 ? "th" : "td";
      const align = parent && parent.type === "table" ? parent.align : void 0;
      const length2 = align ? align.length : node2.children.length;
      let cellIndex = -1;
      const cells = [];
      while (++cellIndex < length2) {
        const cell = node2.children[cellIndex];
        const properties = {};
        const alignValue = align ? align[cellIndex] : void 0;
        if (alignValue) {
          properties.align = alignValue;
        }
        let result2 = { type: "element", tagName, properties, children: [] };
        if (cell) {
          result2.children = state.all(cell);
          state.patch(cell, result2);
          result2 = state.applyData(node2, result2);
        }
        cells.push(result2);
      }
      const result = {
        type: "element",
        tagName: "tr",
        properties: {},
        children: state.wrap(cells, true)
      };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function tableCell(state, node2) {
      const result = {
        type: "element",
        tagName: "td",
        // Assume body cell.
        properties: {},
        children: state.all(node2)
      };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    const tab = 9;
    const space$1 = 32;
    function trimLines(value) {
      const source = String(value);
      const search2 = /\r?\n|\r/g;
      let match5 = search2.exec(source);
      let last = 0;
      const lines = [];
      while (match5) {
        lines.push(
          trimLine(source.slice(last, match5.index), last > 0, true),
          match5[0]
        );
        last = match5.index + match5[0].length;
        match5 = search2.exec(source);
      }
      lines.push(trimLine(source.slice(last), last > 0, false));
      return lines.join("");
    }
    function trimLine(value, start, end) {
      let startIndex = 0;
      let endIndex = value.length;
      if (start) {
        let code2 = value.codePointAt(startIndex);
        while (code2 === tab || code2 === space$1) {
          startIndex++;
          code2 = value.codePointAt(startIndex);
        }
      }
      if (end) {
        let code2 = value.codePointAt(endIndex - 1);
        while (code2 === tab || code2 === space$1) {
          endIndex--;
          code2 = value.codePointAt(endIndex - 1);
        }
      }
      return endIndex > startIndex ? value.slice(startIndex, endIndex) : "";
    }
    function text$4(state, node2) {
      const result = { type: "text", value: trimLines(String(node2.value)) };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function thematicBreak(state, node2) {
      const result = {
        type: "element",
        tagName: "hr",
        properties: {},
        children: []
      };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    const handlers = {
      blockquote,
      break: hardBreak,
      code: code$1,
      delete: strikethrough$3,
      emphasis,
      footnoteReference,
      footnote,
      heading,
      html: html$3,
      imageReference,
      image,
      inlineCode: inlineCode$1,
      linkReference,
      link,
      listItem: listItem$1,
      list,
      paragraph,
      root: root$3,
      strong,
      table: table$3,
      tableCell,
      tableRow,
      text: text$4,
      thematicBreak,
      toml: ignore,
      yaml: ignore,
      definition: ignore,
      footnoteDefinition: ignore
    };
    function ignore() {
      return null;
    }
    const convert = (
      /**
       * @type {(
       *   (<T extends Node>(test: T['type']|Partial<T>|TestFunctionPredicate<T>) => AssertPredicate<T>) &
       *   ((test?: Test) => AssertAnything)
       * )}
       */
      /**
       * Generate an assertion from a check.
       * @param {Test} [test]
       * When nullish, checks if `node` is a `Node`.
       * When `string`, works like passing `function (node) {return node.type === test}`.
       * When `function` checks if function passed the node is true.
       * When `object`, checks that all keys in test are in node, and that they have (strictly) equal values.
       * When `array`, checks any one of the subtests pass.
       * @returns {AssertAnything}
       */
      function(test) {
        if (test === void 0 || test === null) {
          return ok;
        }
        if (typeof test === "string") {
          return typeFactory(test);
        }
        if (typeof test === "object") {
          return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
        }
        if (typeof test === "function") {
          return castFactory(test);
        }
        throw new Error("Expected function, string, or object as test");
      }
    );
    function anyFactory(tests) {
      const checks2 = [];
      let index2 = -1;
      while (++index2 < tests.length) {
        checks2[index2] = convert(tests[index2]);
      }
      return castFactory(any);
      function any(...parameters) {
        let index3 = -1;
        while (++index3 < checks2.length) {
          if (checks2[index3].call(this, ...parameters))
            return true;
        }
        return false;
      }
    }
    function propsFactory(check2) {
      return castFactory(all2);
      function all2(node2) {
        let key;
        for (key in check2) {
          if (node2[key] !== check2[key])
            return false;
        }
        return true;
      }
    }
    function typeFactory(check2) {
      return castFactory(type);
      function type(node2) {
        return node2 && node2.type === check2;
      }
    }
    function castFactory(check2) {
      return assertion;
      function assertion(...parameters) {
        return Boolean(check2.call(this, ...parameters));
      }
    }
    function ok() {
      return true;
    }
    function color$1(d2) {
      return d2;
    }
    const CONTINUE$1 = true;
    const SKIP$1 = "skip";
    const EXIT$1 = false;
    const visitParents$1 = (
      /**
       * @type {(
       *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: Visitor<import('./complex-types').Matches<import('./complex-types').InclusiveDescendant<Tree>, Check>>, reverse?: boolean) => void) &
       *   (<Tree extends Node>(tree: Tree, visitor: Visitor<import('./complex-types').InclusiveDescendant<Tree>>, reverse?: boolean) => void)
       * )}
       */
      /**
       * @param {Node} tree
       * @param {Test} test
       * @param {Visitor<Node>} visitor
       * @param {boolean} [reverse]
       */
      function(tree, test, visitor, reverse) {
        if (typeof test === "function" && typeof visitor !== "function") {
          reverse = visitor;
          visitor = test;
          test = null;
        }
        const is2 = convert(test);
        const step = reverse ? -1 : 1;
        factory(tree, null, [])();
        function factory(node2, index2, parents) {
          const value = typeof node2 === "object" && node2 !== null ? node2 : {};
          let name2;
          if (typeof value.type === "string") {
            name2 = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : void 0;
            Object.defineProperty(visit2, "name", {
              value: "node (" + color$1(value.type + (name2 ? "<" + name2 + ">" : "")) + ")"
            });
          }
          return visit2;
          function visit2() {
            let result = [];
            let subresult;
            let offset2;
            let grandparents;
            if (!test || is2(node2, index2, parents[parents.length - 1] || null)) {
              result = toResult$1(visitor(node2, parents));
              if (result[0] === EXIT$1) {
                return result;
              }
            }
            if (node2.children && result[0] !== SKIP$1) {
              offset2 = (reverse ? node2.children.length : -1) + step;
              grandparents = parents.concat(node2);
              while (offset2 > -1 && offset2 < node2.children.length) {
                subresult = factory(node2.children[offset2], offset2, grandparents)();
                if (subresult[0] === EXIT$1) {
                  return subresult;
                }
                offset2 = typeof subresult[1] === "number" ? subresult[1] : offset2 + step;
              }
            }
            return result;
          }
        }
      }
    );
    function toResult$1(value) {
      if (Array.isArray(value)) {
        return value;
      }
      if (typeof value === "number") {
        return [CONTINUE$1, value];
      }
      return [value];
    }
    const visit$1 = (
      /**
       * @type {(
       *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: Visitor<import('unist-util-visit-parents/complex-types').Matches<import('unist-util-visit-parents/complex-types').InclusiveDescendant<Tree>, Check>>, reverse?: boolean) => void) &
       *   (<Tree extends Node>(tree: Tree, visitor: Visitor<import('unist-util-visit-parents/complex-types').InclusiveDescendant<Tree>>, reverse?: boolean) => void)
       * )}
       */
      /**
       * @param {Node} tree
       * @param {Test} test
       * @param {Visitor<Node>} visitor
       * @param {boolean} [reverse]
       */
      function(tree, test, visitor, reverse) {
        if (typeof test === "function" && typeof visitor !== "function") {
          reverse = visitor;
          visitor = test;
          test = null;
        }
        visitParents$1(tree, test, overload, reverse);
        function overload(node2, parents) {
          const parent = parents[parents.length - 1];
          return visitor(
            node2,
            parent ? parent.children.indexOf(node2) : null,
            parent
          );
        }
      }
    );
    function generated(node2) {
      return !node2 || !node2.position || !node2.position.start || !node2.position.start.line || !node2.position.start.column || !node2.position.end || !node2.position.end.line || !node2.position.end.column;
    }
    function color(d2) {
      return d2;
    }
    const CONTINUE = true;
    const SKIP = "skip";
    const EXIT = false;
    const visitParents = (
      /**
       * @type {(
       *   (<T extends Node>(tree: Node, test: T['type']|Partial<T>|import('unist-util-is').TestFunctionPredicate<T>|Array.<T['type']|Partial<T>|import('unist-util-is').TestFunctionPredicate<T>>, visitor: Visitor<T>, reverse?: boolean) => void) &
       *   ((tree: Node, test: Test, visitor: Visitor<Node>, reverse?: boolean) => void) &
       *   ((tree: Node, visitor: Visitor<Node>, reverse?: boolean) => void)
       * )}
       */
      /**
       * Visit children of tree which pass a test
       *
       * @param {Node} tree Abstract syntax tree to walk
       * @param {Test} test test Test node
       * @param {Visitor<Node>} visitor Function to run for each node
       * @param {boolean} [reverse] Fisit the tree in reverse, defaults to false
       */
      function(tree, test, visitor, reverse) {
        if (typeof test === "function" && typeof visitor !== "function") {
          reverse = visitor;
          visitor = test;
          test = null;
        }
        var is2 = convert(test);
        var step = reverse ? -1 : 1;
        factory(tree, null, [])();
        function factory(node2, index2, parents) {
          var value = typeof node2 === "object" && node2 !== null ? node2 : {};
          var name2;
          if (typeof value.type === "string") {
            name2 = typeof value.tagName === "string" ? value.tagName : typeof value.name === "string" ? value.name : void 0;
            Object.defineProperty(visit2, "name", {
              value: "node (" + color(value.type + (name2 ? "<" + name2 + ">" : "")) + ")"
            });
          }
          return visit2;
          function visit2() {
            var result = [];
            var subresult;
            var offset2;
            var grandparents;
            if (!test || is2(node2, index2, parents[parents.length - 1] || null)) {
              result = toResult(visitor(node2, parents));
              if (result[0] === EXIT) {
                return result;
              }
            }
            if (node2.children && result[0] !== SKIP) {
              offset2 = (reverse ? node2.children.length : -1) + step;
              grandparents = parents.concat(node2);
              while (offset2 > -1 && offset2 < node2.children.length) {
                subresult = factory(node2.children[offset2], offset2, grandparents)();
                if (subresult[0] === EXIT) {
                  return subresult;
                }
                offset2 = typeof subresult[1] === "number" ? subresult[1] : offset2 + step;
              }
            }
            return result;
          }
        }
      }
    );
    function toResult(value) {
      if (Array.isArray(value)) {
        return value;
      }
      if (typeof value === "number") {
        return [CONTINUE, value];
      }
      return [value];
    }
    const visit = (
      /**
       * @type {(
       *   (<T extends Node>(tree: Node, test: T['type']|Partial<T>|import('unist-util-is').TestFunctionPredicate<T>|Array.<T['type']|Partial<T>|import('unist-util-is').TestFunctionPredicate<T>>, visitor: Visitor<T>, reverse?: boolean) => void) &
       *   ((tree: Node, test: Test, visitor: Visitor<Node>, reverse?: boolean) => void) &
       *   ((tree: Node, visitor: Visitor<Node>, reverse?: boolean) => void)
       * )}
       */
      /**
       * Visit children of tree which pass a test
       *
       * @param {Node} tree Abstract syntax tree to walk
       * @param {Test} test test Test node
       * @param {Visitor<Node>} visitor Function to run for each node
       * @param {boolean} [reverse] Fisit the tree in reverse, defaults to false
       */
      function(tree, test, visitor, reverse) {
        if (typeof test === "function" && typeof visitor !== "function") {
          reverse = visitor;
          visitor = test;
          test = null;
        }
        visitParents(tree, test, overload, reverse);
        function overload(node2, parents) {
          var parent = parents[parents.length - 1];
          return visitor(
            node2,
            parent ? parent.children.indexOf(node2) : null,
            parent
          );
        }
      }
    );
    const own$c = {}.hasOwnProperty;
    function definitions(node2) {
      const cache2 = /* @__PURE__ */ Object.create(null);
      if (!node2 || !node2.type) {
        throw new Error("mdast-util-definitions expected node");
      }
      visit(node2, "definition", ondefinition);
      return getDefinition;
      function ondefinition(definition2) {
        const id2 = clean(definition2.identifier);
        if (id2 && !own$c.call(cache2, id2)) {
          cache2[id2] = definition2;
        }
      }
      function getDefinition(identifier2) {
        const id2 = clean(identifier2);
        return id2 && own$c.call(cache2, id2) ? cache2[id2] : null;
      }
    }
    function clean(value) {
      return String(value || "").toUpperCase();
    }
    const own$b = {}.hasOwnProperty;
    function createState(tree, options) {
      const settings = options || {};
      const dangerous = settings.allowDangerousHtml || false;
      const footnoteById = {};
      state.dangerous = dangerous;
      state.clobberPrefix = settings.clobberPrefix === void 0 || settings.clobberPrefix === null ? "user-content-" : settings.clobberPrefix;
      state.footnoteLabel = settings.footnoteLabel || "Footnotes";
      state.footnoteLabelTagName = settings.footnoteLabelTagName || "h2";
      state.footnoteLabelProperties = settings.footnoteLabelProperties || {
        className: ["sr-only"]
      };
      state.footnoteBackLabel = settings.footnoteBackLabel || "Back to content";
      state.unknownHandler = settings.unknownHandler;
      state.passThrough = settings.passThrough;
      state.handlers = { ...handlers, ...settings.handlers };
      state.definition = definitions(tree);
      state.footnoteById = footnoteById;
      state.footnoteOrder = [];
      state.footnoteCounts = {};
      state.patch = patch$1;
      state.applyData = applyData;
      state.one = oneBound;
      state.all = allBound;
      state.wrap = wrap;
      state.augment = augment;
      visit$1(tree, "footnoteDefinition", (definition2) => {
        const id2 = String(definition2.identifier).toUpperCase();
        if (!own$b.call(footnoteById, id2)) {
          footnoteById[id2] = definition2;
        }
      });
      return state;
      function augment(left, right) {
        if (left && "data" in left && left.data) {
          const data = left.data;
          if (data.hName) {
            if (right.type !== "element") {
              right = {
                type: "element",
                tagName: "",
                properties: {},
                children: []
              };
            }
            right.tagName = data.hName;
          }
          if (right.type === "element" && data.hProperties) {
            right.properties = { ...right.properties, ...data.hProperties };
          }
          if ("children" in right && right.children && data.hChildren) {
            right.children = data.hChildren;
          }
        }
        if (left) {
          const ctx = "type" in left ? left : { position: left };
          if (!generated(ctx)) {
            right.position = { start: pointStart(ctx), end: pointEnd(ctx) };
          }
        }
        return right;
      }
      function state(node2, tagName, props, children) {
        if (Array.isArray(props)) {
          children = props;
          props = {};
        }
        return augment(node2, {
          type: "element",
          tagName,
          properties: props || {},
          children: children || []
        });
      }
      function oneBound(node2, parent) {
        return one$1(state, node2, parent);
      }
      function allBound(parent) {
        return all$1(state, parent);
      }
    }
    function patch$1(from2, to2) {
      if (from2.position)
        to2.position = position$1(from2);
    }
    function applyData(from2, to2) {
      let result = to2;
      if (from2 && from2.data) {
        const hName = from2.data.hName;
        const hChildren = from2.data.hChildren;
        const hProperties = from2.data.hProperties;
        if (typeof hName === "string") {
          if (result.type === "element") {
            result.tagName = hName;
          } else {
            result = {
              type: "element",
              tagName: hName,
              properties: {},
              children: []
            };
          }
        }
        if (result.type === "element" && hProperties) {
          result.properties = { ...result.properties, ...hProperties };
        }
        if ("children" in result && result.children && hChildren !== null && hChildren !== void 0) {
          result.children = hChildren;
        }
      }
      return result;
    }
    function one$1(state, node2, parent) {
      const type = node2 && node2.type;
      if (!type) {
        throw new Error("Expected node, got `" + node2 + "`");
      }
      if (own$b.call(state.handlers, type)) {
        return state.handlers[type](state, node2, parent);
      }
      if (state.passThrough && state.passThrough.includes(type)) {
        return "children" in node2 ? { ...node2, children: all$1(state, node2) } : node2;
      }
      if (state.unknownHandler) {
        return state.unknownHandler(state, node2, parent);
      }
      return defaultUnknownHandler(state, node2);
    }
    function all$1(state, parent) {
      const values = [];
      if ("children" in parent) {
        const nodes2 = parent.children;
        let index2 = -1;
        while (++index2 < nodes2.length) {
          const result = one$1(state, nodes2[index2], parent);
          if (result) {
            if (index2 && nodes2[index2 - 1].type === "break") {
              if (!Array.isArray(result) && result.type === "text") {
                result.value = result.value.replace(/^\s+/, "");
              }
              if (!Array.isArray(result) && result.type === "element") {
                const head = result.children[0];
                if (head && head.type === "text") {
                  head.value = head.value.replace(/^\s+/, "");
                }
              }
            }
            if (Array.isArray(result)) {
              values.push(...result);
            } else {
              values.push(result);
            }
          }
        }
      }
      return values;
    }
    function defaultUnknownHandler(state, node2) {
      const data = node2.data || {};
      const result = "value" in node2 && !(own$b.call(data, "hProperties") || own$b.call(data, "hChildren")) ? { type: "text", value: node2.value } : {
        type: "element",
        tagName: "div",
        properties: {},
        children: all$1(state, node2)
      };
      state.patch(node2, result);
      return state.applyData(node2, result);
    }
    function wrap(nodes2, loose) {
      const result = [];
      let index2 = -1;
      if (loose) {
        result.push({ type: "text", value: "\n" });
      }
      while (++index2 < nodes2.length) {
        if (index2)
          result.push({ type: "text", value: "\n" });
        result.push(nodes2[index2]);
      }
      if (loose && nodes2.length > 0) {
        result.push({ type: "text", value: "\n" });
      }
      return result;
    }
    function footer(state) {
      const listItems = [];
      let index2 = -1;
      while (++index2 < state.footnoteOrder.length) {
        const def = state.footnoteById[state.footnoteOrder[index2]];
        if (!def) {
          continue;
        }
        const content2 = state.all(def);
        const id2 = String(def.identifier).toUpperCase();
        const safeId = normalizeUri(id2.toLowerCase());
        let referenceIndex = 0;
        const backReferences = [];
        while (++referenceIndex <= state.footnoteCounts[id2]) {
          const backReference = {
            type: "element",
            tagName: "a",
            properties: {
              href: "#" + state.clobberPrefix + "fnref-" + safeId + (referenceIndex > 1 ? "-" + referenceIndex : ""),
              dataFootnoteBackref: true,
              className: ["data-footnote-backref"],
              ariaLabel: state.footnoteBackLabel
            },
            children: [{ type: "text", value: "↩" }]
          };
          if (referenceIndex > 1) {
            backReference.children.push({
              type: "element",
              tagName: "sup",
              children: [{ type: "text", value: String(referenceIndex) }]
            });
          }
          if (backReferences.length > 0) {
            backReferences.push({ type: "text", value: " " });
          }
          backReferences.push(backReference);
        }
        const tail = content2[content2.length - 1];
        if (tail && tail.type === "element" && tail.tagName === "p") {
          const tailTail = tail.children[tail.children.length - 1];
          if (tailTail && tailTail.type === "text") {
            tailTail.value += " ";
          } else {
            tail.children.push({ type: "text", value: " " });
          }
          tail.children.push(...backReferences);
        } else {
          content2.push(...backReferences);
        }
        const listItem2 = {
          type: "element",
          tagName: "li",
          properties: { id: state.clobberPrefix + "fn-" + safeId },
          children: state.wrap(content2, true)
        };
        state.patch(def, listItem2);
        listItems.push(listItem2);
      }
      if (listItems.length === 0) {
        return;
      }
      return {
        type: "element",
        tagName: "section",
        properties: { dataFootnotes: true, className: ["footnotes"] },
        children: [
          {
            type: "element",
            tagName: state.footnoteLabelTagName,
            properties: {
              // To do: use structured clone.
              ...JSON.parse(JSON.stringify(state.footnoteLabelProperties)),
              id: "footnote-label"
            },
            children: [{ type: "text", value: state.footnoteLabel }]
          },
          { type: "text", value: "\n" },
          {
            type: "element",
            tagName: "ol",
            properties: {},
            children: state.wrap(listItems, true)
          },
          { type: "text", value: "\n" }
        ]
      };
    }
    function toHast(tree, options) {
      const state = createState(tree, options);
      const node2 = state.one(tree, null);
      const foot = footer(state);
      if (foot) {
        node2.children.push({ type: "text", value: "\n" }, foot);
      }
      return Array.isArray(node2) ? { type: "root", children: node2 } : node2;
    }
    const remarkRehype = (
      /** @type {(import('unified').Plugin<[Processor, Options?]|[null|undefined, Options?]|[Options]|[], MdastRoot>)} */
      function(destination, options) {
        return destination && "run" in destination ? bridge(destination, options) : mutate(destination || options);
      }
    );
    const remarkRehype$1 = remarkRehype;
    function bridge(destination, options) {
      return (node2, file, next2) => {
        destination.run(toHast(node2, options), file, (error) => {
          next2(error);
        });
      };
    }
    function mutate(options) {
      return (node2) => toHast(node2, options);
    }
    class Schema {
      /**
       * @constructor
       * @param {Properties} property
       * @param {Normal} normal
       * @param {string} [space]
       */
      constructor(property, normal, space2) {
        this.property = property;
        this.normal = normal;
        if (space2) {
          this.space = space2;
        }
      }
    }
    Schema.prototype.property = {};
    Schema.prototype.normal = {};
    Schema.prototype.space = null;
    function merge(definitions2, space2) {
      var property = {};
      var normal = {};
      var index2 = -1;
      while (++index2 < definitions2.length) {
        Object.assign(property, definitions2[index2].property);
        Object.assign(normal, definitions2[index2].normal);
      }
      return new Schema(property, normal, space2);
    }
    function normalize(value) {
      return value.toLowerCase();
    }
    class Info {
      /**
       * @constructor
       * @param {string} property
       * @param {string} attribute
       */
      constructor(property, attribute) {
        this.property = property;
        this.attribute = attribute;
      }
    }
    Info.prototype.space = null;
    Info.prototype.attribute = null;
    Info.prototype.property = null;
    Info.prototype.boolean = false;
    Info.prototype.booleanish = false;
    Info.prototype.overloadedBoolean = false;
    Info.prototype.number = false;
    Info.prototype.commaSeparated = false;
    Info.prototype.spaceSeparated = false;
    Info.prototype.commaOrSpaceSeparated = false;
    Info.prototype.mustUseProperty = false;
    Info.prototype.defined = false;
    var powers = 0;
    var boolean = increment();
    var booleanish = increment();
    var overloadedBoolean = increment();
    var number = increment();
    var spaceSeparated = increment();
    var commaSeparated = increment();
    var commaOrSpaceSeparated = increment();
    function increment() {
      return 2 ** ++powers;
    }
    const types = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      boolean,
      booleanish,
      commaOrSpaceSeparated,
      commaSeparated,
      number,
      overloadedBoolean,
      spaceSeparated
    }, Symbol.toStringTag, { value: "Module" }));
    var checks = Object.keys(types);
    class DefinedInfo extends Info {
      /**
       * @constructor
       * @param {string} property
       * @param {string} attribute
       * @param {number} [mask]
       * @param {string} [space]
       */
      constructor(property, attribute, mask, space2) {
        var index2 = -1;
        super(property, attribute);
        mark(this, "space", space2);
        while (++index2 < checks.length) {
          mark(
            this,
            checks[index2],
            (mask & types[checks[index2]]) === types[checks[index2]]
          );
        }
      }
    }
    DefinedInfo.prototype.defined = true;
    function mark(values, key, value) {
      if (value) {
        values[key] = value;
      }
    }
    var own$a = {}.hasOwnProperty;
    function create$2(definition2) {
      var property = {};
      var normal = {};
      var prop;
      var info;
      for (prop in definition2.properties) {
        if (own$a.call(definition2.properties, prop)) {
          info = new DefinedInfo(
            prop,
            definition2.transform(definition2.attributes, prop),
            definition2.properties[prop],
            definition2.space
          );
          if (definition2.mustUseProperty && definition2.mustUseProperty.includes(prop)) {
            info.mustUseProperty = true;
          }
          property[prop] = info;
          normal[normalize(prop)] = prop;
          normal[normalize(info.attribute)] = prop;
        }
      }
      return new Schema(property, normal, definition2.space);
    }
    var xlink = create$2({
      space: "xlink",
      transform: xlinkTransform,
      properties: {
        xLinkActuate: null,
        xLinkArcRole: null,
        xLinkHref: null,
        xLinkRole: null,
        xLinkShow: null,
        xLinkTitle: null,
        xLinkType: null
      }
    });
    function xlinkTransform(_2, prop) {
      return "xlink:" + prop.slice(5).toLowerCase();
    }
    var xml = create$2({
      space: "xml",
      transform: xmlTransform,
      properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
    });
    function xmlTransform(_2, prop) {
      return "xml:" + prop.slice(3).toLowerCase();
    }
    function caseSensitiveTransform(attributes2, attribute) {
      return attribute in attributes2 ? attributes2[attribute] : attribute;
    }
    function caseInsensitiveTransform(attributes2, property) {
      return caseSensitiveTransform(attributes2, property.toLowerCase());
    }
    var xmlns = create$2({
      space: "xmlns",
      attributes: { xmlnsxlink: "xmlns:xlink" },
      transform: caseInsensitiveTransform,
      properties: { xmlns: null, xmlnsXLink: null }
    });
    var aria = create$2({
      transform: ariaTransform,
      properties: {
        ariaActiveDescendant: null,
        ariaAtomic: booleanish,
        ariaAutoComplete: null,
        ariaBusy: booleanish,
        ariaChecked: booleanish,
        ariaColCount: number,
        ariaColIndex: number,
        ariaColSpan: number,
        ariaControls: spaceSeparated,
        ariaCurrent: null,
        ariaDescribedBy: spaceSeparated,
        ariaDetails: null,
        ariaDisabled: booleanish,
        ariaDropEffect: spaceSeparated,
        ariaErrorMessage: null,
        ariaExpanded: booleanish,
        ariaFlowTo: spaceSeparated,
        ariaGrabbed: booleanish,
        ariaHasPopup: null,
        ariaHidden: booleanish,
        ariaInvalid: null,
        ariaKeyShortcuts: null,
        ariaLabel: null,
        ariaLabelledBy: spaceSeparated,
        ariaLevel: number,
        ariaLive: null,
        ariaModal: booleanish,
        ariaMultiLine: booleanish,
        ariaMultiSelectable: booleanish,
        ariaOrientation: null,
        ariaOwns: spaceSeparated,
        ariaPlaceholder: null,
        ariaPosInSet: number,
        ariaPressed: booleanish,
        ariaReadOnly: booleanish,
        ariaRelevant: null,
        ariaRequired: booleanish,
        ariaRoleDescription: spaceSeparated,
        ariaRowCount: number,
        ariaRowIndex: number,
        ariaRowSpan: number,
        ariaSelected: booleanish,
        ariaSetSize: number,
        ariaSort: null,
        ariaValueMax: number,
        ariaValueMin: number,
        ariaValueNow: number,
        ariaValueText: null,
        role: null
      }
    });
    function ariaTransform(_2, prop) {
      return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
    }
    var html$2 = create$2({
      space: "html",
      attributes: {
        acceptcharset: "accept-charset",
        classname: "class",
        htmlfor: "for",
        httpequiv: "http-equiv"
      },
      transform: caseInsensitiveTransform,
      mustUseProperty: ["checked", "multiple", "muted", "selected"],
      properties: {
        // Standard Properties.
        abbr: null,
        accept: commaSeparated,
        acceptCharset: spaceSeparated,
        accessKey: spaceSeparated,
        action: null,
        allow: null,
        allowFullScreen: boolean,
        allowPaymentRequest: boolean,
        allowUserMedia: boolean,
        alt: null,
        as: null,
        async: boolean,
        autoCapitalize: null,
        autoComplete: spaceSeparated,
        autoFocus: boolean,
        autoPlay: boolean,
        capture: boolean,
        charSet: null,
        checked: boolean,
        cite: null,
        className: spaceSeparated,
        cols: number,
        colSpan: null,
        content: null,
        contentEditable: booleanish,
        controls: boolean,
        controlsList: spaceSeparated,
        coords: number | commaSeparated,
        crossOrigin: null,
        data: null,
        dateTime: null,
        decoding: null,
        default: boolean,
        defer: boolean,
        dir: null,
        dirName: null,
        disabled: boolean,
        download: overloadedBoolean,
        draggable: booleanish,
        encType: null,
        enterKeyHint: null,
        form: null,
        formAction: null,
        formEncType: null,
        formMethod: null,
        formNoValidate: boolean,
        formTarget: null,
        headers: spaceSeparated,
        height: number,
        hidden: boolean,
        high: number,
        href: null,
        hrefLang: null,
        htmlFor: spaceSeparated,
        httpEquiv: spaceSeparated,
        id: null,
        imageSizes: null,
        imageSrcSet: commaSeparated,
        inputMode: null,
        integrity: null,
        is: null,
        isMap: boolean,
        itemId: null,
        itemProp: spaceSeparated,
        itemRef: spaceSeparated,
        itemScope: boolean,
        itemType: spaceSeparated,
        kind: null,
        label: null,
        lang: null,
        language: null,
        list: null,
        loading: null,
        loop: boolean,
        low: number,
        manifest: null,
        max: null,
        maxLength: number,
        media: null,
        method: null,
        min: null,
        minLength: number,
        multiple: boolean,
        muted: boolean,
        name: null,
        nonce: null,
        noModule: boolean,
        noValidate: boolean,
        onAbort: null,
        onAfterPrint: null,
        onAuxClick: null,
        onBeforePrint: null,
        onBeforeUnload: null,
        onBlur: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onContextMenu: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFormData: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLanguageChange: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadEnd: null,
        onLoadStart: null,
        onMessage: null,
        onMessageError: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRejectionHandled: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onSecurityPolicyViolation: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onSlotChange: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnhandledRejection: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onWheel: null,
        open: boolean,
        optimum: number,
        pattern: null,
        ping: spaceSeparated,
        placeholder: null,
        playsInline: boolean,
        poster: null,
        preload: null,
        readOnly: boolean,
        referrerPolicy: null,
        rel: spaceSeparated,
        required: boolean,
        reversed: boolean,
        rows: number,
        rowSpan: number,
        sandbox: spaceSeparated,
        scope: null,
        scoped: boolean,
        seamless: boolean,
        selected: boolean,
        shape: null,
        size: number,
        sizes: null,
        slot: null,
        span: number,
        spellCheck: booleanish,
        src: null,
        srcDoc: null,
        srcLang: null,
        srcSet: commaSeparated,
        start: number,
        step: null,
        style: null,
        tabIndex: number,
        target: null,
        title: null,
        translate: null,
        type: null,
        typeMustMatch: boolean,
        useMap: null,
        value: booleanish,
        width: number,
        wrap: null,
        // Legacy.
        // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
        align: null,
        // Several. Use CSS `text-align` instead,
        aLink: null,
        // `<body>`. Use CSS `a:active {color}` instead
        archive: spaceSeparated,
        // `<object>`. List of URIs to archives
        axis: null,
        // `<td>` and `<th>`. Use `scope` on `<th>`
        background: null,
        // `<body>`. Use CSS `background-image` instead
        bgColor: null,
        // `<body>` and table elements. Use CSS `background-color` instead
        border: number,
        // `<table>`. Use CSS `border-width` instead,
        borderColor: null,
        // `<table>`. Use CSS `border-color` instead,
        bottomMargin: number,
        // `<body>`
        cellPadding: null,
        // `<table>`
        cellSpacing: null,
        // `<table>`
        char: null,
        // Several table elements. When `align=char`, sets the character to align on
        charOff: null,
        // Several table elements. When `char`, offsets the alignment
        classId: null,
        // `<object>`
        clear: null,
        // `<br>`. Use CSS `clear` instead
        code: null,
        // `<object>`
        codeBase: null,
        // `<object>`
        codeType: null,
        // `<object>`
        color: null,
        // `<font>` and `<hr>`. Use CSS instead
        compact: boolean,
        // Lists. Use CSS to reduce space between items instead
        declare: boolean,
        // `<object>`
        event: null,
        // `<script>`
        face: null,
        // `<font>`. Use CSS instead
        frame: null,
        // `<table>`
        frameBorder: null,
        // `<iframe>`. Use CSS `border` instead
        hSpace: number,
        // `<img>` and `<object>`
        leftMargin: number,
        // `<body>`
        link: null,
        // `<body>`. Use CSS `a:link {color: *}` instead
        longDesc: null,
        // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
        lowSrc: null,
        // `<img>`. Use a `<picture>`
        marginHeight: number,
        // `<body>`
        marginWidth: number,
        // `<body>`
        noResize: boolean,
        // `<frame>`
        noHref: boolean,
        // `<area>`. Use no href instead of an explicit `nohref`
        noShade: boolean,
        // `<hr>`. Use background-color and height instead of borders
        noWrap: boolean,
        // `<td>` and `<th>`
        object: null,
        // `<applet>`
        profile: null,
        // `<head>`
        prompt: null,
        // `<isindex>`
        rev: null,
        // `<link>`
        rightMargin: number,
        // `<body>`
        rules: null,
        // `<table>`
        scheme: null,
        // `<meta>`
        scrolling: booleanish,
        // `<frame>`. Use overflow in the child context
        standby: null,
        // `<object>`
        summary: null,
        // `<table>`
        text: null,
        // `<body>`. Use CSS `color` instead
        topMargin: number,
        // `<body>`
        valueType: null,
        // `<param>`
        version: null,
        // `<html>`. Use a doctype.
        vAlign: null,
        // Several. Use CSS `vertical-align` instead
        vLink: null,
        // `<body>`. Use CSS `a:visited {color}` instead
        vSpace: number,
        // `<img>` and `<object>`
        // Non-standard Properties.
        allowTransparency: null,
        autoCorrect: null,
        autoSave: null,
        disablePictureInPicture: boolean,
        disableRemotePlayback: boolean,
        prefix: null,
        property: null,
        results: number,
        security: null,
        unselectable: null
      }
    });
    var svg$1 = create$2({
      space: "svg",
      attributes: {
        accentHeight: "accent-height",
        alignmentBaseline: "alignment-baseline",
        arabicForm: "arabic-form",
        baselineShift: "baseline-shift",
        capHeight: "cap-height",
        className: "class",
        clipPath: "clip-path",
        clipRule: "clip-rule",
        colorInterpolation: "color-interpolation",
        colorInterpolationFilters: "color-interpolation-filters",
        colorProfile: "color-profile",
        colorRendering: "color-rendering",
        crossOrigin: "crossorigin",
        dataType: "datatype",
        dominantBaseline: "dominant-baseline",
        enableBackground: "enable-background",
        fillOpacity: "fill-opacity",
        fillRule: "fill-rule",
        floodColor: "flood-color",
        floodOpacity: "flood-opacity",
        fontFamily: "font-family",
        fontSize: "font-size",
        fontSizeAdjust: "font-size-adjust",
        fontStretch: "font-stretch",
        fontStyle: "font-style",
        fontVariant: "font-variant",
        fontWeight: "font-weight",
        glyphName: "glyph-name",
        glyphOrientationHorizontal: "glyph-orientation-horizontal",
        glyphOrientationVertical: "glyph-orientation-vertical",
        hrefLang: "hreflang",
        horizAdvX: "horiz-adv-x",
        horizOriginX: "horiz-origin-x",
        horizOriginY: "horiz-origin-y",
        imageRendering: "image-rendering",
        letterSpacing: "letter-spacing",
        lightingColor: "lighting-color",
        markerEnd: "marker-end",
        markerMid: "marker-mid",
        markerStart: "marker-start",
        navDown: "nav-down",
        navDownLeft: "nav-down-left",
        navDownRight: "nav-down-right",
        navLeft: "nav-left",
        navNext: "nav-next",
        navPrev: "nav-prev",
        navRight: "nav-right",
        navUp: "nav-up",
        navUpLeft: "nav-up-left",
        navUpRight: "nav-up-right",
        onAbort: "onabort",
        onActivate: "onactivate",
        onAfterPrint: "onafterprint",
        onBeforePrint: "onbeforeprint",
        onBegin: "onbegin",
        onCancel: "oncancel",
        onCanPlay: "oncanplay",
        onCanPlayThrough: "oncanplaythrough",
        onChange: "onchange",
        onClick: "onclick",
        onClose: "onclose",
        onCopy: "oncopy",
        onCueChange: "oncuechange",
        onCut: "oncut",
        onDblClick: "ondblclick",
        onDrag: "ondrag",
        onDragEnd: "ondragend",
        onDragEnter: "ondragenter",
        onDragExit: "ondragexit",
        onDragLeave: "ondragleave",
        onDragOver: "ondragover",
        onDragStart: "ondragstart",
        onDrop: "ondrop",
        onDurationChange: "ondurationchange",
        onEmptied: "onemptied",
        onEnd: "onend",
        onEnded: "onended",
        onError: "onerror",
        onFocus: "onfocus",
        onFocusIn: "onfocusin",
        onFocusOut: "onfocusout",
        onHashChange: "onhashchange",
        onInput: "oninput",
        onInvalid: "oninvalid",
        onKeyDown: "onkeydown",
        onKeyPress: "onkeypress",
        onKeyUp: "onkeyup",
        onLoad: "onload",
        onLoadedData: "onloadeddata",
        onLoadedMetadata: "onloadedmetadata",
        onLoadStart: "onloadstart",
        onMessage: "onmessage",
        onMouseDown: "onmousedown",
        onMouseEnter: "onmouseenter",
        onMouseLeave: "onmouseleave",
        onMouseMove: "onmousemove",
        onMouseOut: "onmouseout",
        onMouseOver: "onmouseover",
        onMouseUp: "onmouseup",
        onMouseWheel: "onmousewheel",
        onOffline: "onoffline",
        onOnline: "ononline",
        onPageHide: "onpagehide",
        onPageShow: "onpageshow",
        onPaste: "onpaste",
        onPause: "onpause",
        onPlay: "onplay",
        onPlaying: "onplaying",
        onPopState: "onpopstate",
        onProgress: "onprogress",
        onRateChange: "onratechange",
        onRepeat: "onrepeat",
        onReset: "onreset",
        onResize: "onresize",
        onScroll: "onscroll",
        onSeeked: "onseeked",
        onSeeking: "onseeking",
        onSelect: "onselect",
        onShow: "onshow",
        onStalled: "onstalled",
        onStorage: "onstorage",
        onSubmit: "onsubmit",
        onSuspend: "onsuspend",
        onTimeUpdate: "ontimeupdate",
        onToggle: "ontoggle",
        onUnload: "onunload",
        onVolumeChange: "onvolumechange",
        onWaiting: "onwaiting",
        onZoom: "onzoom",
        overlinePosition: "overline-position",
        overlineThickness: "overline-thickness",
        paintOrder: "paint-order",
        panose1: "panose-1",
        pointerEvents: "pointer-events",
        referrerPolicy: "referrerpolicy",
        renderingIntent: "rendering-intent",
        shapeRendering: "shape-rendering",
        stopColor: "stop-color",
        stopOpacity: "stop-opacity",
        strikethroughPosition: "strikethrough-position",
        strikethroughThickness: "strikethrough-thickness",
        strokeDashArray: "stroke-dasharray",
        strokeDashOffset: "stroke-dashoffset",
        strokeLineCap: "stroke-linecap",
        strokeLineJoin: "stroke-linejoin",
        strokeMiterLimit: "stroke-miterlimit",
        strokeOpacity: "stroke-opacity",
        strokeWidth: "stroke-width",
        tabIndex: "tabindex",
        textAnchor: "text-anchor",
        textDecoration: "text-decoration",
        textRendering: "text-rendering",
        typeOf: "typeof",
        underlinePosition: "underline-position",
        underlineThickness: "underline-thickness",
        unicodeBidi: "unicode-bidi",
        unicodeRange: "unicode-range",
        unitsPerEm: "units-per-em",
        vAlphabetic: "v-alphabetic",
        vHanging: "v-hanging",
        vIdeographic: "v-ideographic",
        vMathematical: "v-mathematical",
        vectorEffect: "vector-effect",
        vertAdvY: "vert-adv-y",
        vertOriginX: "vert-origin-x",
        vertOriginY: "vert-origin-y",
        wordSpacing: "word-spacing",
        writingMode: "writing-mode",
        xHeight: "x-height",
        // These were camelcased in Tiny. Now lowercased in SVG 2
        playbackOrder: "playbackorder",
        timelineBegin: "timelinebegin"
      },
      transform: caseSensitiveTransform,
      properties: {
        about: commaOrSpaceSeparated,
        accentHeight: number,
        accumulate: null,
        additive: null,
        alignmentBaseline: null,
        alphabetic: number,
        amplitude: number,
        arabicForm: null,
        ascent: number,
        attributeName: null,
        attributeType: null,
        azimuth: number,
        bandwidth: null,
        baselineShift: null,
        baseFrequency: null,
        baseProfile: null,
        bbox: null,
        begin: null,
        bias: number,
        by: null,
        calcMode: null,
        capHeight: number,
        className: spaceSeparated,
        clip: null,
        clipPath: null,
        clipPathUnits: null,
        clipRule: null,
        color: null,
        colorInterpolation: null,
        colorInterpolationFilters: null,
        colorProfile: null,
        colorRendering: null,
        content: null,
        contentScriptType: null,
        contentStyleType: null,
        crossOrigin: null,
        cursor: null,
        cx: null,
        cy: null,
        d: null,
        dataType: null,
        defaultAction: null,
        descent: number,
        diffuseConstant: number,
        direction: null,
        display: null,
        dur: null,
        divisor: number,
        dominantBaseline: null,
        download: boolean,
        dx: null,
        dy: null,
        edgeMode: null,
        editable: null,
        elevation: number,
        enableBackground: null,
        end: null,
        event: null,
        exponent: number,
        externalResourcesRequired: null,
        fill: null,
        fillOpacity: number,
        fillRule: null,
        filter: null,
        filterRes: null,
        filterUnits: null,
        floodColor: null,
        floodOpacity: null,
        focusable: null,
        focusHighlight: null,
        fontFamily: null,
        fontSize: null,
        fontSizeAdjust: null,
        fontStretch: null,
        fontStyle: null,
        fontVariant: null,
        fontWeight: null,
        format: null,
        fr: null,
        from: null,
        fx: null,
        fy: null,
        g1: commaSeparated,
        g2: commaSeparated,
        glyphName: commaSeparated,
        glyphOrientationHorizontal: null,
        glyphOrientationVertical: null,
        glyphRef: null,
        gradientTransform: null,
        gradientUnits: null,
        handler: null,
        hanging: number,
        hatchContentUnits: null,
        hatchUnits: null,
        height: null,
        href: null,
        hrefLang: null,
        horizAdvX: number,
        horizOriginX: number,
        horizOriginY: number,
        id: null,
        ideographic: number,
        imageRendering: null,
        initialVisibility: null,
        in: null,
        in2: null,
        intercept: number,
        k: number,
        k1: number,
        k2: number,
        k3: number,
        k4: number,
        kernelMatrix: commaOrSpaceSeparated,
        kernelUnitLength: null,
        keyPoints: null,
        // SEMI_COLON_SEPARATED
        keySplines: null,
        // SEMI_COLON_SEPARATED
        keyTimes: null,
        // SEMI_COLON_SEPARATED
        kerning: null,
        lang: null,
        lengthAdjust: null,
        letterSpacing: null,
        lightingColor: null,
        limitingConeAngle: number,
        local: null,
        markerEnd: null,
        markerMid: null,
        markerStart: null,
        markerHeight: null,
        markerUnits: null,
        markerWidth: null,
        mask: null,
        maskContentUnits: null,
        maskUnits: null,
        mathematical: null,
        max: null,
        media: null,
        mediaCharacterEncoding: null,
        mediaContentEncodings: null,
        mediaSize: number,
        mediaTime: null,
        method: null,
        min: null,
        mode: null,
        name: null,
        navDown: null,
        navDownLeft: null,
        navDownRight: null,
        navLeft: null,
        navNext: null,
        navPrev: null,
        navRight: null,
        navUp: null,
        navUpLeft: null,
        navUpRight: null,
        numOctaves: null,
        observer: null,
        offset: null,
        onAbort: null,
        onActivate: null,
        onAfterPrint: null,
        onBeforePrint: null,
        onBegin: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnd: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFocusIn: null,
        onFocusOut: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadStart: null,
        onMessage: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onMouseWheel: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRepeat: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onShow: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onZoom: null,
        opacity: null,
        operator: null,
        order: null,
        orient: null,
        orientation: null,
        origin: null,
        overflow: null,
        overlay: null,
        overlinePosition: number,
        overlineThickness: number,
        paintOrder: null,
        panose1: null,
        path: null,
        pathLength: number,
        patternContentUnits: null,
        patternTransform: null,
        patternUnits: null,
        phase: null,
        ping: spaceSeparated,
        pitch: null,
        playbackOrder: null,
        pointerEvents: null,
        points: null,
        pointsAtX: number,
        pointsAtY: number,
        pointsAtZ: number,
        preserveAlpha: null,
        preserveAspectRatio: null,
        primitiveUnits: null,
        propagate: null,
        property: commaOrSpaceSeparated,
        r: null,
        radius: null,
        referrerPolicy: null,
        refX: null,
        refY: null,
        rel: commaOrSpaceSeparated,
        rev: commaOrSpaceSeparated,
        renderingIntent: null,
        repeatCount: null,
        repeatDur: null,
        requiredExtensions: commaOrSpaceSeparated,
        requiredFeatures: commaOrSpaceSeparated,
        requiredFonts: commaOrSpaceSeparated,
        requiredFormats: commaOrSpaceSeparated,
        resource: null,
        restart: null,
        result: null,
        rotate: null,
        rx: null,
        ry: null,
        scale: null,
        seed: null,
        shapeRendering: null,
        side: null,
        slope: null,
        snapshotTime: null,
        specularConstant: number,
        specularExponent: number,
        spreadMethod: null,
        spacing: null,
        startOffset: null,
        stdDeviation: null,
        stemh: null,
        stemv: null,
        stitchTiles: null,
        stopColor: null,
        stopOpacity: null,
        strikethroughPosition: number,
        strikethroughThickness: number,
        string: null,
        stroke: null,
        strokeDashArray: commaOrSpaceSeparated,
        strokeDashOffset: null,
        strokeLineCap: null,
        strokeLineJoin: null,
        strokeMiterLimit: number,
        strokeOpacity: number,
        strokeWidth: null,
        style: null,
        surfaceScale: number,
        syncBehavior: null,
        syncBehaviorDefault: null,
        syncMaster: null,
        syncTolerance: null,
        syncToleranceDefault: null,
        systemLanguage: commaOrSpaceSeparated,
        tabIndex: number,
        tableValues: null,
        target: null,
        targetX: number,
        targetY: number,
        textAnchor: null,
        textDecoration: null,
        textRendering: null,
        textLength: null,
        timelineBegin: null,
        title: null,
        transformBehavior: null,
        type: null,
        typeOf: commaOrSpaceSeparated,
        to: null,
        transform: null,
        u1: null,
        u2: null,
        underlinePosition: number,
        underlineThickness: number,
        unicode: null,
        unicodeBidi: null,
        unicodeRange: null,
        unitsPerEm: number,
        values: null,
        vAlphabetic: number,
        vMathematical: number,
        vectorEffect: null,
        vHanging: number,
        vIdeographic: number,
        version: null,
        vertAdvY: number,
        vertOriginX: number,
        vertOriginY: number,
        viewBox: null,
        viewTarget: null,
        visibility: null,
        width: null,
        widths: null,
        wordSpacing: null,
        writingMode: null,
        x: null,
        x1: null,
        x2: null,
        xChannelSelector: null,
        xHeight: number,
        y: null,
        y1: null,
        y2: null,
        yChannelSelector: null,
        z: null,
        zoomAndPan: null
      }
    });
    var valid = /^data[-\w.:]+$/i;
    var dash$1 = /-[a-z]/g;
    var cap = /[A-Z]/g;
    function find(schema, value) {
      var normal = normalize(value);
      var prop = value;
      var Type = Info;
      if (normal in schema.normal) {
        return schema.property[schema.normal[normal]];
      }
      if (normal.length > 4 && normal.slice(0, 4) === "data" && valid.test(value)) {
        if (value.charAt(4) === "-") {
          prop = datasetToProperty(value);
        } else {
          value = datasetToAttribute(value);
        }
        Type = DefinedInfo;
      }
      return new Type(prop, value);
    }
    function datasetToProperty(attribute) {
      var value = attribute.slice(5).replace(dash$1, camelcase);
      return "data" + value.charAt(0).toUpperCase() + value.slice(1);
    }
    function datasetToAttribute(property) {
      var value = property.slice(4);
      if (dash$1.test(value)) {
        return property;
      }
      value = value.replace(cap, kebab);
      if (value.charAt(0) !== "-") {
        value = "-" + value;
      }
      return "data" + value;
    }
    function kebab($0) {
      return "-" + $0.toLowerCase();
    }
    function camelcase($0) {
      return $0.charAt(1).toUpperCase();
    }
    var hastToReact = {
      classId: "classID",
      dataType: "datatype",
      itemId: "itemID",
      strokeDashArray: "strokeDasharray",
      strokeDashOffset: "strokeDashoffset",
      strokeLineCap: "strokeLinecap",
      strokeLineJoin: "strokeLinejoin",
      strokeMiterLimit: "strokeMiterlimit",
      typeOf: "typeof",
      xLinkActuate: "xlinkActuate",
      xLinkArcRole: "xlinkArcrole",
      xLinkHref: "xlinkHref",
      xLinkRole: "xlinkRole",
      xLinkShow: "xlinkShow",
      xLinkTitle: "xlinkTitle",
      xLinkType: "xlinkType",
      xmlnsXLink: "xmlnsXlink"
    };
    var html$1 = merge([xml, xlink, xmlns, aria, html$2], "html");
    var svg = merge([xml, xlink, xmlns, aria, svg$1], "svg");
    function rehypeFilter(options) {
      if (options.allowedElements && options.disallowedElements) {
        throw new TypeError(
          "Only one of `allowedElements` and `disallowedElements` should be defined"
        );
      }
      if (options.allowedElements || options.disallowedElements || options.allowElement) {
        return (tree) => {
          visit$1(tree, "element", (node2, index2, parent_) => {
            const parent = (
              /** @type {Element|Root} */
              parent_
            );
            let remove;
            if (options.allowedElements) {
              remove = !options.allowedElements.includes(node2.tagName);
            } else if (options.disallowedElements) {
              remove = options.disallowedElements.includes(node2.tagName);
            }
            if (!remove && options.allowElement && typeof index2 === "number") {
              remove = !options.allowElement(node2, index2, parent);
            }
            if (remove && typeof index2 === "number") {
              if (options.unwrapDisallowed && node2.children) {
                parent.children.splice(index2, 1, ...node2.children);
              } else {
                parent.children.splice(index2, 1);
              }
              return index2;
            }
            return void 0;
          });
        };
      }
    }
    var reactIs = { exports: {} };
    var reactIs_production_min = {};
    /**
     * @license React
     * react-is.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var b = Symbol.for("react.element"), c$2 = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), e = Symbol.for("react.strict_mode"), f = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), h$1 = Symbol.for("react.context"), k = Symbol.for("react.server_context"), l$1 = Symbol.for("react.forward_ref"), m = Symbol.for("react.suspense"), n = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), t = Symbol.for("react.offscreen"), u;
    u = Symbol.for("react.module.reference");
    function v(a2) {
      if ("object" === typeof a2 && null !== a2) {
        var r2 = a2.$$typeof;
        switch (r2) {
          case b:
            switch (a2 = a2.type, a2) {
              case d:
              case f:
              case e:
              case m:
              case n:
                return a2;
              default:
                switch (a2 = a2 && a2.$$typeof, a2) {
                  case k:
                  case h$1:
                  case l$1:
                  case q:
                  case p:
                  case g:
                    return a2;
                  default:
                    return r2;
                }
            }
          case c$2:
            return r2;
        }
      }
    }
    reactIs_production_min.ContextConsumer = h$1;
    reactIs_production_min.ContextProvider = g;
    reactIs_production_min.Element = b;
    reactIs_production_min.ForwardRef = l$1;
    reactIs_production_min.Fragment = d;
    reactIs_production_min.Lazy = q;
    reactIs_production_min.Memo = p;
    reactIs_production_min.Portal = c$2;
    reactIs_production_min.Profiler = f;
    reactIs_production_min.StrictMode = e;
    reactIs_production_min.Suspense = m;
    reactIs_production_min.SuspenseList = n;
    reactIs_production_min.isAsyncMode = function() {
      return false;
    };
    reactIs_production_min.isConcurrentMode = function() {
      return false;
    };
    reactIs_production_min.isContextConsumer = function(a2) {
      return v(a2) === h$1;
    };
    reactIs_production_min.isContextProvider = function(a2) {
      return v(a2) === g;
    };
    reactIs_production_min.isElement = function(a2) {
      return "object" === typeof a2 && null !== a2 && a2.$$typeof === b;
    };
    reactIs_production_min.isForwardRef = function(a2) {
      return v(a2) === l$1;
    };
    reactIs_production_min.isFragment = function(a2) {
      return v(a2) === d;
    };
    reactIs_production_min.isLazy = function(a2) {
      return v(a2) === q;
    };
    reactIs_production_min.isMemo = function(a2) {
      return v(a2) === p;
    };
    reactIs_production_min.isPortal = function(a2) {
      return v(a2) === c$2;
    };
    reactIs_production_min.isProfiler = function(a2) {
      return v(a2) === f;
    };
    reactIs_production_min.isStrictMode = function(a2) {
      return v(a2) === e;
    };
    reactIs_production_min.isSuspense = function(a2) {
      return v(a2) === m;
    };
    reactIs_production_min.isSuspenseList = function(a2) {
      return v(a2) === n;
    };
    reactIs_production_min.isValidElementType = function(a2) {
      return "string" === typeof a2 || "function" === typeof a2 || a2 === d || a2 === f || a2 === e || a2 === m || a2 === n || a2 === t || "object" === typeof a2 && null !== a2 && (a2.$$typeof === q || a2.$$typeof === p || a2.$$typeof === g || a2.$$typeof === h$1 || a2.$$typeof === l$1 || a2.$$typeof === u || void 0 !== a2.getModuleId) ? true : false;
    };
    reactIs_production_min.typeOf = v;
    {
      reactIs.exports = reactIs_production_min;
    }
    var reactIsExports = reactIs.exports;
    const ReactIs = /* @__PURE__ */ getDefaultExportFromCjs(reactIsExports);
    function whitespace(thing) {
      var value = (
        // @ts-ignore looks like a node.
        thing && typeof thing === "object" && thing.type === "text" ? (
          // @ts-ignore looks like a text.
          thing.value || ""
        ) : thing
      );
      return typeof value === "string" && value.replace(/[ \t\n\f\r]/g, "") === "";
    }
    function parse$3(value) {
      const input = String(value || "").trim();
      return input ? input.split(/[ \t\n\r\f]+/g) : [];
    }
    function stringify$2(values) {
      return values.join(" ").trim();
    }
    function parse$2(value) {
      var tokens2 = [];
      var input = String(value || "");
      var index2 = input.indexOf(",");
      var start = 0;
      var end;
      var token2;
      while (!end) {
        if (index2 === -1) {
          index2 = input.length;
          end = true;
        }
        token2 = input.slice(start, index2).trim();
        if (token2 || !end) {
          tokens2.push(token2);
        }
        start = index2 + 1;
        index2 = input.indexOf(",", start);
      }
      return tokens2;
    }
    function stringify$1(values, options) {
      var settings = options || {};
      if (values[values.length - 1] === "") {
        values = values.concat("");
      }
      return values.join(
        (settings.padRight ? " " : "") + "," + (settings.padLeft === false ? "" : " ")
      ).trim();
    }
    var styleToObject$1 = { exports: {} };
    var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
    var NEWLINE_REGEX = /\n/g;
    var WHITESPACE_REGEX = /^\s*/;
    var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
    var COLON_REGEX = /^:\s*/;
    var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
    var SEMICOLON_REGEX = /^[;\s]*/;
    var TRIM_REGEX = /^\s+|\s+$/g;
    var NEWLINE = "\n";
    var FORWARD_SLASH = "/";
    var ASTERISK = "*";
    var EMPTY_STRING = "";
    var TYPE_COMMENT = "comment";
    var TYPE_DECLARATION = "declaration";
    var inlineStyleParser = function(style2, options) {
      if (typeof style2 !== "string") {
        throw new TypeError("First argument must be a string");
      }
      if (!style2)
        return [];
      options = options || {};
      var lineno = 1;
      var column2 = 1;
      function updatePosition(str) {
        var lines = str.match(NEWLINE_REGEX);
        if (lines)
          lineno += lines.length;
        var i2 = str.lastIndexOf(NEWLINE);
        column2 = ~i2 ? str.length - i2 : column2 + str.length;
      }
      function position2() {
        var start = { line: lineno, column: column2 };
        return function(node2) {
          node2.position = new Position2(start);
          whitespace2();
          return node2;
        };
      }
      function Position2(start) {
        this.start = start;
        this.end = { line: lineno, column: column2 };
        this.source = options.source;
      }
      Position2.prototype.content = style2;
      function error(msg) {
        var err = new Error(
          options.source + ":" + lineno + ":" + column2 + ": " + msg
        );
        err.reason = msg;
        err.filename = options.source;
        err.line = lineno;
        err.column = column2;
        err.source = style2;
        if (options.silent)
          ;
        else {
          throw err;
        }
      }
      function match5(re2) {
        var m2 = re2.exec(style2);
        if (!m2)
          return;
        var str = m2[0];
        updatePosition(str);
        style2 = style2.slice(str.length);
        return m2;
      }
      function whitespace2() {
        match5(WHITESPACE_REGEX);
      }
      function comments(rules2) {
        var c2;
        rules2 = rules2 || [];
        while (c2 = comment2()) {
          if (c2 !== false) {
            rules2.push(c2);
          }
        }
        return rules2;
      }
      function comment2() {
        var pos = position2();
        if (FORWARD_SLASH != style2.charAt(0) || ASTERISK != style2.charAt(1))
          return;
        var i2 = 2;
        while (EMPTY_STRING != style2.charAt(i2) && (ASTERISK != style2.charAt(i2) || FORWARD_SLASH != style2.charAt(i2 + 1))) {
          ++i2;
        }
        i2 += 2;
        if (EMPTY_STRING === style2.charAt(i2 - 1)) {
          return error("End of comment missing");
        }
        var str = style2.slice(2, i2 - 2);
        column2 += 2;
        updatePosition(str);
        style2 = style2.slice(i2);
        column2 += 2;
        return pos({
          type: TYPE_COMMENT,
          comment: str
        });
      }
      function declaration2() {
        var pos = position2();
        var prop = match5(PROPERTY_REGEX);
        if (!prop)
          return;
        comment2();
        if (!match5(COLON_REGEX))
          return error("property missing ':'");
        var val = match5(VALUE_REGEX);
        var ret = pos({
          type: TYPE_DECLARATION,
          property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
          value: val ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
        });
        match5(SEMICOLON_REGEX);
        return ret;
      }
      function declarations() {
        var decls = [];
        comments(decls);
        var decl;
        while (decl = declaration2()) {
          if (decl !== false) {
            decls.push(decl);
            comments(decls);
          }
        }
        return decls;
      }
      whitespace2();
      return declarations();
    };
    function trim(str) {
      return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
    }
    var parse$1 = inlineStyleParser;
    function StyleToObject$1(style2, iterator) {
      var output = null;
      if (!style2 || typeof style2 !== "string") {
        return output;
      }
      var declaration2;
      var declarations = parse$1(style2);
      var hasIterator = typeof iterator === "function";
      var property;
      var value;
      for (var i2 = 0, len = declarations.length; i2 < len; i2++) {
        declaration2 = declarations[i2];
        property = declaration2.property;
        value = declaration2.value;
        if (hasIterator) {
          iterator(property, value, declaration2);
        } else if (value) {
          output || (output = {});
          output[property] = value;
        }
      }
      return output;
    }
    styleToObject$1.exports = StyleToObject$1;
    styleToObject$1.exports.default = StyleToObject$1;
    var styleToObjectExports = styleToObject$1.exports;
    const StyleToObject$2 = /* @__PURE__ */ getDefaultExportFromCjs(styleToObjectExports);
    const own$9 = {}.hasOwnProperty;
    const tableElements = /* @__PURE__ */ new Set(["table", "thead", "tbody", "tfoot", "tr"]);
    function childrenToReact(context, node2) {
      const children = [];
      let childIndex = -1;
      let child;
      while (++childIndex < node2.children.length) {
        child = node2.children[childIndex];
        if (child.type === "element") {
          children.push(toReact$1(context, child, childIndex, node2));
        } else if (child.type === "text") {
          if (node2.type !== "element" || !tableElements.has(node2.tagName) || !whitespace(child)) {
            children.push(child.value);
          }
        } else if (child.type === "raw" && !context.options.skipHtml) {
          children.push(child.value);
        }
      }
      return children;
    }
    function toReact$1(context, node2, index2, parent) {
      const options = context.options;
      const transform2 = options.transformLinkUri === void 0 ? uriTransformer : options.transformLinkUri;
      const parentSchema = context.schema;
      const name2 = node2.tagName;
      const properties = {};
      let schema = parentSchema;
      let property;
      if (parentSchema.space === "html" && name2 === "svg") {
        schema = svg;
        context.schema = schema;
      }
      if (node2.properties) {
        for (property in node2.properties) {
          if (own$9.call(node2.properties, property)) {
            addProperty$1(properties, property, node2.properties[property], context);
          }
        }
      }
      if (name2 === "ol" || name2 === "ul") {
        context.listDepth++;
      }
      const children = childrenToReact(context, node2);
      if (name2 === "ol" || name2 === "ul") {
        context.listDepth--;
      }
      context.schema = parentSchema;
      const position2 = node2.position || {
        start: { line: null, column: null, offset: null },
        end: { line: null, column: null, offset: null }
      };
      const component = options.components && own$9.call(options.components, name2) ? options.components[name2] : name2;
      const basic2 = typeof component === "string" || component === React.Fragment;
      if (!ReactIs.isValidElementType(component)) {
        throw new TypeError(
          `Component for name \`${name2}\` not defined or is not renderable`
        );
      }
      properties.key = index2;
      if (name2 === "a" && options.linkTarget) {
        properties.target = typeof options.linkTarget === "function" ? options.linkTarget(
          String(properties.href || ""),
          node2.children,
          typeof properties.title === "string" ? properties.title : null
        ) : options.linkTarget;
      }
      if (name2 === "a" && transform2) {
        properties.href = transform2(
          String(properties.href || ""),
          node2.children,
          typeof properties.title === "string" ? properties.title : null
        );
      }
      if (!basic2 && name2 === "code" && parent.type === "element" && parent.tagName !== "pre") {
        properties.inline = true;
      }
      if (!basic2 && (name2 === "h1" || name2 === "h2" || name2 === "h3" || name2 === "h4" || name2 === "h5" || name2 === "h6")) {
        properties.level = Number.parseInt(name2.charAt(1), 10);
      }
      if (name2 === "img" && options.transformImageUri) {
        properties.src = options.transformImageUri(
          String(properties.src || ""),
          String(properties.alt || ""),
          typeof properties.title === "string" ? properties.title : null
        );
      }
      if (!basic2 && name2 === "li" && parent.type === "element") {
        const input = getInputElement(node2);
        properties.checked = input && input.properties ? Boolean(input.properties.checked) : null;
        properties.index = getElementsBeforeCount(parent, node2);
        properties.ordered = parent.tagName === "ol";
      }
      if (!basic2 && (name2 === "ol" || name2 === "ul")) {
        properties.ordered = name2 === "ol";
        properties.depth = context.listDepth;
      }
      if (name2 === "td" || name2 === "th") {
        if (properties.align) {
          if (!properties.style)
            properties.style = {};
          properties.style.textAlign = properties.align;
          delete properties.align;
        }
        if (!basic2) {
          properties.isHeader = name2 === "th";
        }
      }
      if (!basic2 && name2 === "tr" && parent.type === "element") {
        properties.isHeader = Boolean(parent.tagName === "thead");
      }
      if (options.sourcePos) {
        properties["data-sourcepos"] = flattenPosition(position2);
      }
      if (!basic2 && options.rawSourcePos) {
        properties.sourcePosition = node2.position;
      }
      if (!basic2 && options.includeElementIndex) {
        properties.index = getElementsBeforeCount(parent, node2);
        properties.siblingCount = getElementsBeforeCount(parent);
      }
      if (!basic2) {
        properties.node = node2;
      }
      return children.length > 0 ? React.createElement(component, properties, children) : React.createElement(component, properties);
    }
    function getInputElement(node2) {
      let index2 = -1;
      while (++index2 < node2.children.length) {
        const child = node2.children[index2];
        if (child.type === "element" && child.tagName === "input") {
          return child;
        }
      }
      return null;
    }
    function getElementsBeforeCount(parent, node2) {
      let index2 = -1;
      let count = 0;
      while (++index2 < parent.children.length) {
        if (parent.children[index2] === node2)
          break;
        if (parent.children[index2].type === "element")
          count++;
      }
      return count;
    }
    function addProperty$1(props, prop, value, ctx) {
      const info = find(ctx.schema, prop);
      let result = value;
      if (result === null || result === void 0 || result !== result) {
        return;
      }
      if (Array.isArray(result)) {
        result = info.commaSeparated ? stringify$1(result) : stringify$2(result);
      }
      if (info.property === "style" && typeof result === "string") {
        result = parseStyle$1(result);
      }
      if (info.space && info.property) {
        props[own$9.call(hastToReact, info.property) ? hastToReact[info.property] : info.property] = result;
      } else if (info.attribute) {
        props[info.attribute] = result;
      }
    }
    function parseStyle$1(value) {
      const result = {};
      try {
        StyleToObject$2(value, iterator);
      } catch {
      }
      return result;
      function iterator(name2, v2) {
        const k2 = name2.slice(0, 4) === "-ms-" ? `ms-${name2.slice(4)}` : name2;
        result[k2.replace(/-([a-z])/g, styleReplacer)] = v2;
      }
    }
    function styleReplacer(_2, $1) {
      return $1.toUpperCase();
    }
    function flattenPosition(pos) {
      return [
        pos.start.line,
        ":",
        pos.start.column,
        "-",
        pos.end.line,
        ":",
        pos.end.column
      ].map(String).join("");
    }
    const own$8 = {}.hasOwnProperty;
    const changelog = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md";
    const deprecated = {
      plugins: { to: "remarkPlugins", id: "change-plugins-to-remarkplugins" },
      renderers: { to: "components", id: "change-renderers-to-components" },
      astPlugins: { id: "remove-buggy-html-in-markdown-parser" },
      allowDangerousHtml: { id: "remove-buggy-html-in-markdown-parser" },
      escapeHtml: { id: "remove-buggy-html-in-markdown-parser" },
      source: { to: "children", id: "change-source-to-children" },
      allowNode: {
        to: "allowElement",
        id: "replace-allownode-allowedtypes-and-disallowedtypes"
      },
      allowedTypes: {
        to: "allowedElements",
        id: "replace-allownode-allowedtypes-and-disallowedtypes"
      },
      disallowedTypes: {
        to: "disallowedElements",
        id: "replace-allownode-allowedtypes-and-disallowedtypes"
      },
      includeNodeIndex: {
        to: "includeElementIndex",
        id: "change-includenodeindex-to-includeelementindex"
      }
    };
    function ReactMarkdown(options) {
      for (const key in deprecated) {
        if (own$8.call(deprecated, key) && own$8.call(options, key)) {
          const deprecation = deprecated[key];
          console.warn(
            `[react-markdown] Warning: please ${deprecation.to ? `use \`${deprecation.to}\` instead of` : "remove"} \`${key}\` (see <${changelog}#${deprecation.id}> for more info)`
          );
          delete deprecated[key];
        }
      }
      const processor = unified().use(remarkParse).use(options.remarkPlugins || []).use(remarkRehype$1, {
        ...options.remarkRehypeOptions,
        allowDangerousHtml: true
      }).use(options.rehypePlugins || []).use(rehypeFilter, options);
      const file = new VFile();
      if (typeof options.children === "string") {
        file.value = options.children;
      } else if (options.children !== void 0 && options.children !== null) {
        console.warn(
          `[react-markdown] Warning: please pass a string as \`children\` (not: \`${options.children}\`)`
        );
      }
      const hastNode = processor.runSync(processor.parse(file), file);
      if (hastNode.type !== "root") {
        throw new TypeError("Expected a `root` node");
      }
      let result = React.createElement(
        React.Fragment,
        {},
        childrenToReact({ options, schema: html$1, listDepth: 0 }, hastNode)
      );
      if (options.className) {
        result = React.createElement("div", { className: options.className }, result);
      }
      return result;
    }
    ReactMarkdown.propTypes = {
      // Core options:
      children: PropTypes.string,
      // Layout options:
      className: PropTypes.string,
      // Filter options:
      allowElement: PropTypes.func,
      allowedElements: PropTypes.arrayOf(PropTypes.string),
      disallowedElements: PropTypes.arrayOf(PropTypes.string),
      unwrapDisallowed: PropTypes.bool,
      // Plugin options:
      remarkPlugins: PropTypes.arrayOf(
        PropTypes.oneOfType([
          PropTypes.object,
          PropTypes.func,
          PropTypes.arrayOf(
            PropTypes.oneOfType([
              PropTypes.bool,
              PropTypes.string,
              PropTypes.object,
              PropTypes.func,
              PropTypes.arrayOf(
                // prettier-ignore
                // type-coverage:ignore-next-line
                PropTypes.any
              )
            ])
          )
        ])
      ),
      rehypePlugins: PropTypes.arrayOf(
        PropTypes.oneOfType([
          PropTypes.object,
          PropTypes.func,
          PropTypes.arrayOf(
            PropTypes.oneOfType([
              PropTypes.bool,
              PropTypes.string,
              PropTypes.object,
              PropTypes.func,
              PropTypes.arrayOf(
                // prettier-ignore
                // type-coverage:ignore-next-line
                PropTypes.any
              )
            ])
          )
        ])
      ),
      // Transform options:
      sourcePos: PropTypes.bool,
      rawSourcePos: PropTypes.bool,
      skipHtml: PropTypes.bool,
      includeElementIndex: PropTypes.bool,
      transformLinkUri: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),
      linkTarget: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),
      transformImageUri: PropTypes.func,
      components: PropTypes.object
    };
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i2;
      for (i2 = 0; i2 < sourceKeys.length; i2++) {
        key = sourceKeys[i2];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    var objectWithoutPropertiesLoose$1 = _objectWithoutPropertiesLoose;
    var objectWithoutPropertiesLoose = objectWithoutPropertiesLoose$1;
    function _objectWithoutProperties(source, excluded) {
      if (source == null)
        return {};
      var target = objectWithoutPropertiesLoose(source, excluded);
      var key, i2;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
          key = sourceSymbolKeys[i2];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    var objectWithoutProperties = _objectWithoutProperties;
    const _objectWithoutProperties$1 = /* @__PURE__ */ getDefaultExportFromCjs(objectWithoutProperties);
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) {
        for (var i2 = 0, arr2 = new Array(arr.length); i2 < arr.length; i2++) {
          arr2[i2] = arr[i2];
        }
        return arr2;
      }
    }
    var arrayWithoutHoles$1 = _arrayWithoutHoles;
    function _iterableToArray(iter) {
      if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]")
        return Array.from(iter);
    }
    var iterableToArray$1 = _iterableToArray;
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance");
    }
    var nonIterableSpread$1 = _nonIterableSpread;
    var arrayWithoutHoles = arrayWithoutHoles$1;
    var iterableToArray = iterableToArray$1;
    var nonIterableSpread = nonIterableSpread$1;
    function _toConsumableArray(arr) {
      return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
    }
    var toConsumableArray = _toConsumableArray;
    const _toConsumableArray$1 = /* @__PURE__ */ getDefaultExportFromCjs(toConsumableArray);
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var defineProperty = _defineProperty;
    const _defineProperty$1 = /* @__PURE__ */ getDefaultExportFromCjs(defineProperty);
    function _extends() {
      _extends_1 = _extends = Object.assign || function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    var _extends_1 = _extends;
    const _extends$1 = /* @__PURE__ */ getDefaultExportFromCjs(_extends_1);
    function ownKeys$1(object, enumerableOnly) {
      var keys2 = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread$1(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
          _defineProperty$1(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function powerSetPermutations(arr) {
      var arrLength = arr.length;
      if (arrLength === 0 || arrLength === 1)
        return arr;
      if (arrLength === 2) {
        return [arr[0], arr[1], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0])];
      }
      if (arrLength === 3) {
        return [arr[0], arr[1], arr[2], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2]), "".concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0])];
      }
      if (arrLength >= 4) {
        return [arr[0], arr[1], arr[2], arr[3], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[3]), "".concat(arr[3], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[1], ".").concat(arr[0])];
      }
    }
    var classNameCombinations = {};
    function getClassNameCombinations(classNames2) {
      if (classNames2.length === 0 || classNames2.length === 1)
        return classNames2;
      var key = classNames2.join(".");
      if (!classNameCombinations[key]) {
        classNameCombinations[key] = powerSetPermutations(classNames2);
      }
      return classNameCombinations[key];
    }
    function createStyleObject(classNames2) {
      var elementStyle = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var stylesheet2 = arguments.length > 2 ? arguments[2] : void 0;
      var nonTokenClassNames = classNames2.filter(function(className) {
        return className !== "token";
      });
      var classNamesCombinations = getClassNameCombinations(nonTokenClassNames);
      return classNamesCombinations.reduce(function(styleObject, className) {
        return _objectSpread$1(_objectSpread$1({}, styleObject), stylesheet2[className]);
      }, elementStyle);
    }
    function createClassNameString(classNames2) {
      return classNames2.join(" ");
    }
    function createChildren(stylesheet2, useInlineStyles) {
      var childrenCount = 0;
      return function(children) {
        childrenCount += 1;
        return children.map(function(child, i2) {
          return createElement({
            node: child,
            stylesheet: stylesheet2,
            useInlineStyles,
            key: "code-segment-".concat(childrenCount, "-").concat(i2)
          });
        });
      };
    }
    function createElement(_ref) {
      var node2 = _ref.node, stylesheet2 = _ref.stylesheet, _ref$style = _ref.style, style2 = _ref$style === void 0 ? {} : _ref$style, useInlineStyles = _ref.useInlineStyles, key = _ref.key;
      var properties = node2.properties, type = node2.type, TagName = node2.tagName, value = node2.value;
      if (type === "text") {
        return value;
      } else if (TagName) {
        var childrenCreator = createChildren(stylesheet2, useInlineStyles);
        var props;
        if (!useInlineStyles) {
          props = _objectSpread$1(_objectSpread$1({}, properties), {}, {
            className: createClassNameString(properties.className)
          });
        } else {
          var allStylesheetSelectors = Object.keys(stylesheet2).reduce(function(classes, selector) {
            selector.split(".").forEach(function(className2) {
              if (!classes.includes(className2))
                classes.push(className2);
            });
            return classes;
          }, []);
          var startingClassName = properties.className && properties.className.includes("token") ? ["token"] : [];
          var className = properties.className && startingClassName.concat(properties.className.filter(function(className2) {
            return !allStylesheetSelectors.includes(className2);
          }));
          props = _objectSpread$1(_objectSpread$1({}, properties), {}, {
            className: createClassNameString(className) || void 0,
            style: createStyleObject(properties.className, Object.assign({}, properties.style, style2), stylesheet2)
          });
        }
        var children = childrenCreator(node2.children);
        return /* @__PURE__ */ React.createElement(TagName, _extends$1({
          key
        }, props), children);
      }
    }
    const checkForListedLanguage = function(astGenerator, language) {
      var langs = astGenerator.listLanguages();
      return langs.indexOf(language) !== -1;
    };
    var _excluded = ["language", "children", "style", "customStyle", "codeTagProps", "useInlineStyles", "showLineNumbers", "showInlineLineNumbers", "startingLineNumber", "lineNumberContainerStyle", "lineNumberStyle", "wrapLines", "wrapLongLines", "lineProps", "renderer", "PreTag", "CodeTag", "code", "astGenerator"];
    function ownKeys(object, enumerableOnly) {
      var keys2 = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty$1(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    var newLineRegex = /\n/g;
    function getNewLines(str) {
      return str.match(newLineRegex);
    }
    function getAllLineNumbers(_ref) {
      var lines = _ref.lines, startingLineNumber = _ref.startingLineNumber, style2 = _ref.style;
      return lines.map(function(_2, i2) {
        var number2 = i2 + startingLineNumber;
        return /* @__PURE__ */ React.createElement("span", {
          key: "line-".concat(i2),
          className: "react-syntax-highlighter-line-number",
          style: typeof style2 === "function" ? style2(number2) : style2
        }, "".concat(number2, "\n"));
      });
    }
    function AllLineNumbers(_ref2) {
      var codeString = _ref2.codeString, codeStyle = _ref2.codeStyle, _ref2$containerStyle = _ref2.containerStyle, containerStyle = _ref2$containerStyle === void 0 ? {
        "float": "left",
        paddingRight: "10px"
      } : _ref2$containerStyle, _ref2$numberStyle = _ref2.numberStyle, numberStyle = _ref2$numberStyle === void 0 ? {} : _ref2$numberStyle, startingLineNumber = _ref2.startingLineNumber;
      return /* @__PURE__ */ React.createElement("code", {
        style: Object.assign({}, codeStyle, containerStyle)
      }, getAllLineNumbers({
        lines: codeString.replace(/\n$/, "").split("\n"),
        style: numberStyle,
        startingLineNumber
      }));
    }
    function getEmWidthOfNumber(num) {
      return "".concat(num.toString().length, ".25em");
    }
    function getInlineLineNumber(lineNumber, inlineLineNumberStyle) {
      return {
        type: "element",
        tagName: "span",
        properties: {
          key: "line-number--".concat(lineNumber),
          className: ["comment", "linenumber", "react-syntax-highlighter-line-number"],
          style: inlineLineNumberStyle
        },
        children: [{
          type: "text",
          value: lineNumber
        }]
      };
    }
    function assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber) {
      var defaultLineNumberStyle = {
        display: "inline-block",
        minWidth: getEmWidthOfNumber(largestLineNumber),
        paddingRight: "1em",
        textAlign: "right",
        userSelect: "none"
      };
      var customLineNumberStyle = typeof lineNumberStyle === "function" ? lineNumberStyle(lineNumber) : lineNumberStyle;
      var assembledStyle = _objectSpread(_objectSpread({}, defaultLineNumberStyle), customLineNumberStyle);
      return assembledStyle;
    }
    function createLineElement(_ref3) {
      var children = _ref3.children, lineNumber = _ref3.lineNumber, lineNumberStyle = _ref3.lineNumberStyle, largestLineNumber = _ref3.largestLineNumber, showInlineLineNumbers = _ref3.showInlineLineNumbers, _ref3$lineProps = _ref3.lineProps, lineProps = _ref3$lineProps === void 0 ? {} : _ref3$lineProps, _ref3$className = _ref3.className, className = _ref3$className === void 0 ? [] : _ref3$className, showLineNumbers = _ref3.showLineNumbers, wrapLongLines = _ref3.wrapLongLines;
      var properties = typeof lineProps === "function" ? lineProps(lineNumber) : lineProps;
      properties["className"] = className;
      if (lineNumber && showInlineLineNumbers) {
        var inlineLineNumberStyle = assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber);
        children.unshift(getInlineLineNumber(lineNumber, inlineLineNumberStyle));
      }
      if (wrapLongLines & showLineNumbers) {
        properties.style = _objectSpread(_objectSpread({}, properties.style), {}, {
          display: "flex"
        });
      }
      return {
        type: "element",
        tagName: "span",
        properties,
        children
      };
    }
    function flattenCodeTree(tree) {
      var className = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var newTree = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      if (tree.type === "root") {
        return flattenCodeTree(tree.children, className, newTree);
      }
      for (var i2 = 0; i2 < tree.length; i2++) {
        var node2 = tree[i2];
        if (node2.type === "text") {
          newTree.push(createLineElement({
            children: [node2],
            className: _toConsumableArray$1(new Set(className))
          }));
        } else if (node2.children) {
          var classNames2 = className.concat(node2.properties.className);
          flattenCodeTree(node2.children, classNames2).forEach(function(i3) {
            return newTree.push(i3);
          });
        }
      }
      return newTree;
    }
    function processLines(codeTree, wrapLines, lineProps, showLineNumbers, showInlineLineNumbers, startingLineNumber, largestLineNumber, lineNumberStyle, wrapLongLines) {
      var _ref4;
      var tree = flattenCodeTree(codeTree.value);
      var newTree = [];
      var lastLineBreakIndex = -1;
      var index2 = 0;
      function createWrappedLine(children2, lineNumber2) {
        var className = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
        return createLineElement({
          children: children2,
          lineNumber: lineNumber2,
          lineNumberStyle,
          largestLineNumber,
          showInlineLineNumbers,
          lineProps,
          className,
          showLineNumbers,
          wrapLongLines
        });
      }
      function createUnwrappedLine(children2, lineNumber2) {
        if (showLineNumbers && lineNumber2 && showInlineLineNumbers) {
          var inlineLineNumberStyle = assembleLineNumberStyles(lineNumberStyle, lineNumber2, largestLineNumber);
          children2.unshift(getInlineLineNumber(lineNumber2, inlineLineNumberStyle));
        }
        return children2;
      }
      function createLine(children2, lineNumber2) {
        var className = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
        return wrapLines || className.length > 0 ? createWrappedLine(children2, lineNumber2, className) : createUnwrappedLine(children2, lineNumber2);
      }
      var _loop = function _loop2() {
        var node2 = tree[index2];
        var value = node2.children[0].value;
        var newLines = getNewLines(value);
        if (newLines) {
          var splitValue = value.split("\n");
          splitValue.forEach(function(text2, i2) {
            var lineNumber2 = showLineNumbers && newTree.length + startingLineNumber;
            var newChild = {
              type: "text",
              value: "".concat(text2, "\n")
            };
            if (i2 === 0) {
              var _children = tree.slice(lastLineBreakIndex + 1, index2).concat(createLineElement({
                children: [newChild],
                className: node2.properties.className
              }));
              var _line = createLine(_children, lineNumber2);
              newTree.push(_line);
            } else if (i2 === splitValue.length - 1) {
              var stringChild = tree[index2 + 1] && tree[index2 + 1].children && tree[index2 + 1].children[0];
              var lastLineInPreviousSpan = {
                type: "text",
                value: "".concat(text2)
              };
              if (stringChild) {
                var newElem = createLineElement({
                  children: [lastLineInPreviousSpan],
                  className: node2.properties.className
                });
                tree.splice(index2 + 1, 0, newElem);
              } else {
                var _children2 = [lastLineInPreviousSpan];
                var _line2 = createLine(_children2, lineNumber2, node2.properties.className);
                newTree.push(_line2);
              }
            } else {
              var _children3 = [newChild];
              var _line3 = createLine(_children3, lineNumber2, node2.properties.className);
              newTree.push(_line3);
            }
          });
          lastLineBreakIndex = index2;
        }
        index2++;
      };
      while (index2 < tree.length) {
        _loop();
      }
      if (lastLineBreakIndex !== tree.length - 1) {
        var children = tree.slice(lastLineBreakIndex + 1, tree.length);
        if (children && children.length) {
          var lineNumber = showLineNumbers && newTree.length + startingLineNumber;
          var line2 = createLine(children, lineNumber);
          newTree.push(line2);
        }
      }
      return wrapLines ? newTree : (_ref4 = []).concat.apply(_ref4, newTree);
    }
    function defaultRenderer(_ref5) {
      var rows = _ref5.rows, stylesheet2 = _ref5.stylesheet, useInlineStyles = _ref5.useInlineStyles;
      return rows.map(function(node2, i2) {
        return createElement({
          node: node2,
          stylesheet: stylesheet2,
          useInlineStyles,
          key: "code-segement".concat(i2)
        });
      });
    }
    function isHighlightJs(astGenerator) {
      return astGenerator && typeof astGenerator.highlightAuto !== "undefined";
    }
    function getCodeTree(_ref6) {
      var astGenerator = _ref6.astGenerator, language = _ref6.language, code2 = _ref6.code, defaultCodeValue = _ref6.defaultCodeValue;
      if (isHighlightJs(astGenerator)) {
        var hasLanguage = checkForListedLanguage(astGenerator, language);
        if (language === "text") {
          return {
            value: defaultCodeValue,
            language: "text"
          };
        } else if (hasLanguage) {
          return astGenerator.highlight(language, code2);
        } else {
          return astGenerator.highlightAuto(code2);
        }
      }
      try {
        return language && language !== "text" ? {
          value: astGenerator.highlight(code2, language)
        } : {
          value: defaultCodeValue
        };
      } catch (e2) {
        return {
          value: defaultCodeValue
        };
      }
    }
    function highlight$1(defaultAstGenerator, defaultStyle2) {
      return function SyntaxHighlighter2(_ref7) {
        var language = _ref7.language, children = _ref7.children, _ref7$style = _ref7.style, style2 = _ref7$style === void 0 ? defaultStyle2 : _ref7$style, _ref7$customStyle = _ref7.customStyle, customStyle = _ref7$customStyle === void 0 ? {} : _ref7$customStyle, _ref7$codeTagProps = _ref7.codeTagProps, codeTagProps = _ref7$codeTagProps === void 0 ? {
          className: language ? "language-".concat(language) : void 0,
          style: _objectSpread(_objectSpread({}, style2['code[class*="language-"]']), style2['code[class*="language-'.concat(language, '"]')])
        } : _ref7$codeTagProps, _ref7$useInlineStyles = _ref7.useInlineStyles, useInlineStyles = _ref7$useInlineStyles === void 0 ? true : _ref7$useInlineStyles, _ref7$showLineNumbers = _ref7.showLineNumbers, showLineNumbers = _ref7$showLineNumbers === void 0 ? false : _ref7$showLineNumbers, _ref7$showInlineLineN = _ref7.showInlineLineNumbers, showInlineLineNumbers = _ref7$showInlineLineN === void 0 ? true : _ref7$showInlineLineN, _ref7$startingLineNum = _ref7.startingLineNumber, startingLineNumber = _ref7$startingLineNum === void 0 ? 1 : _ref7$startingLineNum, lineNumberContainerStyle = _ref7.lineNumberContainerStyle, _ref7$lineNumberStyle = _ref7.lineNumberStyle, lineNumberStyle = _ref7$lineNumberStyle === void 0 ? {} : _ref7$lineNumberStyle, wrapLines = _ref7.wrapLines, _ref7$wrapLongLines = _ref7.wrapLongLines, wrapLongLines = _ref7$wrapLongLines === void 0 ? false : _ref7$wrapLongLines, _ref7$lineProps = _ref7.lineProps, lineProps = _ref7$lineProps === void 0 ? {} : _ref7$lineProps, renderer = _ref7.renderer, _ref7$PreTag = _ref7.PreTag, PreTag = _ref7$PreTag === void 0 ? "pre" : _ref7$PreTag, _ref7$CodeTag = _ref7.CodeTag, CodeTag = _ref7$CodeTag === void 0 ? "code" : _ref7$CodeTag, _ref7$code = _ref7.code, code2 = _ref7$code === void 0 ? (Array.isArray(children) ? children[0] : children) || "" : _ref7$code, astGenerator = _ref7.astGenerator, rest = _objectWithoutProperties$1(_ref7, _excluded);
        astGenerator = astGenerator || defaultAstGenerator;
        var allLineNumbers = showLineNumbers ? /* @__PURE__ */ React.createElement(AllLineNumbers, {
          containerStyle: lineNumberContainerStyle,
          codeStyle: codeTagProps.style || {},
          numberStyle: lineNumberStyle,
          startingLineNumber,
          codeString: code2
        }) : null;
        var defaultPreStyle = style2.hljs || style2['pre[class*="language-"]'] || {
          backgroundColor: "#fff"
        };
        var generatorClassName = isHighlightJs(astGenerator) ? "hljs" : "prismjs";
        var preProps = useInlineStyles ? Object.assign({}, rest, {
          style: Object.assign({}, defaultPreStyle, customStyle)
        }) : Object.assign({}, rest, {
          className: rest.className ? "".concat(generatorClassName, " ").concat(rest.className) : generatorClassName,
          style: Object.assign({}, customStyle)
        });
        if (wrapLongLines) {
          codeTagProps.style = _objectSpread(_objectSpread({}, codeTagProps.style), {}, {
            whiteSpace: "pre-wrap"
          });
        } else {
          codeTagProps.style = _objectSpread(_objectSpread({}, codeTagProps.style), {}, {
            whiteSpace: "pre"
          });
        }
        if (!astGenerator) {
          return /* @__PURE__ */ React.createElement(PreTag, preProps, allLineNumbers, /* @__PURE__ */ React.createElement(CodeTag, codeTagProps, code2));
        }
        if (wrapLines === void 0 && renderer || wrapLongLines)
          wrapLines = true;
        renderer = renderer || defaultRenderer;
        var defaultCodeValue = [{
          type: "text",
          value: code2
        }];
        var codeTree = getCodeTree({
          astGenerator,
          language,
          code: code2,
          defaultCodeValue
        });
        if (codeTree.language === null) {
          codeTree.value = defaultCodeValue;
        }
        var lineCount = codeTree.value.length;
        if (lineCount === 1 && codeTree.value[0].type === "text") {
          lineCount = codeTree.value[0].value.split("\n").length;
        }
        var largestLineNumber = lineCount + startingLineNumber;
        var rows = processLines(codeTree, wrapLines, lineProps, showLineNumbers, showInlineLineNumbers, startingLineNumber, largestLineNumber, lineNumberStyle, wrapLongLines);
        return /* @__PURE__ */ React.createElement(PreTag, preProps, /* @__PURE__ */ React.createElement(CodeTag, codeTagProps, !showInlineLineNumbers && allLineNumbers, renderer({
          rows,
          stylesheet: style2,
          useInlineStyles
        })));
      };
    }
    const supportedLanguages = ["abap", "abnf", "actionscript", "ada", "agda", "al", "antlr4", "apacheconf", "apex", "apl", "applescript", "aql", "arduino", "arff", "armasm", "arturo", "asciidoc", "asm6502", "asmatmel", "aspnet", "autohotkey", "autoit", "avisynth", "avro-idl", "awk", "bash", "basic", "batch", "bbcode", "bbj", "bicep", "birb", "bison", "bnf", "bqn", "brainfuck", "brightscript", "bro", "bsl", "c", "cfscript", "chaiscript", "cil", "cilkc", "cilkcpp", "clike", "clojure", "cmake", "cobol", "coffeescript", "concurnas", "cooklang", "coq", "cpp", "crystal", "csharp", "cshtml", "csp", "css-extras", "css", "csv", "cue", "cypher", "d", "dart", "dataweave", "dax", "dhall", "diff", "django", "dns-zone-file", "docker", "dot", "ebnf", "editorconfig", "eiffel", "ejs", "elixir", "elm", "erb", "erlang", "etlua", "excel-formula", "factor", "false", "firestore-security-rules", "flow", "fortran", "fsharp", "ftl", "gap", "gcode", "gdscript", "gedcom", "gettext", "gherkin", "git", "glsl", "gml", "gn", "go-module", "go", "gradle", "graphql", "groovy", "haml", "handlebars", "haskell", "haxe", "hcl", "hlsl", "hoon", "hpkp", "hsts", "http", "ichigojam", "icon", "icu-message-format", "idris", "iecst", "ignore", "inform7", "ini", "io", "j", "java", "javadoc", "javadoclike", "javascript", "javastacktrace", "jexl", "jolie", "jq", "js-extras", "js-templates", "jsdoc", "json", "json5", "jsonp", "jsstacktrace", "jsx", "julia", "keepalived", "keyman", "kotlin", "kumir", "kusto", "latex", "latte", "less", "lilypond", "linker-script", "liquid", "lisp", "livescript", "llvm", "log", "lolcode", "lua", "magma", "makefile", "markdown", "markup-templating", "markup", "mata", "matlab", "maxscript", "mel", "mermaid", "metafont", "mizar", "mongodb", "monkey", "moonscript", "n1ql", "n4js", "nand2tetris-hdl", "naniscript", "nasm", "neon", "nevod", "nginx", "nim", "nix", "nsis", "objectivec", "ocaml", "odin", "opencl", "openqasm", "oz", "parigp", "parser", "pascal", "pascaligo", "pcaxis", "peoplecode", "perl", "php-extras", "php", "phpdoc", "plant-uml", "plsql", "powerquery", "powershell", "processing", "prolog", "promql", "properties", "protobuf", "psl", "pug", "puppet", "pure", "purebasic", "purescript", "python", "q", "qml", "qore", "qsharp", "r", "racket", "reason", "regex", "rego", "renpy", "rescript", "rest", "rip", "roboconf", "robotframework", "ruby", "rust", "sas", "sass", "scala", "scheme", "scss", "shell-session", "smali", "smalltalk", "smarty", "sml", "solidity", "solution-file", "soy", "sparql", "splunk-spl", "sqf", "sql", "squirrel", "stan", "stata", "stylus", "supercollider", "swift", "systemd", "t4-cs", "t4-templating", "t4-vb", "tap", "tcl", "textile", "toml", "tremor", "tsx", "tt2", "turtle", "twig", "typescript", "typoscript", "unrealscript", "uorazor", "uri", "v", "vala", "vbnet", "velocity", "verilog", "vhdl", "vim", "visual-basic", "warpscript", "wasm", "web-idl", "wgsl", "wiki", "wolfram", "wren", "xeora", "xml-doc", "xojo", "xquery", "yaml", "yang", "zig"];
    var search = /[#.]/g;
    const parseSelector = (
      /**
       * @type {(
       *  <Selector extends string, DefaultTagName extends string = 'div'>(selector?: Selector, defaultTagName?: DefaultTagName) => Element & {tagName: import('./extract.js').ExtractTagName<Selector, DefaultTagName>}
       * )}
       */
      /**
       * @param {string} [selector]
       * @param {string} [defaultTagName='div']
       * @returns {Element}
       */
      function(selector, defaultTagName = "div") {
        var value = selector || "";
        var props = {};
        var start = 0;
        var subvalue;
        var previous2;
        var match5;
        while (start < value.length) {
          search.lastIndex = start;
          match5 = search.exec(value);
          subvalue = value.slice(start, match5 ? match5.index : value.length);
          if (subvalue) {
            if (!previous2) {
              defaultTagName = subvalue;
            } else if (previous2 === "#") {
              props.id = subvalue;
            } else if (Array.isArray(props.className)) {
              props.className.push(subvalue);
            } else {
              props.className = [subvalue];
            }
            start += subvalue.length;
          }
          if (match5) {
            previous2 = match5[0];
            start++;
          }
        }
        return {
          type: "element",
          tagName: defaultTagName,
          properties: props,
          children: []
        };
      }
    );
    const buttonTypes = /* @__PURE__ */ new Set(["menu", "submit", "reset", "button"]);
    const own$7 = {}.hasOwnProperty;
    function core(schema, defaultTagName, caseSensitive) {
      const adjust = caseSensitive && createAdjustMap(caseSensitive);
      const h2 = (
        /**
         * @type {{
         *   (): Root
         *   (selector: null|undefined, ...children: HChild[]): Root
         *   (selector: string, properties?: HProperties, ...children: HChild[]): Element
         *   (selector: string, ...children: HChild[]): Element
         * }}
         */
        /**
         * Hyperscript compatible DSL for creating virtual hast trees.
         *
         * @param {string|null} [selector]
         * @param {HProperties|HChild} [properties]
         * @param {HChild[]} children
         * @returns {HResult}
         */
        function(selector, properties, ...children) {
          let index2 = -1;
          let node2;
          if (selector === void 0 || selector === null) {
            node2 = { type: "root", children: [] };
            children.unshift(properties);
          } else {
            node2 = parseSelector(selector, defaultTagName);
            node2.tagName = node2.tagName.toLowerCase();
            if (adjust && own$7.call(adjust, node2.tagName)) {
              node2.tagName = adjust[node2.tagName];
            }
            if (isProperties(properties, node2.tagName)) {
              let key;
              for (key in properties) {
                if (own$7.call(properties, key)) {
                  addProperty(schema, node2.properties, key, properties[key]);
                }
              }
            } else {
              children.unshift(properties);
            }
          }
          while (++index2 < children.length) {
            addChild(node2.children, children[index2]);
          }
          if (node2.type === "element" && node2.tagName === "template") {
            node2.content = { type: "root", children: node2.children };
            node2.children = [];
          }
          return node2;
        }
      );
      return h2;
    }
    function isProperties(value, name2) {
      if (value === null || value === void 0 || typeof value !== "object" || Array.isArray(value)) {
        return false;
      }
      if (name2 === "input" || !value.type || typeof value.type !== "string") {
        return true;
      }
      if ("children" in value && Array.isArray(value.children)) {
        return false;
      }
      if (name2 === "button") {
        return buttonTypes.has(value.type.toLowerCase());
      }
      return !("value" in value);
    }
    function addProperty(schema, properties, key, value) {
      const info = find(schema, key);
      let index2 = -1;
      let result;
      if (value === void 0 || value === null)
        return;
      if (typeof value === "number") {
        if (Number.isNaN(value))
          return;
        result = value;
      } else if (typeof value === "boolean") {
        result = value;
      } else if (typeof value === "string") {
        if (info.spaceSeparated) {
          result = parse$3(value);
        } else if (info.commaSeparated) {
          result = parse$2(value);
        } else if (info.commaOrSpaceSeparated) {
          result = parse$3(parse$2(value).join(" "));
        } else {
          result = parsePrimitive(info, info.property, value);
        }
      } else if (Array.isArray(value)) {
        result = value.concat();
      } else {
        result = info.property === "style" ? style$1(value) : String(value);
      }
      if (Array.isArray(result)) {
        const finalResult = [];
        while (++index2 < result.length) {
          finalResult[index2] = parsePrimitive(info, info.property, result[index2]);
        }
        result = finalResult;
      }
      if (info.property === "className" && Array.isArray(properties.className)) {
        result = properties.className.concat(result);
      }
      properties[info.property] = result;
    }
    function addChild(nodes2, value) {
      let index2 = -1;
      if (value === void 0 || value === null)
        ;
      else if (typeof value === "string" || typeof value === "number") {
        nodes2.push({ type: "text", value: String(value) });
      } else if (Array.isArray(value)) {
        while (++index2 < value.length) {
          addChild(nodes2, value[index2]);
        }
      } else if (typeof value === "object" && "type" in value) {
        if (value.type === "root") {
          addChild(nodes2, value.children);
        } else {
          nodes2.push(value);
        }
      } else {
        throw new Error("Expected node, nodes, or string, got `" + value + "`");
      }
    }
    function parsePrimitive(info, name2, value) {
      if (typeof value === "string") {
        if (info.number && value && !Number.isNaN(Number(value))) {
          return Number(value);
        }
        if ((info.boolean || info.overloadedBoolean) && (value === "" || normalize(value) === normalize(name2))) {
          return true;
        }
      }
      return value;
    }
    function style$1(value) {
      const result = [];
      let key;
      for (key in value) {
        if (own$7.call(value, key)) {
          result.push([key, value[key]].join(": "));
        }
      }
      return result.join("; ");
    }
    function createAdjustMap(values) {
      const result = {};
      let index2 = -1;
      while (++index2 < values.length) {
        result[values[index2].toLowerCase()] = values[index2];
      }
      return result;
    }
    const h = core(html$1, "div");
    const svgCaseSensitiveTagNames = [
      "altGlyph",
      "altGlyphDef",
      "altGlyphItem",
      "animateColor",
      "animateMotion",
      "animateTransform",
      "clipPath",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDistantLight",
      "feDropShadow",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence",
      "foreignObject",
      "glyphRef",
      "linearGradient",
      "radialGradient",
      "solidColor",
      "textArea",
      "textPath"
    ];
    const s = core(svg, "g", svgCaseSensitiveTagNames);
    const characterEntitiesLegacy = [
      "AElig",
      "AMP",
      "Aacute",
      "Acirc",
      "Agrave",
      "Aring",
      "Atilde",
      "Auml",
      "COPY",
      "Ccedil",
      "ETH",
      "Eacute",
      "Ecirc",
      "Egrave",
      "Euml",
      "GT",
      "Iacute",
      "Icirc",
      "Igrave",
      "Iuml",
      "LT",
      "Ntilde",
      "Oacute",
      "Ocirc",
      "Ograve",
      "Oslash",
      "Otilde",
      "Ouml",
      "QUOT",
      "REG",
      "THORN",
      "Uacute",
      "Ucirc",
      "Ugrave",
      "Uuml",
      "Yacute",
      "aacute",
      "acirc",
      "acute",
      "aelig",
      "agrave",
      "amp",
      "aring",
      "atilde",
      "auml",
      "brvbar",
      "ccedil",
      "cedil",
      "cent",
      "copy",
      "curren",
      "deg",
      "divide",
      "eacute",
      "ecirc",
      "egrave",
      "eth",
      "euml",
      "frac12",
      "frac14",
      "frac34",
      "gt",
      "iacute",
      "icirc",
      "iexcl",
      "igrave",
      "iquest",
      "iuml",
      "laquo",
      "lt",
      "macr",
      "micro",
      "middot",
      "nbsp",
      "not",
      "ntilde",
      "oacute",
      "ocirc",
      "ograve",
      "ordf",
      "ordm",
      "oslash",
      "otilde",
      "ouml",
      "para",
      "plusmn",
      "pound",
      "quot",
      "raquo",
      "reg",
      "sect",
      "shy",
      "sup1",
      "sup2",
      "sup3",
      "szlig",
      "thorn",
      "times",
      "uacute",
      "ucirc",
      "ugrave",
      "uml",
      "uuml",
      "yacute",
      "yen",
      "yuml"
    ];
    const characterReferenceInvalid = {
      0: "�",
      128: "€",
      130: "‚",
      131: "ƒ",
      132: "„",
      133: "…",
      134: "†",
      135: "‡",
      136: "ˆ",
      137: "‰",
      138: "Š",
      139: "‹",
      140: "Œ",
      142: "Ž",
      145: "‘",
      146: "’",
      147: "“",
      148: "”",
      149: "•",
      150: "–",
      151: "—",
      152: "˜",
      153: "™",
      154: "š",
      155: "›",
      156: "œ",
      158: "ž",
      159: "Ÿ"
    };
    function isDecimal(character2) {
      const code2 = typeof character2 === "string" ? character2.charCodeAt(0) : character2;
      return code2 >= 48 && code2 <= 57;
    }
    function isHexadecimal(character2) {
      const code2 = typeof character2 === "string" ? character2.charCodeAt(0) : character2;
      return code2 >= 97 && code2 <= 102 || code2 >= 65 && code2 <= 70 || code2 >= 48 && code2 <= 57;
    }
    function isAlphabetical(character2) {
      const code2 = typeof character2 === "string" ? character2.charCodeAt(0) : character2;
      return code2 >= 97 && code2 <= 122 || code2 >= 65 && code2 <= 90;
    }
    function isAlphanumerical(character2) {
      return isAlphabetical(character2) || isDecimal(character2);
    }
    const fromCharCode$2 = String.fromCharCode;
    const messages = [
      "",
      /* 1: Non terminated (named) */
      "Named character references must be terminated by a semicolon",
      /* 2: Non terminated (numeric) */
      "Numeric character references must be terminated by a semicolon",
      /* 3: Empty (named) */
      "Named character references cannot be empty",
      /* 4: Empty (numeric) */
      "Numeric character references cannot be empty",
      /* 5: Unknown (named) */
      "Named character references must be known",
      /* 6: Disallowed (numeric) */
      "Numeric character references cannot be disallowed",
      /* 7: Prohibited (numeric) */
      "Numeric character references cannot be outside the permissible Unicode range"
    ];
    function parseEntities(value, options = {}) {
      const additional = typeof options.additional === "string" ? options.additional.charCodeAt(0) : options.additional;
      const result = [];
      let index2 = 0;
      let lines = -1;
      let queue = "";
      let point2;
      let indent;
      if (options.position) {
        if ("start" in options.position || "indent" in options.position) {
          indent = options.position.indent;
          point2 = options.position.start;
        } else {
          point2 = options.position;
        }
      }
      let line2 = (point2 ? point2.line : 0) || 1;
      let column2 = (point2 ? point2.column : 0) || 1;
      let previous2 = now2();
      let character2;
      index2--;
      while (++index2 <= value.length) {
        if (character2 === 10) {
          column2 = (indent ? indent[lines] : 0) || 1;
        }
        character2 = value.charCodeAt(index2);
        if (character2 === 38) {
          const following = value.charCodeAt(index2 + 1);
          if (following === 9 || following === 10 || following === 12 || following === 32 || following === 38 || following === 60 || Number.isNaN(following) || additional && following === additional) {
            queue += fromCharCode$2(character2);
            column2++;
            continue;
          }
          const start = index2 + 1;
          let begin = start;
          let end = start;
          let type;
          if (following === 35) {
            end = ++begin;
            const following2 = value.charCodeAt(end);
            if (following2 === 88 || following2 === 120) {
              type = "hexadecimal";
              end = ++begin;
            } else {
              type = "decimal";
            }
          } else {
            type = "named";
          }
          let characterReferenceCharacters = "";
          let characterReference2 = "";
          let characters2 = "";
          const test = type === "named" ? isAlphanumerical : type === "decimal" ? isDecimal : isHexadecimal;
          end--;
          while (++end <= value.length) {
            const following2 = value.charCodeAt(end);
            if (!test(following2)) {
              break;
            }
            characters2 += fromCharCode$2(following2);
            if (type === "named" && characterEntitiesLegacy.includes(characters2)) {
              characterReferenceCharacters = characters2;
              characterReference2 = decodeNamedCharacterReference(characters2);
            }
          }
          let terminated = value.charCodeAt(end) === 59;
          if (terminated) {
            end++;
            const namedReference = type === "named" ? decodeNamedCharacterReference(characters2) : false;
            if (namedReference) {
              characterReferenceCharacters = characters2;
              characterReference2 = namedReference;
            }
          }
          let diff2 = 1 + end - start;
          let reference = "";
          if (!terminated && options.nonTerminated === false)
            ;
          else if (!characters2) {
            if (type !== "named") {
              warning(4, diff2);
            }
          } else if (type === "named") {
            if (terminated && !characterReference2) {
              warning(5, 1);
            } else {
              if (characterReferenceCharacters !== characters2) {
                end = begin + characterReferenceCharacters.length;
                diff2 = 1 + end - begin;
                terminated = false;
              }
              if (!terminated) {
                const reason = characterReferenceCharacters ? 1 : 3;
                if (options.attribute) {
                  const following2 = value.charCodeAt(end);
                  if (following2 === 61) {
                    warning(reason, diff2);
                    characterReference2 = "";
                  } else if (isAlphanumerical(following2)) {
                    characterReference2 = "";
                  } else {
                    warning(reason, diff2);
                  }
                } else {
                  warning(reason, diff2);
                }
              }
            }
            reference = characterReference2;
          } else {
            if (!terminated) {
              warning(2, diff2);
            }
            let referenceCode = Number.parseInt(
              characters2,
              type === "hexadecimal" ? 16 : 10
            );
            if (prohibited(referenceCode)) {
              warning(7, diff2);
              reference = fromCharCode$2(
                65533
                /* `�` */
              );
            } else if (referenceCode in characterReferenceInvalid) {
              warning(6, diff2);
              reference = characterReferenceInvalid[referenceCode];
            } else {
              let output = "";
              if (disallowed(referenceCode)) {
                warning(6, diff2);
              }
              if (referenceCode > 65535) {
                referenceCode -= 65536;
                output += fromCharCode$2(referenceCode >>> (10 & 1023) | 55296);
                referenceCode = 56320 | referenceCode & 1023;
              }
              reference = output + fromCharCode$2(referenceCode);
            }
          }
          if (reference) {
            flush();
            previous2 = now2();
            index2 = end - 1;
            column2 += end - start + 1;
            result.push(reference);
            const next2 = now2();
            next2.offset++;
            if (options.reference) {
              options.reference.call(
                options.referenceContext,
                reference,
                { start: previous2, end: next2 },
                value.slice(start - 1, end)
              );
            }
            previous2 = next2;
          } else {
            characters2 = value.slice(start - 1, end);
            queue += characters2;
            column2 += characters2.length;
            index2 = end - 1;
          }
        } else {
          if (character2 === 10) {
            line2++;
            lines++;
            column2 = 0;
          }
          if (Number.isNaN(character2)) {
            flush();
          } else {
            queue += fromCharCode$2(character2);
            column2++;
          }
        }
      }
      return result.join("");
      function now2() {
        return {
          line: line2,
          column: column2,
          offset: index2 + ((point2 ? point2.offset : 0) || 0)
        };
      }
      function warning(code2, offset2) {
        let position2;
        if (options.warning) {
          position2 = now2();
          position2.column += offset2;
          position2.offset += offset2;
          options.warning.call(
            options.warningContext,
            messages[code2],
            position2,
            code2
          );
        }
      }
      function flush() {
        if (queue) {
          result.push(queue);
          if (options.text) {
            options.text.call(options.textContext, queue, {
              start: previous2,
              end: now2()
            });
          }
          queue = "";
        }
      }
    }
    function prohibited(code2) {
      return code2 >= 55296 && code2 <= 57343 || code2 > 1114111;
    }
    function disallowed(code2) {
      return code2 >= 1 && code2 <= 8 || code2 === 11 || code2 >= 13 && code2 <= 31 || code2 >= 127 && code2 <= 159 || code2 >= 64976 && code2 <= 65007 || (code2 & 65535) === 65535 || (code2 & 65535) === 65534;
    }
    var uniqueId = 0;
    var plainTextGrammar = {};
    var _ = {
      /**
       * A namespace for utility methods.
       *
       * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
       * change or disappear at any time.
       *
       * @namespace
       * @memberof Prism
       */
      util: {
        /**
         * Returns the name of the type of the given value.
         *
         * @param {any} o
         * @returns {string}
         * @example
         * type(null)      === 'Null'
         * type(undefined) === 'Undefined'
         * type(123)       === 'Number'
         * type('foo')     === 'String'
         * type(true)      === 'Boolean'
         * type([1, 2])    === 'Array'
         * type({})        === 'Object'
         * type(String)    === 'Function'
         * type(/abc+/)    === 'RegExp'
         */
        type: function(o2) {
          return Object.prototype.toString.call(o2).slice(8, -1);
        },
        /**
         * Returns a unique number for the given object. Later calls will still return the same number.
         *
         * @param {Object} obj
         * @returns {number}
         */
        objId: function(obj) {
          if (!obj["__id"]) {
            Object.defineProperty(obj, "__id", { value: ++uniqueId });
          }
          return obj["__id"];
        },
        /**
         * Creates a deep clone of the given object.
         *
         * The main intended use of this function is to clone language definitions.
         *
         * @param {T} o
         * @param {Record<number, any>} [visited]
         * @returns {T}
         * @template T
         */
        clone: function deepClone(o2, visited) {
          visited = visited || {};
          var clone2;
          var id2;
          switch (_.util.type(o2)) {
            case "Object":
              id2 = _.util.objId(o2);
              if (visited[id2]) {
                return visited[id2];
              }
              clone2 = /** @type {Record<string, any>} */
              {};
              visited[id2] = clone2;
              for (var key in o2) {
                if (o2.hasOwnProperty(key)) {
                  clone2[key] = deepClone(o2[key], visited);
                }
              }
              return (
                /** @type {any} */
                clone2
              );
            case "Array":
              id2 = _.util.objId(o2);
              if (visited[id2]) {
                return visited[id2];
              }
              clone2 = [];
              visited[id2] = clone2;
              o2.forEach(function(v2, i2) {
                clone2[i2] = deepClone(v2, visited);
              });
              return (
                /** @type {any} */
                clone2
              );
            default:
              return o2;
          }
        }
      },
      /**
       * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
       *
       * @namespace
       * @memberof Prism
       * @public
       */
      languages: {
        /**
         * The grammar for plain, unformatted text.
         */
        plain: plainTextGrammar,
        plaintext: plainTextGrammar,
        text: plainTextGrammar,
        txt: plainTextGrammar,
        /**
         * Creates a deep copy of the language with the given id and appends the given tokens.
         *
         * If a token in `redef` also appears in the copied language, then the existing token in the copied language
         * will be overwritten at its original position.
         *
         * ## Best practices
         *
         * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
         * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
         * understand the language definition because, normally, the order of tokens matters in Prism grammars.
         *
         * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
         * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
         *
         * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
         * @param {Grammar} redef The new tokens to append.
         * @returns {Grammar} The new language created.
         * @public
         * @example
         * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
         *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
         *     // at its original position
         *     'comment': { ... },
         *     // CSS doesn't have a 'color' token, so this token will be appended
         *     'color': /\b(?:red|green|blue)\b/
         * });
         */
        extend: function(id2, redef) {
          var lang2 = _.util.clone(_.languages[id2]);
          for (var key in redef) {
            lang2[key] = redef[key];
          }
          return lang2;
        },
        /**
         * Inserts tokens _before_ another token in a language definition or any other grammar.
         *
         * ## Usage
         *
         * This helper method makes it easy to modify existing languages. For example, the CSS language definition
         * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
         * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
         * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
         * this:
         *
         * ```js
         * Prism.languages.markup.style = {
         *     // token
         * };
         * ```
         *
         * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
         * before existing tokens. For the CSS example above, you would use it like this:
         *
         * ```js
         * Prism.languages.insertBefore('markup', 'cdata', {
         *     'style': {
         *         // token
         *     }
         * });
         * ```
         *
         * ## Special cases
         *
         * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
         * will be ignored.
         *
         * This behavior can be used to insert tokens after `before`:
         *
         * ```js
         * Prism.languages.insertBefore('markup', 'comment', {
         *     'comment': Prism.languages.markup.comment,
         *     // tokens after 'comment'
         * });
         * ```
         *
         * ## Limitations
         *
         * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
         * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
         * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
         * deleting properties which is necessary to insert at arbitrary positions.
         *
         * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
         * Instead, it will create a new object and replace all references to the target object with the new one. This
         * can be done without temporarily deleting properties, so the iteration order is well-defined.
         *
         * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
         * you hold the target object in a variable, then the value of the variable will not change.
         *
         * ```js
         * var oldMarkup = Prism.languages.markup;
         * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
         *
         * assert(oldMarkup !== Prism.languages.markup);
         * assert(newMarkup === Prism.languages.markup);
         * ```
         *
         * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
         * object to be modified.
         * @param {string} before The key to insert before.
         * @param {Grammar} insert An object containing the key-value pairs to be inserted.
         * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
         * object to be modified.
         *
         * Defaults to `Prism.languages`.
         * @returns {Grammar} The new grammar object.
         * @public
         */
        insertBefore: function(inside, before, insert, root2) {
          root2 = root2 || /** @type {any} */
          _.languages;
          var grammar = root2[inside];
          var ret = {};
          for (var token2 in grammar) {
            if (grammar.hasOwnProperty(token2)) {
              if (token2 == before) {
                for (var newToken in insert) {
                  if (insert.hasOwnProperty(newToken)) {
                    ret[newToken] = insert[newToken];
                  }
                }
              }
              if (!insert.hasOwnProperty(token2)) {
                ret[token2] = grammar[token2];
              }
            }
          }
          var old = root2[inside];
          root2[inside] = ret;
          _.languages.DFS(_.languages, function(key, value) {
            if (value === old && key != inside) {
              this[key] = ret;
            }
          });
          return ret;
        },
        // Traverse a language definition with Depth First Search
        DFS: function DFS(o2, callback, type, visited) {
          visited = visited || {};
          var objId = _.util.objId;
          for (var i2 in o2) {
            if (o2.hasOwnProperty(i2)) {
              callback.call(o2, i2, o2[i2], type || i2);
              var property = o2[i2];
              var propertyType = _.util.type(property);
              if (propertyType === "Object" && !visited[objId(property)]) {
                visited[objId(property)] = true;
                DFS(property, callback, null, visited);
              } else if (propertyType === "Array" && !visited[objId(property)]) {
                visited[objId(property)] = true;
                DFS(property, callback, i2, visited);
              }
            }
          }
        }
      },
      plugins: {},
      /**
       * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
       * and the language definitions to use, and returns a string with the HTML produced.
       *
       * The following hooks will be run:
       * 1. `before-tokenize`
       * 2. `after-tokenize`
       * 3. `wrap`: On each {@link Token}.
       *
       * @param {string} text A string with the code to be highlighted.
       * @param {Grammar} grammar An object containing the tokens to use.
       *
       * Usually a language definition like `Prism.languages.markup`.
       * @param {string} language The name of the language definition passed to `grammar`.
       * @returns {string} The highlighted HTML.
       * @memberof Prism
       * @public
       * @example
       * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
       */
      highlight: function(text2, grammar, language) {
        var env = {
          code: text2,
          grammar,
          language
        };
        _.hooks.run("before-tokenize", env);
        if (!env.grammar) {
          throw new Error('The language "' + env.language + '" has no grammar.');
        }
        env.tokens = _.tokenize(env.code, env.grammar);
        _.hooks.run("after-tokenize", env);
        return Token.stringify(_.util.encode(env.tokens), env.language);
      },
      /**
       * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
       * and the language definitions to use, and returns an array with the tokenized code.
       *
       * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
       *
       * This method could be useful in other contexts as well, as a very crude parser.
       *
       * @param {string} text A string with the code to be highlighted.
       * @param {Grammar} grammar An object containing the tokens to use.
       *
       * Usually a language definition like `Prism.languages.markup`.
       * @returns {TokenStream} An array of strings and tokens, a token stream.
       * @memberof Prism
       * @public
       * @example
       * let code = `var foo = 0;`;
       * let tokens = Prism.tokenize(code, Prism.languages.javascript);
       * tokens.forEach(token => {
       *     if (token instanceof Prism.Token && token.type === 'number') {
       *         console.log(`Found numeric literal: ${token.content}`);
       *     }
       * });
       */
      tokenize: function(text2, grammar) {
        var rest = grammar.rest;
        if (rest) {
          for (var token2 in rest) {
            grammar[token2] = rest[token2];
          }
          delete grammar.rest;
        }
        var tokenList = new LinkedList();
        addAfter(tokenList, tokenList.head, text2);
        matchGrammar(text2, tokenList, grammar, tokenList.head, 0);
        return toArray(tokenList);
      },
      /**
       * @namespace
       * @memberof Prism
       * @public
       */
      hooks: {
        all: {},
        /**
         * Adds the given callback to the list of callbacks for the given hook.
         *
         * The callback will be invoked when the hook it is registered for is run.
         * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
         *
         * One callback function can be registered to multiple hooks and the same hook multiple times.
         *
         * @param {string} name The name of the hook.
         * @param {HookCallback} callback The callback function which is given environment variables.
         * @public
         */
        add: function(name2, callback) {
          var hooks2 = _.hooks.all;
          hooks2[name2] = hooks2[name2] || [];
          hooks2[name2].push(callback);
        },
        /**
         * Runs a hook invoking all registered callbacks with the given environment variables.
         *
         * Callbacks will be invoked synchronously and in the order in which they were registered.
         *
         * @param {string} name The name of the hook.
         * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
         * @public
         */
        run: function(name2, env) {
          var callbacks = _.hooks.all[name2];
          if (!callbacks || !callbacks.length) {
            return;
          }
          for (var i2 = 0, callback; callback = callbacks[i2++]; ) {
            callback(env);
          }
        }
      },
      Token
    };
    function Token(type, content2, alias2, matchedStr) {
      this.type = type;
      this.content = content2;
      this.alias = alias2;
      this.length = (matchedStr || "").length | 0;
    }
    function matchPattern(pattern, pos, text2, lookbehind) {
      pattern.lastIndex = pos;
      var match5 = pattern.exec(text2);
      if (match5 && lookbehind && match5[1]) {
        var lookbehindLength = match5[1].length;
        match5.index += lookbehindLength;
        match5[0] = match5[0].slice(lookbehindLength);
      }
      return match5;
    }
    function matchGrammar(text2, tokenList, grammar, startNode, startPos, rematch) {
      for (var token2 in grammar) {
        if (!grammar.hasOwnProperty(token2) || !grammar[token2]) {
          continue;
        }
        var patterns = grammar[token2];
        patterns = Array.isArray(patterns) ? patterns : [patterns];
        for (var j = 0; j < patterns.length; ++j) {
          if (rematch && rematch.cause == token2 + "," + j) {
            return;
          }
          var patternObj = patterns[j];
          var inside = patternObj.inside;
          var lookbehind = !!patternObj.lookbehind;
          var greedy = !!patternObj.greedy;
          var alias2 = patternObj.alias;
          if (greedy && !patternObj.pattern.global) {
            var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
            patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
          }
          var pattern = patternObj.pattern || patternObj;
          for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
            if (rematch && pos >= rematch.reach) {
              break;
            }
            var str = currentNode.value;
            if (tokenList.length > text2.length) {
              return;
            }
            if (str instanceof Token) {
              continue;
            }
            var removeCount = 1;
            var match5;
            if (greedy) {
              match5 = matchPattern(pattern, pos, text2, lookbehind);
              if (!match5 || match5.index >= text2.length) {
                break;
              }
              var from2 = match5.index;
              var to2 = match5.index + match5[0].length;
              var p2 = pos;
              p2 += currentNode.value.length;
              while (from2 >= p2) {
                currentNode = currentNode.next;
                p2 += currentNode.value.length;
              }
              p2 -= currentNode.value.length;
              pos = p2;
              if (currentNode.value instanceof Token) {
                continue;
              }
              for (var k2 = currentNode; k2 !== tokenList.tail && (p2 < to2 || typeof k2.value === "string"); k2 = k2.next) {
                removeCount++;
                p2 += k2.value.length;
              }
              removeCount--;
              str = text2.slice(pos, p2);
              match5.index -= pos;
            } else {
              match5 = matchPattern(pattern, 0, str, lookbehind);
              if (!match5) {
                continue;
              }
            }
            var from2 = match5.index;
            var matchStr = match5[0];
            var before = str.slice(0, from2);
            var after = str.slice(from2 + matchStr.length);
            var reach = pos + str.length;
            if (rematch && reach > rematch.reach) {
              rematch.reach = reach;
            }
            var removeFrom = currentNode.prev;
            if (before) {
              removeFrom = addAfter(tokenList, removeFrom, before);
              pos += before.length;
            }
            removeRange(tokenList, removeFrom, removeCount);
            var wrapped = new Token(
              token2,
              inside ? _.tokenize(matchStr, inside) : matchStr,
              alias2,
              matchStr
            );
            currentNode = addAfter(tokenList, removeFrom, wrapped);
            if (after) {
              addAfter(tokenList, currentNode, after);
            }
            if (removeCount > 1) {
              var nestedRematch = {
                cause: token2 + "," + j,
                reach
              };
              matchGrammar(
                text2,
                tokenList,
                grammar,
                currentNode.prev,
                pos,
                nestedRematch
              );
              if (rematch && nestedRematch.reach > rematch.reach) {
                rematch.reach = nestedRematch.reach;
              }
            }
          }
        }
      }
    }
    function LinkedList() {
      var head = { value: null, prev: null, next: null };
      var tail = { value: null, prev: head, next: null };
      head.next = tail;
      this.head = head;
      this.tail = tail;
      this.length = 0;
    }
    function addAfter(list2, node2, value) {
      var next2 = node2.next;
      var newNode = { value, prev: node2, next: next2 };
      node2.next = newNode;
      next2.prev = newNode;
      list2.length++;
      return newNode;
    }
    function removeRange(list2, node2, count) {
      var next2 = node2.next;
      for (var i2 = 0; i2 < count && next2 !== list2.tail; i2++) {
        next2 = next2.next;
      }
      node2.next = next2;
      next2.prev = node2;
      list2.length -= i2;
    }
    function toArray(list2) {
      var array = [];
      var node2 = list2.head.next;
      while (node2 !== list2.tail) {
        array.push(node2.value);
        node2 = node2.next;
      }
      return array;
    }
    const Prism = _;
    const own$6 = {}.hasOwnProperty;
    function Refractor() {
    }
    Refractor.prototype = Prism;
    const refractor = new Refractor();
    refractor.highlight = highlight;
    refractor.register = register;
    refractor.alias = alias;
    refractor.registered = registered;
    refractor.listLanguages = listLanguages;
    refractor.util.encode = encode;
    refractor.Token.stringify = stringify;
    function highlight(value, language) {
      if (typeof value !== "string") {
        throw new TypeError("Expected `string` for `value`, got `" + value + "`");
      }
      let grammar;
      let name2;
      if (language && typeof language === "object") {
        grammar = language;
      } else {
        name2 = language;
        if (typeof name2 !== "string") {
          throw new TypeError("Expected `string` for `name`, got `" + name2 + "`");
        }
        if (own$6.call(refractor.languages, name2)) {
          grammar = refractor.languages[name2];
        } else {
          throw new Error("Unknown language: `" + name2 + "` is not registered");
        }
      }
      return {
        type: "root",
        // @ts-expect-error: we hacked Prism to accept and return the things we want.
        children: Prism.highlight.call(refractor, value, grammar, name2)
      };
    }
    function register(syntax2) {
      if (typeof syntax2 !== "function" || !syntax2.displayName) {
        throw new Error("Expected `function` for `syntax`, got `" + syntax2 + "`");
      }
      if (!own$6.call(refractor.languages, syntax2.displayName)) {
        syntax2(refractor);
      }
    }
    function alias(language, alias2) {
      const languages = refractor.languages;
      let map2 = {};
      if (typeof language === "string") {
        if (alias2) {
          map2[language] = alias2;
        }
      } else {
        map2 = language;
      }
      let key;
      for (key in map2) {
        if (own$6.call(map2, key)) {
          const value = map2[key];
          const list2 = typeof value === "string" ? [value] : value;
          let index2 = -1;
          while (++index2 < list2.length) {
            languages[list2[index2]] = languages[key];
          }
        }
      }
    }
    function registered(aliasOrLanguage) {
      if (typeof aliasOrLanguage !== "string") {
        throw new TypeError(
          "Expected `string` for `aliasOrLanguage`, got `" + aliasOrLanguage + "`"
        );
      }
      return own$6.call(refractor.languages, aliasOrLanguage);
    }
    function listLanguages() {
      const languages = refractor.languages;
      const list2 = [];
      let language;
      for (language in languages) {
        if (own$6.call(languages, language) && typeof languages[language] === "object") {
          list2.push(language);
        }
      }
      return list2;
    }
    function stringify(value, language) {
      if (typeof value === "string") {
        return { type: "text", value };
      }
      if (Array.isArray(value)) {
        const result = [];
        let index2 = -1;
        while (++index2 < value.length) {
          if (value[index2] !== "" && value[index2] !== null && value[index2] !== void 0) {
            result.push(stringify(value[index2], language));
          }
        }
        return result;
      }
      const env = {
        type: value.type,
        content: stringify(value.content, language),
        tag: "span",
        classes: ["token", value.type],
        attributes: {},
        language
      };
      if (value.alias) {
        env.classes.push(
          ...typeof value.alias === "string" ? [value.alias] : value.alias
        );
      }
      refractor.hooks.run("wrap", env);
      return h(
        env.tag + "." + env.classes.join("."),
        attributes$1(env.attributes),
        env.content
      );
    }
    function encode(tokens2) {
      return tokens2;
    }
    function attributes$1(attrs) {
      let key;
      for (key in attrs) {
        if (own$6.call(attrs, key)) {
          attrs[key] = parseEntities(attrs[key]);
        }
      }
      return attrs;
    }
    const defaultStyle = {
      'code[class*="language-"]': {
        "color": "black",
        "background": "none",
        "textShadow": "0 1px white",
        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "fontSize": "1em",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
      },
      'pre[class*="language-"]': {
        "color": "black",
        "background": "#f5f2f0",
        "textShadow": "0 1px white",
        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "fontSize": "1em",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "padding": "1em",
        "margin": ".5em 0",
        "overflow": "auto"
      },
      'pre[class*="language-"]::-moz-selection': {
        "textShadow": "none",
        "background": "#b3d4fc"
      },
      'pre[class*="language-"] ::-moz-selection': {
        "textShadow": "none",
        "background": "#b3d4fc"
      },
      'code[class*="language-"]::-moz-selection': {
        "textShadow": "none",
        "background": "#b3d4fc"
      },
      'code[class*="language-"] ::-moz-selection': {
        "textShadow": "none",
        "background": "#b3d4fc"
      },
      'pre[class*="language-"]::selection': {
        "textShadow": "none",
        "background": "#b3d4fc"
      },
      'pre[class*="language-"] ::selection': {
        "textShadow": "none",
        "background": "#b3d4fc"
      },
      'code[class*="language-"]::selection': {
        "textShadow": "none",
        "background": "#b3d4fc"
      },
      'code[class*="language-"] ::selection': {
        "textShadow": "none",
        "background": "#b3d4fc"
      },
      ':not(pre) > code[class*="language-"]': {
        "background": "#f5f2f0",
        "padding": ".1em",
        "borderRadius": ".3em",
        "whiteSpace": "normal"
      },
      "comment": {
        "color": "slategray"
      },
      "prolog": {
        "color": "slategray"
      },
      "doctype": {
        "color": "slategray"
      },
      "cdata": {
        "color": "slategray"
      },
      "punctuation": {
        "color": "#999"
      },
      "namespace": {
        "Opacity": ".7"
      },
      "property": {
        "color": "#905"
      },
      "tag": {
        "color": "#905"
      },
      "boolean": {
        "color": "#905"
      },
      "number": {
        "color": "#905"
      },
      "constant": {
        "color": "#905"
      },
      "symbol": {
        "color": "#905"
      },
      "deleted": {
        "color": "#905"
      },
      "selector": {
        "color": "#690"
      },
      "attr-name": {
        "color": "#690"
      },
      "string": {
        "color": "#690"
      },
      "char": {
        "color": "#690"
      },
      "builtin": {
        "color": "#690"
      },
      "inserted": {
        "color": "#690"
      },
      "operator": {
        "color": "#9a6e3a",
        "background": "hsla(0, 0%, 100%, .5)"
      },
      "entity": {
        "color": "#9a6e3a",
        "background": "hsla(0, 0%, 100%, .5)",
        "cursor": "help"
      },
      "url": {
        "color": "#9a6e3a",
        "background": "hsla(0, 0%, 100%, .5)"
      },
      ".language-css .token.string": {
        "color": "#9a6e3a",
        "background": "hsla(0, 0%, 100%, .5)"
      },
      ".style .token.string": {
        "color": "#9a6e3a",
        "background": "hsla(0, 0%, 100%, .5)"
      },
      "atrule": {
        "color": "#07a"
      },
      "attr-value": {
        "color": "#07a"
      },
      "keyword": {
        "color": "#07a"
      },
      "function": {
        "color": "#DD4A68"
      },
      "class-name": {
        "color": "#DD4A68"
      },
      "regex": {
        "color": "#e90"
      },
      "important": {
        "color": "#e90",
        "fontWeight": "bold"
      },
      "variable": {
        "color": "#e90"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "italic": {
        "fontStyle": "italic"
      }
    };
    clike.displayName = "clike";
    clike.aliases = [];
    function clike(Prism2) {
      Prism2.languages.clike = {
        comment: [
          {
            pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
            lookbehind: true,
            greedy: true
          },
          {
            pattern: /(^|[^\\:])\/\/.*/,
            lookbehind: true,
            greedy: true
          }
        ],
        string: {
          pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
          greedy: true
        },
        "class-name": {
          pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
          lookbehind: true,
          inside: {
            punctuation: /[.\\]/
          }
        },
        keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
        boolean: /\b(?:false|true)\b/,
        function: /\b\w+(?=\()/,
        number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
        operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
        punctuation: /[{}[\];(),.:]/
      };
    }
    c$1.displayName = "c";
    c$1.aliases = [];
    function c$1(Prism2) {
      Prism2.register(clike);
      Prism2.languages.c = Prism2.languages.extend("clike", {
        comment: {
          pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
          greedy: true
        },
        string: {
          // https://en.cppreference.com/w/c/language/string_literal
          pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
          greedy: true
        },
        "class-name": {
          pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
          lookbehind: true
        },
        keyword: /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
        function: /\b[a-z_]\w*(?=\s*\()/i,
        number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
        operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
      });
      Prism2.languages.insertBefore("c", "string", {
        char: {
          // https://en.cppreference.com/w/c/language/character_constant
          pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
          greedy: true
        }
      });
      Prism2.languages.insertBefore("c", "string", {
        macro: {
          // allow for multiline macro definitions
          // spaces after the # character compile fine with gcc
          pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
          lookbehind: true,
          greedy: true,
          alias: "property",
          inside: {
            string: [
              {
                // highlight the path of the include statement as a string
                pattern: /^(#\s*include\s*)<[^>]+>/,
                lookbehind: true
              },
              Prism2.languages.c["string"]
            ],
            char: Prism2.languages.c["char"],
            comment: Prism2.languages.c["comment"],
            "macro-name": [
              {
                pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
                lookbehind: true
              },
              {
                pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
                lookbehind: true,
                alias: "function"
              }
            ],
            // highlight macro directives as keywords
            directive: {
              pattern: /^(#\s*)[a-z]+/,
              lookbehind: true,
              alias: "keyword"
            },
            "directive-hash": /^#/,
            punctuation: /##|\\(?=[\r\n])/,
            expression: {
              pattern: /\S[\s\S]*/,
              inside: Prism2.languages.c
            }
          }
        }
      });
      Prism2.languages.insertBefore("c", "function", {
        // highlight predefined macros as constants
        constant: /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
      });
      delete Prism2.languages.c["boolean"];
    }
    cpp.displayName = "cpp";
    cpp.aliases = [];
    function cpp(Prism2) {
      Prism2.register(c$1);
      (function(Prism3) {
        var keyword = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/;
        var modName = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(
          /<keyword>/g,
          function() {
            return keyword.source;
          }
        );
        Prism3.languages.cpp = Prism3.languages.extend("c", {
          "class-name": [
            {
              pattern: RegExp(
                /(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(
                  /<keyword>/g,
                  function() {
                    return keyword.source;
                  }
                )
              ),
              lookbehind: true
            },
            // This is intended to capture the class name of method implementations like:
            //   void foo::bar() const {}
            // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
            // it starts with an uppercase letter. This approximation should give decent results.
            /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
            // This will capture the class name before destructors like:
            //   Foo::~Foo() {}
            /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
            // This also intends to capture the class name of method implementations but here the class has template
            // parameters, so it can't be a namespace (until C++ adds generic namespaces).
            /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
          ],
          keyword,
          number: {
            pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
            greedy: true
          },
          operator: />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
          boolean: /\b(?:false|true)\b/
        });
        Prism3.languages.insertBefore("cpp", "string", {
          module: {
            // https://en.cppreference.com/w/cpp/language/modules
            pattern: RegExp(
              /(\b(?:import|module)\s+)/.source + "(?:" + // header-name
              /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + // module name or partition or both
              /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(
                /<mod-name>/g,
                function() {
                  return modName;
                }
              ) + ")"
            ),
            lookbehind: true,
            greedy: true,
            inside: {
              string: /^[<"][\s\S]+/,
              operator: /:/,
              punctuation: /\./
            }
          },
          "raw-string": {
            pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
            alias: "string",
            greedy: true
          }
        });
        Prism3.languages.insertBefore("cpp", "keyword", {
          "generic-function": {
            pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
            inside: {
              function: /^\w+/,
              generic: {
                pattern: /<[\s\S]+/,
                alias: "class-name",
                inside: Prism3.languages.cpp
              }
            }
          }
        });
        Prism3.languages.insertBefore("cpp", "operator", {
          "double-colon": {
            pattern: /::/,
            alias: "punctuation"
          }
        });
        Prism3.languages.insertBefore("cpp", "class-name", {
          // the base clause is an optional list of parent classes
          // https://en.cppreference.com/w/cpp/language/class
          "base-clause": {
            pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
            lookbehind: true,
            greedy: true,
            inside: Prism3.languages.extend("cpp", {})
          }
        });
        Prism3.languages.insertBefore(
          "inside",
          "double-colon",
          {
            // All untokenized words that are not namespaces should be class names
            "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
          },
          Prism3.languages.cpp["base-clause"]
        );
      })(Prism2);
    }
    arduino.displayName = "arduino";
    arduino.aliases = ["ino"];
    function arduino(Prism2) {
      Prism2.register(cpp);
      Prism2.languages.arduino = Prism2.languages.extend("cpp", {
        keyword: /\b(?:String|array|bool|boolean|break|byte|case|catch|continue|default|do|double|else|finally|for|function|goto|if|in|instanceof|int|integer|long|loop|new|null|return|setup|string|switch|throw|try|void|while|word)\b/,
        constant: /\b(?:ANALOG_MESSAGE|DEFAULT|DIGITAL_MESSAGE|EXTERNAL|FIRMATA_STRING|HIGH|INPUT|INPUT_PULLUP|INTERNAL|INTERNAL1V1|INTERNAL2V56|LED_BUILTIN|LOW|OUTPUT|REPORT_ANALOG|REPORT_DIGITAL|SET_PIN_MODE|SYSEX_START|SYSTEM_RESET)\b/,
        builtin: /\b(?:Audio|BSSID|Bridge|Client|Console|EEPROM|Esplora|EsploraTFT|Ethernet|EthernetClient|EthernetServer|EthernetUDP|File|FileIO|FileSystem|Firmata|GPRS|GSM|GSMBand|GSMClient|GSMModem|GSMPIN|GSMScanner|GSMServer|GSMVoiceCall|GSM_SMS|HttpClient|IPAddress|IRread|Keyboard|KeyboardController|LiquidCrystal|LiquidCrystal_I2C|Mailbox|Mouse|MouseController|PImage|Process|RSSI|RobotControl|RobotMotor|SD|SPI|SSID|Scheduler|Serial|Server|Servo|SoftwareSerial|Stepper|Stream|TFT|Task|USBHost|WiFi|WiFiClient|WiFiServer|WiFiUDP|Wire|YunClient|YunServer|abs|addParameter|analogRead|analogReadResolution|analogReference|analogWrite|analogWriteResolution|answerCall|attach|attachGPRS|attachInterrupt|attached|autoscroll|available|background|beep|begin|beginPacket|beginSD|beginSMS|beginSpeaker|beginTFT|beginTransmission|beginWrite|bit|bitClear|bitRead|bitSet|bitWrite|blink|blinkVersion|buffer|changePIN|checkPIN|checkPUK|checkReg|circle|cityNameRead|cityNameWrite|clear|clearScreen|click|close|compassRead|config|connect|connected|constrain|cos|countryNameRead|countryNameWrite|createChar|cursor|debugPrint|delay|delayMicroseconds|detach|detachInterrupt|digitalRead|digitalWrite|disconnect|display|displayLogos|drawBMP|drawCompass|encryptionType|end|endPacket|endSMS|endTransmission|endWrite|exists|exitValue|fill|find|findUntil|flush|gatewayIP|get|getAsynchronously|getBand|getButton|getCurrentCarrier|getIMEI|getKey|getModifiers|getOemKey|getPINUsed|getResult|getSignalStrength|getSocket|getVoiceCallStatus|getXChange|getYChange|hangCall|height|highByte|home|image|interrupts|isActionDone|isDirectory|isListening|isPIN|isPressed|isValid|keyPressed|keyReleased|keyboardRead|knobRead|leftToRight|line|lineFollowConfig|listen|listenOnLocalhost|loadImage|localIP|lowByte|macAddress|maintain|map|max|messageAvailable|micros|millis|min|mkdir|motorsStop|motorsWrite|mouseDragged|mouseMoved|mousePressed|mouseReleased|move|noAutoscroll|noBlink|noBuffer|noCursor|noDisplay|noFill|noInterrupts|noListenOnLocalhost|noStroke|noTone|onReceive|onRequest|open|openNextFile|overflow|parseCommand|parseFloat|parseInt|parsePacket|pauseMode|peek|pinMode|playFile|playMelody|point|pointTo|position|pow|prepare|press|print|printFirmwareVersion|printVersion|println|process|processInput|pulseIn|put|random|randomSeed|read|readAccelerometer|readBlue|readButton|readBytes|readBytesUntil|readGreen|readJoystickButton|readJoystickSwitch|readJoystickX|readJoystickY|readLightSensor|readMessage|readMicrophone|readNetworks|readRed|readSlider|readString|readStringUntil|readTemperature|ready|rect|release|releaseAll|remoteIP|remoteNumber|remotePort|remove|requestFrom|retrieveCallingNumber|rewindDirectory|rightToLeft|rmdir|robotNameRead|robotNameWrite|run|runAsynchronously|runShellCommand|runShellCommandAsynchronously|running|scanNetworks|scrollDisplayLeft|scrollDisplayRight|seek|sendAnalog|sendDigitalPortPair|sendDigitalPorts|sendString|sendSysex|serialEvent|setBand|setBitOrder|setClockDivider|setCursor|setDNS|setDataMode|setFirmwareVersion|setMode|setPINUsed|setSpeed|setTextSize|setTimeout|shiftIn|shiftOut|shutdown|sin|size|sqrt|startLoop|step|stop|stroke|subnetMask|switchPIN|tan|tempoWrite|text|tone|transfer|tuneWrite|turn|updateIR|userNameRead|userNameWrite|voiceCall|waitContinue|width|write|writeBlue|writeGreen|writeJSON|writeMessage|writeMicroseconds|writeRGB|writeRed|yield)\b/
      });
      Prism2.languages.ino = Prism2.languages.arduino;
    }
    bash.displayName = "bash";
    bash.aliases = ["sh", "shell"];
    function bash(Prism2) {
      (function(Prism3) {
        var envVars = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b";
        var commandAfterHeredoc = {
          pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
          lookbehind: true,
          alias: "punctuation",
          // this looks reasonably well in all themes
          inside: null
          // see below
        };
        var insideString = {
          bash: commandAfterHeredoc,
          environment: {
            pattern: RegExp("\\$" + envVars),
            alias: "constant"
          },
          variable: [
            // [0]: Arithmetic Environment
            {
              pattern: /\$?\(\([\s\S]+?\)\)/,
              greedy: true,
              inside: {
                // If there is a $ sign at the beginning highlight $(( and )) as variable
                variable: [
                  {
                    pattern: /(^\$\(\([\s\S]+)\)\)/,
                    lookbehind: true
                  },
                  /^\$\(\(/
                ],
                number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
                // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
                operator: /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
                // If there is no $ sign at the beginning highlight (( and )) as punctuation
                punctuation: /\(\(?|\)\)?|,|;/
              }
            },
            // [1]: Command Substitution
            {
              pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
              greedy: true,
              inside: {
                variable: /^\$\(|^`|\)$|`$/
              }
            },
            // [2]: Brace expansion
            {
              pattern: /\$\{[^}]+\}/,
              greedy: true,
              inside: {
                operator: /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
                punctuation: /[\[\]]/,
                environment: {
                  pattern: RegExp("(\\{)" + envVars),
                  lookbehind: true,
                  alias: "constant"
                }
              }
            },
            /\$(?:\w+|[#?*!@$])/
          ],
          // Escape sequences from echo and printf's manuals, and escaped quotes.
          entity: /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
        };
        Prism3.languages.bash = {
          shebang: {
            pattern: /^#!\s*\/.*/,
            alias: "important"
          },
          comment: {
            pattern: /(^|[^"{\\$])#.*/,
            lookbehind: true
          },
          "function-name": [
            // a) function foo {
            // b) foo() {
            // c) function foo() {
            // but not “foo {”
            {
              // a) and c)
              pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
              lookbehind: true,
              alias: "function"
            },
            {
              // b)
              pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
              alias: "function"
            }
          ],
          // Highlight variable names as variables in for and select beginnings.
          "for-or-select": {
            pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
            alias: "variable",
            lookbehind: true
          },
          // Highlight variable names as variables in the left-hand part
          // of assignments (“=” and “+=”).
          "assign-left": {
            pattern: /(^|[\s;|&]|[<>]\()\w+(?:\.\w+)*(?=\+?=)/,
            inside: {
              environment: {
                pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + envVars),
                lookbehind: true,
                alias: "constant"
              }
            },
            alias: "variable",
            lookbehind: true
          },
          // Highlight parameter names as variables
          parameter: {
            pattern: /(^|\s)-{1,2}(?:\w+:[+-]?)?\w+(?:\.\w+)*(?=[=\s]|$)/,
            alias: "variable",
            lookbehind: true
          },
          string: [
            // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
            {
              pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
              lookbehind: true,
              greedy: true,
              inside: insideString
            },
            // Here-document with quotes around the tag
            // → No expansion (so no “inside”).
            {
              pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
              lookbehind: true,
              greedy: true,
              inside: {
                bash: commandAfterHeredoc
              }
            },
            // “Normal” string
            {
              // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
              pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
              lookbehind: true,
              greedy: true,
              inside: insideString
            },
            {
              // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
              pattern: /(^|[^$\\])'[^']*'/,
              lookbehind: true,
              greedy: true
            },
            {
              // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
              pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
              greedy: true,
              inside: {
                entity: insideString.entity
              }
            }
          ],
          environment: {
            pattern: RegExp("\\$?" + envVars),
            alias: "constant"
          },
          variable: insideString.variable,
          function: {
            pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
            lookbehind: true
          },
          keyword: {
            pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
            lookbehind: true
          },
          // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
          builtin: {
            pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
            lookbehind: true,
            // Alias added to make those easier to distinguish from strings.
            alias: "class-name"
          },
          boolean: {
            pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
            lookbehind: true
          },
          "file-descriptor": {
            pattern: /\B&\d\b/,
            alias: "important"
          },
          operator: {
            // Lots of redirections here, but not just that.
            pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
            inside: {
              "file-descriptor": {
                pattern: /^\d/,
                alias: "important"
              }
            }
          },
          punctuation: /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
          number: {
            pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
            lookbehind: true
          }
        };
        commandAfterHeredoc.inside = Prism3.languages.bash;
        var toBeCopied = [
          "comment",
          "function-name",
          "for-or-select",
          "assign-left",
          "parameter",
          "string",
          "environment",
          "function",
          "keyword",
          "builtin",
          "boolean",
          "file-descriptor",
          "operator",
          "punctuation",
          "number"
        ];
        var inside = insideString.variable[1].inside;
        for (var i2 = 0; i2 < toBeCopied.length; i2++) {
          inside[toBeCopied[i2]] = Prism3.languages.bash[toBeCopied[i2]];
        }
        Prism3.languages.sh = Prism3.languages.bash;
        Prism3.languages.shell = Prism3.languages.bash;
      })(Prism2);
    }
    csharp.displayName = "csharp";
    csharp.aliases = ["cs", "dotnet"];
    function csharp(Prism2) {
      Prism2.register(clike);
      (function(Prism3) {
        function replace2(pattern, replacements) {
          return pattern.replace(/<<(\d+)>>/g, function(m2, index2) {
            return "(?:" + replacements[+index2] + ")";
          });
        }
        function re2(pattern, replacements, flags) {
          return RegExp(replace2(pattern, replacements), flags || "");
        }
        function nested(pattern, depthLog2) {
          for (var i2 = 0; i2 < depthLog2; i2++) {
            pattern = pattern.replace(/<<self>>/g, function() {
              return "(?:" + pattern + ")";
            });
          }
          return pattern.replace(/<<self>>/g, "[^\\s\\S]");
        }
        var keywordKinds = {
          // keywords which represent a return or variable type
          type: "bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void",
          // keywords which are used to declare a type
          typeDeclaration: "class enum interface record struct",
          // contextual keywords
          // ("var" and "dynamic" are missing because they are used like types)
          contextual: "add alias and ascending async await by descending from(?=\\s*(?:\\w|$)) get global group into init(?=\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\s*{)",
          // all other keywords
          other: "abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield"
        };
        function keywordsToPattern(words) {
          return "\\b(?:" + words.trim().replace(/ /g, "|") + ")\\b";
        }
        var typeDeclarationKeywords = keywordsToPattern(
          keywordKinds.typeDeclaration
        );
        var keywords2 = RegExp(
          keywordsToPattern(
            keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other
          )
        );
        var nonTypeKeywords = keywordsToPattern(
          keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other
        );
        var nonContextualKeywords = keywordsToPattern(
          keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.other
        );
        var generic = nested(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source, 2);
        var nestedRound = nested(/\((?:[^()]|<<self>>)*\)/.source, 2);
        var name2 = /@?\b[A-Za-z_]\w*\b/.source;
        var genericName = replace2(/<<0>>(?:\s*<<1>>)?/.source, [name2, generic]);
        var identifier2 = replace2(/(?!<<0>>)<<1>>(?:\s*\.\s*<<1>>)*/.source, [
          nonTypeKeywords,
          genericName
        ]);
        var array = /\[\s*(?:,\s*)*\]/.source;
        var typeExpressionWithoutTuple = replace2(
          /<<0>>(?:\s*(?:\?\s*)?<<1>>)*(?:\s*\?)?/.source,
          [identifier2, array]
        );
        var tupleElement = replace2(
          /[^,()<>[\];=+\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source,
          [generic, nestedRound, array]
        );
        var tuple = replace2(/\(<<0>>+(?:,<<0>>+)+\)/.source, [tupleElement]);
        var typeExpression = replace2(
          /(?:<<0>>|<<1>>)(?:\s*(?:\?\s*)?<<2>>)*(?:\s*\?)?/.source,
          [tuple, identifier2, array]
        );
        var typeInside = {
          keyword: keywords2,
          punctuation: /[<>()?,.:[\]]/
        };
        var character2 = /'(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'/.source;
        var regularString = /"(?:\\.|[^\\"\r\n])*"/.source;
        var verbatimString = /@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source;
        Prism3.languages.csharp = Prism3.languages.extend("clike", {
          string: [
            {
              pattern: re2(/(^|[^$\\])<<0>>/.source, [verbatimString]),
              lookbehind: true,
              greedy: true
            },
            {
              pattern: re2(/(^|[^@$\\])<<0>>/.source, [regularString]),
              lookbehind: true,
              greedy: true
            }
          ],
          "class-name": [
            {
              // Using static
              // using static System.Math;
              pattern: re2(/(\busing\s+static\s+)<<0>>(?=\s*;)/.source, [
                identifier2
              ]),
              lookbehind: true,
              inside: typeInside
            },
            {
              // Using alias (type)
              // using Project = PC.MyCompany.Project;
              pattern: re2(/(\busing\s+<<0>>\s*=\s*)<<1>>(?=\s*;)/.source, [
                name2,
                typeExpression
              ]),
              lookbehind: true,
              inside: typeInside
            },
            {
              // Using alias (alias)
              // using Project = PC.MyCompany.Project;
              pattern: re2(/(\busing\s+)<<0>>(?=\s*=)/.source, [name2]),
              lookbehind: true
            },
            {
              // Type declarations
              // class Foo<A, B>
              // interface Foo<out A, B>
              pattern: re2(/(\b<<0>>\s+)<<1>>/.source, [
                typeDeclarationKeywords,
                genericName
              ]),
              lookbehind: true,
              inside: typeInside
            },
            {
              // Single catch exception declaration
              // catch(Foo)
              // (things like catch(Foo e) is covered by variable declaration)
              pattern: re2(/(\bcatch\s*\(\s*)<<0>>/.source, [identifier2]),
              lookbehind: true,
              inside: typeInside
            },
            {
              // Name of the type parameter of generic constraints
              // where Foo : class
              pattern: re2(/(\bwhere\s+)<<0>>/.source, [name2]),
              lookbehind: true
            },
            {
              // Casts and checks via as and is.
              // as Foo<A>, is Bar<B>
              // (things like if(a is Foo b) is covered by variable declaration)
              pattern: re2(/(\b(?:is(?:\s+not)?|as)\s+)<<0>>/.source, [
                typeExpressionWithoutTuple
              ]),
              lookbehind: true,
              inside: typeInside
            },
            {
              // Variable, field and parameter declaration
              // (Foo bar, Bar baz, Foo[,,] bay, Foo<Bar, FooBar<Bar>> bax)
              pattern: re2(
                /\b<<0>>(?=\s+(?!<<1>>|with\s*\{)<<2>>(?:\s*[=,;:{)\]]|\s+(?:in|when)\b))/.source,
                [typeExpression, nonContextualKeywords, name2]
              ),
              inside: typeInside
            }
          ],
          keyword: keywords2,
          // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#literals
          number: /(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:[dflmu]|lu|ul)?\b/i,
          operator: />>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/,
          punctuation: /\?\.?|::|[{}[\];(),.:]/
        });
        Prism3.languages.insertBefore("csharp", "number", {
          range: {
            pattern: /\.\./,
            alias: "operator"
          }
        });
        Prism3.languages.insertBefore("csharp", "punctuation", {
          "named-parameter": {
            pattern: re2(/([(,]\s*)<<0>>(?=\s*:)/.source, [name2]),
            lookbehind: true,
            alias: "punctuation"
          }
        });
        Prism3.languages.insertBefore("csharp", "class-name", {
          namespace: {
            // namespace Foo.Bar {}
            // using Foo.Bar;
            pattern: re2(
              /(\b(?:namespace|using)\s+)<<0>>(?:\s*\.\s*<<0>>)*(?=\s*[;{])/.source,
              [name2]
            ),
            lookbehind: true,
            inside: {
              punctuation: /\./
            }
          },
          "type-expression": {
            // default(Foo), typeof(Foo<Bar>), sizeof(int)
            pattern: re2(
              /(\b(?:default|sizeof|typeof)\s*\(\s*(?!\s))(?:[^()\s]|\s(?!\s)|<<0>>)*(?=\s*\))/.source,
              [nestedRound]
            ),
            lookbehind: true,
            alias: "class-name",
            inside: typeInside
          },
          "return-type": {
            // Foo<Bar> ForBar(); Foo IFoo.Bar() => 0
            // int this[int index] => 0; T IReadOnlyList<T>.this[int index] => this[index];
            // int Foo => 0; int Foo { get; set } = 0;
            pattern: re2(
              /<<0>>(?=\s+(?:<<1>>\s*(?:=>|[({]|\.\s*this\s*\[)|this\s*\[))/.source,
              [typeExpression, identifier2]
            ),
            inside: typeInside,
            alias: "class-name"
          },
          "constructor-invocation": {
            // new List<Foo<Bar[]>> { }
            pattern: re2(/(\bnew\s+)<<0>>(?=\s*[[({])/.source, [typeExpression]),
            lookbehind: true,
            inside: typeInside,
            alias: "class-name"
          },
          /*'explicit-implementation': {
          // int IFoo<Foo>.Bar => 0; void IFoo<Foo<Foo>>.Foo<T>();
          pattern: replace(/\b<<0>>(?=\.<<1>>)/, className, methodOrPropertyDeclaration),
          inside: classNameInside,
          alias: 'class-name'
          },*/
          "generic-method": {
            // foo<Bar>()
            pattern: re2(/<<0>>\s*<<1>>(?=\s*\()/.source, [name2, generic]),
            inside: {
              function: re2(/^<<0>>/.source, [name2]),
              generic: {
                pattern: RegExp(generic),
                alias: "class-name",
                inside: typeInside
              }
            }
          },
          "type-list": {
            // The list of types inherited or of generic constraints
            // class Foo<F> : Bar, IList<FooBar>
            // where F : Bar, IList<int>
            pattern: re2(
              /\b((?:<<0>>\s+<<1>>|record\s+<<1>>\s*<<5>>|where\s+<<2>>)\s*:\s*)(?:<<3>>|<<4>>|<<1>>\s*<<5>>|<<6>>)(?:\s*,\s*(?:<<3>>|<<4>>|<<6>>))*(?=\s*(?:where|[{;]|=>|$))/.source,
              [
                typeDeclarationKeywords,
                genericName,
                name2,
                typeExpression,
                keywords2.source,
                nestedRound,
                /\bnew\s*\(\s*\)/.source
              ]
            ),
            lookbehind: true,
            inside: {
              "record-arguments": {
                pattern: re2(/(^(?!new\s*\()<<0>>\s*)<<1>>/.source, [
                  genericName,
                  nestedRound
                ]),
                lookbehind: true,
                greedy: true,
                inside: Prism3.languages.csharp
              },
              keyword: keywords2,
              "class-name": {
                pattern: RegExp(typeExpression),
                greedy: true,
                inside: typeInside
              },
              punctuation: /[,()]/
            }
          },
          preprocessor: {
            pattern: /(^[\t ]*)#.*/m,
            lookbehind: true,
            alias: "property",
            inside: {
              // highlight preprocessor directives as keywords
              directive: {
                pattern: /(#)\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\b/,
                lookbehind: true,
                alias: "keyword"
              }
            }
          }
        });
        var regularStringOrCharacter = regularString + "|" + character2;
        var regularStringCharacterOrComment = replace2(
          /\/(?![*/])|\/\/[^\r\n]*[\r\n]|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>/.source,
          [regularStringOrCharacter]
        );
        var roundExpression = nested(
          replace2(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [
            regularStringCharacterOrComment
          ]),
          2
        );
        var attrTarget = /\b(?:assembly|event|field|method|module|param|property|return|type)\b/.source;
        var attr = replace2(/<<0>>(?:\s*\(<<1>>*\))?/.source, [
          identifier2,
          roundExpression
        ]);
        Prism3.languages.insertBefore("csharp", "class-name", {
          attribute: {
            // Attributes
            // [Foo], [Foo(1), Bar(2, Prop = "foo")], [return: Foo(1), Bar(2)], [assembly: Foo(Bar)]
            pattern: re2(
              /((?:^|[^\s\w>)?])\s*\[\s*)(?:<<0>>\s*:\s*)?<<1>>(?:\s*,\s*<<1>>)*(?=\s*\])/.source,
              [attrTarget, attr]
            ),
            lookbehind: true,
            greedy: true,
            inside: {
              target: {
                pattern: re2(/^<<0>>(?=\s*:)/.source, [attrTarget]),
                alias: "keyword"
              },
              "attribute-arguments": {
                pattern: re2(/\(<<0>>*\)/.source, [roundExpression]),
                inside: Prism3.languages.csharp
              },
              "class-name": {
                pattern: RegExp(identifier2),
                inside: {
                  punctuation: /\./
                }
              },
              punctuation: /[:,]/
            }
          }
        });
        var formatString = /:[^}\r\n]+/.source;
        var mInterpolationRound = nested(
          replace2(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [
            regularStringCharacterOrComment
          ]),
          2
        );
        var mInterpolation = replace2(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [
          mInterpolationRound,
          formatString
        ]);
        var sInterpolationRound = nested(
          replace2(
            /[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/.source,
            [regularStringOrCharacter]
          ),
          2
        );
        var sInterpolation = replace2(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [
          sInterpolationRound,
          formatString
        ]);
        function createInterpolationInside(interpolation, interpolationRound) {
          return {
            interpolation: {
              pattern: re2(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [interpolation]),
              lookbehind: true,
              inside: {
                "format-string": {
                  pattern: re2(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source, [
                    interpolationRound,
                    formatString
                  ]),
                  lookbehind: true,
                  inside: {
                    punctuation: /^:/
                  }
                },
                punctuation: /^\{|\}$/,
                expression: {
                  pattern: /[\s\S]+/,
                  alias: "language-csharp",
                  inside: Prism3.languages.csharp
                }
              }
            },
            string: /[\s\S]+/
          };
        }
        Prism3.languages.insertBefore("csharp", "string", {
          "interpolation-string": [
            {
              pattern: re2(
                /(^|[^\\])(?:\$@|@\$)"(?:""|\\[\s\S]|\{\{|<<0>>|[^\\{"])*"/.source,
                [mInterpolation]
              ),
              lookbehind: true,
              greedy: true,
              inside: createInterpolationInside(mInterpolation, mInterpolationRound)
            },
            {
              pattern: re2(/(^|[^@\\])\$"(?:\\.|\{\{|<<0>>|[^\\"{])*"/.source, [
                sInterpolation
              ]),
              lookbehind: true,
              greedy: true,
              inside: createInterpolationInside(sInterpolation, sInterpolationRound)
            }
          ],
          char: {
            pattern: RegExp(character2),
            greedy: true
          }
        });
        Prism3.languages.dotnet = Prism3.languages.cs = Prism3.languages.csharp;
      })(Prism2);
    }
    markup.displayName = "markup";
    markup.aliases = ["atom", "html", "mathml", "rss", "ssml", "svg", "xml"];
    function markup(Prism2) {
      Prism2.languages.markup = {
        comment: {
          pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
          greedy: true
        },
        prolog: {
          pattern: /<\?[\s\S]+?\?>/,
          greedy: true
        },
        doctype: {
          // https://www.w3.org/TR/xml/#NT-doctypedecl
          pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
          greedy: true,
          inside: {
            "internal-subset": {
              pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
              lookbehind: true,
              greedy: true,
              inside: null
              // see below
            },
            string: {
              pattern: /"[^"]*"|'[^']*'/,
              greedy: true
            },
            punctuation: /^<!|>$|[[\]]/,
            "doctype-tag": /^DOCTYPE/i,
            name: /[^\s<>'"]+/
          }
        },
        cdata: {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          greedy: true
        },
        tag: {
          pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
          greedy: true,
          inside: {
            tag: {
              pattern: /^<\/?[^\s>\/]+/,
              inside: {
                punctuation: /^<\/?/,
                namespace: /^[^\s>\/:]+:/
              }
            },
            "special-attr": [],
            "attr-value": {
              pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
              inside: {
                punctuation: [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  {
                    pattern: /^(\s*)["']|["']$/,
                    lookbehind: true
                  }
                ]
              }
            },
            punctuation: /\/?>/,
            "attr-name": {
              pattern: /[^\s>\/]+/,
              inside: {
                namespace: /^[^\s>\/:]+:/
              }
            }
          }
        },
        entity: [
          {
            pattern: /&[\da-z]{1,8};/i,
            alias: "named-entity"
          },
          /&#x?[\da-f]{1,8};/i
        ]
      };
      Prism2.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism2.languages.markup["entity"];
      Prism2.languages.markup["doctype"].inside["internal-subset"].inside = Prism2.languages.markup;
      Prism2.hooks.add("wrap", function(env) {
        if (env.type === "entity") {
          env.attributes["title"] = env.content.value.replace(/&amp;/, "&");
        }
      });
      Object.defineProperty(Prism2.languages.markup.tag, "addInlined", {
        /**
         * Adds an inlined language to markup.
         *
         * An example of an inlined language is CSS with `<style>` tags.
         *
         * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
         * case insensitive.
         * @param {string} lang The language key.
         * @example
         * addInlined('style', 'css');
         */
        value: function addInlined(tagName, lang2) {
          var includedCdataInside = {};
          includedCdataInside["language-" + lang2] = {
            pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
            lookbehind: true,
            inside: Prism2.languages[lang2]
          };
          includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
          var inside = {
            "included-cdata": {
              pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
              inside: includedCdataInside
            }
          };
          inside["language-" + lang2] = {
            pattern: /[\s\S]+/,
            inside: Prism2.languages[lang2]
          };
          var def = {};
          def[tagName] = {
            pattern: RegExp(
              /(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(
                /__/g,
                function() {
                  return tagName;
                }
              ),
              "i"
            ),
            lookbehind: true,
            greedy: true,
            inside
          };
          Prism2.languages.insertBefore("markup", "cdata", def);
        }
      });
      Object.defineProperty(Prism2.languages.markup.tag, "addAttribute", {
        /**
         * Adds an pattern to highlight languages embedded in HTML attributes.
         *
         * An example of an inlined language is CSS with `style` attributes.
         *
         * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
         * case insensitive.
         * @param {string} lang The language key.
         * @example
         * addAttribute('style', 'css');
         */
        value: function(attrName, lang2) {
          Prism2.languages.markup.tag.inside["special-attr"].push({
            pattern: RegExp(
              /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
              "i"
            ),
            lookbehind: true,
            inside: {
              "attr-name": /^[^\s=]+/,
              "attr-value": {
                pattern: /=[\s\S]+/,
                inside: {
                  value: {
                    pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                    lookbehind: true,
                    alias: [lang2, "language-" + lang2],
                    inside: Prism2.languages[lang2]
                  },
                  punctuation: [
                    {
                      pattern: /^=/,
                      alias: "attr-equals"
                    },
                    /"|'/
                  ]
                }
              }
            }
          });
        }
      });
      Prism2.languages.html = Prism2.languages.markup;
      Prism2.languages.mathml = Prism2.languages.markup;
      Prism2.languages.svg = Prism2.languages.markup;
      Prism2.languages.xml = Prism2.languages.extend("markup", {});
      Prism2.languages.ssml = Prism2.languages.xml;
      Prism2.languages.atom = Prism2.languages.xml;
      Prism2.languages.rss = Prism2.languages.xml;
    }
    css.displayName = "css";
    css.aliases = [];
    function css(Prism2) {
      (function(Prism3) {
        var string2 = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
        Prism3.languages.css = {
          comment: /\/\*[\s\S]*?\*\//,
          atrule: {
            pattern: RegExp(
              "@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string2.source + ")*?" + /(?:;|(?=\s*\{))/.source
            ),
            inside: {
              rule: /^@[\w-]+/,
              "selector-function-argument": {
                pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
                lookbehind: true,
                alias: "selector"
              },
              keyword: {
                pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
                lookbehind: true
              }
              // See rest below
            }
          },
          url: {
            // https://drafts.csswg.org/css-values-3/#urls
            pattern: RegExp(
              "\\burl\\((?:" + string2.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)",
              "i"
            ),
            greedy: true,
            inside: {
              function: /^url/i,
              punctuation: /^\(|\)$/,
              string: {
                pattern: RegExp("^" + string2.source + "$"),
                alias: "url"
              }
            }
          },
          selector: {
            pattern: RegExp(
              `(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string2.source + ")*(?=\\s*\\{)"
            ),
            lookbehind: true
          },
          string: {
            pattern: string2,
            greedy: true
          },
          property: {
            pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
            lookbehind: true
          },
          important: /!important\b/i,
          function: {
            pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
            lookbehind: true
          },
          punctuation: /[(){};:,]/
        };
        Prism3.languages.css["atrule"].inside.rest = Prism3.languages.css;
        var markup2 = Prism3.languages.markup;
        if (markup2) {
          markup2.tag.addInlined("style", "css");
          markup2.tag.addAttribute("style", "css");
        }
      })(Prism2);
    }
    diff.displayName = "diff";
    diff.aliases = [];
    function diff(Prism2) {
      (function(Prism3) {
        Prism3.languages.diff = {
          coord: [
            // Match all kinds of coord lines (prefixed by "+++", "---" or "***").
            /^(?:\*{3}|-{3}|\+{3}).*$/m,
            // Match "@@ ... @@" coord lines in unified diff.
            /^@@.*@@$/m,
            // Match coord lines in normal diff (starts with a number).
            /^\d.*$/m
          ]
          // deleted, inserted, unchanged, diff
        };
        var PREFIXES = {
          "deleted-sign": "-",
          "deleted-arrow": "<",
          "inserted-sign": "+",
          "inserted-arrow": ">",
          unchanged: " ",
          diff: "!"
        };
        Object.keys(PREFIXES).forEach(function(name2) {
          var prefix2 = PREFIXES[name2];
          var alias2 = [];
          if (!/^\w+$/.test(name2)) {
            alias2.push(/\w+/.exec(name2)[0]);
          }
          if (name2 === "diff") {
            alias2.push("bold");
          }
          Prism3.languages.diff[name2] = {
            pattern: RegExp(
              "^(?:[" + prefix2 + "].*(?:\r\n?|\n|(?![\\s\\S])))+",
              "m"
            ),
            alias: alias2,
            inside: {
              line: {
                pattern: /(.)(?=[\s\S]).*(?:\r\n?|\n)?/,
                lookbehind: true
              },
              prefix: {
                pattern: /[\s\S]/,
                alias: /\w+/.exec(name2)[0]
              }
            }
          };
        });
        Object.defineProperty(Prism3.languages.diff, "PREFIXES", {
          value: PREFIXES
        });
      })(Prism2);
    }
    go.displayName = "go";
    go.aliases = [];
    function go(Prism2) {
      Prism2.register(clike);
      Prism2.languages.go = Prism2.languages.extend("clike", {
        string: {
          pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/,
          lookbehind: true,
          greedy: true
        },
        keyword: /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
        boolean: /\b(?:_|false|iota|nil|true)\b/,
        number: [
          // binary and octal integers
          /\b0(?:b[01_]+|o[0-7_]+)i?\b/i,
          // hexadecimal integers and floats
          /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
          // decimal integers and floats
          /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i
        ],
        operator: /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
        builtin: /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/
      });
      Prism2.languages.insertBefore("go", "string", {
        char: {
          pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/,
          greedy: true
        }
      });
      delete Prism2.languages.go["class-name"];
    }
    ini.displayName = "ini";
    ini.aliases = [];
    function ini(Prism2) {
      Prism2.languages.ini = {
        /**
         * The component mimics the behavior of the Win32 API parser.
         *
         * @see {@link https://github.com/PrismJS/prism/issues/2775#issuecomment-787477723}
         */
        comment: {
          pattern: /(^[ \f\t\v]*)[#;][^\n\r]*/m,
          lookbehind: true
        },
        section: {
          pattern: /(^[ \f\t\v]*)\[[^\n\r\]]*\]?/m,
          lookbehind: true,
          inside: {
            "section-name": {
              pattern: /(^\[[ \f\t\v]*)[^ \f\t\v\]]+(?:[ \f\t\v]+[^ \f\t\v\]]+)*/,
              lookbehind: true,
              alias: "selector"
            },
            punctuation: /\[|\]/
          }
        },
        key: {
          pattern: /(^[ \f\t\v]*)[^ \f\n\r\t\v=]+(?:[ \f\t\v]+[^ \f\n\r\t\v=]+)*(?=[ \f\t\v]*=)/m,
          lookbehind: true,
          alias: "attr-name"
        },
        value: {
          pattern: /(=[ \f\t\v]*)[^ \f\n\r\t\v]+(?:[ \f\t\v]+[^ \f\n\r\t\v]+)*/,
          lookbehind: true,
          alias: "attr-value",
          inside: {
            "inner-value": {
              pattern: /^("|').+(?=\1$)/,
              lookbehind: true
            }
          }
        },
        punctuation: /=/
      };
    }
    java.displayName = "java";
    java.aliases = [];
    function java(Prism2) {
      Prism2.register(clike);
      (function(Prism3) {
        var keywords2 = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/;
        var classNamePrefix = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source;
        var className = {
          pattern: RegExp(
            /(^|[^\w.])/.source + classNamePrefix + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source
          ),
          lookbehind: true,
          inside: {
            namespace: {
              pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
              inside: {
                punctuation: /\./
              }
            },
            punctuation: /\./
          }
        };
        Prism3.languages.java = Prism3.languages.extend("clike", {
          string: {
            pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
            lookbehind: true,
            greedy: true
          },
          "class-name": [
            className,
            {
              // variables, parameters, and constructor references
              // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
              pattern: RegExp(
                /(^|[^\w.])/.source + classNamePrefix + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source
              ),
              lookbehind: true,
              inside: className.inside
            },
            {
              // class names based on keyword
              // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
              pattern: RegExp(
                /(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + classNamePrefix + /[A-Z]\w*\b/.source
              ),
              lookbehind: true,
              inside: className.inside
            }
          ],
          keyword: keywords2,
          function: [
            Prism3.languages.clike.function,
            {
              pattern: /(::\s*)[a-z_]\w*/,
              lookbehind: true
            }
          ],
          number: /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
          operator: {
            pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
            lookbehind: true
          },
          constant: /\b[A-Z][A-Z_\d]+\b/
        });
        Prism3.languages.insertBefore("java", "string", {
          "triple-quoted-string": {
            // http://openjdk.java.net/jeps/355#Description
            pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
            greedy: true,
            alias: "string"
          },
          char: {
            pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
            greedy: true
          }
        });
        Prism3.languages.insertBefore("java", "class-name", {
          annotation: {
            pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
            lookbehind: true,
            alias: "punctuation"
          },
          generics: {
            pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
            inside: {
              "class-name": className,
              keyword: keywords2,
              punctuation: /[<>(),.:]/,
              operator: /[?&|]/
            }
          },
          import: [
            {
              pattern: RegExp(
                /(\bimport\s+)/.source + classNamePrefix + /(?:[A-Z]\w*|\*)(?=\s*;)/.source
              ),
              lookbehind: true,
              inside: {
                namespace: className.inside.namespace,
                punctuation: /\./,
                operator: /\*/,
                "class-name": /\w+/
              }
            },
            {
              pattern: RegExp(
                /(\bimport\s+static\s+)/.source + classNamePrefix + /(?:\w+|\*)(?=\s*;)/.source
              ),
              lookbehind: true,
              alias: "static",
              inside: {
                namespace: className.inside.namespace,
                static: /\b\w+$/,
                punctuation: /\./,
                operator: /\*/,
                "class-name": /\w+/
              }
            }
          ],
          namespace: {
            pattern: RegExp(
              /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(
                /<keyword>/g,
                function() {
                  return keywords2.source;
                }
              )
            ),
            lookbehind: true,
            inside: {
              punctuation: /\./
            }
          }
        });
      })(Prism2);
    }
    regex.displayName = "regex";
    regex.aliases = [];
    function regex(Prism2) {
      (function(Prism3) {
        var specialEscape = {
          pattern: /\\[\\(){}[\]^$+*?|.]/,
          alias: "escape"
        };
        var escape2 = /\\(?:x[\da-fA-F]{2}|u[\da-fA-F]{4}|u\{[\da-fA-F]+\}|0[0-7]{0,2}|[123][0-7]{2}|c[a-zA-Z]|.)/;
        var charSet = {
          pattern: /\.|\\[wsd]|\\p\{[^{}]+\}/i,
          alias: "class-name"
        };
        var charSetWithoutDot = {
          pattern: /\\[wsd]|\\p\{[^{}]+\}/i,
          alias: "class-name"
        };
        var rangeChar = "(?:[^\\\\-]|" + escape2.source + ")";
        var range = RegExp(rangeChar + "-" + rangeChar);
        var groupName = {
          pattern: /(<|')[^<>']+(?=[>']$)/,
          lookbehind: true,
          alias: "variable"
        };
        Prism3.languages.regex = {
          "char-class": {
            pattern: /((?:^|[^\\])(?:\\\\)*)\[(?:[^\\\]]|\\[\s\S])*\]/,
            lookbehind: true,
            inside: {
              "char-class-negation": {
                pattern: /(^\[)\^/,
                lookbehind: true,
                alias: "operator"
              },
              "char-class-punctuation": {
                pattern: /^\[|\]$/,
                alias: "punctuation"
              },
              range: {
                pattern: range,
                inside: {
                  escape: escape2,
                  "range-punctuation": {
                    pattern: /-/,
                    alias: "operator"
                  }
                }
              },
              "special-escape": specialEscape,
              "char-set": charSetWithoutDot,
              escape: escape2
            }
          },
          "special-escape": specialEscape,
          "char-set": charSet,
          backreference: [
            {
              // a backreference which is not an octal escape
              pattern: /\\(?![123][0-7]{2})[1-9]/,
              alias: "keyword"
            },
            {
              pattern: /\\k<[^<>']+>/,
              alias: "keyword",
              inside: {
                "group-name": groupName
              }
            }
          ],
          anchor: {
            pattern: /[$^]|\\[ABbGZz]/,
            alias: "function"
          },
          escape: escape2,
          group: [
            {
              // https://docs.oracle.com/javase/10/docs/api/java/util/regex/Pattern.html
              // https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference?view=netframework-4.7.2#grouping-constructs
              // (), (?<name>), (?'name'), (?>), (?:), (?=), (?!), (?<=), (?<!), (?is-m), (?i-m:)
              pattern: /\((?:\?(?:<[^<>']+>|'[^<>']+'|[>:]|<?[=!]|[idmnsuxU]+(?:-[idmnsuxU]+)?:?))?/,
              alias: "punctuation",
              inside: {
                "group-name": groupName
              }
            },
            {
              pattern: /\)/,
              alias: "punctuation"
            }
          ],
          quantifier: {
            pattern: /(?:[+*?]|\{\d+(?:,\d*)?\})[?+]?/,
            alias: "number"
          },
          alternation: {
            pattern: /\|/,
            alias: "keyword"
          }
        };
      })(Prism2);
    }
    javascript.displayName = "javascript";
    javascript.aliases = ["js"];
    function javascript(Prism2) {
      Prism2.register(clike);
      Prism2.languages.javascript = Prism2.languages.extend("clike", {
        "class-name": [
          Prism2.languages.clike["class-name"],
          {
            pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
            lookbehind: true
          }
        ],
        keyword: [
          {
            pattern: /((?:^|\})\s*)catch\b/,
            lookbehind: true
          },
          {
            pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
            lookbehind: true
          }
        ],
        // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
        function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
        number: {
          pattern: RegExp(
            /(^|[^\w$])/.source + "(?:" + // constant
            (/NaN|Infinity/.source + "|" + // binary integer
            /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
            /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
            /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
            /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
            /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
          ),
          lookbehind: true
        },
        operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
      });
      Prism2.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
      Prism2.languages.insertBefore("javascript", "keyword", {
        regex: {
          pattern: RegExp(
            // lookbehind
            // eslint-disable-next-line regexp/no-dupe-characters-character-class
            /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
            // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
            // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
            // with the only syntax, so we have to define 2 different regex patterns.
            /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
            /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
            /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
          ),
          lookbehind: true,
          greedy: true,
          inside: {
            "regex-source": {
              pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
              lookbehind: true,
              alias: "language-regex",
              inside: Prism2.languages.regex
            },
            "regex-delimiter": /^\/|\/$/,
            "regex-flags": /^[a-z]+$/
          }
        },
        // This must be declared before keyword because we use "function" inside the look-forward
        "function-variable": {
          pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
          alias: "function"
        },
        parameter: [
          {
            pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
            lookbehind: true,
            inside: Prism2.languages.javascript
          },
          {
            pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
            lookbehind: true,
            inside: Prism2.languages.javascript
          },
          {
            pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
            lookbehind: true,
            inside: Prism2.languages.javascript
          },
          {
            pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
            lookbehind: true,
            inside: Prism2.languages.javascript
          }
        ],
        constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
      });
      Prism2.languages.insertBefore("javascript", "string", {
        hashbang: {
          pattern: /^#!.*/,
          greedy: true,
          alias: "comment"
        },
        "template-string": {
          pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
          greedy: true,
          inside: {
            "template-punctuation": {
              pattern: /^`|`$/,
              alias: "string"
            },
            interpolation: {
              pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
              lookbehind: true,
              inside: {
                "interpolation-punctuation": {
                  pattern: /^\$\{|\}$/,
                  alias: "punctuation"
                },
                rest: Prism2.languages.javascript
              }
            },
            string: /[\s\S]+/
          }
        },
        "string-property": {
          pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
          lookbehind: true,
          greedy: true,
          alias: "property"
        }
      });
      Prism2.languages.insertBefore("javascript", "operator", {
        "literal-property": {
          pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
          lookbehind: true,
          alias: "property"
        }
      });
      if (Prism2.languages.markup) {
        Prism2.languages.markup.tag.addInlined("script", "javascript");
        Prism2.languages.markup.tag.addAttribute(
          /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
          "javascript"
        );
      }
      Prism2.languages.js = Prism2.languages.javascript;
    }
    json.displayName = "json";
    json.aliases = ["webmanifest"];
    function json(Prism2) {
      Prism2.languages.json = {
        property: {
          pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
          lookbehind: true,
          greedy: true
        },
        string: {
          pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
          lookbehind: true,
          greedy: true
        },
        comment: {
          pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
          greedy: true
        },
        number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
        punctuation: /[{}[\],]/,
        operator: /:/,
        boolean: /\b(?:false|true)\b/,
        null: {
          pattern: /\bnull\b/,
          alias: "keyword"
        }
      };
      Prism2.languages.webmanifest = Prism2.languages.json;
    }
    kotlin.displayName = "kotlin";
    kotlin.aliases = ["kt", "kts"];
    function kotlin(Prism2) {
      Prism2.register(clike);
      (function(Prism3) {
        Prism3.languages.kotlin = Prism3.languages.extend("clike", {
          keyword: {
            // The lookbehind prevents wrong highlighting of e.g. kotlin.properties.get
            pattern: /(^|[^.])\b(?:abstract|actual|annotation|as|break|by|catch|class|companion|const|constructor|continue|crossinline|data|do|dynamic|else|enum|expect|external|final|finally|for|fun|get|if|import|in|infix|init|inline|inner|interface|internal|is|lateinit|noinline|null|object|open|operator|out|override|package|private|protected|public|reified|return|sealed|set|super|suspend|tailrec|this|throw|to|try|typealias|val|var|vararg|when|where|while)\b/,
            lookbehind: true
          },
          function: [
            {
              pattern: /(?:`[^\r\n`]+`|\b\w+)(?=\s*\()/,
              greedy: true
            },
            {
              pattern: /(\.)(?:`[^\r\n`]+`|\w+)(?=\s*\{)/,
              lookbehind: true,
              greedy: true
            }
          ],
          number: /\b(?:0[xX][\da-fA-F]+(?:_[\da-fA-F]+)*|0[bB][01]+(?:_[01]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?[fFL]?)\b/,
          operator: /\+[+=]?|-[-=>]?|==?=?|!(?:!|==?)?|[\/*%<>]=?|[?:]:?|\.\.|&&|\|\||\b(?:and|inv|or|shl|shr|ushr|xor)\b/
        });
        delete Prism3.languages.kotlin["class-name"];
        var interpolationInside = {
          "interpolation-punctuation": {
            pattern: /^\$\{?|\}$/,
            alias: "punctuation"
          },
          expression: {
            pattern: /[\s\S]+/,
            inside: Prism3.languages.kotlin
          }
        };
        Prism3.languages.insertBefore("kotlin", "string", {
          // https://kotlinlang.org/spec/expressions.html#string-interpolation-expressions
          "string-literal": [
            {
              pattern: /"""(?:[^$]|\$(?:(?!\{)|\{[^{}]*\}))*?"""/,
              alias: "multiline",
              inside: {
                interpolation: {
                  pattern: /\$(?:[a-z_]\w*|\{[^{}]*\})/i,
                  inside: interpolationInside
                },
                string: /[\s\S]+/
              }
            },
            {
              pattern: /"(?:[^"\\\r\n$]|\\.|\$(?:(?!\{)|\{[^{}]*\}))*"/,
              alias: "singleline",
              inside: {
                interpolation: {
                  pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:[a-z_]\w*|\{[^{}]*\})/i,
                  lookbehind: true,
                  inside: interpolationInside
                },
                string: /[\s\S]+/
              }
            }
          ],
          char: {
            // https://kotlinlang.org/spec/expressions.html#character-literals
            pattern: /'(?:[^'\\\r\n]|\\(?:.|u[a-fA-F0-9]{0,4}))'/,
            greedy: true
          }
        });
        delete Prism3.languages.kotlin["string"];
        Prism3.languages.insertBefore("kotlin", "keyword", {
          annotation: {
            pattern: /\B@(?:\w+:)?(?:[A-Z]\w*|\[[^\]]+\])/,
            alias: "builtin"
          }
        });
        Prism3.languages.insertBefore("kotlin", "function", {
          label: {
            pattern: /\b\w+@|@\w+\b/,
            alias: "symbol"
          }
        });
        Prism3.languages.kt = Prism3.languages.kotlin;
        Prism3.languages.kts = Prism3.languages.kotlin;
      })(Prism2);
    }
    less.displayName = "less";
    less.aliases = [];
    function less(Prism2) {
      Prism2.register(css);
      Prism2.languages.less = Prism2.languages.extend("css", {
        comment: [
          /\/\*[\s\S]*?\*\//,
          {
            pattern: /(^|[^\\])\/\/.*/,
            lookbehind: true
          }
        ],
        atrule: {
          pattern: /@[\w-](?:\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};\s]|\s+(?!\s))*?(?=\s*\{)/,
          inside: {
            punctuation: /[:()]/
          }
        },
        // selectors and mixins are considered the same
        selector: {
          pattern: /(?:@\{[\w-]+\}|[^{};\s@])(?:@\{[\w-]+\}|\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};@\s]|\s+(?!\s))*?(?=\s*\{)/,
          inside: {
            // mixin parameters
            variable: /@+[\w-]+/
          }
        },
        property: /(?:@\{[\w-]+\}|[\w-])+(?:\+_?)?(?=\s*:)/,
        operator: /[+\-*\/]/
      });
      Prism2.languages.insertBefore("less", "property", {
        variable: [
          // Variable declaration (the colon must be consumed!)
          {
            pattern: /@[\w-]+\s*:/,
            inside: {
              punctuation: /:/
            }
          },
          // Variable usage
          /@@?[\w-]+/
        ],
        "mixin-usage": {
          pattern: /([{;]\s*)[.#](?!\d)[\w-].*?(?=[(;])/,
          lookbehind: true,
          alias: "function"
        }
      });
    }
    lua.displayName = "lua";
    lua.aliases = [];
    function lua(Prism2) {
      Prism2.languages.lua = {
        comment: /^#!.+|--(?:\[(=*)\[[\s\S]*?\]\1\]|.*)/m,
        // \z may be used to skip the following space
        string: {
          pattern: /(["'])(?:(?!\1)[^\\\r\n]|\\z(?:\r\n|\s)|\\(?:\r\n|[^z]))*\1|\[(=*)\[[\s\S]*?\]\2\]/,
          greedy: true
        },
        number: /\b0x[a-f\d]+(?:\.[a-f\d]*)?(?:p[+-]?\d+)?\b|\b\d+(?:\.\B|(?:\.\d*)?(?:e[+-]?\d+)?\b)|\B\.\d+(?:e[+-]?\d+)?\b/i,
        keyword: /\b(?:and|break|do|else|elseif|end|false|for|function|goto|if|in|local|nil|not|or|repeat|return|then|true|until|while)\b/,
        function: /(?!\d)\w+(?=\s*(?:[({]))/,
        operator: [
          /[-+*%^&|#]|\/\/?|<[<=]?|>[>=]?|[=~]=?/,
          {
            // Match ".." but don't break "..."
            pattern: /(^|[^.])\.\.(?!\.)/,
            lookbehind: true
          }
        ],
        punctuation: /[\[\](){},;]|\.+|:+/
      };
    }
    makefile.displayName = "makefile";
    makefile.aliases = [];
    function makefile(Prism2) {
      Prism2.languages.makefile = {
        comment: {
          pattern: /(^|[^\\])#(?:\\(?:\r\n|[\s\S])|[^\\\r\n])*/,
          lookbehind: true
        },
        string: {
          pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
          greedy: true
        },
        "builtin-target": {
          pattern: /\.[A-Z][^:#=\s]+(?=\s*:(?!=))/,
          alias: "builtin"
        },
        target: {
          pattern: /^(?:[^:=\s]|[ \t]+(?![\s:]))+(?=\s*:(?!=))/m,
          alias: "symbol",
          inside: {
            variable: /\$+(?:(?!\$)[^(){}:#=\s]+|(?=[({]))/
          }
        },
        variable: /\$+(?:(?!\$)[^(){}:#=\s]+|\([@*%<^+?][DF]\)|(?=[({]))/,
        // Directives
        keyword: /-include\b|\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|include|override|private|sinclude|undefine|unexport|vpath)\b/,
        function: {
          pattern: /(\()(?:abspath|addsuffix|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:list|s)?)(?=[ \t])/,
          lookbehind: true
        },
        operator: /(?:::|[?:+!])?=|[|@]/,
        punctuation: /[:;(){}]/
      };
    }
    yaml.displayName = "yaml";
    yaml.aliases = ["yml"];
    function yaml(Prism2) {
      (function(Prism3) {
        var anchorOrAlias = /[*&][^\s[\]{},]+/;
        var tag = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/;
        var properties = "(?:" + tag.source + "(?:[ 	]+" + anchorOrAlias.source + ")?|" + anchorOrAlias.source + "(?:[ 	]+" + tag.source + ")?)";
        var plainKey = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(
          /<PLAIN>/g,
          function() {
            return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
          }
        );
        var string2 = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
        function createValuePattern(value, flags) {
          flags = (flags || "").replace(/m/g, "") + "m";
          var pattern = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
            return properties;
          }).replace(/<<value>>/g, function() {
            return value;
          });
          return RegExp(pattern, flags);
        }
        Prism3.languages.yaml = {
          scalar: {
            pattern: RegExp(
              /([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(
                /<<prop>>/g,
                function() {
                  return properties;
                }
              )
            ),
            lookbehind: true,
            alias: "string"
          },
          comment: /#.*/,
          key: {
            pattern: RegExp(
              /((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
                return properties;
              }).replace(/<<key>>/g, function() {
                return "(?:" + plainKey + "|" + string2 + ")";
              })
            ),
            lookbehind: true,
            greedy: true,
            alias: "atrule"
          },
          directive: {
            pattern: /(^[ \t]*)%.+/m,
            lookbehind: true,
            alias: "important"
          },
          datetime: {
            pattern: createValuePattern(
              /\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source
            ),
            lookbehind: true,
            alias: "number"
          },
          boolean: {
            pattern: createValuePattern(/false|true/.source, "i"),
            lookbehind: true,
            alias: "important"
          },
          null: {
            pattern: createValuePattern(/null|~/.source, "i"),
            lookbehind: true,
            alias: "important"
          },
          string: {
            pattern: createValuePattern(string2),
            lookbehind: true,
            greedy: true
          },
          number: {
            pattern: createValuePattern(
              /[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source,
              "i"
            ),
            lookbehind: true
          },
          tag,
          important: anchorOrAlias,
          punctuation: /---|[:[\]{}\-,|>?]|\.\.\./
        };
        Prism3.languages.yml = Prism3.languages.yaml;
      })(Prism2);
    }
    markdown.displayName = "markdown";
    markdown.aliases = ["md"];
    function markdown(Prism2) {
      Prism2.register(markup);
      (function(Prism3) {
        var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
        function createInline(pattern) {
          pattern = pattern.replace(/<inner>/g, function() {
            return inner;
          });
          return RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + pattern + ")");
        }
        var tableCell2 = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
        var tableRow2 = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(
          /__/g,
          function() {
            return tableCell2;
          }
        );
        var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
        Prism3.languages.markdown = Prism3.languages.extend("markup", {});
        Prism3.languages.insertBefore("markdown", "prolog", {
          "front-matter-block": {
            pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
            lookbehind: true,
            greedy: true,
            inside: {
              punctuation: /^---|---$/,
              "front-matter": {
                pattern: /\S+(?:\s+\S+)*/,
                alias: ["yaml", "language-yaml"],
                inside: Prism3.languages.yaml
              }
            }
          },
          blockquote: {
            // > ...
            pattern: /^>(?:[\t ]*>)*/m,
            alias: "punctuation"
          },
          table: {
            pattern: RegExp(
              "^" + tableRow2 + tableLine + "(?:" + tableRow2 + ")*",
              "m"
            ),
            inside: {
              "table-data-rows": {
                pattern: RegExp(
                  "^(" + tableRow2 + tableLine + ")(?:" + tableRow2 + ")*$"
                ),
                lookbehind: true,
                inside: {
                  "table-data": {
                    pattern: RegExp(tableCell2),
                    inside: Prism3.languages.markdown
                  },
                  punctuation: /\|/
                }
              },
              "table-line": {
                pattern: RegExp("^(" + tableRow2 + ")" + tableLine + "$"),
                lookbehind: true,
                inside: {
                  punctuation: /\||:?-{3,}:?/
                }
              },
              "table-header-row": {
                pattern: RegExp("^" + tableRow2 + "$"),
                inside: {
                  "table-header": {
                    pattern: RegExp(tableCell2),
                    alias: "important",
                    inside: Prism3.languages.markdown
                  },
                  punctuation: /\|/
                }
              }
            }
          },
          code: [
            {
              // Prefixed by 4 spaces or 1 tab and preceded by an empty line
              pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
              lookbehind: true,
              alias: "keyword"
            },
            {
              // ```optional language
              // code block
              // ```
              pattern: /^```[\s\S]*?^```$/m,
              greedy: true,
              inside: {
                "code-block": {
                  pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
                  lookbehind: true
                },
                "code-language": {
                  pattern: /^(```).+/,
                  lookbehind: true
                },
                punctuation: /```/
              }
            }
          ],
          title: [
            {
              // title 1
              // =======
              // title 2
              // -------
              pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
              alias: "important",
              inside: {
                punctuation: /==+$|--+$/
              }
            },
            {
              // # title 1
              // ###### title 6
              pattern: /(^\s*)#.+/m,
              lookbehind: true,
              alias: "important",
              inside: {
                punctuation: /^#+|#+$/
              }
            }
          ],
          hr: {
            // ***
            // ---
            // * * *
            // -----------
            pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
            lookbehind: true,
            alias: "punctuation"
          },
          list: {
            // * item
            // + item
            // - item
            // 1. item
            pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
            lookbehind: true,
            alias: "punctuation"
          },
          "url-reference": {
            // [id]: http://example.com "Optional title"
            // [id]: http://example.com 'Optional title'
            // [id]: http://example.com (Optional title)
            // [id]: <http://example.com> "Optional title"
            pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
            inside: {
              variable: {
                pattern: /^(!?\[)[^\]]+/,
                lookbehind: true
              },
              string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
              punctuation: /^[\[\]!:]|[<>]/
            },
            alias: "url"
          },
          bold: {
            // **strong**
            // __strong__
            // allow one nested instance of italic text using the same delimiter
            pattern: createInline(
              /\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source
            ),
            lookbehind: true,
            greedy: true,
            inside: {
              content: {
                pattern: /(^..)[\s\S]+(?=..$)/,
                lookbehind: true,
                inside: {}
                // see below
              },
              punctuation: /\*\*|__/
            }
          },
          italic: {
            // *em*
            // _em_
            // allow one nested instance of bold text using the same delimiter
            pattern: createInline(
              /\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source
            ),
            lookbehind: true,
            greedy: true,
            inside: {
              content: {
                pattern: /(^.)[\s\S]+(?=.$)/,
                lookbehind: true,
                inside: {}
                // see below
              },
              punctuation: /[*_]/
            }
          },
          strike: {
            // ~~strike through~~
            // ~strike~
            // eslint-disable-next-line regexp/strict
            pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source),
            lookbehind: true,
            greedy: true,
            inside: {
              content: {
                pattern: /(^~~?)[\s\S]+(?=\1$)/,
                lookbehind: true,
                inside: {}
                // see below
              },
              punctuation: /~~?/
            }
          },
          "code-snippet": {
            // `code`
            // ``code``
            pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
            lookbehind: true,
            greedy: true,
            alias: ["code", "keyword"]
          },
          url: {
            // [example](http://example.com "Optional title")
            // [example][id]
            // [example] [id]
            pattern: createInline(
              /!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source
            ),
            lookbehind: true,
            greedy: true,
            inside: {
              operator: /^!/,
              content: {
                pattern: /(^\[)[^\]]+(?=\])/,
                lookbehind: true,
                inside: {}
                // see below
              },
              variable: {
                pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
                lookbehind: true
              },
              url: {
                pattern: /(^\]\()[^\s)]+/,
                lookbehind: true
              },
              string: {
                pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
                lookbehind: true
              }
            }
          }
        });
        ["url", "bold", "italic", "strike"].forEach(function(token2) {
          ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(inside) {
            if (token2 !== inside) {
              Prism3.languages.markdown[token2].inside.content.inside[inside] = Prism3.languages.markdown[inside];
            }
          });
        });
        Prism3.hooks.add("after-tokenize", function(env) {
          if (env.language !== "markdown" && env.language !== "md") {
            return;
          }
          function walkTokens(tokens2) {
            if (!tokens2 || typeof tokens2 === "string") {
              return;
            }
            for (var i2 = 0, l2 = tokens2.length; i2 < l2; i2++) {
              var token2 = tokens2[i2];
              if (token2.type !== "code") {
                walkTokens(token2.content);
                continue;
              }
              var codeLang = token2.content[1];
              var codeBlock = token2.content[3];
              if (codeLang && codeBlock && codeLang.type === "code-language" && codeBlock.type === "code-block" && typeof codeLang.content === "string") {
                var lang2 = codeLang.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
                lang2 = (/[a-z][\w-]*/i.exec(lang2) || [""])[0].toLowerCase();
                var alias2 = "language-" + lang2;
                if (!codeBlock.alias) {
                  codeBlock.alias = [alias2];
                } else if (typeof codeBlock.alias === "string") {
                  codeBlock.alias = [codeBlock.alias, alias2];
                } else {
                  codeBlock.alias.push(alias2);
                }
              }
            }
          }
          walkTokens(env.tokens);
        });
        Prism3.hooks.add("wrap", function(env) {
          if (env.type !== "code-block") {
            return;
          }
          var codeLang = "";
          for (var i2 = 0, l2 = env.classes.length; i2 < l2; i2++) {
            var cls = env.classes[i2];
            var match5 = /language-(.+)/.exec(cls);
            if (match5) {
              codeLang = match5[1];
              break;
            }
          }
          var grammar = Prism3.languages[codeLang];
          if (!grammar) {
            if (codeLang && codeLang !== "none" && Prism3.plugins.autoloader) {
              var id2 = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(Math.random() * 1e16);
              env.attributes["id"] = id2;
              Prism3.plugins.autoloader.loadLanguages(codeLang, function() {
                var ele = document.getElementById(id2);
                if (ele) {
                  ele.innerHTML = Prism3.highlight(
                    ele.textContent,
                    Prism3.languages[codeLang],
                    codeLang
                  );
                }
              });
            }
          } else {
            env.content = Prism3.highlight(env.content.value, grammar, codeLang);
          }
        });
        RegExp(Prism3.languages.markup.tag.pattern.source, "gi");
        Prism3.languages.md = Prism3.languages.markdown;
      })(Prism2);
    }
    objectivec.displayName = "objectivec";
    objectivec.aliases = ["objc"];
    function objectivec(Prism2) {
      Prism2.register(c$1);
      Prism2.languages.objectivec = Prism2.languages.extend("c", {
        string: {
          pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
          greedy: true
        },
        keyword: /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
        operator: /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
      });
      delete Prism2.languages.objectivec["class-name"];
      Prism2.languages.objc = Prism2.languages.objectivec;
    }
    perl.displayName = "perl";
    perl.aliases = [];
    function perl(Prism2) {
      (function(Prism3) {
        var brackets = /(?:\((?:[^()\\]|\\[\s\S])*\)|\{(?:[^{}\\]|\\[\s\S])*\}|\[(?:[^[\]\\]|\\[\s\S])*\]|<(?:[^<>\\]|\\[\s\S])*>)/.source;
        Prism3.languages.perl = {
          comment: [
            {
              // POD
              pattern: /(^\s*)=\w[\s\S]*?=cut.*/m,
              lookbehind: true,
              greedy: true
            },
            {
              pattern: /(^|[^\\$])#.*/,
              lookbehind: true,
              greedy: true
            }
          ],
          // TODO Could be nice to handle Heredoc too.
          string: [
            {
              pattern: RegExp(
                /\b(?:q|qq|qw|qx)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
                  // q/.../
                  /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
                  // q a...a
                  // eslint-disable-next-line regexp/strict
                  /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
                  // q(...)
                  // q{...}
                  // q[...]
                  // q<...>
                  brackets
                ].join("|") + ")"
              ),
              greedy: true
            },
            // "...", `...`
            {
              pattern: /("|`)(?:(?!\1)[^\\]|\\[\s\S])*\1/,
              greedy: true
            },
            // '...'
            // FIXME Multi-line single-quoted strings are not supported as they would break variables containing '
            {
              pattern: /'(?:[^'\\\r\n]|\\.)*'/,
              greedy: true
            }
          ],
          regex: [
            {
              pattern: RegExp(
                /\b(?:m|qr)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
                  // m/.../
                  /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
                  // m a...a
                  // eslint-disable-next-line regexp/strict
                  /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
                  // m(...)
                  // m{...}
                  // m[...]
                  // m<...>
                  brackets
                ].join("|") + ")" + /[msixpodualngc]*/.source
              ),
              greedy: true
            },
            // The lookbehinds prevent -s from breaking
            {
              pattern: RegExp(
                /(^|[^-])\b(?:s|tr|y)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
                  // s/.../.../
                  // eslint-disable-next-line regexp/strict
                  /([^a-zA-Z0-9\s{(\[<])(?:(?!\2)[^\\]|\\[\s\S])*\2(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
                  // s a...a...a
                  // eslint-disable-next-line regexp/strict
                  /([a-zA-Z0-9])(?:(?!\3)[^\\]|\\[\s\S])*\3(?:(?!\3)[^\\]|\\[\s\S])*\3/.source,
                  // s(...)(...)
                  // s{...}{...}
                  // s[...][...]
                  // s<...><...>
                  // s(...)[...]
                  brackets + /\s*/.source + brackets
                ].join("|") + ")" + /[msixpodualngcer]*/.source
              ),
              lookbehind: true,
              greedy: true
            },
            // /.../
            // The look-ahead tries to prevent two divisions on
            // the same line from being highlighted as regex.
            // This does not support multi-line regex.
            {
              pattern: /\/(?:[^\/\\\r\n]|\\.)*\/[msixpodualngc]*(?=\s*(?:$|[\r\n,.;})&|\-+*~<>!?^]|(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|x|xor)\b))/,
              greedy: true
            }
          ],
          // FIXME Not sure about the handling of ::, ', and #
          variable: [
            // ${^POSTMATCH}
            /[&*$@%]\{\^[A-Z]+\}/,
            // $^V
            /[&*$@%]\^[A-Z_]/,
            // ${...}
            /[&*$@%]#?(?=\{)/,
            // $foo
            /[&*$@%]#?(?:(?:::)*'?(?!\d)[\w$]+(?![\w$]))+(?:::)*/,
            // $1
            /[&*$@%]\d+/,
            // $_, @_, %!
            // The negative lookahead prevents from breaking the %= operator
            /(?!%=)[$@%][!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~]/
          ],
          filehandle: {
            // <>, <FOO>, _
            pattern: /<(?![<=])\S*?>|\b_\b/,
            alias: "symbol"
          },
          "v-string": {
            // v1.2, 1.2.3
            pattern: /v\d+(?:\.\d+)*|\d+(?:\.\d+){2,}/,
            alias: "string"
          },
          function: {
            pattern: /(\bsub[ \t]+)\w+/,
            lookbehind: true
          },
          keyword: /\b(?:any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|return|say|state|sub|switch|undef|unless|until|use|when|while)\b/,
          number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)\b/,
          operator: /-[rwxoRWXOezsfdlpSbctugkTBMAC]\b|\+[+=]?|-[-=>]?|\*\*?=?|\/\/?=?|=[=~>]?|~[~=]?|\|\|?=?|&&?=?|<(?:=>?|<=?)?|>>?=?|![~=]?|[%^]=?|\.(?:=|\.\.?)?|[\\?]|\bx(?:=|\b)|\b(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|xor)\b/,
          punctuation: /[{}[\];(),:]/
        };
      })(Prism2);
    }
    markupTemplating.displayName = "markup-templating";
    markupTemplating.aliases = [];
    function markupTemplating(Prism2) {
      Prism2.register(markup);
      (function(Prism3) {
        function getPlaceholder(language, index2) {
          return "___" + language.toUpperCase() + index2 + "___";
        }
        Object.defineProperties(Prism3.languages["markup-templating"] = {}, {
          buildPlaceholders: {
            /**
             * Tokenize all inline templating expressions matching `placeholderPattern`.
             *
             * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns
             * `true` will be replaced.
             *
             * @param {object} env The environment of the `before-tokenize` hook.
             * @param {string} language The language id.
             * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.
             * @param {(match: string) => boolean} [replaceFilter]
             */
            value: function(env, language, placeholderPattern, replaceFilter) {
              if (env.language !== language) {
                return;
              }
              var tokenStack = env.tokenStack = [];
              env.code = env.code.replace(placeholderPattern, function(match5) {
                if (typeof replaceFilter === "function" && !replaceFilter(match5)) {
                  return match5;
                }
                var i2 = tokenStack.length;
                var placeholder;
                while (env.code.indexOf(placeholder = getPlaceholder(language, i2)) !== -1) {
                  ++i2;
                }
                tokenStack[i2] = match5;
                return placeholder;
              });
              env.grammar = Prism3.languages.markup;
            }
          },
          tokenizePlaceholders: {
            /**
             * Replace placeholders with proper tokens after tokenizing.
             *
             * @param {object} env The environment of the `after-tokenize` hook.
             * @param {string} language The language id.
             */
            value: function(env, language) {
              if (env.language !== language || !env.tokenStack) {
                return;
              }
              env.grammar = Prism3.languages[language];
              var j = 0;
              var keys2 = Object.keys(env.tokenStack);
              function walkTokens(tokens2) {
                for (var i2 = 0; i2 < tokens2.length; i2++) {
                  if (j >= keys2.length) {
                    break;
                  }
                  var token2 = tokens2[i2];
                  if (typeof token2 === "string" || token2.content && typeof token2.content === "string") {
                    var k2 = keys2[j];
                    var t2 = env.tokenStack[k2];
                    var s2 = typeof token2 === "string" ? token2 : token2.content;
                    var placeholder = getPlaceholder(language, k2);
                    var index2 = s2.indexOf(placeholder);
                    if (index2 > -1) {
                      ++j;
                      var before = s2.substring(0, index2);
                      var middle = new Prism3.Token(
                        language,
                        Prism3.tokenize(t2, env.grammar),
                        "language-" + language,
                        t2
                      );
                      var after = s2.substring(index2 + placeholder.length);
                      var replacement = [];
                      if (before) {
                        replacement.push.apply(replacement, walkTokens([before]));
                      }
                      replacement.push(middle);
                      if (after) {
                        replacement.push.apply(replacement, walkTokens([after]));
                      }
                      if (typeof token2 === "string") {
                        tokens2.splice.apply(tokens2, [i2, 1].concat(replacement));
                      } else {
                        token2.content = replacement;
                      }
                    }
                  } else if (token2.content) {
                    walkTokens(token2.content);
                  }
                }
                return tokens2;
              }
              walkTokens(env.tokens);
            }
          }
        });
      })(Prism2);
    }
    php.displayName = "php";
    php.aliases = [];
    function php(Prism2) {
      Prism2.register(markupTemplating);
      (function(Prism3) {
        var comment2 = /\/\*[\s\S]*?\*\/|\/\/.*|#(?!\[).*/;
        var constant = [
          {
            pattern: /\b(?:false|true)\b/i,
            alias: "boolean"
          },
          {
            pattern: /(::\s*)\b[a-z_]\w*\b(?!\s*\()/i,
            greedy: true,
            lookbehind: true
          },
          {
            pattern: /(\b(?:case|const)\s+)\b[a-z_]\w*(?=\s*[;=])/i,
            greedy: true,
            lookbehind: true
          },
          /\b(?:null)\b/i,
          /\b[A-Z_][A-Z0-9_]*\b(?!\s*\()/
        ];
        var number2 = /\b0b[01]+(?:_[01]+)*\b|\b0o[0-7]+(?:_[0-7]+)*\b|\b0x[\da-f]+(?:_[\da-f]+)*\b|(?:\b\d+(?:_\d+)*\.?(?:\d+(?:_\d+)*)?|\B\.\d+)(?:e[+-]?\d+)?/i;
        var operator = /<?=>|\?\?=?|\.{3}|\??->|[!=]=?=?|::|\*\*=?|--|\+\+|&&|\|\||<<|>>|[?~]|[/^|%*&<>.+-]=?/;
        var punctuation2 = /[{}\[\](),:;]/;
        Prism3.languages.php = {
          delimiter: {
            pattern: /\?>$|^<\?(?:php(?=\s)|=)?/i,
            alias: "important"
          },
          comment: comment2,
          variable: /\$+(?:\w+\b|(?=\{))/,
          package: {
            pattern: /(namespace\s+|use\s+(?:function\s+)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
            lookbehind: true,
            inside: {
              punctuation: /\\/
            }
          },
          "class-name-definition": {
            pattern: /(\b(?:class|enum|interface|trait)\s+)\b[a-z_]\w*(?!\\)\b/i,
            lookbehind: true,
            alias: "class-name"
          },
          "function-definition": {
            pattern: /(\bfunction\s+)[a-z_]\w*(?=\s*\()/i,
            lookbehind: true,
            alias: "function"
          },
          keyword: [
            {
              pattern: /(\(\s*)\b(?:array|bool|boolean|float|int|integer|object|string)\b(?=\s*\))/i,
              alias: "type-casting",
              greedy: true,
              lookbehind: true
            },
            {
              pattern: /([(,?]\s*)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string)\b(?=\s*\$)/i,
              alias: "type-hint",
              greedy: true,
              lookbehind: true
            },
            {
              pattern: /(\)\s*:\s*(?:\?\s*)?)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|never|object|self|static|string|void)\b/i,
              alias: "return-type",
              greedy: true,
              lookbehind: true
            },
            {
              pattern: /\b(?:array(?!\s*\()|bool|float|int|iterable|mixed|object|string|void)\b/i,
              alias: "type-declaration",
              greedy: true
            },
            {
              pattern: /(\|\s*)(?:false|null)\b|\b(?:false|null)(?=\s*\|)/i,
              alias: "type-declaration",
              greedy: true,
              lookbehind: true
            },
            {
              pattern: /\b(?:parent|self|static)(?=\s*::)/i,
              alias: "static-context",
              greedy: true
            },
            {
              // yield from
              pattern: /(\byield\s+)from\b/i,
              lookbehind: true
            },
            // `class` is always a keyword unlike other keywords
            /\bclass\b/i,
            {
              // https://www.php.net/manual/en/reserved.keywords.php
              //
              // keywords cannot be preceded by "->"
              // the complex lookbehind means `(?<!(?:->|::)\s*)`
              pattern: /((?:^|[^\s>:]|(?:^|[^-])>|(?:^|[^:]):)\s*)\b(?:abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|match|namespace|never|new|or|parent|print|private|protected|public|readonly|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield|__halt_compiler)\b/i,
              lookbehind: true
            }
          ],
          "argument-name": {
            pattern: /([(,]\s*)\b[a-z_]\w*(?=\s*:(?!:))/i,
            lookbehind: true
          },
          "class-name": [
            {
              pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self|\s+static))\s+|\bcatch\s*\()\b[a-z_]\w*(?!\\)\b/i,
              greedy: true,
              lookbehind: true
            },
            {
              pattern: /(\|\s*)\b[a-z_]\w*(?!\\)\b/i,
              greedy: true,
              lookbehind: true
            },
            {
              pattern: /\b[a-z_]\w*(?!\\)\b(?=\s*\|)/i,
              greedy: true
            },
            {
              pattern: /(\|\s*)(?:\\?\b[a-z_]\w*)+\b/i,
              alias: "class-name-fully-qualified",
              greedy: true,
              lookbehind: true,
              inside: {
                punctuation: /\\/
              }
            },
            {
              pattern: /(?:\\?\b[a-z_]\w*)+\b(?=\s*\|)/i,
              alias: "class-name-fully-qualified",
              greedy: true,
              inside: {
                punctuation: /\\/
              }
            },
            {
              pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self\b|\s+static\b))\s+|\bcatch\s*\()(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
              alias: "class-name-fully-qualified",
              greedy: true,
              lookbehind: true,
              inside: {
                punctuation: /\\/
              }
            },
            {
              pattern: /\b[a-z_]\w*(?=\s*\$)/i,
              alias: "type-declaration",
              greedy: true
            },
            {
              pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
              alias: ["class-name-fully-qualified", "type-declaration"],
              greedy: true,
              inside: {
                punctuation: /\\/
              }
            },
            {
              pattern: /\b[a-z_]\w*(?=\s*::)/i,
              alias: "static-context",
              greedy: true
            },
            {
              pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*::)/i,
              alias: ["class-name-fully-qualified", "static-context"],
              greedy: true,
              inside: {
                punctuation: /\\/
              }
            },
            {
              pattern: /([(,?]\s*)[a-z_]\w*(?=\s*\$)/i,
              alias: "type-hint",
              greedy: true,
              lookbehind: true
            },
            {
              pattern: /([(,?]\s*)(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
              alias: ["class-name-fully-qualified", "type-hint"],
              greedy: true,
              lookbehind: true,
              inside: {
                punctuation: /\\/
              }
            },
            {
              pattern: /(\)\s*:\s*(?:\?\s*)?)\b[a-z_]\w*(?!\\)\b/i,
              alias: "return-type",
              greedy: true,
              lookbehind: true
            },
            {
              pattern: /(\)\s*:\s*(?:\?\s*)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
              alias: ["class-name-fully-qualified", "return-type"],
              greedy: true,
              lookbehind: true,
              inside: {
                punctuation: /\\/
              }
            }
          ],
          constant,
          function: {
            pattern: /(^|[^\\\w])\\?[a-z_](?:[\w\\]*\w)?(?=\s*\()/i,
            lookbehind: true,
            inside: {
              punctuation: /\\/
            }
          },
          property: {
            pattern: /(->\s*)\w+/,
            lookbehind: true
          },
          number: number2,
          operator,
          punctuation: punctuation2
        };
        var string_interpolation = {
          pattern: /\{\$(?:\{(?:\{[^{}]+\}|[^{}]+)\}|[^{}])+\}|(^|[^\\{])\$+(?:\w+(?:\[[^\r\n\[\]]+\]|->\w+)?)/,
          lookbehind: true,
          inside: Prism3.languages.php
        };
        var string2 = [
          {
            pattern: /<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/,
            alias: "nowdoc-string",
            greedy: true,
            inside: {
              delimiter: {
                pattern: /^<<<'[^']+'|[a-z_]\w*;$/i,
                alias: "symbol",
                inside: {
                  punctuation: /^<<<'?|[';]$/
                }
              }
            }
          },
          {
            pattern: /<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i,
            alias: "heredoc-string",
            greedy: true,
            inside: {
              delimiter: {
                pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i,
                alias: "symbol",
                inside: {
                  punctuation: /^<<<"?|[";]$/
                }
              },
              interpolation: string_interpolation
            }
          },
          {
            pattern: /`(?:\\[\s\S]|[^\\`])*`/,
            alias: "backtick-quoted-string",
            greedy: true
          },
          {
            pattern: /'(?:\\[\s\S]|[^\\'])*'/,
            alias: "single-quoted-string",
            greedy: true
          },
          {
            pattern: /"(?:\\[\s\S]|[^\\"])*"/,
            alias: "double-quoted-string",
            greedy: true,
            inside: {
              interpolation: string_interpolation
            }
          }
        ];
        Prism3.languages.insertBefore("php", "variable", {
          string: string2,
          attribute: {
            pattern: /#\[(?:[^"'\/#]|\/(?![*/])|\/\/.*$|#(?!\[).*$|\/\*(?:[^*]|\*(?!\/))*\*\/|"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*')+\](?=\s*[a-z$#])/im,
            greedy: true,
            inside: {
              "attribute-content": {
                pattern: /^(#\[)[\s\S]+(?=\]$)/,
                lookbehind: true,
                // inside can appear subset of php
                inside: {
                  comment: comment2,
                  string: string2,
                  "attribute-class-name": [
                    {
                      pattern: /([^:]|^)\b[a-z_]\w*(?!\\)\b/i,
                      alias: "class-name",
                      greedy: true,
                      lookbehind: true
                    },
                    {
                      pattern: /([^:]|^)(?:\\?\b[a-z_]\w*)+/i,
                      alias: ["class-name", "class-name-fully-qualified"],
                      greedy: true,
                      lookbehind: true,
                      inside: {
                        punctuation: /\\/
                      }
                    }
                  ],
                  constant,
                  number: number2,
                  operator,
                  punctuation: punctuation2
                }
              },
              delimiter: {
                pattern: /^#\[|\]$/,
                alias: "punctuation"
              }
            }
          }
        });
        Prism3.hooks.add("before-tokenize", function(env) {
          if (!/<\?/.test(env.code)) {
            return;
          }
          var phpPattern = /<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/g;
          Prism3.languages["markup-templating"].buildPlaceholders(
            env,
            "php",
            phpPattern
          );
        });
        Prism3.hooks.add("after-tokenize", function(env) {
          Prism3.languages["markup-templating"].tokenizePlaceholders(env, "php");
        });
      })(Prism2);
    }
    python.displayName = "python";
    python.aliases = ["py"];
    function python(Prism2) {
      Prism2.languages.python = {
        comment: {
          pattern: /(^|[^\\])#.*/,
          lookbehind: true,
          greedy: true
        },
        "string-interpolation": {
          pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
          greedy: true,
          inside: {
            interpolation: {
              // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
              pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
              lookbehind: true,
              inside: {
                "format-spec": {
                  pattern: /(:)[^:(){}]+(?=\}$)/,
                  lookbehind: true
                },
                "conversion-option": {
                  pattern: /![sra](?=[:}]$)/,
                  alias: "punctuation"
                },
                rest: null
              }
            },
            string: /[\s\S]+/
          }
        },
        "triple-quoted-string": {
          pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
          greedy: true,
          alias: "string"
        },
        string: {
          pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
          greedy: true
        },
        function: {
          pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
          lookbehind: true
        },
        "class-name": {
          pattern: /(\bclass\s+)\w+/i,
          lookbehind: true
        },
        decorator: {
          pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
          lookbehind: true,
          alias: ["annotation", "punctuation"],
          inside: {
            punctuation: /\./
          }
        },
        keyword: /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
        builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
        boolean: /\b(?:False|None|True)\b/,
        number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
        operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
        punctuation: /[{}[\];(),.:]/
      };
      Prism2.languages.python["string-interpolation"].inside["interpolation"].inside.rest = Prism2.languages.python;
      Prism2.languages.py = Prism2.languages.python;
    }
    r$1.displayName = "r";
    r$1.aliases = [];
    function r$1(Prism2) {
      Prism2.languages.r = {
        comment: /#.*/,
        string: {
          pattern: /(['"])(?:\\.|(?!\1)[^\\\r\n])*\1/,
          greedy: true
        },
        "percent-operator": {
          // Includes user-defined operators
          // and %%, %*%, %/%, %in%, %o%, %x%
          pattern: /%[^%\s]*%/,
          alias: "operator"
        },
        boolean: /\b(?:FALSE|TRUE)\b/,
        ellipsis: /\.\.(?:\.|\d+)/,
        number: [
          /\b(?:Inf|NaN)\b/,
          /(?:\b0x[\dA-Fa-f]+(?:\.\d*)?|\b\d+(?:\.\d*)?|\B\.\d+)(?:[EePp][+-]?\d+)?[iL]?/
        ],
        keyword: /\b(?:NA|NA_character_|NA_complex_|NA_integer_|NA_real_|NULL|break|else|for|function|if|in|next|repeat|while)\b/,
        operator: /->?>?|<(?:=|<?-)?|[>=!]=?|::?|&&?|\|\|?|[+*\/^$@~]/,
        punctuation: /[(){}\[\],;]/
      };
    }
    ruby.displayName = "ruby";
    ruby.aliases = ["rb"];
    function ruby(Prism2) {
      Prism2.register(clike);
      (function(Prism3) {
        Prism3.languages.ruby = Prism3.languages.extend("clike", {
          comment: {
            pattern: /#.*|^=begin\s[\s\S]*?^=end/m,
            greedy: true
          },
          "class-name": {
            pattern: /(\b(?:class|module)\s+|\bcatch\s+\()[\w.\\]+|\b[A-Z_]\w*(?=\s*\.\s*new\b)/,
            lookbehind: true,
            inside: {
              punctuation: /[.\\]/
            }
          },
          keyword: /\b(?:BEGIN|END|alias|and|begin|break|case|class|def|define_method|defined|do|each|else|elsif|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|private|protected|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\b/,
          operator: /\.{2,3}|&\.|===|<?=>|[!=]?~|(?:&&|\|\||<<|>>|\*\*|[+\-*/%<>!^&|=])=?|[?:]/,
          punctuation: /[(){}[\].,;]/
        });
        Prism3.languages.insertBefore("ruby", "operator", {
          "double-colon": {
            pattern: /::/,
            alias: "punctuation"
          }
        });
        var interpolation = {
          pattern: /((?:^|[^\\])(?:\\{2})*)#\{(?:[^{}]|\{[^{}]*\})*\}/,
          lookbehind: true,
          inside: {
            content: {
              pattern: /^(#\{)[\s\S]+(?=\}$)/,
              lookbehind: true,
              inside: Prism3.languages.ruby
            },
            delimiter: {
              pattern: /^#\{|\}$/,
              alias: "punctuation"
            }
          }
        };
        delete Prism3.languages.ruby.function;
        var percentExpression = "(?:" + [
          /([^a-zA-Z0-9\s{(\[<=])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
          /\((?:[^()\\]|\\[\s\S]|\((?:[^()\\]|\\[\s\S])*\))*\)/.source,
          /\{(?:[^{}\\]|\\[\s\S]|\{(?:[^{}\\]|\\[\s\S])*\})*\}/.source,
          /\[(?:[^\[\]\\]|\\[\s\S]|\[(?:[^\[\]\\]|\\[\s\S])*\])*\]/.source,
          /<(?:[^<>\\]|\\[\s\S]|<(?:[^<>\\]|\\[\s\S])*>)*>/.source
        ].join("|") + ")";
        var symbolName = /(?:"(?:\\.|[^"\\\r\n])*"|(?:\b[a-zA-Z_]\w*|[^\s\0-\x7F]+)[?!]?|\$.)/.source;
        Prism3.languages.insertBefore("ruby", "keyword", {
          "regex-literal": [
            {
              pattern: RegExp(
                /%r/.source + percentExpression + /[egimnosux]{0,6}/.source
              ),
              greedy: true,
              inside: {
                interpolation,
                regex: /[\s\S]+/
              }
            },
            {
              pattern: /(^|[^/])\/(?!\/)(?:\[[^\r\n\]]+\]|\\.|[^[/\\\r\n])+\/[egimnosux]{0,6}(?=\s*(?:$|[\r\n,.;})#]))/,
              lookbehind: true,
              greedy: true,
              inside: {
                interpolation,
                regex: /[\s\S]+/
              }
            }
          ],
          variable: /[@$]+[a-zA-Z_]\w*(?:[?!]|\b)/,
          symbol: [
            {
              pattern: RegExp(/(^|[^:]):/.source + symbolName),
              lookbehind: true,
              greedy: true
            },
            {
              pattern: RegExp(
                /([\r\n{(,][ \t]*)/.source + symbolName + /(?=:(?!:))/.source
              ),
              lookbehind: true,
              greedy: true
            }
          ],
          "method-definition": {
            pattern: /(\bdef\s+)\w+(?:\s*\.\s*\w+)?/,
            lookbehind: true,
            inside: {
              function: /\b\w+$/,
              keyword: /^self\b/,
              "class-name": /^\w+/,
              punctuation: /\./
            }
          }
        });
        Prism3.languages.insertBefore("ruby", "string", {
          "string-literal": [
            {
              pattern: RegExp(/%[qQiIwWs]?/.source + percentExpression),
              greedy: true,
              inside: {
                interpolation,
                string: /[\s\S]+/
              }
            },
            {
              pattern: /("|')(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|(?!\1)[^\\#\r\n])*\1/,
              greedy: true,
              inside: {
                interpolation,
                string: /[\s\S]+/
              }
            },
            {
              pattern: /<<[-~]?([a-z_]\w*)[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
              alias: "heredoc-string",
              greedy: true,
              inside: {
                delimiter: {
                  pattern: /^<<[-~]?[a-z_]\w*|\b[a-z_]\w*$/i,
                  inside: {
                    symbol: /\b\w+/,
                    punctuation: /^<<[-~]?/
                  }
                },
                interpolation,
                string: /[\s\S]+/
              }
            },
            {
              pattern: /<<[-~]?'([a-z_]\w*)'[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
              alias: "heredoc-string",
              greedy: true,
              inside: {
                delimiter: {
                  pattern: /^<<[-~]?'[a-z_]\w*'|\b[a-z_]\w*$/i,
                  inside: {
                    symbol: /\b\w+/,
                    punctuation: /^<<[-~]?'|'$/
                  }
                },
                string: /[\s\S]+/
              }
            }
          ],
          "command-literal": [
            {
              pattern: RegExp(/%x/.source + percentExpression),
              greedy: true,
              inside: {
                interpolation,
                command: {
                  pattern: /[\s\S]+/,
                  alias: "string"
                }
              }
            },
            {
              pattern: /`(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|[^\\`#\r\n])*`/,
              greedy: true,
              inside: {
                interpolation,
                command: {
                  pattern: /[\s\S]+/,
                  alias: "string"
                }
              }
            }
          ]
        });
        delete Prism3.languages.ruby.string;
        Prism3.languages.insertBefore("ruby", "number", {
          builtin: /\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Fixnum|Float|Hash|IO|Integer|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|Stat|String|Struct|Symbol|TMS|Thread|ThreadGroup|Time|TrueClass)\b/,
          constant: /\b[A-Z][A-Z0-9_]*(?:[?!]|\b)/
        });
        Prism3.languages.rb = Prism3.languages.ruby;
      })(Prism2);
    }
    rust.displayName = "rust";
    rust.aliases = [];
    function rust(Prism2) {
      (function(Prism3) {
        var multilineComment = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source;
        for (var i2 = 0; i2 < 2; i2++) {
          multilineComment = multilineComment.replace(/<self>/g, function() {
            return multilineComment;
          });
        }
        multilineComment = multilineComment.replace(/<self>/g, function() {
          return /[^\s\S]/.source;
        });
        Prism3.languages.rust = {
          comment: [
            {
              pattern: RegExp(/(^|[^\\])/.source + multilineComment),
              lookbehind: true,
              greedy: true
            },
            {
              pattern: /(^|[^\\:])\/\/.*/,
              lookbehind: true,
              greedy: true
            }
          ],
          string: {
            pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
            greedy: true
          },
          char: {
            pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
            greedy: true
          },
          attribute: {
            pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
            greedy: true,
            alias: "attr-name",
            inside: {
              string: null
              // see below
            }
          },
          // Closure params should not be confused with bitwise OR |
          "closure-params": {
            pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
            lookbehind: true,
            greedy: true,
            inside: {
              "closure-punctuation": {
                pattern: /^\||\|$/,
                alias: "punctuation"
              },
              rest: null
              // see below
            }
          },
          "lifetime-annotation": {
            pattern: /'\w+/,
            alias: "symbol"
          },
          "fragment-specifier": {
            pattern: /(\$\w+:)[a-z]+/,
            lookbehind: true,
            alias: "punctuation"
          },
          variable: /\$\w+/,
          "function-definition": {
            pattern: /(\bfn\s+)\w+/,
            lookbehind: true,
            alias: "function"
          },
          "type-definition": {
            pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
            lookbehind: true,
            alias: "class-name"
          },
          "module-declaration": [
            {
              pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
              lookbehind: true,
              alias: "namespace"
            },
            {
              pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
              lookbehind: true,
              alias: "namespace",
              inside: {
                punctuation: /::/
              }
            }
          ],
          keyword: [
            // https://github.com/rust-lang/reference/blob/master/src/keywords.md
            /\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
            // primitives and str
            // https://doc.rust-lang.org/stable/rust-by-example/primitives.html
            /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/
          ],
          // functions can technically start with an upper-case letter, but this will introduce a lot of false positives
          // and Rust's naming conventions recommend snake_case anyway.
          // https://doc.rust-lang.org/1.0.0/style/style/naming/README.html
          function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
          macro: {
            pattern: /\b\w+!/,
            alias: "property"
          },
          constant: /\b[A-Z_][A-Z_\d]+\b/,
          "class-name": /\b[A-Z]\w*\b/,
          namespace: {
            pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
            inside: {
              punctuation: /::/
            }
          },
          // Hex, oct, bin, dec numbers with visual separators and type suffix
          number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
          boolean: /\b(?:false|true)\b/,
          punctuation: /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
          operator: /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
        };
        Prism3.languages.rust["closure-params"].inside.rest = Prism3.languages.rust;
        Prism3.languages.rust["attribute"].inside["string"] = Prism3.languages.rust["string"];
      })(Prism2);
    }
    sass.displayName = "sass";
    sass.aliases = [];
    function sass(Prism2) {
      Prism2.register(css);
      (function(Prism3) {
        Prism3.languages.sass = Prism3.languages.extend("css", {
          // Sass comments don't need to be closed, only indented
          comment: {
            pattern: /^([ \t]*)\/[\/*].*(?:(?:\r?\n|\r)\1[ \t].+)*/m,
            lookbehind: true,
            greedy: true
          }
        });
        Prism3.languages.insertBefore("sass", "atrule", {
          // We want to consume the whole line
          "atrule-line": {
            // Includes support for = and + shortcuts
            pattern: /^(?:[ \t]*)[@+=].+/m,
            greedy: true,
            inside: {
              atrule: /(?:@[\w-]+|[+=])/
            }
          }
        });
        delete Prism3.languages.sass.atrule;
        var variable = /\$[-\w]+|#\{\$[-\w]+\}/;
        var operator = [
          /[+*\/%]|[=!]=|<=?|>=?|\b(?:and|not|or)\b/,
          {
            pattern: /(\s)-(?=\s)/,
            lookbehind: true
          }
        ];
        Prism3.languages.insertBefore("sass", "property", {
          // We want to consume the whole line
          "variable-line": {
            pattern: /^[ \t]*\$.+/m,
            greedy: true,
            inside: {
              punctuation: /:/,
              variable,
              operator
            }
          },
          // We want to consume the whole line
          "property-line": {
            pattern: /^[ \t]*(?:[^:\s]+ *:.*|:[^:\s].*)/m,
            greedy: true,
            inside: {
              property: [
                /[^:\s]+(?=\s*:)/,
                {
                  pattern: /(:)[^:\s]+/,
                  lookbehind: true
                }
              ],
              punctuation: /:/,
              variable,
              operator,
              important: Prism3.languages.sass.important
            }
          }
        });
        delete Prism3.languages.sass.property;
        delete Prism3.languages.sass.important;
        Prism3.languages.insertBefore("sass", "punctuation", {
          selector: {
            pattern: /^([ \t]*)\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*(?:,(?:\r?\n|\r)\1[ \t]+\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*)*/m,
            lookbehind: true,
            greedy: true
          }
        });
      })(Prism2);
    }
    scss.displayName = "scss";
    scss.aliases = [];
    function scss(Prism2) {
      Prism2.register(css);
      Prism2.languages.scss = Prism2.languages.extend("css", {
        comment: {
          pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
          lookbehind: true
        },
        atrule: {
          pattern: /@[\w-](?:\([^()]+\)|[^()\s]|\s+(?!\s))*?(?=\s+[{;])/,
          inside: {
            rule: /@[\w-]+/
            // See rest below
          }
        },
        // url, compassified
        url: /(?:[-a-z]+-)?url(?=\()/i,
        // CSS selector regex is not appropriate for Sass
        // since there can be lot more things (var, @ directive, nesting..)
        // a selector must start at the end of a property or after a brace (end of other rules or nesting)
        // it can contain some characters that aren't used for defining rules or end of selector, & (parent selector), or interpolated variable
        // the end of a selector is found when there is no rules in it ( {} or {\s}) or if there is a property (because an interpolated var
        // can "pass" as a selector- e.g: proper#{$erty})
        // this one was hard to do, so please be careful if you edit this one :)
        selector: {
          // Initial look-ahead is used to prevent matching of blank selectors
          pattern: /(?=\S)[^@;{}()]?(?:[^@;{}()\s]|\s+(?!\s)|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}][^:{}]*[:{][^}]))/,
          inside: {
            parent: {
              pattern: /&/,
              alias: "important"
            },
            placeholder: /%[-\w]+/,
            variable: /\$[-\w]+|#\{\$[-\w]+\}/
          }
        },
        property: {
          pattern: /(?:[-\w]|\$[-\w]|#\{\$[-\w]+\})+(?=\s*:)/,
          inside: {
            variable: /\$[-\w]+|#\{\$[-\w]+\}/
          }
        }
      });
      Prism2.languages.insertBefore("scss", "atrule", {
        keyword: [
          /@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\b/i,
          {
            pattern: /( )(?:from|through)(?= )/,
            lookbehind: true
          }
        ]
      });
      Prism2.languages.insertBefore("scss", "important", {
        // var and interpolated vars
        variable: /\$[-\w]+|#\{\$[-\w]+\}/
      });
      Prism2.languages.insertBefore("scss", "function", {
        "module-modifier": {
          pattern: /\b(?:as|hide|show|with)\b/i,
          alias: "keyword"
        },
        placeholder: {
          pattern: /%[-\w]+/,
          alias: "selector"
        },
        statement: {
          pattern: /\B!(?:default|optional)\b/i,
          alias: "keyword"
        },
        boolean: /\b(?:false|true)\b/,
        null: {
          pattern: /\bnull\b/,
          alias: "keyword"
        },
        operator: {
          pattern: /(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|not|or)(?=\s)/,
          lookbehind: true
        }
      });
      Prism2.languages.scss["atrule"].inside.rest = Prism2.languages.scss;
    }
    sql.displayName = "sql";
    sql.aliases = [];
    function sql(Prism2) {
      Prism2.languages.sql = {
        comment: {
          pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
          lookbehind: true
        },
        variable: [
          {
            pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
            greedy: true
          },
          /@[\w.$]+/
        ],
        string: {
          pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
          greedy: true,
          lookbehind: true
        },
        identifier: {
          pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
          greedy: true,
          lookbehind: true,
          inside: {
            punctuation: /^`|`$/
          }
        },
        function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
        // Should we highlight user defined functions too?
        keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
        boolean: /\b(?:FALSE|NULL|TRUE)\b/i,
        number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
        operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
        punctuation: /[;[\]()`,.]/
      };
    }
    swift.displayName = "swift";
    swift.aliases = [];
    function swift(Prism2) {
      Prism2.languages.swift = {
        comment: {
          // Nested comments are supported up to 2 levels
          pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
          lookbehind: true,
          greedy: true
        },
        "string-literal": [
          // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
          {
            pattern: RegExp(
              /(^|[^"#])/.source + "(?:" + // single-line string
              /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + // multi-line string
              /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source
            ),
            lookbehind: true,
            greedy: true,
            inside: {
              interpolation: {
                pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
                lookbehind: true,
                inside: null
                // see below
              },
              "interpolation-punctuation": {
                pattern: /^\)|\\\($/,
                alias: "punctuation"
              },
              punctuation: /\\(?=[\r\n])/,
              string: /[\s\S]+/
            }
          },
          {
            pattern: RegExp(
              /(^|[^"#])(#+)/.source + "(?:" + // single-line string
              /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + // multi-line string
              /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"
            ),
            lookbehind: true,
            greedy: true,
            inside: {
              interpolation: {
                pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
                lookbehind: true,
                inside: null
                // see below
              },
              "interpolation-punctuation": {
                pattern: /^\)|\\#+\($/,
                alias: "punctuation"
              },
              string: /[\s\S]+/
            }
          }
        ],
        directive: {
          // directives with conditions
          pattern: RegExp(
            /#/.source + "(?:" + (/(?:elseif|if)\b/.source + "(?:[ 	]*" + // This regex is a little complex. It's equivalent to this:
            //   (?:![ \t]*)?(?:\b\w+\b(?:[ \t]*<round>)?|<round>)(?:[ \t]*(?:&&|\|\|))?
            // where <round> is a general parentheses expression.
            /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+") + "|" + /(?:else|endif)\b/.source + ")"
          ),
          alias: "property",
          inside: {
            "directive-name": /^#\w+/,
            boolean: /\b(?:false|true)\b/,
            number: /\b\d+(?:\.\d+)*\b/,
            operator: /!|&&|\|\||[<>]=?/,
            punctuation: /[(),]/
          }
        },
        literal: {
          pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
          alias: "constant"
        },
        "other-directive": {
          pattern: /#\w+\b/,
          alias: "property"
        },
        attribute: {
          pattern: /@\w+/,
          alias: "atrule"
        },
        "function-definition": {
          pattern: /(\bfunc\s+)\w+/,
          lookbehind: true,
          alias: "function"
        },
        label: {
          // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141
          pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
          lookbehind: true,
          alias: "important"
        },
        keyword: /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
        boolean: /\b(?:false|true)\b/,
        nil: {
          pattern: /\bnil\b/,
          alias: "constant"
        },
        "short-argument": /\$\d+\b/,
        omit: {
          pattern: /\b_\b/,
          alias: "keyword"
        },
        number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
        // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.
        "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
        function: /\b[a-z_]\w*(?=\s*\()/i,
        constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
        // Operators are generic in Swift. Developers can even create new operators (e.g. +++).
        // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481
        // This regex only supports ASCII operators.
        operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
        punctuation: /[{}[\]();,.:\\]/
      };
      Prism2.languages.swift["string-literal"].forEach(function(rule) {
        rule.inside["interpolation"].inside = Prism2.languages.swift;
      });
    }
    typescript.displayName = "typescript";
    typescript.aliases = ["ts"];
    function typescript(Prism2) {
      Prism2.register(javascript);
      (function(Prism3) {
        Prism3.languages.typescript = Prism3.languages.extend("javascript", {
          "class-name": {
            pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
            lookbehind: true,
            greedy: true,
            inside: null
            // see below
          },
          builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
        });
        Prism3.languages.typescript.keyword.push(
          /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
          // keywords that have to be followed by an identifier
          /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
          // This is for `import type *, {}`
          /\btype\b(?=\s*(?:[\{*]|$))/
        );
        delete Prism3.languages.typescript["parameter"];
        delete Prism3.languages.typescript["literal-property"];
        var typeInside = Prism3.languages.extend("typescript", {});
        delete typeInside["class-name"];
        Prism3.languages.typescript["class-name"].inside = typeInside;
        Prism3.languages.insertBefore("typescript", "function", {
          decorator: {
            pattern: /@[$\w\xA0-\uFFFF]+/,
            inside: {
              at: {
                pattern: /^@/,
                alias: "operator"
              },
              function: /^[\s\S]+/
            }
          },
          "generic-function": {
            // e.g. foo<T extends "bar" | "baz">( ...
            pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
            greedy: true,
            inside: {
              function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
              generic: {
                pattern: /<[\s\S]+/,
                // everything after the first <
                alias: "class-name",
                inside: typeInside
              }
            }
          }
        });
        Prism3.languages.ts = Prism3.languages.typescript;
      })(Prism2);
    }
    basic.displayName = "basic";
    basic.aliases = [];
    function basic(Prism2) {
      Prism2.languages.basic = {
        comment: {
          pattern: /(?:!|REM\b).+/i,
          inside: {
            keyword: /^REM/i
          }
        },
        string: {
          pattern: /"(?:""|[!#$%&'()*,\/:;<=>?^\w +\-.])*"/,
          greedy: true
        },
        number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
        keyword: /\b(?:AS|BEEP|BLOAD|BSAVE|CALL(?: ABSOLUTE)?|CASE|CHAIN|CHDIR|CLEAR|CLOSE|CLS|COM|COMMON|CONST|DATA|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DIM|DO|DOUBLE|ELSE|ELSEIF|END|ENVIRON|ERASE|ERROR|EXIT|FIELD|FILES|FOR|FUNCTION|GET|GOSUB|GOTO|IF|INPUT|INTEGER|IOCTL|KEY|KILL|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|MKDIR|NAME|NEXT|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPTION BASE|OUT|POKE|PUT|READ|REDIM|REM|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SELECT CASE|SHARED|SHELL|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|SUB|SWAP|SYSTEM|THEN|TIMER|TO|TROFF|TRON|TYPE|UNLOCK|UNTIL|USING|VIEW PRINT|WAIT|WEND|WHILE|WRITE)(?:\$|\b)/i,
        function: /\b(?:ABS|ACCESS|ACOS|ANGLE|AREA|ARITHMETIC|ARRAY|ASIN|ASK|AT|ATN|BASE|BEGIN|BREAK|CAUSE|CEIL|CHR|CLIP|COLLATE|COLOR|CON|COS|COSH|COT|CSC|DATE|DATUM|DEBUG|DECIMAL|DEF|DEG|DEGREES|DELETE|DET|DEVICE|DISPLAY|DOT|ELAPSED|EPS|ERASABLE|EXLINE|EXP|EXTERNAL|EXTYPE|FILETYPE|FIXED|FP|GO|GRAPH|HANDLER|IDN|IMAGE|IN|INT|INTERNAL|IP|IS|KEYED|LBOUND|LCASE|LEFT|LEN|LENGTH|LET|LINE|LINES|LOG|LOG10|LOG2|LTRIM|MARGIN|MAT|MAX|MAXNUM|MID|MIN|MISSING|MOD|NATIVE|NUL|NUMERIC|OF|OPTION|ORD|ORGANIZATION|OUTIN|OUTPUT|PI|POINT|POINTER|POINTS|POS|PRINT|PROGRAM|PROMPT|RAD|RADIANS|RANDOMIZE|RECORD|RECSIZE|RECTYPE|RELATIVE|REMAINDER|REPEAT|REST|RETRY|REWRITE|RIGHT|RND|ROUND|RTRIM|SAME|SEC|SELECT|SEQUENTIAL|SET|SETTER|SGN|SIN|SINH|SIZE|SKIP|SQR|STANDARD|STATUS|STR|STREAM|STYLE|TAB|TAN|TANH|TEMPLATE|TEXT|THERE|TIME|TIMEOUT|TRACE|TRANSFORM|TRUNCATE|UBOUND|UCASE|USE|VAL|VARIABLE|VIEWPORT|WHEN|WINDOW|WITH|ZER|ZONEWIDTH)(?:\$|\b)/i,
        operator: /<[=>]?|>=?|[+\-*\/^=&]|\b(?:AND|EQV|IMP|NOT|OR|XOR)\b/i,
        punctuation: /[,;:()]/
      };
    }
    vbnet.displayName = "vbnet";
    vbnet.aliases = [];
    function vbnet(Prism2) {
      Prism2.register(basic);
      Prism2.languages.vbnet = Prism2.languages.extend("basic", {
        comment: [
          {
            pattern: /(?:!|REM\b).+/i,
            inside: {
              keyword: /^REM/i
            }
          },
          {
            pattern: /(^|[^\\:])'.*/,
            lookbehind: true,
            greedy: true
          }
        ],
        string: {
          pattern: /(^|[^"])"(?:""|[^"])*"(?!")/,
          lookbehind: true,
          greedy: true
        },
        keyword: /(?:\b(?:ADDHANDLER|ADDRESSOF|ALIAS|AND|ANDALSO|AS|BEEP|BLOAD|BOOLEAN|BSAVE|BYREF|BYTE|BYVAL|CALL(?: ABSOLUTE)?|CASE|CATCH|CBOOL|CBYTE|CCHAR|CDATE|CDBL|CDEC|CHAIN|CHAR|CHDIR|CINT|CLASS|CLEAR|CLNG|CLOSE|CLS|COBJ|COM|COMMON|CONST|CONTINUE|CSBYTE|CSHORT|CSNG|CSTR|CTYPE|CUINT|CULNG|CUSHORT|DATA|DATE|DECIMAL|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DEFAULT|DELEGATE|DIM|DIRECTCAST|DO|DOUBLE|ELSE|ELSEIF|END|ENUM|ENVIRON|ERASE|ERROR|EVENT|EXIT|FALSE|FIELD|FILES|FINALLY|FOR(?: EACH)?|FRIEND|FUNCTION|GET|GETTYPE|GETXMLNAMESPACE|GLOBAL|GOSUB|GOTO|HANDLES|IF|IMPLEMENTS|IMPORTS|IN|INHERITS|INPUT|INTEGER|INTERFACE|IOCTL|IS|ISNOT|KEY|KILL|LET|LIB|LIKE|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|ME|MKDIR|MOD|MODULE|MUSTINHERIT|MUSTOVERRIDE|MYBASE|MYCLASS|NAME|NAMESPACE|NARROWING|NEW|NEXT|NOT|NOTHING|NOTINHERITABLE|NOTOVERRIDABLE|OBJECT|OF|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPERATOR|OPTION(?: BASE)?|OPTIONAL|OR|ORELSE|OUT|OVERLOADS|OVERRIDABLE|OVERRIDES|PARAMARRAY|PARTIAL|POKE|PRIVATE|PROPERTY|PROTECTED|PUBLIC|PUT|RAISEEVENT|READ|READONLY|REDIM|REM|REMOVEHANDLER|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SBYTE|SELECT(?: CASE)?|SET|SHADOWS|SHARED|SHELL|SHORT|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|STRUCTURE|SUB|SWAP|SYNCLOCK|SYSTEM|THEN|THROW|TIMER|TO|TROFF|TRON|TRUE|TRY|TRYCAST|TYPE|TYPEOF|UINTEGER|ULONG|UNLOCK|UNTIL|USHORT|USING|VIEW PRINT|WAIT|WEND|WHEN|WHILE|WIDENING|WITH|WITHEVENTS|WRITE|WRITEONLY|XOR)|\B(?:#CONST|#ELSE|#ELSEIF|#END|#IF))(?:\$|\b)/i,
        punctuation: /[,;:(){}]/
      });
    }
    refractor.register(clike);
    refractor.register(c$1);
    refractor.register(cpp);
    refractor.register(arduino);
    refractor.register(bash);
    refractor.register(csharp);
    refractor.register(markup);
    refractor.register(css);
    refractor.register(diff);
    refractor.register(go);
    refractor.register(ini);
    refractor.register(java);
    refractor.register(regex);
    refractor.register(javascript);
    refractor.register(json);
    refractor.register(kotlin);
    refractor.register(less);
    refractor.register(lua);
    refractor.register(makefile);
    refractor.register(yaml);
    refractor.register(markdown);
    refractor.register(objectivec);
    refractor.register(perl);
    refractor.register(markupTemplating);
    refractor.register(php);
    refractor.register(python);
    refractor.register(r$1);
    refractor.register(ruby);
    refractor.register(rust);
    refractor.register(sass);
    refractor.register(scss);
    refractor.register(sql);
    refractor.register(swift);
    refractor.register(typescript);
    refractor.register(basic);
    refractor.register(vbnet);
    var highlighter = highlight$1(refractor, defaultStyle);
    highlighter.supportedLanguages = supportedLanguages;
    const SyntaxHighlighter = highlighter;
    var main = { exports: {} };
    (function(module2, exports2) {
      !function(e2, t2) {
        module2.exports = t2(reactExports);
      }(commonjsGlobal, function(e2) {
        return function(e3) {
          var t2 = {};
          function n2(a2) {
            if (t2[a2])
              return t2[a2].exports;
            var r2 = t2[a2] = { i: a2, l: false, exports: {} };
            return e3[a2].call(r2.exports, r2, r2.exports, n2), r2.l = true, r2.exports;
          }
          return n2.m = e3, n2.c = t2, n2.d = function(e4, t3, a2) {
            n2.o(e4, t3) || Object.defineProperty(e4, t3, { enumerable: true, get: a2 });
          }, n2.r = function(e4) {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e4, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e4, "__esModule", { value: true });
          }, n2.t = function(e4, t3) {
            if (1 & t3 && (e4 = n2(e4)), 8 & t3)
              return e4;
            if (4 & t3 && "object" == typeof e4 && e4 && e4.__esModule)
              return e4;
            var a2 = /* @__PURE__ */ Object.create(null);
            if (n2.r(a2), Object.defineProperty(a2, "default", { enumerable: true, value: e4 }), 2 & t3 && "string" != typeof e4)
              for (var r2 in e4)
                n2.d(a2, r2, (function(t4) {
                  return e4[t4];
                }).bind(null, r2));
            return a2;
          }, n2.n = function(e4) {
            var t3 = e4 && e4.__esModule ? function() {
              return e4.default;
            } : function() {
              return e4;
            };
            return n2.d(t3, "a", t3), t3;
          }, n2.o = function(e4, t3) {
            return Object.prototype.hasOwnProperty.call(e4, t3);
          }, n2.p = "", n2(n2.s = 48);
        }([function(t2, n2) {
          t2.exports = e2;
        }, function(e3, t2) {
          var n2 = e3.exports = { version: "2.6.12" };
          "number" == typeof __e && (__e = n2);
        }, function(e3, t2, n2) {
          var a2 = n2(26)("wks"), r2 = n2(17), o2 = n2(3).Symbol, i2 = "function" == typeof o2;
          (e3.exports = function(e4) {
            return a2[e4] || (a2[e4] = i2 && o2[e4] || (i2 ? o2 : r2)("Symbol." + e4));
          }).store = a2;
        }, function(e3, t2) {
          var n2 = e3.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
          "number" == typeof __g && (__g = n2);
        }, function(e3, t2, n2) {
          e3.exports = !n2(8)(function() {
            return 7 != Object.defineProperty({}, "a", { get: function() {
              return 7;
            } }).a;
          });
        }, function(e3, t2) {
          var n2 = {}.hasOwnProperty;
          e3.exports = function(e4, t3) {
            return n2.call(e4, t3);
          };
        }, function(e3, t2, n2) {
          var a2 = n2(7), r2 = n2(16);
          e3.exports = n2(4) ? function(e4, t3, n3) {
            return a2.f(e4, t3, r2(1, n3));
          } : function(e4, t3, n3) {
            return e4[t3] = n3, e4;
          };
        }, function(e3, t2, n2) {
          var a2 = n2(10), r2 = n2(35), o2 = n2(23), i2 = Object.defineProperty;
          t2.f = n2(4) ? Object.defineProperty : function(e4, t3, n3) {
            if (a2(e4), t3 = o2(t3, true), a2(n3), r2)
              try {
                return i2(e4, t3, n3);
              } catch (e5) {
              }
            if ("get" in n3 || "set" in n3)
              throw TypeError("Accessors not supported!");
            return "value" in n3 && (e4[t3] = n3.value), e4;
          };
        }, function(e3, t2) {
          e3.exports = function(e4) {
            try {
              return !!e4();
            } catch (e5) {
              return true;
            }
          };
        }, function(e3, t2, n2) {
          var a2 = n2(40), r2 = n2(22);
          e3.exports = function(e4) {
            return a2(r2(e4));
          };
        }, function(e3, t2, n2) {
          var a2 = n2(11);
          e3.exports = function(e4) {
            if (!a2(e4))
              throw TypeError(e4 + " is not an object!");
            return e4;
          };
        }, function(e3, t2) {
          e3.exports = function(e4) {
            return "object" == typeof e4 ? null !== e4 : "function" == typeof e4;
          };
        }, function(e3, t2) {
          e3.exports = {};
        }, function(e3, t2, n2) {
          var a2 = n2(39), r2 = n2(27);
          e3.exports = Object.keys || function(e4) {
            return a2(e4, r2);
          };
        }, function(e3, t2) {
          e3.exports = true;
        }, function(e3, t2, n2) {
          var a2 = n2(3), r2 = n2(1), o2 = n2(53), i2 = n2(6), s2 = n2(5), c2 = function(e4, t3, n3) {
            var l2, u2, f2, p2 = e4 & c2.F, d2 = e4 & c2.G, b2 = e4 & c2.S, h2 = e4 & c2.P, v2 = e4 & c2.B, m2 = e4 & c2.W, y2 = d2 ? r2 : r2[t3] || (r2[t3] = {}), g2 = y2.prototype, E2 = d2 ? a2 : b2 ? a2[t3] : (a2[t3] || {}).prototype;
            for (l2 in d2 && (n3 = t3), n3)
              (u2 = !p2 && E2 && void 0 !== E2[l2]) && s2(y2, l2) || (f2 = u2 ? E2[l2] : n3[l2], y2[l2] = d2 && "function" != typeof E2[l2] ? n3[l2] : v2 && u2 ? o2(f2, a2) : m2 && E2[l2] == f2 ? function(e5) {
                var t4 = function(t5, n4, a3) {
                  if (this instanceof e5) {
                    switch (arguments.length) {
                      case 0:
                        return new e5();
                      case 1:
                        return new e5(t5);
                      case 2:
                        return new e5(t5, n4);
                    }
                    return new e5(t5, n4, a3);
                  }
                  return e5.apply(this, arguments);
                };
                return t4.prototype = e5.prototype, t4;
              }(f2) : h2 && "function" == typeof f2 ? o2(Function.call, f2) : f2, h2 && ((y2.virtual || (y2.virtual = {}))[l2] = f2, e4 & c2.R && g2 && !g2[l2] && i2(g2, l2, f2)));
          };
          c2.F = 1, c2.G = 2, c2.S = 4, c2.P = 8, c2.B = 16, c2.W = 32, c2.U = 64, c2.R = 128, e3.exports = c2;
        }, function(e3, t2) {
          e3.exports = function(e4, t3) {
            return { enumerable: !(1 & e4), configurable: !(2 & e4), writable: !(4 & e4), value: t3 };
          };
        }, function(e3, t2) {
          var n2 = 0, a2 = Math.random();
          e3.exports = function(e4) {
            return "Symbol(".concat(void 0 === e4 ? "" : e4, ")_", (++n2 + a2).toString(36));
          };
        }, function(e3, t2, n2) {
          var a2 = n2(22);
          e3.exports = function(e4) {
            return Object(a2(e4));
          };
        }, function(e3, t2) {
          t2.f = {}.propertyIsEnumerable;
        }, function(e3, t2, n2) {
          var a2 = n2(52)(true);
          n2(34)(String, "String", function(e4) {
            this._t = String(e4), this._i = 0;
          }, function() {
            var e4, t3 = this._t, n3 = this._i;
            return n3 >= t3.length ? { value: void 0, done: true } : (e4 = a2(t3, n3), this._i += e4.length, { value: e4, done: false });
          });
        }, function(e3, t2) {
          var n2 = Math.ceil, a2 = Math.floor;
          e3.exports = function(e4) {
            return isNaN(e4 = +e4) ? 0 : (e4 > 0 ? a2 : n2)(e4);
          };
        }, function(e3, t2) {
          e3.exports = function(e4) {
            if (null == e4)
              throw TypeError("Can't call method on  " + e4);
            return e4;
          };
        }, function(e3, t2, n2) {
          var a2 = n2(11);
          e3.exports = function(e4, t3) {
            if (!a2(e4))
              return e4;
            var n3, r2;
            if (t3 && "function" == typeof (n3 = e4.toString) && !a2(r2 = n3.call(e4)))
              return r2;
            if ("function" == typeof (n3 = e4.valueOf) && !a2(r2 = n3.call(e4)))
              return r2;
            if (!t3 && "function" == typeof (n3 = e4.toString) && !a2(r2 = n3.call(e4)))
              return r2;
            throw TypeError("Can't convert object to primitive value");
          };
        }, function(e3, t2) {
          var n2 = {}.toString;
          e3.exports = function(e4) {
            return n2.call(e4).slice(8, -1);
          };
        }, function(e3, t2, n2) {
          var a2 = n2(26)("keys"), r2 = n2(17);
          e3.exports = function(e4) {
            return a2[e4] || (a2[e4] = r2(e4));
          };
        }, function(e3, t2, n2) {
          var a2 = n2(1), r2 = n2(3), o2 = r2["__core-js_shared__"] || (r2["__core-js_shared__"] = {});
          (e3.exports = function(e4, t3) {
            return o2[e4] || (o2[e4] = void 0 !== t3 ? t3 : {});
          })("versions", []).push({ version: a2.version, mode: n2(14) ? "pure" : "global", copyright: "© 2020 Denis Pushkarev (zloirock.ru)" });
        }, function(e3, t2) {
          e3.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
        }, function(e3, t2, n2) {
          var a2 = n2(7).f, r2 = n2(5), o2 = n2(2)("toStringTag");
          e3.exports = function(e4, t3, n3) {
            e4 && !r2(e4 = n3 ? e4 : e4.prototype, o2) && a2(e4, o2, { configurable: true, value: t3 });
          };
        }, function(e3, t2, n2) {
          n2(62);
          for (var a2 = n2(3), r2 = n2(6), o2 = n2(12), i2 = n2(2)("toStringTag"), s2 = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(","), c2 = 0; c2 < s2.length; c2++) {
            var l2 = s2[c2], u2 = a2[l2], f2 = u2 && u2.prototype;
            f2 && !f2[i2] && r2(f2, i2, l2), o2[l2] = o2.Array;
          }
        }, function(e3, t2, n2) {
          t2.f = n2(2);
        }, function(e3, t2, n2) {
          var a2 = n2(3), r2 = n2(1), o2 = n2(14), i2 = n2(30), s2 = n2(7).f;
          e3.exports = function(e4) {
            var t3 = r2.Symbol || (r2.Symbol = o2 ? {} : a2.Symbol || {});
            "_" == e4.charAt(0) || e4 in t3 || s2(t3, e4, { value: i2.f(e4) });
          };
        }, function(e3, t2) {
          t2.f = Object.getOwnPropertySymbols;
        }, function(e3, t2) {
          e3.exports = function(e4, t3, n2) {
            return Math.min(Math.max(e4, t3), n2);
          };
        }, function(e3, t2, n2) {
          var a2 = n2(14), r2 = n2(15), o2 = n2(37), i2 = n2(6), s2 = n2(12), c2 = n2(55), l2 = n2(28), u2 = n2(61), f2 = n2(2)("iterator"), p2 = !([].keys && "next" in [].keys()), d2 = function() {
            return this;
          };
          e3.exports = function(e4, t3, n3, b2, h2, v2, m2) {
            c2(n3, t3, b2);
            var y2, g2, E2, j = function(e5) {
              if (!p2 && e5 in O2)
                return O2[e5];
              switch (e5) {
                case "keys":
                case "values":
                  return function() {
                    return new n3(this, e5);
                  };
              }
              return function() {
                return new n3(this, e5);
              };
            }, x2 = t3 + " Iterator", _2 = "values" == h2, k2 = false, O2 = e4.prototype, C2 = O2[f2] || O2["@@iterator"] || h2 && O2[h2], S2 = C2 || j(h2), w2 = h2 ? _2 ? j("entries") : S2 : void 0, A2 = "Array" == t3 && O2.entries || C2;
            if (A2 && (E2 = u2(A2.call(new e4()))) !== Object.prototype && E2.next && (l2(E2, x2, true), a2 || "function" == typeof E2[f2] || i2(E2, f2, d2)), _2 && C2 && "values" !== C2.name && (k2 = true, S2 = function() {
              return C2.call(this);
            }), a2 && !m2 || !p2 && !k2 && O2[f2] || i2(O2, f2, S2), s2[t3] = S2, s2[x2] = d2, h2)
              if (y2 = { values: _2 ? S2 : j("values"), keys: v2 ? S2 : j("keys"), entries: w2 }, m2)
                for (g2 in y2)
                  g2 in O2 || o2(O2, g2, y2[g2]);
              else
                r2(r2.P + r2.F * (p2 || k2), t3, y2);
            return y2;
          };
        }, function(e3, t2, n2) {
          e3.exports = !n2(4) && !n2(8)(function() {
            return 7 != Object.defineProperty(n2(36)("div"), "a", { get: function() {
              return 7;
            } }).a;
          });
        }, function(e3, t2, n2) {
          var a2 = n2(11), r2 = n2(3).document, o2 = a2(r2) && a2(r2.createElement);
          e3.exports = function(e4) {
            return o2 ? r2.createElement(e4) : {};
          };
        }, function(e3, t2, n2) {
          e3.exports = n2(6);
        }, function(e3, t2, n2) {
          var a2 = n2(10), r2 = n2(56), o2 = n2(27), i2 = n2(25)("IE_PROTO"), s2 = function() {
          }, c2 = function() {
            var e4, t3 = n2(36)("iframe"), a3 = o2.length;
            for (t3.style.display = "none", n2(60).appendChild(t3), t3.src = "javascript:", (e4 = t3.contentWindow.document).open(), e4.write("<script>document.F=Object<\/script>"), e4.close(), c2 = e4.F; a3--; )
              delete c2.prototype[o2[a3]];
            return c2();
          };
          e3.exports = Object.create || function(e4, t3) {
            var n3;
            return null !== e4 ? (s2.prototype = a2(e4), n3 = new s2(), s2.prototype = null, n3[i2] = e4) : n3 = c2(), void 0 === t3 ? n3 : r2(n3, t3);
          };
        }, function(e3, t2, n2) {
          var a2 = n2(5), r2 = n2(9), o2 = n2(57)(false), i2 = n2(25)("IE_PROTO");
          e3.exports = function(e4, t3) {
            var n3, s2 = r2(e4), c2 = 0, l2 = [];
            for (n3 in s2)
              n3 != i2 && a2(s2, n3) && l2.push(n3);
            for (; t3.length > c2; )
              a2(s2, n3 = t3[c2++]) && (~o2(l2, n3) || l2.push(n3));
            return l2;
          };
        }, function(e3, t2, n2) {
          var a2 = n2(24);
          e3.exports = Object("z").propertyIsEnumerable(0) ? Object : function(e4) {
            return "String" == a2(e4) ? e4.split("") : Object(e4);
          };
        }, function(e3, t2, n2) {
          var a2 = n2(39), r2 = n2(27).concat("length", "prototype");
          t2.f = Object.getOwnPropertyNames || function(e4) {
            return a2(e4, r2);
          };
        }, function(e3, t2, n2) {
          var a2 = n2(24), r2 = n2(2)("toStringTag"), o2 = "Arguments" == a2(function() {
            return arguments;
          }());
          e3.exports = function(e4) {
            var t3, n3, i2;
            return void 0 === e4 ? "Undefined" : null === e4 ? "Null" : "string" == typeof (n3 = function(e5, t4) {
              try {
                return e5[t4];
              } catch (e6) {
              }
            }(t3 = Object(e4), r2)) ? n3 : o2 ? a2(t3) : "Object" == (i2 = a2(t3)) && "function" == typeof t3.callee ? "Arguments" : i2;
          };
        }, function(e3, t2) {
          var n2;
          n2 = function() {
            return this;
          }();
          try {
            n2 = n2 || new Function("return this")();
          } catch (e4) {
            "object" == typeof window && (n2 = window);
          }
          e3.exports = n2;
        }, function(e3, t2) {
          var n2 = /-?\d+(\.\d+)?%?/g;
          e3.exports = function(e4) {
            return e4.match(n2);
          };
        }, function(e3, t2, n2) {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.getBase16Theme = t2.createStyling = t2.invertTheme = void 0;
          var a2 = d2(n2(49)), r2 = d2(n2(76)), o2 = d2(n2(81)), i2 = d2(n2(89)), s2 = d2(n2(93)), c2 = function(e4) {
            if (e4 && e4.__esModule)
              return e4;
            var t3 = {};
            if (null != e4)
              for (var n3 in e4)
                Object.prototype.hasOwnProperty.call(e4, n3) && (t3[n3] = e4[n3]);
            return t3.default = e4, t3;
          }(n2(94)), l2 = d2(n2(132)), u2 = d2(n2(133)), f2 = d2(n2(138)), p2 = n2(139);
          function d2(e4) {
            return e4 && e4.__esModule ? e4 : { default: e4 };
          }
          var b2 = c2.default, h2 = (0, i2.default)(b2), v2 = (0, f2.default)(u2.default, p2.rgb2yuv, function(e4) {
            var t3, n3 = (0, o2.default)(e4, 3), a3 = n3[0], r3 = n3[1], i3 = n3[2];
            return [(t3 = a3, t3 < 0.25 ? 1 : t3 < 0.5 ? 0.9 - t3 : 1.1 - t3), r3, i3];
          }, p2.yuv2rgb, l2.default), m2 = function(e4) {
            return function(t3) {
              return { className: [t3.className, e4.className].filter(Boolean).join(" "), style: (0, r2.default)({}, t3.style || {}, e4.style || {}) };
            };
          }, y2 = function(e4, t3) {
            var n3 = (0, i2.default)(t3);
            for (var o3 in e4)
              -1 === n3.indexOf(o3) && n3.push(o3);
            return n3.reduce(function(n4, o4) {
              return n4[o4] = function(e5, t4) {
                if (void 0 === e5)
                  return t4;
                if (void 0 === t4)
                  return e5;
                var n5 = void 0 === e5 ? "undefined" : (0, a2.default)(e5), o5 = void 0 === t4 ? "undefined" : (0, a2.default)(t4);
                switch (n5) {
                  case "string":
                    switch (o5) {
                      case "string":
                        return [t4, e5].filter(Boolean).join(" ");
                      case "object":
                        return m2({ className: e5, style: t4 });
                      case "function":
                        return function(n6) {
                          for (var a3 = arguments.length, r3 = Array(a3 > 1 ? a3 - 1 : 0), o6 = 1; o6 < a3; o6++)
                            r3[o6 - 1] = arguments[o6];
                          return m2({ className: e5 })(t4.apply(void 0, [n6].concat(r3)));
                        };
                    }
                  case "object":
                    switch (o5) {
                      case "string":
                        return m2({ className: t4, style: e5 });
                      case "object":
                        return (0, r2.default)({}, t4, e5);
                      case "function":
                        return function(n6) {
                          for (var a3 = arguments.length, r3 = Array(a3 > 1 ? a3 - 1 : 0), o6 = 1; o6 < a3; o6++)
                            r3[o6 - 1] = arguments[o6];
                          return m2({ style: e5 })(t4.apply(void 0, [n6].concat(r3)));
                        };
                    }
                  case "function":
                    switch (o5) {
                      case "string":
                        return function(n6) {
                          for (var a3 = arguments.length, r3 = Array(a3 > 1 ? a3 - 1 : 0), o6 = 1; o6 < a3; o6++)
                            r3[o6 - 1] = arguments[o6];
                          return e5.apply(void 0, [m2(n6)({ className: t4 })].concat(r3));
                        };
                      case "object":
                        return function(n6) {
                          for (var a3 = arguments.length, r3 = Array(a3 > 1 ? a3 - 1 : 0), o6 = 1; o6 < a3; o6++)
                            r3[o6 - 1] = arguments[o6];
                          return e5.apply(void 0, [m2(n6)({ style: t4 })].concat(r3));
                        };
                      case "function":
                        return function(n6) {
                          for (var a3 = arguments.length, r3 = Array(a3 > 1 ? a3 - 1 : 0), o6 = 1; o6 < a3; o6++)
                            r3[o6 - 1] = arguments[o6];
                          return e5.apply(void 0, [t4.apply(void 0, [n6].concat(r3))].concat(r3));
                        };
                    }
                }
              }(e4[o4], t3[o4]), n4;
            }, {});
          }, g2 = function(e4, t3) {
            for (var n3 = arguments.length, o3 = Array(n3 > 2 ? n3 - 2 : 0), s3 = 2; s3 < n3; s3++)
              o3[s3 - 2] = arguments[s3];
            if (null === t3)
              return e4;
            Array.isArray(t3) || (t3 = [t3]);
            var c3 = t3.map(function(t4) {
              return e4[t4];
            }).filter(Boolean), l3 = c3.reduce(function(e5, t4) {
              return "string" == typeof t4 ? e5.className = [e5.className, t4].filter(Boolean).join(" ") : "object" === (void 0 === t4 ? "undefined" : (0, a2.default)(t4)) ? e5.style = (0, r2.default)({}, e5.style, t4) : "function" == typeof t4 && (e5 = (0, r2.default)({}, e5, t4.apply(void 0, [e5].concat(o3)))), e5;
            }, { className: "", style: {} });
            return l3.className || delete l3.className, 0 === (0, i2.default)(l3.style).length && delete l3.style, l3;
          }, E2 = t2.invertTheme = function(e4) {
            return (0, i2.default)(e4).reduce(function(t3, n3) {
              return t3[n3] = /^base/.test(n3) ? v2(e4[n3]) : "scheme" === n3 ? e4[n3] + ":inverted" : e4[n3], t3;
            }, {});
          }, j = (t2.createStyling = (0, s2.default)(function(e4) {
            for (var t3 = arguments.length, n3 = Array(t3 > 3 ? t3 - 3 : 0), a3 = 3; a3 < t3; a3++)
              n3[a3 - 3] = arguments[a3];
            var o3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, c3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, l3 = o3.defaultBase16, u3 = void 0 === l3 ? b2 : l3, f3 = o3.base16Themes, p3 = void 0 === f3 ? null : f3, d3 = j(c3, p3);
            d3 && (c3 = (0, r2.default)({}, d3, c3));
            var v3 = h2.reduce(function(e5, t4) {
              return e5[t4] = c3[t4] || u3[t4], e5;
            }, {}), m3 = (0, i2.default)(c3).reduce(function(e5, t4) {
              return -1 === h2.indexOf(t4) ? (e5[t4] = c3[t4], e5) : e5;
            }, {}), E3 = e4(v3), x2 = y2(m3, E3);
            return (0, s2.default)(g2, 2).apply(void 0, [x2].concat(n3));
          }, 3), t2.getBase16Theme = function(e4, t3) {
            if (e4 && e4.extend && (e4 = e4.extend), "string" == typeof e4) {
              var n3 = e4.split(":"), a3 = (0, o2.default)(n3, 2), r3 = a3[0], i3 = a3[1];
              e4 = (t3 || {})[r3] || c2[r3], "inverted" === i3 && (e4 = E2(e4));
            }
            return e4 && e4.hasOwnProperty("base00") ? e4 : void 0;
          });
        }, function(e3, t2, n2) {
          var a2, r2 = "object" == typeof Reflect ? Reflect : null, o2 = r2 && "function" == typeof r2.apply ? r2.apply : function(e4, t3, n3) {
            return Function.prototype.apply.call(e4, t3, n3);
          };
          a2 = r2 && "function" == typeof r2.ownKeys ? r2.ownKeys : Object.getOwnPropertySymbols ? function(e4) {
            return Object.getOwnPropertyNames(e4).concat(Object.getOwnPropertySymbols(e4));
          } : function(e4) {
            return Object.getOwnPropertyNames(e4);
          };
          var i2 = Number.isNaN || function(e4) {
            return e4 != e4;
          };
          function s2() {
            s2.init.call(this);
          }
          e3.exports = s2, e3.exports.once = function(e4, t3) {
            return new Promise(function(n3, a3) {
              function r3() {
                void 0 !== o3 && e4.removeListener("error", o3), n3([].slice.call(arguments));
              }
              var o3;
              "error" !== t3 && (o3 = function(n4) {
                e4.removeListener(t3, r3), a3(n4);
              }, e4.once("error", o3)), e4.once(t3, r3);
            });
          }, s2.EventEmitter = s2, s2.prototype._events = void 0, s2.prototype._eventsCount = 0, s2.prototype._maxListeners = void 0;
          var c2 = 10;
          function l2(e4) {
            if ("function" != typeof e4)
              throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e4);
          }
          function u2(e4) {
            return void 0 === e4._maxListeners ? s2.defaultMaxListeners : e4._maxListeners;
          }
          function f2(e4, t3, n3, a3) {
            var r3, o3, i3, s3;
            if (l2(n3), void 0 === (o3 = e4._events) ? (o3 = e4._events = /* @__PURE__ */ Object.create(null), e4._eventsCount = 0) : (void 0 !== o3.newListener && (e4.emit("newListener", t3, n3.listener ? n3.listener : n3), o3 = e4._events), i3 = o3[t3]), void 0 === i3)
              i3 = o3[t3] = n3, ++e4._eventsCount;
            else if ("function" == typeof i3 ? i3 = o3[t3] = a3 ? [n3, i3] : [i3, n3] : a3 ? i3.unshift(n3) : i3.push(n3), (r3 = u2(e4)) > 0 && i3.length > r3 && !i3.warned) {
              i3.warned = true;
              var c3 = new Error("Possible EventEmitter memory leak detected. " + i3.length + " " + String(t3) + " listeners added. Use emitter.setMaxListeners() to increase limit");
              c3.name = "MaxListenersExceededWarning", c3.emitter = e4, c3.type = t3, c3.count = i3.length, s3 = c3, console && console.warn && console.warn(s3);
            }
            return e4;
          }
          function p2() {
            if (!this.fired)
              return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
          }
          function d2(e4, t3, n3) {
            var a3 = { fired: false, wrapFn: void 0, target: e4, type: t3, listener: n3 }, r3 = p2.bind(a3);
            return r3.listener = n3, a3.wrapFn = r3, r3;
          }
          function b2(e4, t3, n3) {
            var a3 = e4._events;
            if (void 0 === a3)
              return [];
            var r3 = a3[t3];
            return void 0 === r3 ? [] : "function" == typeof r3 ? n3 ? [r3.listener || r3] : [r3] : n3 ? function(e5) {
              for (var t4 = new Array(e5.length), n4 = 0; n4 < t4.length; ++n4)
                t4[n4] = e5[n4].listener || e5[n4];
              return t4;
            }(r3) : v2(r3, r3.length);
          }
          function h2(e4) {
            var t3 = this._events;
            if (void 0 !== t3) {
              var n3 = t3[e4];
              if ("function" == typeof n3)
                return 1;
              if (void 0 !== n3)
                return n3.length;
            }
            return 0;
          }
          function v2(e4, t3) {
            for (var n3 = new Array(t3), a3 = 0; a3 < t3; ++a3)
              n3[a3] = e4[a3];
            return n3;
          }
          Object.defineProperty(s2, "defaultMaxListeners", { enumerable: true, get: function() {
            return c2;
          }, set: function(e4) {
            if ("number" != typeof e4 || e4 < 0 || i2(e4))
              throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e4 + ".");
            c2 = e4;
          } }), s2.init = function() {
            void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
          }, s2.prototype.setMaxListeners = function(e4) {
            if ("number" != typeof e4 || e4 < 0 || i2(e4))
              throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e4 + ".");
            return this._maxListeners = e4, this;
          }, s2.prototype.getMaxListeners = function() {
            return u2(this);
          }, s2.prototype.emit = function(e4) {
            for (var t3 = [], n3 = 1; n3 < arguments.length; n3++)
              t3.push(arguments[n3]);
            var a3 = "error" === e4, r3 = this._events;
            if (void 0 !== r3)
              a3 = a3 && void 0 === r3.error;
            else if (!a3)
              return false;
            if (a3) {
              var i3;
              if (t3.length > 0 && (i3 = t3[0]), i3 instanceof Error)
                throw i3;
              var s3 = new Error("Unhandled error." + (i3 ? " (" + i3.message + ")" : ""));
              throw s3.context = i3, s3;
            }
            var c3 = r3[e4];
            if (void 0 === c3)
              return false;
            if ("function" == typeof c3)
              o2(c3, this, t3);
            else {
              var l3 = c3.length, u3 = v2(c3, l3);
              for (n3 = 0; n3 < l3; ++n3)
                o2(u3[n3], this, t3);
            }
            return true;
          }, s2.prototype.addListener = function(e4, t3) {
            return f2(this, e4, t3, false);
          }, s2.prototype.on = s2.prototype.addListener, s2.prototype.prependListener = function(e4, t3) {
            return f2(this, e4, t3, true);
          }, s2.prototype.once = function(e4, t3) {
            return l2(t3), this.on(e4, d2(this, e4, t3)), this;
          }, s2.prototype.prependOnceListener = function(e4, t3) {
            return l2(t3), this.prependListener(e4, d2(this, e4, t3)), this;
          }, s2.prototype.removeListener = function(e4, t3) {
            var n3, a3, r3, o3, i3;
            if (l2(t3), void 0 === (a3 = this._events))
              return this;
            if (void 0 === (n3 = a3[e4]))
              return this;
            if (n3 === t3 || n3.listener === t3)
              0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete a3[e4], a3.removeListener && this.emit("removeListener", e4, n3.listener || t3));
            else if ("function" != typeof n3) {
              for (r3 = -1, o3 = n3.length - 1; o3 >= 0; o3--)
                if (n3[o3] === t3 || n3[o3].listener === t3) {
                  i3 = n3[o3].listener, r3 = o3;
                  break;
                }
              if (r3 < 0)
                return this;
              0 === r3 ? n3.shift() : function(e5, t4) {
                for (; t4 + 1 < e5.length; t4++)
                  e5[t4] = e5[t4 + 1];
                e5.pop();
              }(n3, r3), 1 === n3.length && (a3[e4] = n3[0]), void 0 !== a3.removeListener && this.emit("removeListener", e4, i3 || t3);
            }
            return this;
          }, s2.prototype.off = s2.prototype.removeListener, s2.prototype.removeAllListeners = function(e4) {
            var t3, n3, a3;
            if (void 0 === (n3 = this._events))
              return this;
            if (void 0 === n3.removeListener)
              return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== n3[e4] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete n3[e4]), this;
            if (0 === arguments.length) {
              var r3, o3 = Object.keys(n3);
              for (a3 = 0; a3 < o3.length; ++a3)
                "removeListener" !== (r3 = o3[a3]) && this.removeAllListeners(r3);
              return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
            }
            if ("function" == typeof (t3 = n3[e4]))
              this.removeListener(e4, t3);
            else if (void 0 !== t3)
              for (a3 = t3.length - 1; a3 >= 0; a3--)
                this.removeListener(e4, t3[a3]);
            return this;
          }, s2.prototype.listeners = function(e4) {
            return b2(this, e4, true);
          }, s2.prototype.rawListeners = function(e4) {
            return b2(this, e4, false);
          }, s2.listenerCount = function(e4, t3) {
            return "function" == typeof e4.listenerCount ? e4.listenerCount(t3) : h2.call(e4, t3);
          }, s2.prototype.listenerCount = h2, s2.prototype.eventNames = function() {
            return this._eventsCount > 0 ? a2(this._events) : [];
          };
        }, function(e3, t2, n2) {
          e3.exports.Dispatcher = n2(140);
        }, function(e3, t2, n2) {
          e3.exports = n2(142);
        }, function(e3, t2, n2) {
          t2.__esModule = true;
          var a2 = i2(n2(50)), r2 = i2(n2(65)), o2 = "function" == typeof r2.default && "symbol" == typeof a2.default ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof r2.default && e4.constructor === r2.default && e4 !== r2.default.prototype ? "symbol" : typeof e4;
          };
          function i2(e4) {
            return e4 && e4.__esModule ? e4 : { default: e4 };
          }
          t2.default = "function" == typeof r2.default && "symbol" === o2(a2.default) ? function(e4) {
            return void 0 === e4 ? "undefined" : o2(e4);
          } : function(e4) {
            return e4 && "function" == typeof r2.default && e4.constructor === r2.default && e4 !== r2.default.prototype ? "symbol" : void 0 === e4 ? "undefined" : o2(e4);
          };
        }, function(e3, t2, n2) {
          e3.exports = { default: n2(51), __esModule: true };
        }, function(e3, t2, n2) {
          n2(20), n2(29), e3.exports = n2(30).f("iterator");
        }, function(e3, t2, n2) {
          var a2 = n2(21), r2 = n2(22);
          e3.exports = function(e4) {
            return function(t3, n3) {
              var o2, i2, s2 = String(r2(t3)), c2 = a2(n3), l2 = s2.length;
              return c2 < 0 || c2 >= l2 ? e4 ? "" : void 0 : (o2 = s2.charCodeAt(c2)) < 55296 || o2 > 56319 || c2 + 1 === l2 || (i2 = s2.charCodeAt(c2 + 1)) < 56320 || i2 > 57343 ? e4 ? s2.charAt(c2) : o2 : e4 ? s2.slice(c2, c2 + 2) : i2 - 56320 + (o2 - 55296 << 10) + 65536;
            };
          };
        }, function(e3, t2, n2) {
          var a2 = n2(54);
          e3.exports = function(e4, t3, n3) {
            if (a2(e4), void 0 === t3)
              return e4;
            switch (n3) {
              case 1:
                return function(n4) {
                  return e4.call(t3, n4);
                };
              case 2:
                return function(n4, a3) {
                  return e4.call(t3, n4, a3);
                };
              case 3:
                return function(n4, a3, r2) {
                  return e4.call(t3, n4, a3, r2);
                };
            }
            return function() {
              return e4.apply(t3, arguments);
            };
          };
        }, function(e3, t2) {
          e3.exports = function(e4) {
            if ("function" != typeof e4)
              throw TypeError(e4 + " is not a function!");
            return e4;
          };
        }, function(e3, t2, n2) {
          var a2 = n2(38), r2 = n2(16), o2 = n2(28), i2 = {};
          n2(6)(i2, n2(2)("iterator"), function() {
            return this;
          }), e3.exports = function(e4, t3, n3) {
            e4.prototype = a2(i2, { next: r2(1, n3) }), o2(e4, t3 + " Iterator");
          };
        }, function(e3, t2, n2) {
          var a2 = n2(7), r2 = n2(10), o2 = n2(13);
          e3.exports = n2(4) ? Object.defineProperties : function(e4, t3) {
            r2(e4);
            for (var n3, i2 = o2(t3), s2 = i2.length, c2 = 0; s2 > c2; )
              a2.f(e4, n3 = i2[c2++], t3[n3]);
            return e4;
          };
        }, function(e3, t2, n2) {
          var a2 = n2(9), r2 = n2(58), o2 = n2(59);
          e3.exports = function(e4) {
            return function(t3, n3, i2) {
              var s2, c2 = a2(t3), l2 = r2(c2.length), u2 = o2(i2, l2);
              if (e4 && n3 != n3) {
                for (; l2 > u2; )
                  if ((s2 = c2[u2++]) != s2)
                    return true;
              } else
                for (; l2 > u2; u2++)
                  if ((e4 || u2 in c2) && c2[u2] === n3)
                    return e4 || u2 || 0;
              return !e4 && -1;
            };
          };
        }, function(e3, t2, n2) {
          var a2 = n2(21), r2 = Math.min;
          e3.exports = function(e4) {
            return e4 > 0 ? r2(a2(e4), 9007199254740991) : 0;
          };
        }, function(e3, t2, n2) {
          var a2 = n2(21), r2 = Math.max, o2 = Math.min;
          e3.exports = function(e4, t3) {
            return (e4 = a2(e4)) < 0 ? r2(e4 + t3, 0) : o2(e4, t3);
          };
        }, function(e3, t2, n2) {
          var a2 = n2(3).document;
          e3.exports = a2 && a2.documentElement;
        }, function(e3, t2, n2) {
          var a2 = n2(5), r2 = n2(18), o2 = n2(25)("IE_PROTO"), i2 = Object.prototype;
          e3.exports = Object.getPrototypeOf || function(e4) {
            return e4 = r2(e4), a2(e4, o2) ? e4[o2] : "function" == typeof e4.constructor && e4 instanceof e4.constructor ? e4.constructor.prototype : e4 instanceof Object ? i2 : null;
          };
        }, function(e3, t2, n2) {
          var a2 = n2(63), r2 = n2(64), o2 = n2(12), i2 = n2(9);
          e3.exports = n2(34)(Array, "Array", function(e4, t3) {
            this._t = i2(e4), this._i = 0, this._k = t3;
          }, function() {
            var e4 = this._t, t3 = this._k, n3 = this._i++;
            return !e4 || n3 >= e4.length ? (this._t = void 0, r2(1)) : r2(0, "keys" == t3 ? n3 : "values" == t3 ? e4[n3] : [n3, e4[n3]]);
          }, "values"), o2.Arguments = o2.Array, a2("keys"), a2("values"), a2("entries");
        }, function(e3, t2) {
          e3.exports = function() {
          };
        }, function(e3, t2) {
          e3.exports = function(e4, t3) {
            return { value: t3, done: !!e4 };
          };
        }, function(e3, t2, n2) {
          e3.exports = { default: n2(66), __esModule: true };
        }, function(e3, t2, n2) {
          n2(67), n2(73), n2(74), n2(75), e3.exports = n2(1).Symbol;
        }, function(e3, t2, n2) {
          var a2 = n2(3), r2 = n2(5), o2 = n2(4), i2 = n2(15), s2 = n2(37), c2 = n2(68).KEY, l2 = n2(8), u2 = n2(26), f2 = n2(28), p2 = n2(17), d2 = n2(2), b2 = n2(30), h2 = n2(31), v2 = n2(69), m2 = n2(70), y2 = n2(10), g2 = n2(11), E2 = n2(18), j = n2(9), x2 = n2(23), _2 = n2(16), k2 = n2(38), O2 = n2(71), C2 = n2(72), S2 = n2(32), w2 = n2(7), A2 = n2(13), M2 = C2.f, P2 = w2.f, F2 = O2.f, D2 = a2.Symbol, I2 = a2.JSON, R2 = I2 && I2.stringify, L2 = d2("_hidden"), B2 = d2("toPrimitive"), N2 = {}.propertyIsEnumerable, z2 = u2("symbol-registry"), T2 = u2("symbols"), q2 = u2("op-symbols"), V2 = Object.prototype, K2 = "function" == typeof D2 && !!S2.f, W2 = a2.QObject, H2 = !W2 || !W2.prototype || !W2.prototype.findChild, U2 = o2 && l2(function() {
            return 7 != k2(P2({}, "a", { get: function() {
              return P2(this, "a", { value: 7 }).a;
            } })).a;
          }) ? function(e4, t3, n3) {
            var a3 = M2(V2, t3);
            a3 && delete V2[t3], P2(e4, t3, n3), a3 && e4 !== V2 && P2(V2, t3, a3);
          } : P2, G2 = function(e4) {
            var t3 = T2[e4] = k2(D2.prototype);
            return t3._k = e4, t3;
          }, J2 = K2 && "symbol" == typeof D2.iterator ? function(e4) {
            return "symbol" == typeof e4;
          } : function(e4) {
            return e4 instanceof D2;
          }, Y2 = function(e4, t3, n3) {
            return e4 === V2 && Y2(q2, t3, n3), y2(e4), t3 = x2(t3, true), y2(n3), r2(T2, t3) ? (n3.enumerable ? (r2(e4, L2) && e4[L2][t3] && (e4[L2][t3] = false), n3 = k2(n3, { enumerable: _2(0, false) })) : (r2(e4, L2) || P2(e4, L2, _2(1, {})), e4[L2][t3] = true), U2(e4, t3, n3)) : P2(e4, t3, n3);
          }, $2 = function(e4, t3) {
            y2(e4);
            for (var n3, a3 = v2(t3 = j(t3)), r3 = 0, o3 = a3.length; o3 > r3; )
              Y2(e4, n3 = a3[r3++], t3[n3]);
            return e4;
          }, Q2 = function(e4) {
            var t3 = N2.call(this, e4 = x2(e4, true));
            return !(this === V2 && r2(T2, e4) && !r2(q2, e4)) && (!(t3 || !r2(this, e4) || !r2(T2, e4) || r2(this, L2) && this[L2][e4]) || t3);
          }, Z2 = function(e4, t3) {
            if (e4 = j(e4), t3 = x2(t3, true), e4 !== V2 || !r2(T2, t3) || r2(q2, t3)) {
              var n3 = M2(e4, t3);
              return !n3 || !r2(T2, t3) || r2(e4, L2) && e4[L2][t3] || (n3.enumerable = true), n3;
            }
          }, X2 = function(e4) {
            for (var t3, n3 = F2(j(e4)), a3 = [], o3 = 0; n3.length > o3; )
              r2(T2, t3 = n3[o3++]) || t3 == L2 || t3 == c2 || a3.push(t3);
            return a3;
          }, ee2 = function(e4) {
            for (var t3, n3 = e4 === V2, a3 = F2(n3 ? q2 : j(e4)), o3 = [], i3 = 0; a3.length > i3; )
              !r2(T2, t3 = a3[i3++]) || n3 && !r2(V2, t3) || o3.push(T2[t3]);
            return o3;
          };
          K2 || (s2((D2 = function() {
            if (this instanceof D2)
              throw TypeError("Symbol is not a constructor!");
            var e4 = p2(arguments.length > 0 ? arguments[0] : void 0), t3 = function(n3) {
              this === V2 && t3.call(q2, n3), r2(this, L2) && r2(this[L2], e4) && (this[L2][e4] = false), U2(this, e4, _2(1, n3));
            };
            return o2 && H2 && U2(V2, e4, { configurable: true, set: t3 }), G2(e4);
          }).prototype, "toString", function() {
            return this._k;
          }), C2.f = Z2, w2.f = Y2, n2(41).f = O2.f = X2, n2(19).f = Q2, S2.f = ee2, o2 && !n2(14) && s2(V2, "propertyIsEnumerable", Q2, true), b2.f = function(e4) {
            return G2(d2(e4));
          }), i2(i2.G + i2.W + i2.F * !K2, { Symbol: D2 });
          for (var te2 = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), ne2 = 0; te2.length > ne2; )
            d2(te2[ne2++]);
          for (var ae2 = A2(d2.store), re2 = 0; ae2.length > re2; )
            h2(ae2[re2++]);
          i2(i2.S + i2.F * !K2, "Symbol", { for: function(e4) {
            return r2(z2, e4 += "") ? z2[e4] : z2[e4] = D2(e4);
          }, keyFor: function(e4) {
            if (!J2(e4))
              throw TypeError(e4 + " is not a symbol!");
            for (var t3 in z2)
              if (z2[t3] === e4)
                return t3;
          }, useSetter: function() {
            H2 = true;
          }, useSimple: function() {
            H2 = false;
          } }), i2(i2.S + i2.F * !K2, "Object", { create: function(e4, t3) {
            return void 0 === t3 ? k2(e4) : $2(k2(e4), t3);
          }, defineProperty: Y2, defineProperties: $2, getOwnPropertyDescriptor: Z2, getOwnPropertyNames: X2, getOwnPropertySymbols: ee2 });
          var oe2 = l2(function() {
            S2.f(1);
          });
          i2(i2.S + i2.F * oe2, "Object", { getOwnPropertySymbols: function(e4) {
            return S2.f(E2(e4));
          } }), I2 && i2(i2.S + i2.F * (!K2 || l2(function() {
            var e4 = D2();
            return "[null]" != R2([e4]) || "{}" != R2({ a: e4 }) || "{}" != R2(Object(e4));
          })), "JSON", { stringify: function(e4) {
            for (var t3, n3, a3 = [e4], r3 = 1; arguments.length > r3; )
              a3.push(arguments[r3++]);
            if (n3 = t3 = a3[1], (g2(t3) || void 0 !== e4) && !J2(e4))
              return m2(t3) || (t3 = function(e5, t4) {
                if ("function" == typeof n3 && (t4 = n3.call(this, e5, t4)), !J2(t4))
                  return t4;
              }), a3[1] = t3, R2.apply(I2, a3);
          } }), D2.prototype[B2] || n2(6)(D2.prototype, B2, D2.prototype.valueOf), f2(D2, "Symbol"), f2(Math, "Math", true), f2(a2.JSON, "JSON", true);
        }, function(e3, t2, n2) {
          var a2 = n2(17)("meta"), r2 = n2(11), o2 = n2(5), i2 = n2(7).f, s2 = 0, c2 = Object.isExtensible || function() {
            return true;
          }, l2 = !n2(8)(function() {
            return c2(Object.preventExtensions({}));
          }), u2 = function(e4) {
            i2(e4, a2, { value: { i: "O" + ++s2, w: {} } });
          }, f2 = e3.exports = { KEY: a2, NEED: false, fastKey: function(e4, t3) {
            if (!r2(e4))
              return "symbol" == typeof e4 ? e4 : ("string" == typeof e4 ? "S" : "P") + e4;
            if (!o2(e4, a2)) {
              if (!c2(e4))
                return "F";
              if (!t3)
                return "E";
              u2(e4);
            }
            return e4[a2].i;
          }, getWeak: function(e4, t3) {
            if (!o2(e4, a2)) {
              if (!c2(e4))
                return true;
              if (!t3)
                return false;
              u2(e4);
            }
            return e4[a2].w;
          }, onFreeze: function(e4) {
            return l2 && f2.NEED && c2(e4) && !o2(e4, a2) && u2(e4), e4;
          } };
        }, function(e3, t2, n2) {
          var a2 = n2(13), r2 = n2(32), o2 = n2(19);
          e3.exports = function(e4) {
            var t3 = a2(e4), n3 = r2.f;
            if (n3)
              for (var i2, s2 = n3(e4), c2 = o2.f, l2 = 0; s2.length > l2; )
                c2.call(e4, i2 = s2[l2++]) && t3.push(i2);
            return t3;
          };
        }, function(e3, t2, n2) {
          var a2 = n2(24);
          e3.exports = Array.isArray || function(e4) {
            return "Array" == a2(e4);
          };
        }, function(e3, t2, n2) {
          var a2 = n2(9), r2 = n2(41).f, o2 = {}.toString, i2 = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
          e3.exports.f = function(e4) {
            return i2 && "[object Window]" == o2.call(e4) ? function(e5) {
              try {
                return r2(e5);
              } catch (e6) {
                return i2.slice();
              }
            }(e4) : r2(a2(e4));
          };
        }, function(e3, t2, n2) {
          var a2 = n2(19), r2 = n2(16), o2 = n2(9), i2 = n2(23), s2 = n2(5), c2 = n2(35), l2 = Object.getOwnPropertyDescriptor;
          t2.f = n2(4) ? l2 : function(e4, t3) {
            if (e4 = o2(e4), t3 = i2(t3, true), c2)
              try {
                return l2(e4, t3);
              } catch (e5) {
              }
            if (s2(e4, t3))
              return r2(!a2.f.call(e4, t3), e4[t3]);
          };
        }, function(e3, t2) {
        }, function(e3, t2, n2) {
          n2(31)("asyncIterator");
        }, function(e3, t2, n2) {
          n2(31)("observable");
        }, function(e3, t2, n2) {
          t2.__esModule = true;
          var a2, r2 = n2(77), o2 = (a2 = r2) && a2.__esModule ? a2 : { default: a2 };
          t2.default = o2.default || function(e4) {
            for (var t3 = 1; t3 < arguments.length; t3++) {
              var n3 = arguments[t3];
              for (var a3 in n3)
                Object.prototype.hasOwnProperty.call(n3, a3) && (e4[a3] = n3[a3]);
            }
            return e4;
          };
        }, function(e3, t2, n2) {
          e3.exports = { default: n2(78), __esModule: true };
        }, function(e3, t2, n2) {
          n2(79), e3.exports = n2(1).Object.assign;
        }, function(e3, t2, n2) {
          var a2 = n2(15);
          a2(a2.S + a2.F, "Object", { assign: n2(80) });
        }, function(e3, t2, n2) {
          var a2 = n2(4), r2 = n2(13), o2 = n2(32), i2 = n2(19), s2 = n2(18), c2 = n2(40), l2 = Object.assign;
          e3.exports = !l2 || n2(8)(function() {
            var e4 = {}, t3 = {}, n3 = Symbol(), a3 = "abcdefghijklmnopqrst";
            return e4[n3] = 7, a3.split("").forEach(function(e5) {
              t3[e5] = e5;
            }), 7 != l2({}, e4)[n3] || Object.keys(l2({}, t3)).join("") != a3;
          }) ? function(e4, t3) {
            for (var n3 = s2(e4), l3 = arguments.length, u2 = 1, f2 = o2.f, p2 = i2.f; l3 > u2; )
              for (var d2, b2 = c2(arguments[u2++]), h2 = f2 ? r2(b2).concat(f2(b2)) : r2(b2), v2 = h2.length, m2 = 0; v2 > m2; )
                d2 = h2[m2++], a2 && !p2.call(b2, d2) || (n3[d2] = b2[d2]);
            return n3;
          } : l2;
        }, function(e3, t2, n2) {
          t2.__esModule = true;
          var a2 = o2(n2(82)), r2 = o2(n2(85));
          function o2(e4) {
            return e4 && e4.__esModule ? e4 : { default: e4 };
          }
          t2.default = function(e4, t3) {
            if (Array.isArray(e4))
              return e4;
            if ((0, a2.default)(Object(e4)))
              return function(e5, t4) {
                var n3 = [], a3 = true, o3 = false, i2 = void 0;
                try {
                  for (var s2, c2 = (0, r2.default)(e5); !(a3 = (s2 = c2.next()).done) && (n3.push(s2.value), !t4 || n3.length !== t4); a3 = true)
                    ;
                } catch (e6) {
                  o3 = true, i2 = e6;
                } finally {
                  try {
                    !a3 && c2.return && c2.return();
                  } finally {
                    if (o3)
                      throw i2;
                  }
                }
                return n3;
              }(e4, t3);
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          };
        }, function(e3, t2, n2) {
          e3.exports = { default: n2(83), __esModule: true };
        }, function(e3, t2, n2) {
          n2(29), n2(20), e3.exports = n2(84);
        }, function(e3, t2, n2) {
          var a2 = n2(42), r2 = n2(2)("iterator"), o2 = n2(12);
          e3.exports = n2(1).isIterable = function(e4) {
            var t3 = Object(e4);
            return void 0 !== t3[r2] || "@@iterator" in t3 || o2.hasOwnProperty(a2(t3));
          };
        }, function(e3, t2, n2) {
          e3.exports = { default: n2(86), __esModule: true };
        }, function(e3, t2, n2) {
          n2(29), n2(20), e3.exports = n2(87);
        }, function(e3, t2, n2) {
          var a2 = n2(10), r2 = n2(88);
          e3.exports = n2(1).getIterator = function(e4) {
            var t3 = r2(e4);
            if ("function" != typeof t3)
              throw TypeError(e4 + " is not iterable!");
            return a2(t3.call(e4));
          };
        }, function(e3, t2, n2) {
          var a2 = n2(42), r2 = n2(2)("iterator"), o2 = n2(12);
          e3.exports = n2(1).getIteratorMethod = function(e4) {
            if (null != e4)
              return e4[r2] || e4["@@iterator"] || o2[a2(e4)];
          };
        }, function(e3, t2, n2) {
          e3.exports = { default: n2(90), __esModule: true };
        }, function(e3, t2, n2) {
          n2(91), e3.exports = n2(1).Object.keys;
        }, function(e3, t2, n2) {
          var a2 = n2(18), r2 = n2(13);
          n2(92)("keys", function() {
            return function(e4) {
              return r2(a2(e4));
            };
          });
        }, function(e3, t2, n2) {
          var a2 = n2(15), r2 = n2(1), o2 = n2(8);
          e3.exports = function(e4, t3) {
            var n3 = (r2.Object || {})[e4] || Object[e4], i2 = {};
            i2[e4] = t3(n3), a2(a2.S + a2.F * o2(function() {
              n3(1);
            }), "Object", i2);
          };
        }, function(e3, t2, n2) {
          (function(t3) {
            var n3 = [["ary", 128], ["bind", 1], ["bindKey", 2], ["curry", 8], ["curryRight", 16], ["flip", 512], ["partial", 32], ["partialRight", 64], ["rearg", 256]], a2 = /^\s+|\s+$/g, r2 = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, o2 = /\{\n\/\* \[wrapped with (.+)\] \*/, i2 = /,? & /, s2 = /^[-+]0x[0-9a-f]+$/i, c2 = /^0b[01]+$/i, l2 = /^\[object .+?Constructor\]$/, u2 = /^0o[0-7]+$/i, f2 = /^(?:0|[1-9]\d*)$/, p2 = parseInt, d2 = "object" == typeof t3 && t3 && t3.Object === Object && t3, b2 = "object" == typeof self && self && self.Object === Object && self, h2 = d2 || b2 || Function("return this")();
            function v2(e4, t4, n4) {
              switch (n4.length) {
                case 0:
                  return e4.call(t4);
                case 1:
                  return e4.call(t4, n4[0]);
                case 2:
                  return e4.call(t4, n4[0], n4[1]);
                case 3:
                  return e4.call(t4, n4[0], n4[1], n4[2]);
              }
              return e4.apply(t4, n4);
            }
            function m2(e4, t4) {
              return !!(e4 ? e4.length : 0) && function(e5, t5, n4) {
                if (t5 != t5)
                  return function(e6, t6, n5, a4) {
                    var r4 = e6.length, o3 = n5 + (a4 ? 1 : -1);
                    for (; a4 ? o3-- : ++o3 < r4; )
                      if (t6(e6[o3], o3, e6))
                        return o3;
                    return -1;
                  }(e5, y2, n4);
                var a3 = n4 - 1, r3 = e5.length;
                for (; ++a3 < r3; )
                  if (e5[a3] === t5)
                    return a3;
                return -1;
              }(e4, t4, 0) > -1;
            }
            function y2(e4) {
              return e4 != e4;
            }
            function g2(e4, t4) {
              for (var n4 = e4.length, a3 = 0; n4--; )
                e4[n4] === t4 && a3++;
              return a3;
            }
            function E2(e4, t4) {
              for (var n4 = -1, a3 = e4.length, r3 = 0, o3 = []; ++n4 < a3; ) {
                var i3 = e4[n4];
                i3 !== t4 && "__lodash_placeholder__" !== i3 || (e4[n4] = "__lodash_placeholder__", o3[r3++] = n4);
              }
              return o3;
            }
            var j, x2, _2, k2 = Function.prototype, O2 = Object.prototype, C2 = h2["__core-js_shared__"], S2 = (j = /[^.]+$/.exec(C2 && C2.keys && C2.keys.IE_PROTO || "")) ? "Symbol(src)_1." + j : "", w2 = k2.toString, A2 = O2.hasOwnProperty, M2 = O2.toString, P2 = RegExp("^" + w2.call(A2).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), F2 = Object.create, D2 = Math.max, I2 = Math.min, R2 = (x2 = H2(Object, "defineProperty"), (_2 = H2.name) && _2.length > 2 ? x2 : void 0);
            function L2(e4) {
              return X2(e4) ? F2(e4) : {};
            }
            function B2(e4) {
              return !(!X2(e4) || function(e5) {
                return !!S2 && S2 in e5;
              }(e4)) && (function(e5) {
                var t4 = X2(e5) ? M2.call(e5) : "";
                return "[object Function]" == t4 || "[object GeneratorFunction]" == t4;
              }(e4) || function(e5) {
                var t4 = false;
                if (null != e5 && "function" != typeof e5.toString)
                  try {
                    t4 = !!(e5 + "");
                  } catch (e6) {
                  }
                return t4;
              }(e4) ? P2 : l2).test(function(e5) {
                if (null != e5) {
                  try {
                    return w2.call(e5);
                  } catch (e6) {
                  }
                  try {
                    return e5 + "";
                  } catch (e6) {
                  }
                }
                return "";
              }(e4));
            }
            function N2(e4, t4, n4, a3) {
              for (var r3 = -1, o3 = e4.length, i3 = n4.length, s3 = -1, c3 = t4.length, l3 = D2(o3 - i3, 0), u3 = Array(c3 + l3), f3 = !a3; ++s3 < c3; )
                u3[s3] = t4[s3];
              for (; ++r3 < i3; )
                (f3 || r3 < o3) && (u3[n4[r3]] = e4[r3]);
              for (; l3--; )
                u3[s3++] = e4[r3++];
              return u3;
            }
            function z2(e4, t4, n4, a3) {
              for (var r3 = -1, o3 = e4.length, i3 = -1, s3 = n4.length, c3 = -1, l3 = t4.length, u3 = D2(o3 - s3, 0), f3 = Array(u3 + l3), p3 = !a3; ++r3 < u3; )
                f3[r3] = e4[r3];
              for (var d3 = r3; ++c3 < l3; )
                f3[d3 + c3] = t4[c3];
              for (; ++i3 < s3; )
                (p3 || r3 < o3) && (f3[d3 + n4[i3]] = e4[r3++]);
              return f3;
            }
            function T2(e4) {
              return function() {
                var t4 = arguments;
                switch (t4.length) {
                  case 0:
                    return new e4();
                  case 1:
                    return new e4(t4[0]);
                  case 2:
                    return new e4(t4[0], t4[1]);
                  case 3:
                    return new e4(t4[0], t4[1], t4[2]);
                  case 4:
                    return new e4(t4[0], t4[1], t4[2], t4[3]);
                  case 5:
                    return new e4(t4[0], t4[1], t4[2], t4[3], t4[4]);
                  case 6:
                    return new e4(t4[0], t4[1], t4[2], t4[3], t4[4], t4[5]);
                  case 7:
                    return new e4(t4[0], t4[1], t4[2], t4[3], t4[4], t4[5], t4[6]);
                }
                var n4 = L2(e4.prototype), a3 = e4.apply(n4, t4);
                return X2(a3) ? a3 : n4;
              };
            }
            function q2(e4, t4, n4, a3, r3, o3, i3, s3, c3, l3) {
              var u3 = 128 & t4, f3 = 1 & t4, p3 = 2 & t4, d3 = 24 & t4, b3 = 512 & t4, v3 = p3 ? void 0 : T2(e4);
              return function m3() {
                for (var y3 = arguments.length, j2 = Array(y3), x3 = y3; x3--; )
                  j2[x3] = arguments[x3];
                if (d3)
                  var _3 = W2(m3), k3 = g2(j2, _3);
                if (a3 && (j2 = N2(j2, a3, r3, d3)), o3 && (j2 = z2(j2, o3, i3, d3)), y3 -= k3, d3 && y3 < l3) {
                  var O3 = E2(j2, _3);
                  return V2(e4, t4, q2, m3.placeholder, n4, j2, O3, s3, c3, l3 - y3);
                }
                var C3 = f3 ? n4 : this, S3 = p3 ? C3[e4] : e4;
                return y3 = j2.length, s3 ? j2 = Y2(j2, s3) : b3 && y3 > 1 && j2.reverse(), u3 && c3 < y3 && (j2.length = c3), this && this !== h2 && this instanceof m3 && (S3 = v3 || T2(S3)), S3.apply(C3, j2);
              };
            }
            function V2(e4, t4, n4, a3, r3, o3, i3, s3, c3, l3) {
              var u3 = 8 & t4;
              t4 |= u3 ? 32 : 64, 4 & (t4 &= ~(u3 ? 64 : 32)) || (t4 &= -4);
              var f3 = n4(e4, t4, r3, u3 ? o3 : void 0, u3 ? i3 : void 0, u3 ? void 0 : o3, u3 ? void 0 : i3, s3, c3, l3);
              return f3.placeholder = a3, $2(f3, e4, t4);
            }
            function K2(e4, t4, n4, a3, r3, o3, i3, s3) {
              var c3 = 2 & t4;
              if (!c3 && "function" != typeof e4)
                throw new TypeError("Expected a function");
              var l3 = a3 ? a3.length : 0;
              if (l3 || (t4 &= -97, a3 = r3 = void 0), i3 = void 0 === i3 ? i3 : D2(te2(i3), 0), s3 = void 0 === s3 ? s3 : te2(s3), l3 -= r3 ? r3.length : 0, 64 & t4) {
                var u3 = a3, f3 = r3;
                a3 = r3 = void 0;
              }
              var p3 = [e4, t4, n4, a3, r3, u3, f3, o3, i3, s3];
              if (e4 = p3[0], t4 = p3[1], n4 = p3[2], a3 = p3[3], r3 = p3[4], !(s3 = p3[9] = null == p3[9] ? c3 ? 0 : e4.length : D2(p3[9] - l3, 0)) && 24 & t4 && (t4 &= -25), t4 && 1 != t4)
                d3 = 8 == t4 || 16 == t4 ? function(e5, t5, n5) {
                  var a4 = T2(e5);
                  return function r4() {
                    for (var o4 = arguments.length, i4 = Array(o4), s4 = o4, c4 = W2(r4); s4--; )
                      i4[s4] = arguments[s4];
                    var l4 = o4 < 3 && i4[0] !== c4 && i4[o4 - 1] !== c4 ? [] : E2(i4, c4);
                    if ((o4 -= l4.length) < n5)
                      return V2(e5, t5, q2, r4.placeholder, void 0, i4, l4, void 0, void 0, n5 - o4);
                    var u4 = this && this !== h2 && this instanceof r4 ? a4 : e5;
                    return v2(u4, this, i4);
                  };
                }(e4, t4, s3) : 32 != t4 && 33 != t4 || r3.length ? q2.apply(void 0, p3) : function(e5, t5, n5, a4) {
                  var r4 = 1 & t5, o4 = T2(e5);
                  return function t6() {
                    for (var i4 = -1, s4 = arguments.length, c4 = -1, l4 = a4.length, u4 = Array(l4 + s4), f4 = this && this !== h2 && this instanceof t6 ? o4 : e5; ++c4 < l4; )
                      u4[c4] = a4[c4];
                    for (; s4--; )
                      u4[c4++] = arguments[++i4];
                    return v2(f4, r4 ? n5 : this, u4);
                  };
                }(e4, t4, n4, a3);
              else
                var d3 = function(e5, t5, n5) {
                  var a4 = 1 & t5, r4 = T2(e5);
                  return function t6() {
                    var o4 = this && this !== h2 && this instanceof t6 ? r4 : e5;
                    return o4.apply(a4 ? n5 : this, arguments);
                  };
                }(e4, t4, n4);
              return $2(d3, e4, t4);
            }
            function W2(e4) {
              return e4.placeholder;
            }
            function H2(e4, t4) {
              var n4 = function(e5, t5) {
                return null == e5 ? void 0 : e5[t5];
              }(e4, t4);
              return B2(n4) ? n4 : void 0;
            }
            function U2(e4) {
              var t4 = e4.match(o2);
              return t4 ? t4[1].split(i2) : [];
            }
            function G2(e4, t4) {
              var n4 = t4.length, a3 = n4 - 1;
              return t4[a3] = (n4 > 1 ? "& " : "") + t4[a3], t4 = t4.join(n4 > 2 ? ", " : " "), e4.replace(r2, "{\n/* [wrapped with " + t4 + "] */\n");
            }
            function J2(e4, t4) {
              return !!(t4 = null == t4 ? 9007199254740991 : t4) && ("number" == typeof e4 || f2.test(e4)) && e4 > -1 && e4 % 1 == 0 && e4 < t4;
            }
            function Y2(e4, t4) {
              for (var n4 = e4.length, a3 = I2(t4.length, n4), r3 = function(e5, t5) {
                var n5 = -1, a4 = e5.length;
                for (t5 || (t5 = Array(a4)); ++n5 < a4; )
                  t5[n5] = e5[n5];
                return t5;
              }(e4); a3--; ) {
                var o3 = t4[a3];
                e4[a3] = J2(o3, n4) ? r3[o3] : void 0;
              }
              return e4;
            }
            var $2 = R2 ? function(e4, t4, n4) {
              var a3, r3 = t4 + "";
              return R2(e4, "toString", { configurable: true, enumerable: false, value: (a3 = G2(r3, Q2(U2(r3), n4)), function() {
                return a3;
              }) });
            } : function(e4) {
              return e4;
            };
            function Q2(e4, t4) {
              return function(e5, t5) {
                for (var n4 = -1, a3 = e5 ? e5.length : 0; ++n4 < a3 && false !== t5(e5[n4], n4, e5); )
                  ;
              }(n3, function(n4) {
                var a3 = "_." + n4[0];
                t4 & n4[1] && !m2(e4, a3) && e4.push(a3);
              }), e4.sort();
            }
            function Z2(e4, t4, n4) {
              var a3 = K2(e4, 8, void 0, void 0, void 0, void 0, void 0, t4 = n4 ? void 0 : t4);
              return a3.placeholder = Z2.placeholder, a3;
            }
            function X2(e4) {
              var t4 = typeof e4;
              return !!e4 && ("object" == t4 || "function" == t4);
            }
            function ee2(e4) {
              return e4 ? (e4 = function(e5) {
                if ("number" == typeof e5)
                  return e5;
                if (function(e6) {
                  return "symbol" == typeof e6 || function(e7) {
                    return !!e7 && "object" == typeof e7;
                  }(e6) && "[object Symbol]" == M2.call(e6);
                }(e5))
                  return NaN;
                if (X2(e5)) {
                  var t4 = "function" == typeof e5.valueOf ? e5.valueOf() : e5;
                  e5 = X2(t4) ? t4 + "" : t4;
                }
                if ("string" != typeof e5)
                  return 0 === e5 ? e5 : +e5;
                e5 = e5.replace(a2, "");
                var n4 = c2.test(e5);
                return n4 || u2.test(e5) ? p2(e5.slice(2), n4 ? 2 : 8) : s2.test(e5) ? NaN : +e5;
              }(e4)) === 1 / 0 || e4 === -1 / 0 ? 17976931348623157e292 * (e4 < 0 ? -1 : 1) : e4 == e4 ? e4 : 0 : 0 === e4 ? e4 : 0;
            }
            function te2(e4) {
              var t4 = ee2(e4), n4 = t4 % 1;
              return t4 == t4 ? n4 ? t4 - n4 : t4 : 0;
            }
            Z2.placeholder = {}, e3.exports = Z2;
          }).call(this, n2(43));
        }, function(e3, t2, n2) {
          function a2(e4) {
            return e4 && e4.__esModule ? e4.default : e4;
          }
          t2.__esModule = true;
          var r2 = n2(95);
          t2.threezerotwofour = a2(r2);
          var o2 = n2(96);
          t2.apathy = a2(o2);
          var i2 = n2(97);
          t2.ashes = a2(i2);
          var s2 = n2(98);
          t2.atelierDune = a2(s2);
          var c2 = n2(99);
          t2.atelierForest = a2(c2);
          var l2 = n2(100);
          t2.atelierHeath = a2(l2);
          var u2 = n2(101);
          t2.atelierLakeside = a2(u2);
          var f2 = n2(102);
          t2.atelierSeaside = a2(f2);
          var p2 = n2(103);
          t2.bespin = a2(p2);
          var d2 = n2(104);
          t2.brewer = a2(d2);
          var b2 = n2(105);
          t2.bright = a2(b2);
          var h2 = n2(106);
          t2.chalk = a2(h2);
          var v2 = n2(107);
          t2.codeschool = a2(v2);
          var m2 = n2(108);
          t2.colors = a2(m2);
          var y2 = n2(109);
          t2.default = a2(y2);
          var g2 = n2(110);
          t2.eighties = a2(g2);
          var E2 = n2(111);
          t2.embers = a2(E2);
          var j = n2(112);
          t2.flat = a2(j);
          var x2 = n2(113);
          t2.google = a2(x2);
          var _2 = n2(114);
          t2.grayscale = a2(_2);
          var k2 = n2(115);
          t2.greenscreen = a2(k2);
          var O2 = n2(116);
          t2.harmonic = a2(O2);
          var C2 = n2(117);
          t2.hopscotch = a2(C2);
          var S2 = n2(118);
          t2.isotope = a2(S2);
          var w2 = n2(119);
          t2.marrakesh = a2(w2);
          var A2 = n2(120);
          t2.mocha = a2(A2);
          var M2 = n2(121);
          t2.monokai = a2(M2);
          var P2 = n2(122);
          t2.ocean = a2(P2);
          var F2 = n2(123);
          t2.paraiso = a2(F2);
          var D2 = n2(124);
          t2.pop = a2(D2);
          var I2 = n2(125);
          t2.railscasts = a2(I2);
          var R2 = n2(126);
          t2.shapeshifter = a2(R2);
          var L2 = n2(127);
          t2.solarized = a2(L2);
          var B2 = n2(128);
          t2.summerfruit = a2(B2);
          var N2 = n2(129);
          t2.tomorrow = a2(N2);
          var z2 = n2(130);
          t2.tube = a2(z2);
          var T2 = n2(131);
          t2.twilight = a2(T2);
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "threezerotwofour", author: "jan t. sott (http://github.com/idleberg)", base00: "#090300", base01: "#3a3432", base02: "#4a4543", base03: "#5c5855", base04: "#807d7c", base05: "#a5a2a2", base06: "#d6d5d4", base07: "#f7f7f7", base08: "#db2d20", base09: "#e8bbd0", base0A: "#fded02", base0B: "#01a252", base0C: "#b5e4f4", base0D: "#01a0e4", base0E: "#a16a94", base0F: "#cdab53" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "apathy", author: "jannik siebert (https://github.com/janniks)", base00: "#031A16", base01: "#0B342D", base02: "#184E45", base03: "#2B685E", base04: "#5F9C92", base05: "#81B5AC", base06: "#A7CEC8", base07: "#D2E7E4", base08: "#3E9688", base09: "#3E7996", base0A: "#3E4C96", base0B: "#883E96", base0C: "#963E4C", base0D: "#96883E", base0E: "#4C963E", base0F: "#3E965B" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "ashes", author: "jannik siebert (https://github.com/janniks)", base00: "#1C2023", base01: "#393F45", base02: "#565E65", base03: "#747C84", base04: "#ADB3BA", base05: "#C7CCD1", base06: "#DFE2E5", base07: "#F3F4F5", base08: "#C7AE95", base09: "#C7C795", base0A: "#AEC795", base0B: "#95C7AE", base0C: "#95AEC7", base0D: "#AE95C7", base0E: "#C795AE", base0F: "#C79595" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "atelier dune", author: "bram de haan (http://atelierbram.github.io/syntax-highlighting/atelier-schemes/dune)", base00: "#20201d", base01: "#292824", base02: "#6e6b5e", base03: "#7d7a68", base04: "#999580", base05: "#a6a28c", base06: "#e8e4cf", base07: "#fefbec", base08: "#d73737", base09: "#b65611", base0A: "#cfb017", base0B: "#60ac39", base0C: "#1fad83", base0D: "#6684e1", base0E: "#b854d4", base0F: "#d43552" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "atelier forest", author: "bram de haan (http://atelierbram.github.io/syntax-highlighting/atelier-schemes/forest)", base00: "#1b1918", base01: "#2c2421", base02: "#68615e", base03: "#766e6b", base04: "#9c9491", base05: "#a8a19f", base06: "#e6e2e0", base07: "#f1efee", base08: "#f22c40", base09: "#df5320", base0A: "#d5911a", base0B: "#5ab738", base0C: "#00ad9c", base0D: "#407ee7", base0E: "#6666ea", base0F: "#c33ff3" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "atelier heath", author: "bram de haan (http://atelierbram.github.io/syntax-highlighting/atelier-schemes/heath)", base00: "#1b181b", base01: "#292329", base02: "#695d69", base03: "#776977", base04: "#9e8f9e", base05: "#ab9bab", base06: "#d8cad8", base07: "#f7f3f7", base08: "#ca402b", base09: "#a65926", base0A: "#bb8a35", base0B: "#379a37", base0C: "#159393", base0D: "#516aec", base0E: "#7b59c0", base0F: "#cc33cc" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "atelier lakeside", author: "bram de haan (http://atelierbram.github.io/syntax-highlighting/atelier-schemes/lakeside/)", base00: "#161b1d", base01: "#1f292e", base02: "#516d7b", base03: "#5a7b8c", base04: "#7195a8", base05: "#7ea2b4", base06: "#c1e4f6", base07: "#ebf8ff", base08: "#d22d72", base09: "#935c25", base0A: "#8a8a0f", base0B: "#568c3b", base0C: "#2d8f6f", base0D: "#257fad", base0E: "#5d5db1", base0F: "#b72dd2" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "atelier seaside", author: "bram de haan (http://atelierbram.github.io/syntax-highlighting/atelier-schemes/seaside/)", base00: "#131513", base01: "#242924", base02: "#5e6e5e", base03: "#687d68", base04: "#809980", base05: "#8ca68c", base06: "#cfe8cf", base07: "#f0fff0", base08: "#e6193c", base09: "#87711d", base0A: "#c3c322", base0B: "#29a329", base0C: "#1999b3", base0D: "#3d62f5", base0E: "#ad2bee", base0F: "#e619c3" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "bespin", author: "jan t. sott", base00: "#28211c", base01: "#36312e", base02: "#5e5d5c", base03: "#666666", base04: "#797977", base05: "#8a8986", base06: "#9d9b97", base07: "#baae9e", base08: "#cf6a4c", base09: "#cf7d34", base0A: "#f9ee98", base0B: "#54be0d", base0C: "#afc4db", base0D: "#5ea6ea", base0E: "#9b859d", base0F: "#937121" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "brewer", author: "timothée poisot (http://github.com/tpoisot)", base00: "#0c0d0e", base01: "#2e2f30", base02: "#515253", base03: "#737475", base04: "#959697", base05: "#b7b8b9", base06: "#dadbdc", base07: "#fcfdfe", base08: "#e31a1c", base09: "#e6550d", base0A: "#dca060", base0B: "#31a354", base0C: "#80b1d3", base0D: "#3182bd", base0E: "#756bb1", base0F: "#b15928" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "bright", author: "chris kempson (http://chriskempson.com)", base00: "#000000", base01: "#303030", base02: "#505050", base03: "#b0b0b0", base04: "#d0d0d0", base05: "#e0e0e0", base06: "#f5f5f5", base07: "#ffffff", base08: "#fb0120", base09: "#fc6d24", base0A: "#fda331", base0B: "#a1c659", base0C: "#76c7b7", base0D: "#6fb3d2", base0E: "#d381c3", base0F: "#be643c" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "chalk", author: "chris kempson (http://chriskempson.com)", base00: "#151515", base01: "#202020", base02: "#303030", base03: "#505050", base04: "#b0b0b0", base05: "#d0d0d0", base06: "#e0e0e0", base07: "#f5f5f5", base08: "#fb9fb1", base09: "#eda987", base0A: "#ddb26f", base0B: "#acc267", base0C: "#12cfc0", base0D: "#6fc2ef", base0E: "#e1a3ee", base0F: "#deaf8f" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "codeschool", author: "brettof86", base00: "#232c31", base01: "#1c3657", base02: "#2a343a", base03: "#3f4944", base04: "#84898c", base05: "#9ea7a6", base06: "#a7cfa3", base07: "#b5d8f6", base08: "#2a5491", base09: "#43820d", base0A: "#a03b1e", base0B: "#237986", base0C: "#b02f30", base0D: "#484d79", base0E: "#c59820", base0F: "#c98344" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "colors", author: "mrmrs (http://clrs.cc)", base00: "#111111", base01: "#333333", base02: "#555555", base03: "#777777", base04: "#999999", base05: "#bbbbbb", base06: "#dddddd", base07: "#ffffff", base08: "#ff4136", base09: "#ff851b", base0A: "#ffdc00", base0B: "#2ecc40", base0C: "#7fdbff", base0D: "#0074d9", base0E: "#b10dc9", base0F: "#85144b" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "default", author: "chris kempson (http://chriskempson.com)", base00: "#181818", base01: "#282828", base02: "#383838", base03: "#585858", base04: "#b8b8b8", base05: "#d8d8d8", base06: "#e8e8e8", base07: "#f8f8f8", base08: "#ab4642", base09: "#dc9656", base0A: "#f7ca88", base0B: "#a1b56c", base0C: "#86c1b9", base0D: "#7cafc2", base0E: "#ba8baf", base0F: "#a16946" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "eighties", author: "chris kempson (http://chriskempson.com)", base00: "#2d2d2d", base01: "#393939", base02: "#515151", base03: "#747369", base04: "#a09f93", base05: "#d3d0c8", base06: "#e8e6df", base07: "#f2f0ec", base08: "#f2777a", base09: "#f99157", base0A: "#ffcc66", base0B: "#99cc99", base0C: "#66cccc", base0D: "#6699cc", base0E: "#cc99cc", base0F: "#d27b53" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "embers", author: "jannik siebert (https://github.com/janniks)", base00: "#16130F", base01: "#2C2620", base02: "#433B32", base03: "#5A5047", base04: "#8A8075", base05: "#A39A90", base06: "#BEB6AE", base07: "#DBD6D1", base08: "#826D57", base09: "#828257", base0A: "#6D8257", base0B: "#57826D", base0C: "#576D82", base0D: "#6D5782", base0E: "#82576D", base0F: "#825757" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "flat", author: "chris kempson (http://chriskempson.com)", base00: "#2C3E50", base01: "#34495E", base02: "#7F8C8D", base03: "#95A5A6", base04: "#BDC3C7", base05: "#e0e0e0", base06: "#f5f5f5", base07: "#ECF0F1", base08: "#E74C3C", base09: "#E67E22", base0A: "#F1C40F", base0B: "#2ECC71", base0C: "#1ABC9C", base0D: "#3498DB", base0E: "#9B59B6", base0F: "#be643c" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "google", author: "seth wright (http://sethawright.com)", base00: "#1d1f21", base01: "#282a2e", base02: "#373b41", base03: "#969896", base04: "#b4b7b4", base05: "#c5c8c6", base06: "#e0e0e0", base07: "#ffffff", base08: "#CC342B", base09: "#F96A38", base0A: "#FBA922", base0B: "#198844", base0C: "#3971ED", base0D: "#3971ED", base0E: "#A36AC7", base0F: "#3971ED" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "grayscale", author: "alexandre gavioli (https://github.com/alexx2/)", base00: "#101010", base01: "#252525", base02: "#464646", base03: "#525252", base04: "#ababab", base05: "#b9b9b9", base06: "#e3e3e3", base07: "#f7f7f7", base08: "#7c7c7c", base09: "#999999", base0A: "#a0a0a0", base0B: "#8e8e8e", base0C: "#868686", base0D: "#686868", base0E: "#747474", base0F: "#5e5e5e" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "green screen", author: "chris kempson (http://chriskempson.com)", base00: "#001100", base01: "#003300", base02: "#005500", base03: "#007700", base04: "#009900", base05: "#00bb00", base06: "#00dd00", base07: "#00ff00", base08: "#007700", base09: "#009900", base0A: "#007700", base0B: "#00bb00", base0C: "#005500", base0D: "#009900", base0E: "#00bb00", base0F: "#005500" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "harmonic16", author: "jannik siebert (https://github.com/janniks)", base00: "#0b1c2c", base01: "#223b54", base02: "#405c79", base03: "#627e99", base04: "#aabcce", base05: "#cbd6e2", base06: "#e5ebf1", base07: "#f7f9fb", base08: "#bf8b56", base09: "#bfbf56", base0A: "#8bbf56", base0B: "#56bf8b", base0C: "#568bbf", base0D: "#8b56bf", base0E: "#bf568b", base0F: "#bf5656" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "hopscotch", author: "jan t. sott", base00: "#322931", base01: "#433b42", base02: "#5c545b", base03: "#797379", base04: "#989498", base05: "#b9b5b8", base06: "#d5d3d5", base07: "#ffffff", base08: "#dd464c", base09: "#fd8b19", base0A: "#fdcc59", base0B: "#8fc13e", base0C: "#149b93", base0D: "#1290bf", base0E: "#c85e7c", base0F: "#b33508" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "isotope", author: "jan t. sott", base00: "#000000", base01: "#404040", base02: "#606060", base03: "#808080", base04: "#c0c0c0", base05: "#d0d0d0", base06: "#e0e0e0", base07: "#ffffff", base08: "#ff0000", base09: "#ff9900", base0A: "#ff0099", base0B: "#33ff00", base0C: "#00ffff", base0D: "#0066ff", base0E: "#cc00ff", base0F: "#3300ff" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "marrakesh", author: "alexandre gavioli (http://github.com/alexx2/)", base00: "#201602", base01: "#302e00", base02: "#5f5b17", base03: "#6c6823", base04: "#86813b", base05: "#948e48", base06: "#ccc37a", base07: "#faf0a5", base08: "#c35359", base09: "#b36144", base0A: "#a88339", base0B: "#18974e", base0C: "#75a738", base0D: "#477ca1", base0E: "#8868b3", base0F: "#b3588e" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "mocha", author: "chris kempson (http://chriskempson.com)", base00: "#3B3228", base01: "#534636", base02: "#645240", base03: "#7e705a", base04: "#b8afad", base05: "#d0c8c6", base06: "#e9e1dd", base07: "#f5eeeb", base08: "#cb6077", base09: "#d28b71", base0A: "#f4bc87", base0B: "#beb55b", base0C: "#7bbda4", base0D: "#8ab3b5", base0E: "#a89bb9", base0F: "#bb9584" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "monokai", author: "wimer hazenberg (http://www.monokai.nl)", base00: "#272822", base01: "#383830", base02: "#49483e", base03: "#75715e", base04: "#a59f85", base05: "#f8f8f2", base06: "#f5f4f1", base07: "#f9f8f5", base08: "#f92672", base09: "#fd971f", base0A: "#f4bf75", base0B: "#a6e22e", base0C: "#a1efe4", base0D: "#66d9ef", base0E: "#ae81ff", base0F: "#cc6633" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "ocean", author: "chris kempson (http://chriskempson.com)", base00: "#2b303b", base01: "#343d46", base02: "#4f5b66", base03: "#65737e", base04: "#a7adba", base05: "#c0c5ce", base06: "#dfe1e8", base07: "#eff1f5", base08: "#bf616a", base09: "#d08770", base0A: "#ebcb8b", base0B: "#a3be8c", base0C: "#96b5b4", base0D: "#8fa1b3", base0E: "#b48ead", base0F: "#ab7967" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "paraiso", author: "jan t. sott", base00: "#2f1e2e", base01: "#41323f", base02: "#4f424c", base03: "#776e71", base04: "#8d8687", base05: "#a39e9b", base06: "#b9b6b0", base07: "#e7e9db", base08: "#ef6155", base09: "#f99b15", base0A: "#fec418", base0B: "#48b685", base0C: "#5bc4bf", base0D: "#06b6ef", base0E: "#815ba4", base0F: "#e96ba8" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "pop", author: "chris kempson (http://chriskempson.com)", base00: "#000000", base01: "#202020", base02: "#303030", base03: "#505050", base04: "#b0b0b0", base05: "#d0d0d0", base06: "#e0e0e0", base07: "#ffffff", base08: "#eb008a", base09: "#f29333", base0A: "#f8ca12", base0B: "#37b349", base0C: "#00aabb", base0D: "#0e5a94", base0E: "#b31e8d", base0F: "#7a2d00" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "railscasts", author: "ryan bates (http://railscasts.com)", base00: "#2b2b2b", base01: "#272935", base02: "#3a4055", base03: "#5a647e", base04: "#d4cfc9", base05: "#e6e1dc", base06: "#f4f1ed", base07: "#f9f7f3", base08: "#da4939", base09: "#cc7833", base0A: "#ffc66d", base0B: "#a5c261", base0C: "#519f50", base0D: "#6d9cbe", base0E: "#b6b3eb", base0F: "#bc9458" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "shapeshifter", author: "tyler benziger (http://tybenz.com)", base00: "#000000", base01: "#040404", base02: "#102015", base03: "#343434", base04: "#555555", base05: "#ababab", base06: "#e0e0e0", base07: "#f9f9f9", base08: "#e92f2f", base09: "#e09448", base0A: "#dddd13", base0B: "#0ed839", base0C: "#23edda", base0D: "#3b48e3", base0E: "#f996e2", base0F: "#69542d" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "solarized", author: "ethan schoonover (http://ethanschoonover.com/solarized)", base00: "#002b36", base01: "#073642", base02: "#586e75", base03: "#657b83", base04: "#839496", base05: "#93a1a1", base06: "#eee8d5", base07: "#fdf6e3", base08: "#dc322f", base09: "#cb4b16", base0A: "#b58900", base0B: "#859900", base0C: "#2aa198", base0D: "#268bd2", base0E: "#6c71c4", base0F: "#d33682" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "summerfruit", author: "christopher corley (http://cscorley.github.io/)", base00: "#151515", base01: "#202020", base02: "#303030", base03: "#505050", base04: "#B0B0B0", base05: "#D0D0D0", base06: "#E0E0E0", base07: "#FFFFFF", base08: "#FF0086", base09: "#FD8900", base0A: "#ABA800", base0B: "#00C918", base0C: "#1faaaa", base0D: "#3777E6", base0E: "#AD00A1", base0F: "#cc6633" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "tomorrow", author: "chris kempson (http://chriskempson.com)", base00: "#1d1f21", base01: "#282a2e", base02: "#373b41", base03: "#969896", base04: "#b4b7b4", base05: "#c5c8c6", base06: "#e0e0e0", base07: "#ffffff", base08: "#cc6666", base09: "#de935f", base0A: "#f0c674", base0B: "#b5bd68", base0C: "#8abeb7", base0D: "#81a2be", base0E: "#b294bb", base0F: "#a3685a" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "london tube", author: "jan t. sott", base00: "#231f20", base01: "#1c3f95", base02: "#5a5758", base03: "#737171", base04: "#959ca1", base05: "#d9d8d8", base06: "#e7e7e8", base07: "#ffffff", base08: "#ee2e24", base09: "#f386a1", base0A: "#ffd204", base0B: "#00853e", base0C: "#85cebc", base0D: "#009ddc", base0E: "#98005d", base0F: "#b06110" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          t2.__esModule = true, t2.default = { scheme: "twilight", author: "david hart (http://hart-dev.com)", base00: "#1e1e1e", base01: "#323537", base02: "#464b50", base03: "#5f5a60", base04: "#838184", base05: "#a7a7a7", base06: "#c3c3c3", base07: "#ffffff", base08: "#cf6a4c", base09: "#cda869", base0A: "#f9ee98", base0B: "#8f9d6a", base0C: "#afc4db", base0D: "#7587a6", base0E: "#9b859d", base0F: "#9b703f" }, e3.exports = t2.default;
        }, function(e3, t2, n2) {
          var a2 = n2(33);
          function r2(e4) {
            var t3 = Math.round(a2(e4, 0, 255)).toString(16);
            return 1 == t3.length ? "0" + t3 : t3;
          }
          e3.exports = function(e4) {
            var t3 = 4 === e4.length ? r2(255 * e4[3]) : "";
            return "#" + r2(e4[0]) + r2(e4[1]) + r2(e4[2]) + t3;
          };
        }, function(e3, t2, n2) {
          var a2 = n2(134), r2 = n2(135), o2 = n2(136), i2 = n2(137);
          var s2 = { "#": r2, hsl: function(e4) {
            var t3 = a2(e4), n3 = i2(t3);
            return 4 === t3.length && n3.push(t3[3]), n3;
          }, rgb: o2 };
          function c2(e4) {
            for (var t3 in s2)
              if (0 === e4.indexOf(t3))
                return s2[t3](e4);
          }
          c2.rgb = o2, c2.hsl = a2, c2.hex = r2, e3.exports = c2;
        }, function(e3, t2, n2) {
          var a2 = n2(44), r2 = n2(33);
          function o2(e4, t3) {
            switch (e4 = parseFloat(e4), t3) {
              case 0:
                return r2(e4, 0, 360);
              case 1:
              case 2:
                return r2(e4, 0, 100);
              case 3:
                return r2(e4, 0, 1);
            }
          }
          e3.exports = function(e4) {
            return a2(e4).map(o2);
          };
        }, function(e3, t2) {
          e3.exports = function(e4) {
            4 !== e4.length && 5 !== e4.length || (e4 = function(e5) {
              for (var t4 = "#", n3 = 1; n3 < e5.length; n3++) {
                var a2 = e5.charAt(n3);
                t4 += a2 + a2;
              }
              return t4;
            }(e4));
            var t3 = [parseInt(e4.substring(1, 3), 16), parseInt(e4.substring(3, 5), 16), parseInt(e4.substring(5, 7), 16)];
            if (9 === e4.length) {
              var n2 = parseFloat((parseInt(e4.substring(7, 9), 16) / 255).toFixed(2));
              t3.push(n2);
            }
            return t3;
          };
        }, function(e3, t2, n2) {
          var a2 = n2(44), r2 = n2(33);
          function o2(e4, t3) {
            return t3 < 3 ? -1 != e4.indexOf("%") ? Math.round(255 * r2(parseInt(e4, 10), 0, 100) / 100) : r2(parseInt(e4, 10), 0, 255) : r2(parseFloat(e4), 0, 1);
          }
          e3.exports = function(e4) {
            return a2(e4).map(o2);
          };
        }, function(e3, t2) {
          e3.exports = function(e4) {
            var t3, n2, a2, r2, o2, i2 = e4[0] / 360, s2 = e4[1] / 100, c2 = e4[2] / 100;
            if (0 == s2)
              return [o2 = 255 * c2, o2, o2];
            t3 = 2 * c2 - (n2 = c2 < 0.5 ? c2 * (1 + s2) : c2 + s2 - c2 * s2), r2 = [0, 0, 0];
            for (var l2 = 0; l2 < 3; l2++)
              (a2 = i2 + 1 / 3 * -(l2 - 1)) < 0 && a2++, a2 > 1 && a2--, o2 = 6 * a2 < 1 ? t3 + 6 * (n2 - t3) * a2 : 2 * a2 < 1 ? n2 : 3 * a2 < 2 ? t3 + (n2 - t3) * (2 / 3 - a2) * 6 : t3, r2[l2] = 255 * o2;
            return r2;
          };
        }, function(e3, t2, n2) {
          (function(t3) {
            var n3 = "object" == typeof t3 && t3 && t3.Object === Object && t3, a2 = "object" == typeof self && self && self.Object === Object && self, r2 = n3 || a2 || Function("return this")();
            function o2(e4, t4, n4) {
              switch (n4.length) {
                case 0:
                  return e4.call(t4);
                case 1:
                  return e4.call(t4, n4[0]);
                case 2:
                  return e4.call(t4, n4[0], n4[1]);
                case 3:
                  return e4.call(t4, n4[0], n4[1], n4[2]);
              }
              return e4.apply(t4, n4);
            }
            function i2(e4, t4) {
              for (var n4 = -1, a3 = t4.length, r3 = e4.length; ++n4 < a3; )
                e4[r3 + n4] = t4[n4];
              return e4;
            }
            var s2 = Object.prototype, c2 = s2.hasOwnProperty, l2 = s2.toString, u2 = r2.Symbol, f2 = s2.propertyIsEnumerable, p2 = u2 ? u2.isConcatSpreadable : void 0, d2 = Math.max;
            function b2(e4) {
              return h2(e4) || function(e5) {
                return function(e6) {
                  return function(e7) {
                    return !!e7 && "object" == typeof e7;
                  }(e6) && function(e7) {
                    return null != e7 && function(e8) {
                      return "number" == typeof e8 && e8 > -1 && e8 % 1 == 0 && e8 <= 9007199254740991;
                    }(e7.length) && !function(e8) {
                      var t4 = function(e9) {
                        var t5 = typeof e9;
                        return !!e9 && ("object" == t5 || "function" == t5);
                      }(e8) ? l2.call(e8) : "";
                      return "[object Function]" == t4 || "[object GeneratorFunction]" == t4;
                    }(e7);
                  }(e6);
                }(e5) && c2.call(e5, "callee") && (!f2.call(e5, "callee") || "[object Arguments]" == l2.call(e5));
              }(e4) || !!(p2 && e4 && e4[p2]);
            }
            var h2 = Array.isArray;
            var v2, m2, y2, g2 = (m2 = function(e4) {
              var t4 = (e4 = function e5(t5, n5, a3, r3, o3) {
                var s3 = -1, c3 = t5.length;
                for (a3 || (a3 = b2), o3 || (o3 = []); ++s3 < c3; ) {
                  var l3 = t5[s3];
                  n5 > 0 && a3(l3) ? n5 > 1 ? e5(l3, n5 - 1, a3, r3, o3) : i2(o3, l3) : r3 || (o3[o3.length] = l3);
                }
                return o3;
              }(e4, 1)).length, n4 = t4;
              for (v2; n4--; )
                if ("function" != typeof e4[n4])
                  throw new TypeError("Expected a function");
              return function() {
                for (var n5 = 0, a3 = t4 ? e4[n5].apply(this, arguments) : arguments[0]; ++n5 < t4; )
                  a3 = e4[n5].call(this, a3);
                return a3;
              };
            }, y2 = d2(void 0 === y2 ? m2.length - 1 : y2, 0), function() {
              for (var e4 = arguments, t4 = -1, n4 = d2(e4.length - y2, 0), a3 = Array(n4); ++t4 < n4; )
                a3[t4] = e4[y2 + t4];
              t4 = -1;
              for (var r3 = Array(y2 + 1); ++t4 < y2; )
                r3[t4] = e4[t4];
              return r3[y2] = a3, o2(m2, this, r3);
            });
            e3.exports = g2;
          }).call(this, n2(43));
        }, function(e3, t2, n2) {
          Object.defineProperty(t2, "__esModule", { value: true }), t2.yuv2rgb = function(e4) {
            var t3, n3, a2, r2 = e4[0], o2 = e4[1], i2 = e4[2];
            return t3 = 1 * r2 + 0 * o2 + 1.13983 * i2, n3 = 1 * r2 + -0.39465 * o2 + -0.5806 * i2, a2 = 1 * r2 + 2.02311 * o2 + 0 * i2, t3 = Math.min(Math.max(0, t3), 1), n3 = Math.min(Math.max(0, n3), 1), a2 = Math.min(Math.max(0, a2), 1), [255 * t3, 255 * n3, 255 * a2];
          }, t2.rgb2yuv = function(e4) {
            var t3 = e4[0] / 255, n3 = e4[1] / 255, a2 = e4[2] / 255;
            return [0.299 * t3 + 0.587 * n3 + 0.114 * a2, -0.14713 * t3 + -0.28886 * n3 + 0.436 * a2, 0.615 * t3 + -0.51499 * n3 + -0.10001 * a2];
          };
        }, function(e3, t2, n2) {
          function a2(e4, t3, n3) {
            return t3 in e4 ? Object.defineProperty(e4, t3, { value: n3, enumerable: true, configurable: true, writable: true }) : e4[t3] = n3, e4;
          }
          var r2 = n2(141), o2 = function() {
            function e4() {
              a2(this, "_callbacks", void 0), a2(this, "_isDispatching", void 0), a2(this, "_isHandled", void 0), a2(this, "_isPending", void 0), a2(this, "_lastID", void 0), a2(this, "_pendingPayload", void 0), this._callbacks = {}, this._isDispatching = false, this._isHandled = {}, this._isPending = {}, this._lastID = 1;
            }
            var t3 = e4.prototype;
            return t3.register = function(e5) {
              var t4 = "ID_" + this._lastID++;
              return this._callbacks[t4] = e5, t4;
            }, t3.unregister = function(e5) {
              this._callbacks[e5] || r2(false), delete this._callbacks[e5];
            }, t3.waitFor = function(e5) {
              this._isDispatching || r2(false);
              for (var t4 = 0; t4 < e5.length; t4++) {
                var n3 = e5[t4];
                this._isPending[n3] ? this._isHandled[n3] || r2(false) : (this._callbacks[n3] || r2(false), this._invokeCallback(n3));
              }
            }, t3.dispatch = function(e5) {
              this._isDispatching && r2(false), this._startDispatching(e5);
              try {
                for (var t4 in this._callbacks)
                  this._isPending[t4] || this._invokeCallback(t4);
              } finally {
                this._stopDispatching();
              }
            }, t3.isDispatching = function() {
              return this._isDispatching;
            }, t3._invokeCallback = function(e5) {
              this._isPending[e5] = true, this._callbacks[e5](this._pendingPayload), this._isHandled[e5] = true;
            }, t3._startDispatching = function(e5) {
              for (var t4 in this._callbacks)
                this._isPending[t4] = false, this._isHandled[t4] = false;
              this._pendingPayload = e5, this._isDispatching = true;
            }, t3._stopDispatching = function() {
              delete this._pendingPayload, this._isDispatching = false;
            }, e4;
          }();
          e3.exports = o2;
        }, function(e3, t2, n2) {
          e3.exports = function(e4, t3) {
            for (var n3 = arguments.length, r2 = new Array(n3 > 2 ? n3 - 2 : 0), o2 = 2; o2 < n3; o2++)
              r2[o2 - 2] = arguments[o2];
            if (!e4) {
              var i2;
              if (void 0 === t3)
                i2 = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
              else {
                var s2 = 0;
                (i2 = new Error(t3.replace(/%s/g, function() {
                  return String(r2[s2++]);
                }))).name = "Invariant Violation";
              }
              throw i2.framesToPop = 1, i2;
            }
          };
        }, function(e3, t2, n2) {
          function a2(e4, t3, n3) {
            return t3 in e4 ? Object.defineProperty(e4, t3, { value: n3, enumerable: true, configurable: true, writable: true }) : e4[t3] = n3, e4;
          }
          function r2(e4, t3) {
            var n3 = Object.keys(e4);
            if (Object.getOwnPropertySymbols) {
              var a3 = Object.getOwnPropertySymbols(e4);
              t3 && (a3 = a3.filter(function(t4) {
                return Object.getOwnPropertyDescriptor(e4, t4).enumerable;
              })), n3.push.apply(n3, a3);
            }
            return n3;
          }
          function o2(e4) {
            for (var t3 = 1; t3 < arguments.length; t3++) {
              var n3 = null != arguments[t3] ? arguments[t3] : {};
              t3 % 2 ? r2(Object(n3), true).forEach(function(t4) {
                a2(e4, t4, n3[t4]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(n3)) : r2(Object(n3)).forEach(function(t4) {
                Object.defineProperty(e4, t4, Object.getOwnPropertyDescriptor(n3, t4));
              });
            }
            return e4;
          }
          function i2(e4, t3) {
            if (!(e4 instanceof t3))
              throw new TypeError("Cannot call a class as a function");
          }
          function s2(e4, t3) {
            for (var n3 = 0; n3 < t3.length; n3++) {
              var a3 = t3[n3];
              a3.enumerable = a3.enumerable || false, a3.configurable = true, "value" in a3 && (a3.writable = true), Object.defineProperty(e4, a3.key, a3);
            }
          }
          function c2(e4, t3, n3) {
            return t3 && s2(e4.prototype, t3), n3 && s2(e4, n3), e4;
          }
          function l2(e4, t3) {
            return (l2 = Object.setPrototypeOf || function(e5, t4) {
              return e5.__proto__ = t4, e5;
            })(e4, t3);
          }
          function u2(e4, t3) {
            if ("function" != typeof t3 && null !== t3)
              throw new TypeError("Super expression must either be null or a function");
            e4.prototype = Object.create(t3 && t3.prototype, { constructor: { value: e4, writable: true, configurable: true } }), t3 && l2(e4, t3);
          }
          function f2(e4) {
            return (f2 = Object.setPrototypeOf ? Object.getPrototypeOf : function(e5) {
              return e5.__proto__ || Object.getPrototypeOf(e5);
            })(e4);
          }
          function p2(e4) {
            return (p2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
              return typeof e5;
            } : function(e5) {
              return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
            })(e4);
          }
          function d2(e4) {
            if (void 0 === e4)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e4;
          }
          function b2(e4, t3) {
            return !t3 || "object" !== p2(t3) && "function" != typeof t3 ? d2(e4) : t3;
          }
          function h2(e4) {
            var t3 = function() {
              if ("undefined" == typeof Reflect || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if ("function" == typeof Proxy)
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (e5) {
                return false;
              }
            }();
            return function() {
              var n3, a3 = f2(e4);
              if (t3) {
                var r3 = f2(this).constructor;
                n3 = Reflect.construct(a3, arguments, r3);
              } else
                n3 = a3.apply(this, arguments);
              return b2(this, n3);
            };
          }
          n2.r(t2);
          var v2 = n2(0), m2 = n2.n(v2);
          function y2() {
            var e4 = this.constructor.getDerivedStateFromProps(this.props, this.state);
            null != e4 && this.setState(e4);
          }
          function g2(e4) {
            this.setState((function(t3) {
              var n3 = this.constructor.getDerivedStateFromProps(e4, t3);
              return null != n3 ? n3 : null;
            }).bind(this));
          }
          function E2(e4, t3) {
            try {
              var n3 = this.props, a3 = this.state;
              this.props = e4, this.state = t3, this.__reactInternalSnapshotFlag = true, this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(n3, a3);
            } finally {
              this.props = n3, this.state = a3;
            }
          }
          function j(e4) {
            var t3 = e4.prototype;
            if (!t3 || !t3.isReactComponent)
              throw new Error("Can only polyfill class components");
            if ("function" != typeof e4.getDerivedStateFromProps && "function" != typeof t3.getSnapshotBeforeUpdate)
              return e4;
            var n3 = null, a3 = null, r3 = null;
            if ("function" == typeof t3.componentWillMount ? n3 = "componentWillMount" : "function" == typeof t3.UNSAFE_componentWillMount && (n3 = "UNSAFE_componentWillMount"), "function" == typeof t3.componentWillReceiveProps ? a3 = "componentWillReceiveProps" : "function" == typeof t3.UNSAFE_componentWillReceiveProps && (a3 = "UNSAFE_componentWillReceiveProps"), "function" == typeof t3.componentWillUpdate ? r3 = "componentWillUpdate" : "function" == typeof t3.UNSAFE_componentWillUpdate && (r3 = "UNSAFE_componentWillUpdate"), null !== n3 || null !== a3 || null !== r3) {
              var o3 = e4.displayName || e4.name, i3 = "function" == typeof e4.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
              throw Error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n" + o3 + " uses " + i3 + " but also contains the following legacy lifecycles:" + (null !== n3 ? "\n  " + n3 : "") + (null !== a3 ? "\n  " + a3 : "") + (null !== r3 ? "\n  " + r3 : "") + "\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://fb.me/react-async-component-lifecycle-hooks");
            }
            if ("function" == typeof e4.getDerivedStateFromProps && (t3.componentWillMount = y2, t3.componentWillReceiveProps = g2), "function" == typeof t3.getSnapshotBeforeUpdate) {
              if ("function" != typeof t3.componentDidUpdate)
                throw new Error("Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype");
              t3.componentWillUpdate = E2;
              var s3 = t3.componentDidUpdate;
              t3.componentDidUpdate = function(e5, t4, n4) {
                var a4 = this.__reactInternalSnapshotFlag ? this.__reactInternalSnapshot : n4;
                s3.call(this, e5, t4, a4);
              };
            }
            return e4;
          }
          function x2(e4, t3) {
            if (null == e4)
              return {};
            var n3, a3, r3 = function(e5, t4) {
              if (null == e5)
                return {};
              var n4, a4, r4 = {}, o4 = Object.keys(e5);
              for (a4 = 0; a4 < o4.length; a4++)
                n4 = o4[a4], t4.indexOf(n4) >= 0 || (r4[n4] = e5[n4]);
              return r4;
            }(e4, t3);
            if (Object.getOwnPropertySymbols) {
              var o3 = Object.getOwnPropertySymbols(e4);
              for (a3 = 0; a3 < o3.length; a3++)
                n3 = o3[a3], t3.indexOf(n3) >= 0 || Object.prototype.propertyIsEnumerable.call(e4, n3) && (r3[n3] = e4[n3]);
            }
            return r3;
          }
          function _2(e4) {
            var t3 = function(e5) {
              return {}.toString.call(e5).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
            }(e4);
            return "number" === t3 && (t3 = isNaN(e4) ? "nan" : (0 | e4) != e4 ? "float" : "integer"), t3;
          }
          y2.__suppressDeprecationWarning = true, g2.__suppressDeprecationWarning = true, E2.__suppressDeprecationWarning = true;
          var k2 = { scheme: "rjv-default", author: "mac gainor", base00: "rgba(0, 0, 0, 0)", base01: "rgb(245, 245, 245)", base02: "rgb(235, 235, 235)", base03: "#93a1a1", base04: "rgba(0, 0, 0, 0.3)", base05: "#586e75", base06: "#073642", base07: "#002b36", base08: "#d33682", base09: "#cb4b16", base0A: "#dc322f", base0B: "#859900", base0C: "#6c71c4", base0D: "#586e75", base0E: "#2aa198", base0F: "#268bd2" }, O2 = { scheme: "rjv-grey", author: "mac gainor", base00: "rgba(1, 1, 1, 0)", base01: "rgba(1, 1, 1, 0.1)", base02: "rgba(0, 0, 0, 0.2)", base03: "rgba(1, 1, 1, 0.3)", base04: "rgba(0, 0, 0, 0.4)", base05: "rgba(1, 1, 1, 0.5)", base06: "rgba(1, 1, 1, 0.6)", base07: "rgba(1, 1, 1, 0.7)", base08: "rgba(1, 1, 1, 0.8)", base09: "rgba(1, 1, 1, 0.8)", base0A: "rgba(1, 1, 1, 0.8)", base0B: "rgba(1, 1, 1, 0.8)", base0C: "rgba(1, 1, 1, 0.8)", base0D: "rgba(1, 1, 1, 0.8)", base0E: "rgba(1, 1, 1, 0.8)", base0F: "rgba(1, 1, 1, 0.8)" }, C2 = { white: "#fff", black: "#000", transparent: "rgba(1, 1, 1, 0)", globalFontFamily: "monospace", globalCursor: "default", indentBlockWidth: "5px", braceFontWeight: "bold", braceCursor: "pointer", ellipsisFontSize: "18px", ellipsisLineHeight: "10px", ellipsisCursor: "pointer", keyMargin: "0px 5px", keyLetterSpacing: "0.5px", keyFontStyle: "none", keyBorderRadius: "3px", keyColonWeight: "bold", keyVerticalAlign: "top", keyOpacity: "0.85", keyOpacityHover: "1", keyValPaddingTop: "3px", keyValPaddingBottom: "3px", keyValPaddingRight: "5px", keyValBorderLeft: "1px solid", keyValBorderHover: "2px solid", keyValPaddingHover: "3px 5px 3px 4px", pushedContentMarginLeft: "6px", variableValuePaddingRight: "6px", nullFontSize: "11px", nullFontWeight: "bold", nullPadding: "1px 2px", nullBorderRadius: "3px", nanFontSize: "11px", nanFontWeight: "bold", nanPadding: "1px 2px", nanBorderRadius: "3px", undefinedFontSize: "11px", undefinedFontWeight: "bold", undefinedPadding: "1px 2px", undefinedBorderRadius: "3px", dataTypeFontSize: "11px", dataTypeMarginRight: "4px", datatypeOpacity: "0.8", objectSizeBorderRadius: "3px", objectSizeFontStyle: "italic", objectSizeMargin: "0px 6px 0px 0px", clipboardCursor: "pointer", clipboardCheckMarginLeft: "-12px", metaDataPadding: "0px 0px 0px 10px", arrayGroupMetaPadding: "0px 0px 0px 4px", iconContainerWidth: "17px", tooltipPadding: "4px", editInputMinWidth: "130px", editInputBorderRadius: "2px", editInputPadding: "5px", editInputMarginRight: "4px", editInputFontFamily: "monospace", iconCursor: "pointer", iconFontSize: "15px", iconPaddingRight: "1px", dateValueMarginLeft: "2px", iconMarginRight: "3px", detectedRowPaddingTop: "3px", addKeyCoverBackground: "rgba(255, 255, 255, 0.3)", addKeyCoverPosition: "absolute", addKeyCoverPositionPx: "0px", addKeyModalWidth: "200px", addKeyModalMargin: "auto", addKeyModalPadding: "10px", addKeyModalRadius: "3px" }, S2 = n2(45), w2 = function(e4) {
            var t3 = function(e5) {
              return { backgroundColor: e5.base00, ellipsisColor: e5.base09, braceColor: e5.base07, expandedIcon: e5.base0D, collapsedIcon: e5.base0E, keyColor: e5.base07, arrayKeyColor: e5.base0C, objectSize: e5.base04, copyToClipboard: e5.base0F, copyToClipboardCheck: e5.base0D, objectBorder: e5.base02, dataTypes: { boolean: e5.base0E, date: e5.base0D, float: e5.base0B, function: e5.base0D, integer: e5.base0F, string: e5.base09, nan: e5.base08, null: e5.base0A, undefined: e5.base05, regexp: e5.base0A, background: e5.base02 }, editVariable: { editIcon: e5.base0E, cancelIcon: e5.base09, removeIcon: e5.base09, addIcon: e5.base0E, checkIcon: e5.base0E, background: e5.base01, color: e5.base0A, border: e5.base07 }, addKeyModal: { background: e5.base05, border: e5.base04, color: e5.base0A, labelColor: e5.base01 }, validationFailure: { background: e5.base09, iconColor: e5.base01, fontColor: e5.base01 } };
            }(e4);
            return { "app-container": { fontFamily: C2.globalFontFamily, cursor: C2.globalCursor, backgroundColor: t3.backgroundColor, position: "relative" }, ellipsis: { display: "inline-block", color: t3.ellipsisColor, fontSize: C2.ellipsisFontSize, lineHeight: C2.ellipsisLineHeight, cursor: C2.ellipsisCursor }, "brace-row": { display: "inline-block", cursor: "pointer" }, brace: { display: "inline-block", cursor: C2.braceCursor, fontWeight: C2.braceFontWeight, color: t3.braceColor }, "expanded-icon": { color: t3.expandedIcon }, "collapsed-icon": { color: t3.collapsedIcon }, colon: { display: "inline-block", margin: C2.keyMargin, color: t3.keyColor, verticalAlign: "top" }, objectKeyVal: function(e5, n3) {
              return { style: o2({ paddingTop: C2.keyValPaddingTop, paddingRight: C2.keyValPaddingRight, paddingBottom: C2.keyValPaddingBottom, borderLeft: C2.keyValBorderLeft + " " + t3.objectBorder, ":hover": { paddingLeft: n3.paddingLeft - 1 + "px", borderLeft: C2.keyValBorderHover + " " + t3.objectBorder } }, n3) };
            }, "object-key-val-no-border": { padding: C2.keyValPadding }, "pushed-content": { marginLeft: C2.pushedContentMarginLeft }, variableValue: function(e5, t4) {
              return { style: o2({ display: "inline-block", paddingRight: C2.variableValuePaddingRight, position: "relative" }, t4) };
            }, "object-name": { display: "inline-block", color: t3.keyColor, letterSpacing: C2.keyLetterSpacing, fontStyle: C2.keyFontStyle, verticalAlign: C2.keyVerticalAlign, opacity: C2.keyOpacity, ":hover": { opacity: C2.keyOpacityHover } }, "array-key": { display: "inline-block", color: t3.arrayKeyColor, letterSpacing: C2.keyLetterSpacing, fontStyle: C2.keyFontStyle, verticalAlign: C2.keyVerticalAlign, opacity: C2.keyOpacity, ":hover": { opacity: C2.keyOpacityHover } }, "object-size": { color: t3.objectSize, borderRadius: C2.objectSizeBorderRadius, fontStyle: C2.objectSizeFontStyle, margin: C2.objectSizeMargin, cursor: "default" }, "data-type-label": { fontSize: C2.dataTypeFontSize, marginRight: C2.dataTypeMarginRight, opacity: C2.datatypeOpacity }, boolean: { display: "inline-block", color: t3.dataTypes.boolean }, date: { display: "inline-block", color: t3.dataTypes.date }, "date-value": { marginLeft: C2.dateValueMarginLeft }, float: { display: "inline-block", color: t3.dataTypes.float }, function: { display: "inline-block", color: t3.dataTypes.function, cursor: "pointer", whiteSpace: "pre-line" }, "function-value": { fontStyle: "italic" }, integer: { display: "inline-block", color: t3.dataTypes.integer }, string: { display: "inline-block", color: t3.dataTypes.string }, nan: { display: "inline-block", color: t3.dataTypes.nan, fontSize: C2.nanFontSize, fontWeight: C2.nanFontWeight, backgroundColor: t3.dataTypes.background, padding: C2.nanPadding, borderRadius: C2.nanBorderRadius }, null: { display: "inline-block", color: t3.dataTypes.null, fontSize: C2.nullFontSize, fontWeight: C2.nullFontWeight, backgroundColor: t3.dataTypes.background, padding: C2.nullPadding, borderRadius: C2.nullBorderRadius }, undefined: { display: "inline-block", color: t3.dataTypes.undefined, fontSize: C2.undefinedFontSize, padding: C2.undefinedPadding, borderRadius: C2.undefinedBorderRadius, backgroundColor: t3.dataTypes.background }, regexp: { display: "inline-block", color: t3.dataTypes.regexp }, "copy-to-clipboard": { cursor: C2.clipboardCursor }, "copy-icon": { color: t3.copyToClipboard, fontSize: C2.iconFontSize, marginRight: C2.iconMarginRight, verticalAlign: "top" }, "copy-icon-copied": { color: t3.copyToClipboardCheck, marginLeft: C2.clipboardCheckMarginLeft }, "array-group-meta-data": { display: "inline-block", padding: C2.arrayGroupMetaPadding }, "object-meta-data": { display: "inline-block", padding: C2.metaDataPadding }, "icon-container": { display: "inline-block", width: C2.iconContainerWidth }, tooltip: { padding: C2.tooltipPadding }, removeVarIcon: { verticalAlign: "top", display: "inline-block", color: t3.editVariable.removeIcon, cursor: C2.iconCursor, fontSize: C2.iconFontSize, marginRight: C2.iconMarginRight }, addVarIcon: { verticalAlign: "top", display: "inline-block", color: t3.editVariable.addIcon, cursor: C2.iconCursor, fontSize: C2.iconFontSize, marginRight: C2.iconMarginRight }, editVarIcon: { verticalAlign: "top", display: "inline-block", color: t3.editVariable.editIcon, cursor: C2.iconCursor, fontSize: C2.iconFontSize, marginRight: C2.iconMarginRight }, "edit-icon-container": { display: "inline-block", verticalAlign: "top" }, "check-icon": { display: "inline-block", cursor: C2.iconCursor, color: t3.editVariable.checkIcon, fontSize: C2.iconFontSize, paddingRight: C2.iconPaddingRight }, "cancel-icon": { display: "inline-block", cursor: C2.iconCursor, color: t3.editVariable.cancelIcon, fontSize: C2.iconFontSize, paddingRight: C2.iconPaddingRight }, "edit-input": { display: "inline-block", minWidth: C2.editInputMinWidth, borderRadius: C2.editInputBorderRadius, backgroundColor: t3.editVariable.background, color: t3.editVariable.color, padding: C2.editInputPadding, marginRight: C2.editInputMarginRight, fontFamily: C2.editInputFontFamily }, "detected-row": { paddingTop: C2.detectedRowPaddingTop }, "key-modal-request": { position: C2.addKeyCoverPosition, top: C2.addKeyCoverPositionPx, left: C2.addKeyCoverPositionPx, right: C2.addKeyCoverPositionPx, bottom: C2.addKeyCoverPositionPx, backgroundColor: C2.addKeyCoverBackground }, "key-modal": { width: C2.addKeyModalWidth, backgroundColor: t3.addKeyModal.background, marginLeft: C2.addKeyModalMargin, marginRight: C2.addKeyModalMargin, padding: C2.addKeyModalPadding, borderRadius: C2.addKeyModalRadius, marginTop: "15px", position: "relative" }, "key-modal-label": { color: t3.addKeyModal.labelColor, marginLeft: "2px", marginBottom: "5px", fontSize: "11px" }, "key-modal-input-container": { overflow: "hidden" }, "key-modal-input": { width: "100%", padding: "3px 6px", fontFamily: "monospace", color: t3.addKeyModal.color, border: "none", boxSizing: "border-box", borderRadius: "2px" }, "key-modal-cancel": { backgroundColor: t3.editVariable.removeIcon, position: "absolute", top: "0px", right: "0px", borderRadius: "0px 3px 0px 3px", cursor: "pointer" }, "key-modal-cancel-icon": { color: t3.addKeyModal.labelColor, fontSize: C2.iconFontSize, transform: "rotate(45deg)" }, "key-modal-submit": { color: t3.editVariable.addIcon, fontSize: C2.iconFontSize, position: "absolute", right: "2px", top: "3px", cursor: "pointer" }, "function-ellipsis": { display: "inline-block", color: t3.ellipsisColor, fontSize: C2.ellipsisFontSize, lineHeight: C2.ellipsisLineHeight, cursor: C2.ellipsisCursor }, "validation-failure": { float: "right", padding: "3px 6px", borderRadius: "2px", cursor: "pointer", color: t3.validationFailure.fontColor, backgroundColor: t3.validationFailure.background }, "validation-failure-label": { marginRight: "6px" }, "validation-failure-clear": { position: "relative", verticalAlign: "top", cursor: "pointer", color: t3.validationFailure.iconColor, fontSize: C2.iconFontSize, transform: "rotate(45deg)" } };
          };
          function A2(e4, t3, n3) {
            return e4 || console.error("theme has not been set"), function(e5) {
              var t4 = k2;
              return false !== e5 && "none" !== e5 || (t4 = O2), Object(S2.createStyling)(w2, { defaultBase16: t4 })(e5);
            }(e4)(t3, n3);
          }
          var M2 = function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3() {
              return i2(this, n3), t3.apply(this, arguments);
            }
            return c2(n3, [{ key: "render", value: function() {
              var e5 = this.props, t4 = (e5.rjvId, e5.type_name), n4 = e5.displayDataTypes, a3 = e5.theme;
              return n4 ? m2.a.createElement("span", Object.assign({ className: "data-type-label" }, A2(a3, "data-type-label")), t4) : null;
            } }]), n3;
          }(m2.a.PureComponent), P2 = function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3() {
              return i2(this, n3), t3.apply(this, arguments);
            }
            return c2(n3, [{ key: "render", value: function() {
              var e5 = this.props;
              return m2.a.createElement("div", A2(e5.theme, "boolean"), m2.a.createElement(M2, Object.assign({ type_name: "bool" }, e5)), e5.value ? "true" : "false");
            } }]), n3;
          }(m2.a.PureComponent), F2 = function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3() {
              return i2(this, n3), t3.apply(this, arguments);
            }
            return c2(n3, [{ key: "render", value: function() {
              var e5 = this.props;
              return m2.a.createElement("div", A2(e5.theme, "date"), m2.a.createElement(M2, Object.assign({ type_name: "date" }, e5)), m2.a.createElement("span", Object.assign({ className: "date-value" }, A2(e5.theme, "date-value")), e5.value.toLocaleTimeString("en-us", { weekday: "short", year: "numeric", month: "short", day: "numeric", hour: "2-digit", minute: "2-digit" })));
            } }]), n3;
          }(m2.a.PureComponent), D2 = function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3() {
              return i2(this, n3), t3.apply(this, arguments);
            }
            return c2(n3, [{ key: "render", value: function() {
              var e5 = this.props;
              return m2.a.createElement("div", A2(e5.theme, "float"), m2.a.createElement(M2, Object.assign({ type_name: "float" }, e5)), this.props.value);
            } }]), n3;
          }(m2.a.PureComponent);
          function I2(e4, t3) {
            (null == t3 || t3 > e4.length) && (t3 = e4.length);
            for (var n3 = 0, a3 = new Array(t3); n3 < t3; n3++)
              a3[n3] = e4[n3];
            return a3;
          }
          function R2(e4, t3) {
            if (e4) {
              if ("string" == typeof e4)
                return I2(e4, t3);
              var n3 = Object.prototype.toString.call(e4).slice(8, -1);
              return "Object" === n3 && e4.constructor && (n3 = e4.constructor.name), "Map" === n3 || "Set" === n3 ? Array.from(e4) : "Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3) ? I2(e4, t3) : void 0;
            }
          }
          function L2(e4, t3) {
            var n3;
            if ("undefined" == typeof Symbol || null == e4[Symbol.iterator]) {
              if (Array.isArray(e4) || (n3 = R2(e4)) || t3 && e4 && "number" == typeof e4.length) {
                n3 && (e4 = n3);
                var a3 = 0, r3 = function() {
                };
                return { s: r3, n: function() {
                  return a3 >= e4.length ? { done: true } : { done: false, value: e4[a3++] };
                }, e: function(e5) {
                  throw e5;
                }, f: r3 };
              }
              throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var o3, i3 = true, s3 = false;
            return { s: function() {
              n3 = e4[Symbol.iterator]();
            }, n: function() {
              var e5 = n3.next();
              return i3 = e5.done, e5;
            }, e: function(e5) {
              s3 = true, o3 = e5;
            }, f: function() {
              try {
                i3 || null == n3.return || n3.return();
              } finally {
                if (s3)
                  throw o3;
              }
            } };
          }
          function B2(e4) {
            return function(e5) {
              if (Array.isArray(e5))
                return I2(e5);
            }(e4) || function(e5) {
              if ("undefined" != typeof Symbol && Symbol.iterator in Object(e5))
                return Array.from(e5);
            }(e4) || R2(e4) || function() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
          }
          var N2 = n2(46), z2 = new (n2(47)).Dispatcher(), T2 = new (function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3() {
              var e5;
              i2(this, n3);
              for (var a3 = arguments.length, r3 = new Array(a3), s3 = 0; s3 < a3; s3++)
                r3[s3] = arguments[s3];
              return (e5 = t3.call.apply(t3, [this].concat(r3))).objects = {}, e5.set = function(t4, n4, a4, r4) {
                void 0 === e5.objects[t4] && (e5.objects[t4] = {}), void 0 === e5.objects[t4][n4] && (e5.objects[t4][n4] = {}), e5.objects[t4][n4][a4] = r4;
              }, e5.get = function(t4, n4, a4, r4) {
                return void 0 === e5.objects[t4] || void 0 === e5.objects[t4][n4] || null == e5.objects[t4][n4][a4] ? r4 : e5.objects[t4][n4][a4];
              }, e5.handleAction = function(t4) {
                var n4 = t4.rjvId, a4 = t4.data;
                switch (t4.name) {
                  case "RESET":
                    e5.emit("reset-" + n4);
                    break;
                  case "VARIABLE_UPDATED":
                    t4.data.updated_src = e5.updateSrc(n4, a4), e5.set(n4, "action", "variable-update", o2(o2({}, a4), {}, { type: "variable-edited" })), e5.emit("variable-update-" + n4);
                    break;
                  case "VARIABLE_REMOVED":
                    t4.data.updated_src = e5.updateSrc(n4, a4), e5.set(n4, "action", "variable-update", o2(o2({}, a4), {}, { type: "variable-removed" })), e5.emit("variable-update-" + n4);
                    break;
                  case "VARIABLE_ADDED":
                    t4.data.updated_src = e5.updateSrc(n4, a4), e5.set(n4, "action", "variable-update", o2(o2({}, a4), {}, { type: "variable-added" })), e5.emit("variable-update-" + n4);
                    break;
                  case "ADD_VARIABLE_KEY_REQUEST":
                    e5.set(n4, "action", "new-key-request", a4), e5.emit("add-key-request-" + n4);
                }
              }, e5.updateSrc = function(t4, n4) {
                var a4 = n4.name, r4 = n4.namespace, o3 = n4.new_value, i3 = (n4.existing_value, n4.variable_removed);
                r4.shift();
                var s4, c3 = e5.get(t4, "global", "src"), l3 = e5.deepCopy(c3, B2(r4)), u3 = l3, f3 = L2(r4);
                try {
                  for (f3.s(); !(s4 = f3.n()).done; ) {
                    u3 = u3[s4.value];
                  }
                } catch (e6) {
                  f3.e(e6);
                } finally {
                  f3.f();
                }
                return i3 ? "array" == _2(u3) ? u3.splice(a4, 1) : delete u3[a4] : null !== a4 ? u3[a4] = o3 : l3 = o3, e5.set(t4, "global", "src", l3), l3;
              }, e5.deepCopy = function(t4, n4) {
                var a4, r4 = _2(t4), i3 = n4.shift();
                return "array" == r4 ? a4 = B2(t4) : "object" == r4 && (a4 = o2({}, t4)), void 0 !== i3 && (a4[i3] = e5.deepCopy(t4[i3], n4)), a4;
              }, e5;
            }
            return n3;
          }(N2.EventEmitter))();
          z2.register(T2.handleAction.bind(T2));
          var q2 = T2, V2 = function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3(e5) {
              var a3;
              return i2(this, n3), (a3 = t3.call(this, e5)).toggleCollapsed = function() {
                a3.setState({ collapsed: !a3.state.collapsed }, function() {
                  q2.set(a3.props.rjvId, a3.props.namespace, "collapsed", a3.state.collapsed);
                });
              }, a3.getFunctionDisplay = function(e6) {
                var t4 = d2(a3).props;
                return e6 ? m2.a.createElement("span", null, a3.props.value.toString().slice(9, -1).replace(/\{[\s\S]+/, ""), m2.a.createElement("span", { className: "function-collapsed", style: { fontWeight: "bold" } }, m2.a.createElement("span", null, "{"), m2.a.createElement("span", A2(t4.theme, "ellipsis"), "..."), m2.a.createElement("span", null, "}"))) : a3.props.value.toString().slice(9, -1);
              }, a3.state = { collapsed: q2.get(e5.rjvId, e5.namespace, "collapsed", true) }, a3;
            }
            return c2(n3, [{ key: "render", value: function() {
              var e5 = this.props, t4 = this.state.collapsed;
              return m2.a.createElement("div", A2(e5.theme, "function"), m2.a.createElement(M2, Object.assign({ type_name: "function" }, e5)), m2.a.createElement("span", Object.assign({}, A2(e5.theme, "function-value"), { className: "rjv-function-container", onClick: this.toggleCollapsed }), this.getFunctionDisplay(t4)));
            } }]), n3;
          }(m2.a.PureComponent), K2 = function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3() {
              return i2(this, n3), t3.apply(this, arguments);
            }
            return c2(n3, [{ key: "render", value: function() {
              return m2.a.createElement("div", A2(this.props.theme, "nan"), "NaN");
            } }]), n3;
          }(m2.a.PureComponent), W2 = function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3() {
              return i2(this, n3), t3.apply(this, arguments);
            }
            return c2(n3, [{ key: "render", value: function() {
              return m2.a.createElement("div", A2(this.props.theme, "null"), "NULL");
            } }]), n3;
          }(m2.a.PureComponent), H2 = function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3() {
              return i2(this, n3), t3.apply(this, arguments);
            }
            return c2(n3, [{ key: "render", value: function() {
              var e5 = this.props;
              return m2.a.createElement("div", A2(e5.theme, "integer"), m2.a.createElement(M2, Object.assign({ type_name: "int" }, e5)), this.props.value);
            } }]), n3;
          }(m2.a.PureComponent), U2 = function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3() {
              return i2(this, n3), t3.apply(this, arguments);
            }
            return c2(n3, [{ key: "render", value: function() {
              var e5 = this.props;
              return m2.a.createElement("div", A2(e5.theme, "regexp"), m2.a.createElement(M2, Object.assign({ type_name: "regexp" }, e5)), this.props.value.toString());
            } }]), n3;
          }(m2.a.PureComponent), G2 = function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3(e5) {
              var a3;
              return i2(this, n3), (a3 = t3.call(this, e5)).toggleCollapsed = function() {
                a3.setState({ collapsed: !a3.state.collapsed }, function() {
                  q2.set(a3.props.rjvId, a3.props.namespace, "collapsed", a3.state.collapsed);
                });
              }, a3.state = { collapsed: q2.get(e5.rjvId, e5.namespace, "collapsed", true) }, a3;
            }
            return c2(n3, [{ key: "render", value: function() {
              this.state.collapsed;
              var e5 = this.props, t4 = e5.collapseStringsAfterLength, n4 = e5.theme, a3 = e5.value, r3 = { style: { cursor: "default" } };
              return "integer" === _2(t4) && a3.length > t4 && (r3.style.cursor = "pointer", this.state.collapsed && (a3 = m2.a.createElement("span", null, a3.substring(0, t4), m2.a.createElement("span", A2(n4, "ellipsis"), " ...")))), m2.a.createElement("div", A2(n4, "string"), m2.a.createElement(M2, Object.assign({ type_name: "string" }, e5)), m2.a.createElement("span", Object.assign({ className: "string-value" }, r3, { onClick: this.toggleCollapsed }), '"', a3, '"'));
            } }]), n3;
          }(m2.a.PureComponent), J2 = function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3() {
              return i2(this, n3), t3.apply(this, arguments);
            }
            return c2(n3, [{ key: "render", value: function() {
              return m2.a.createElement("div", A2(this.props.theme, "undefined"), "undefined");
            } }]), n3;
          }(m2.a.PureComponent);
          function Y2() {
            return (Y2 = Object.assign || function(e4) {
              for (var t3 = 1; t3 < arguments.length; t3++) {
                var n3 = arguments[t3];
                for (var a3 in n3)
                  Object.prototype.hasOwnProperty.call(n3, a3) && (e4[a3] = n3[a3]);
              }
              return e4;
            }).apply(this, arguments);
          }
          var $2 = v2.useLayoutEffect, Q2 = function(e4) {
            var t3 = Object(v2.useRef)(e4);
            return $2(function() {
              t3.current = e4;
            }), t3;
          }, Z2 = function(e4, t3) {
            "function" != typeof e4 ? e4.current = t3 : e4(t3);
          }, X2 = function(e4, t3) {
            var n3 = Object(v2.useRef)();
            return Object(v2.useCallback)(function(a3) {
              e4.current = a3, n3.current && Z2(n3.current, null), n3.current = t3, t3 && Z2(t3, a3);
            }, [t3]);
          }, ee2 = { "min-height": "0", "max-height": "none", height: "0", visibility: "hidden", overflow: "hidden", position: "absolute", "z-index": "-1000", top: "0", right: "0" }, te2 = function(e4) {
            Object.keys(ee2).forEach(function(t3) {
              e4.style.setProperty(t3, ee2[t3], "important");
            });
          }, ne2 = null;
          var ae2 = function() {
          }, re2 = ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth", "boxSizing", "fontFamily", "fontSize", "fontStyle", "fontWeight", "letterSpacing", "lineHeight", "paddingBottom", "paddingLeft", "paddingRight", "paddingTop", "tabSize", "textIndent", "textRendering", "textTransform", "width"], oe2 = !!document.documentElement.currentStyle, ie2 = function(e4, t3) {
            var n3 = e4.cacheMeasurements, a3 = e4.maxRows, r3 = e4.minRows, o3 = e4.onChange, i3 = void 0 === o3 ? ae2 : o3, s3 = e4.onHeightChange, c3 = void 0 === s3 ? ae2 : s3, l3 = function(e5, t4) {
              if (null == e5)
                return {};
              var n4, a4, r4 = {}, o4 = Object.keys(e5);
              for (a4 = 0; a4 < o4.length; a4++)
                n4 = o4[a4], t4.indexOf(n4) >= 0 || (r4[n4] = e5[n4]);
              return r4;
            }(e4, ["cacheMeasurements", "maxRows", "minRows", "onChange", "onHeightChange"]);
            var u3, f3 = void 0 !== l3.value, p3 = Object(v2.useRef)(null), d3 = X2(p3, t3), b3 = Object(v2.useRef)(0), h3 = Object(v2.useRef)(), m3 = function() {
              var e5 = p3.current, t4 = n3 && h3.current ? h3.current : function(e6) {
                var t5 = window.getComputedStyle(e6);
                if (null === t5)
                  return null;
                var n4, a4 = (n4 = t5, re2.reduce(function(e7, t6) {
                  return e7[t6] = n4[t6], e7;
                }, {})), r4 = a4.boxSizing;
                return "" === r4 ? null : (oe2 && "border-box" === r4 && (a4.width = parseFloat(a4.width) + parseFloat(a4.borderRightWidth) + parseFloat(a4.borderLeftWidth) + parseFloat(a4.paddingRight) + parseFloat(a4.paddingLeft) + "px"), { sizingStyle: a4, paddingSize: parseFloat(a4.paddingBottom) + parseFloat(a4.paddingTop), borderSize: parseFloat(a4.borderBottomWidth) + parseFloat(a4.borderTopWidth) });
              }(e5);
              if (t4) {
                h3.current = t4;
                var o4 = function(e6, t5, n4, a4) {
                  void 0 === n4 && (n4 = 1), void 0 === a4 && (a4 = 1 / 0), ne2 || ((ne2 = document.createElement("textarea")).setAttribute("tab-index", "-1"), ne2.setAttribute("aria-hidden", "true"), te2(ne2)), null === ne2.parentNode && document.body.appendChild(ne2);
                  var r4 = e6.paddingSize, o5 = e6.borderSize, i5 = e6.sizingStyle, s5 = i5.boxSizing;
                  Object.keys(i5).forEach(function(e7) {
                    var t6 = e7;
                    ne2.style[t6] = i5[t6];
                  }), te2(ne2), ne2.value = t5;
                  var c4 = function(e7, t6) {
                    var n5 = e7.scrollHeight;
                    return "border-box" === t6.sizingStyle.boxSizing ? n5 + t6.borderSize : n5 - t6.paddingSize;
                  }(ne2, e6);
                  ne2.value = "x";
                  var l4 = ne2.scrollHeight - r4, u4 = l4 * n4;
                  "border-box" === s5 && (u4 = u4 + r4 + o5), c4 = Math.max(u4, c4);
                  var f4 = l4 * a4;
                  return "border-box" === s5 && (f4 = f4 + r4 + o5), [c4 = Math.min(f4, c4), l4];
                }(t4, e5.value || e5.placeholder || "x", r3, a3), i4 = o4[0], s4 = o4[1];
                b3.current !== i4 && (b3.current = i4, e5.style.setProperty("height", i4 + "px", "important"), c3(i4, { rowHeight: s4 }));
              }
            };
            return Object(v2.useLayoutEffect)(m3), u3 = Q2(m3), Object(v2.useLayoutEffect)(function() {
              var e5 = function(e6) {
                u3.current(e6);
              };
              return window.addEventListener("resize", e5), function() {
                window.removeEventListener("resize", e5);
              };
            }, []), Object(v2.createElement)("textarea", Y2({}, l3, { onChange: function(e5) {
              f3 || m3(), i3(e5);
            }, ref: d3 }));
          }, se2 = Object(v2.forwardRef)(ie2);
          function ce2(e4) {
            e4 = e4.trim();
            try {
              if ("[" === (e4 = JSON.stringify(JSON.parse(e4)))[0])
                return le2("array", JSON.parse(e4));
              if ("{" === e4[0])
                return le2("object", JSON.parse(e4));
              if (e4.match(/\-?\d+\.\d+/) && e4.match(/\-?\d+\.\d+/)[0] === e4)
                return le2("float", parseFloat(e4));
              if (e4.match(/\-?\d+e-\d+/) && e4.match(/\-?\d+e-\d+/)[0] === e4)
                return le2("float", Number(e4));
              if (e4.match(/\-?\d+/) && e4.match(/\-?\d+/)[0] === e4)
                return le2("integer", parseInt(e4));
              if (e4.match(/\-?\d+e\+\d+/) && e4.match(/\-?\d+e\+\d+/)[0] === e4)
                return le2("integer", Number(e4));
            } catch (e5) {
            }
            switch (e4 = e4.toLowerCase()) {
              case "undefined":
                return le2("undefined", void 0);
              case "nan":
                return le2("nan", NaN);
              case "null":
                return le2("null", null);
              case "true":
                return le2("boolean", true);
              case "false":
                return le2("boolean", false);
              default:
                if (e4 = Date.parse(e4))
                  return le2("date", new Date(e4));
            }
            return le2(false, null);
          }
          function le2(e4, t3) {
            return { type: e4, value: t3 };
          }
          var ue2 = function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3() {
              return i2(this, n3), t3.apply(this, arguments);
            }
            return c2(n3, [{ key: "render", value: function() {
              var e5 = this.props, t4 = e5.style, n4 = x2(e5, ["style"]);
              return m2.a.createElement("span", n4, m2.a.createElement("svg", Object.assign({}, xe2(t4), { viewBox: "0 0 24 24", fill: "currentColor", preserveAspectRatio: "xMidYMid meet" }), m2.a.createElement("path", { d: "M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M7,13H17V11H7" })));
            } }]), n3;
          }(m2.a.PureComponent), fe2 = function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3() {
              return i2(this, n3), t3.apply(this, arguments);
            }
            return c2(n3, [{ key: "render", value: function() {
              var e5 = this.props, t4 = e5.style, n4 = x2(e5, ["style"]);
              return m2.a.createElement("span", n4, m2.a.createElement("svg", Object.assign({}, xe2(t4), { viewBox: "0 0 24 24", fill: "currentColor", preserveAspectRatio: "xMidYMid meet" }), m2.a.createElement("path", { d: "M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M13,7H11V11H7V13H11V17H13V13H17V11H13V7Z" })));
            } }]), n3;
          }(m2.a.PureComponent), pe2 = function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3() {
              return i2(this, n3), t3.apply(this, arguments);
            }
            return c2(n3, [{ key: "render", value: function() {
              var e5 = this.props, t4 = e5.style, n4 = x2(e5, ["style"]), a3 = xe2(t4).style;
              return m2.a.createElement("span", n4, m2.a.createElement("svg", { fill: a3.color, width: a3.height, height: a3.width, style: a3, viewBox: "0 0 1792 1792" }, m2.a.createElement("path", { d: "M1344 800v64q0 14-9 23t-23 9h-832q-14 0-23-9t-9-23v-64q0-14 9-23t23-9h832q14 0 23 9t9 23zm128 448v-832q0-66-47-113t-113-47h-832q-66 0-113 47t-47 113v832q0 66 47 113t113 47h832q66 0 113-47t47-113zm128-832v832q0 119-84.5 203.5t-203.5 84.5h-832q-119 0-203.5-84.5t-84.5-203.5v-832q0-119 84.5-203.5t203.5-84.5h832q119 0 203.5 84.5t84.5 203.5z" })));
            } }]), n3;
          }(m2.a.PureComponent), de2 = function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3() {
              return i2(this, n3), t3.apply(this, arguments);
            }
            return c2(n3, [{ key: "render", value: function() {
              var e5 = this.props, t4 = e5.style, n4 = x2(e5, ["style"]), a3 = xe2(t4).style;
              return m2.a.createElement("span", n4, m2.a.createElement("svg", { fill: a3.color, width: a3.height, height: a3.width, style: a3, viewBox: "0 0 1792 1792" }, m2.a.createElement("path", { d: "M1344 800v64q0 14-9 23t-23 9h-352v352q0 14-9 23t-23 9h-64q-14 0-23-9t-9-23v-352h-352q-14 0-23-9t-9-23v-64q0-14 9-23t23-9h352v-352q0-14 9-23t23-9h64q14 0 23 9t9 23v352h352q14 0 23 9t9 23zm128 448v-832q0-66-47-113t-113-47h-832q-66 0-113 47t-47 113v832q0 66 47 113t113 47h832q66 0 113-47t47-113zm128-832v832q0 119-84.5 203.5t-203.5 84.5h-832q-119 0-203.5-84.5t-84.5-203.5v-832q0-119 84.5-203.5t203.5-84.5h832q119 0 203.5 84.5t84.5 203.5z" })));
            } }]), n3;
          }(m2.a.PureComponent), be2 = function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3() {
              return i2(this, n3), t3.apply(this, arguments);
            }
            return c2(n3, [{ key: "render", value: function() {
              var e5 = this.props, t4 = e5.style, n4 = x2(e5, ["style"]);
              return m2.a.createElement("span", n4, m2.a.createElement("svg", { style: o2(o2({}, xe2(t4).style), {}, { paddingLeft: "2px", verticalAlign: "top" }), viewBox: "0 0 15 15", fill: "currentColor" }, m2.a.createElement("path", { d: "M0 14l6-6-6-6z" })));
            } }]), n3;
          }(m2.a.PureComponent), he2 = function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3() {
              return i2(this, n3), t3.apply(this, arguments);
            }
            return c2(n3, [{ key: "render", value: function() {
              var e5 = this.props, t4 = e5.style, n4 = x2(e5, ["style"]);
              return m2.a.createElement("span", n4, m2.a.createElement("svg", { style: o2(o2({}, xe2(t4).style), {}, { paddingLeft: "2px", verticalAlign: "top" }), viewBox: "0 0 15 15", fill: "currentColor" }, m2.a.createElement("path", { d: "M0 5l6 6 6-6z" })));
            } }]), n3;
          }(m2.a.PureComponent), ve2 = function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3() {
              return i2(this, n3), t3.apply(this, arguments);
            }
            return c2(n3, [{ key: "render", value: function() {
              var e5 = this.props, t4 = e5.style, n4 = x2(e5, ["style"]);
              return m2.a.createElement("span", n4, m2.a.createElement("svg", Object.assign({}, xe2(t4), { viewBox: "0 0 40 40", fill: "currentColor", preserveAspectRatio: "xMidYMid meet" }), m2.a.createElement("g", null, m2.a.createElement("path", { d: "m30 35h-25v-22.5h25v7.5h2.5v-12.5c0-1.4-1.1-2.5-2.5-2.5h-7.5c0-2.8-2.2-5-5-5s-5 2.2-5 5h-7.5c-1.4 0-2.5 1.1-2.5 2.5v27.5c0 1.4 1.1 2.5 2.5 2.5h25c1.4 0 2.5-1.1 2.5-2.5v-5h-2.5v5z m-20-27.5h2.5s2.5-1.1 2.5-2.5 1.1-2.5 2.5-2.5 2.5 1.1 2.5 2.5 1.3 2.5 2.5 2.5h2.5s2.5 1.1 2.5 2.5h-20c0-1.5 1.1-2.5 2.5-2.5z m-2.5 20h5v-2.5h-5v2.5z m17.5-5v-5l-10 7.5 10 7.5v-5h12.5v-5h-12.5z m-17.5 10h7.5v-2.5h-7.5v2.5z m12.5-17.5h-12.5v2.5h12.5v-2.5z m-7.5 5h-5v2.5h5v-2.5z" }))));
            } }]), n3;
          }(m2.a.PureComponent), me2 = function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3() {
              return i2(this, n3), t3.apply(this, arguments);
            }
            return c2(n3, [{ key: "render", value: function() {
              var e5 = this.props, t4 = e5.style, n4 = x2(e5, ["style"]);
              return m2.a.createElement("span", n4, m2.a.createElement("svg", Object.assign({}, xe2(t4), { viewBox: "0 0 40 40", fill: "currentColor", preserveAspectRatio: "xMidYMid meet" }), m2.a.createElement("g", null, m2.a.createElement("path", { d: "m28.6 25q0-0.5-0.4-1l-4-4 4-4q0.4-0.5 0.4-1 0-0.6-0.4-1.1l-2-2q-0.4-0.4-1-0.4-0.6 0-1 0.4l-4.1 4.1-4-4.1q-0.4-0.4-1-0.4-0.6 0-1 0.4l-2 2q-0.5 0.5-0.5 1.1 0 0.5 0.5 1l4 4-4 4q-0.5 0.5-0.5 1 0 0.7 0.5 1.1l2 2q0.4 0.4 1 0.4 0.6 0 1-0.4l4-4.1 4.1 4.1q0.4 0.4 1 0.4 0.6 0 1-0.4l2-2q0.4-0.4 0.4-1z m8.7-5q0 4.7-2.3 8.6t-6.3 6.2-8.6 2.3-8.6-2.3-6.2-6.2-2.3-8.6 2.3-8.6 6.2-6.2 8.6-2.3 8.6 2.3 6.3 6.2 2.3 8.6z" }))));
            } }]), n3;
          }(m2.a.PureComponent), ye2 = function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3() {
              return i2(this, n3), t3.apply(this, arguments);
            }
            return c2(n3, [{ key: "render", value: function() {
              var e5 = this.props, t4 = e5.style, n4 = x2(e5, ["style"]);
              return m2.a.createElement("span", n4, m2.a.createElement("svg", Object.assign({}, xe2(t4), { viewBox: "0 0 40 40", fill: "currentColor", preserveAspectRatio: "xMidYMid meet" }), m2.a.createElement("g", null, m2.a.createElement("path", { d: "m30.1 21.4v-2.8q0-0.6-0.4-1t-1-0.5h-5.7v-5.7q0-0.6-0.4-1t-1-0.4h-2.9q-0.6 0-1 0.4t-0.4 1v5.7h-5.7q-0.6 0-1 0.5t-0.5 1v2.8q0 0.6 0.5 1t1 0.5h5.7v5.7q0 0.5 0.4 1t1 0.4h2.9q0.6 0 1-0.4t0.4-1v-5.7h5.7q0.6 0 1-0.5t0.4-1z m7.2-1.4q0 4.7-2.3 8.6t-6.3 6.2-8.6 2.3-8.6-2.3-6.2-6.2-2.3-8.6 2.3-8.6 6.2-6.2 8.6-2.3 8.6 2.3 6.3 6.2 2.3 8.6z" }))));
            } }]), n3;
          }(m2.a.PureComponent), ge2 = function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3() {
              return i2(this, n3), t3.apply(this, arguments);
            }
            return c2(n3, [{ key: "render", value: function() {
              var e5 = this.props, t4 = e5.style, n4 = x2(e5, ["style"]);
              return m2.a.createElement("span", n4, m2.a.createElement("svg", Object.assign({}, xe2(t4), { viewBox: "0 0 40 40", fill: "currentColor", preserveAspectRatio: "xMidYMid meet" }), m2.a.createElement("g", null, m2.a.createElement("path", { d: "m31.6 21.6h-10v10h-3.2v-10h-10v-3.2h10v-10h3.2v10h10v3.2z" }))));
            } }]), n3;
          }(m2.a.PureComponent), Ee2 = function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3() {
              return i2(this, n3), t3.apply(this, arguments);
            }
            return c2(n3, [{ key: "render", value: function() {
              var e5 = this.props, t4 = e5.style, n4 = x2(e5, ["style"]);
              return m2.a.createElement("span", n4, m2.a.createElement("svg", Object.assign({}, xe2(t4), { viewBox: "0 0 40 40", fill: "currentColor", preserveAspectRatio: "xMidYMid meet" }), m2.a.createElement("g", null, m2.a.createElement("path", { d: "m19.8 26.4l2.6-2.6-3.4-3.4-2.6 2.6v1.3h2.2v2.1h1.2z m9.8-16q-0.3-0.4-0.7 0l-7.8 7.8q-0.4 0.4 0 0.7t0.7 0l7.8-7.8q0.4-0.4 0-0.7z m1.8 13.2v4.3q0 2.6-1.9 4.5t-4.5 1.9h-18.6q-2.6 0-4.5-1.9t-1.9-4.5v-18.6q0-2.7 1.9-4.6t4.5-1.8h18.6q1.4 0 2.6 0.5 0.3 0.2 0.4 0.5 0.1 0.4-0.2 0.7l-1.1 1.1q-0.3 0.3-0.7 0.1-0.5-0.1-1-0.1h-18.6q-1.4 0-2.5 1.1t-1 2.5v18.6q0 1.4 1 2.5t2.5 1h18.6q1.5 0 2.5-1t1.1-2.5v-2.9q0-0.2 0.2-0.4l1.4-1.5q0.3-0.3 0.8-0.1t0.4 0.6z m-2.1-16.5l6.4 6.5-15 15h-6.4v-6.5z m9.9 3l-2.1 2-6.4-6.4 2.1-2q0.6-0.7 1.5-0.7t1.5 0.7l3.4 3.4q0.6 0.6 0.6 1.5t-0.6 1.5z" }))));
            } }]), n3;
          }(m2.a.PureComponent), je2 = function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3() {
              return i2(this, n3), t3.apply(this, arguments);
            }
            return c2(n3, [{ key: "render", value: function() {
              var e5 = this.props, t4 = e5.style, n4 = x2(e5, ["style"]);
              return m2.a.createElement("span", n4, m2.a.createElement("svg", Object.assign({}, xe2(t4), { viewBox: "0 0 40 40", fill: "currentColor", preserveAspectRatio: "xMidYMid meet" }), m2.a.createElement("g", null, m2.a.createElement("path", { d: "m31.7 16.4q0-0.6-0.4-1l-2.1-2.1q-0.4-0.4-1-0.4t-1 0.4l-9.1 9.1-5-5q-0.5-0.4-1-0.4t-1 0.4l-2.1 2q-0.4 0.4-0.4 1 0 0.6 0.4 1l8.1 8.1q0.4 0.4 1 0.4 0.6 0 1-0.4l12.2-12.1q0.4-0.4 0.4-1z m5.6 3.6q0 4.7-2.3 8.6t-6.3 6.2-8.6 2.3-8.6-2.3-6.2-6.2-2.3-8.6 2.3-8.6 6.2-6.2 8.6-2.3 8.6 2.3 6.3 6.2 2.3 8.6z" }))));
            } }]), n3;
          }(m2.a.PureComponent);
          function xe2(e4) {
            return e4 || (e4 = {}), { style: o2(o2({ verticalAlign: "middle" }, e4), {}, { color: e4.color ? e4.color : "#000000", height: "1em", width: "1em" }) };
          }
          var _e = function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3(e5) {
              var a3;
              return i2(this, n3), (a3 = t3.call(this, e5)).copiedTimer = null, a3.handleCopy = function() {
                var e6 = document.createElement("textarea"), t4 = a3.props, n4 = t4.clickCallback, r3 = t4.src, o3 = t4.namespace;
                e6.innerHTML = JSON.stringify(a3.clipboardValue(r3), null, "  "), document.body.appendChild(e6), e6.select(), document.execCommand("copy"), document.body.removeChild(e6), a3.copiedTimer = setTimeout(function() {
                  a3.setState({ copied: false });
                }, 5500), a3.setState({ copied: true }, function() {
                  "function" == typeof n4 && n4({ src: r3, namespace: o3, name: o3[o3.length - 1] });
                });
              }, a3.getClippyIcon = function() {
                var e6 = a3.props.theme;
                return a3.state.copied ? m2.a.createElement("span", null, m2.a.createElement(ve2, Object.assign({ className: "copy-icon" }, A2(e6, "copy-icon"))), m2.a.createElement("span", A2(e6, "copy-icon-copied"), "✔")) : m2.a.createElement(ve2, Object.assign({ className: "copy-icon" }, A2(e6, "copy-icon")));
              }, a3.clipboardValue = function(e6) {
                switch (_2(e6)) {
                  case "function":
                  case "regexp":
                    return e6.toString();
                  default:
                    return e6;
                }
              }, a3.state = { copied: false }, a3;
            }
            return c2(n3, [{ key: "componentWillUnmount", value: function() {
              this.copiedTimer && (clearTimeout(this.copiedTimer), this.copiedTimer = null);
            } }, { key: "render", value: function() {
              var e5 = this.props, t4 = (e5.src, e5.theme), n4 = e5.hidden, a3 = e5.rowHovered, r3 = A2(t4, "copy-to-clipboard").style, i3 = "inline";
              return n4 && (i3 = "none"), m2.a.createElement("span", { className: "copy-to-clipboard-container", title: "Copy to clipboard", style: { verticalAlign: "top", display: a3 ? "inline-block" : "none" } }, m2.a.createElement("span", { style: o2(o2({}, r3), {}, { display: i3 }), onClick: this.handleCopy }, this.getClippyIcon()));
            } }]), n3;
          }(m2.a.PureComponent), ke2 = function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3(e5) {
              var a3;
              return i2(this, n3), (a3 = t3.call(this, e5)).getEditIcon = function() {
                var e6 = a3.props, t4 = e6.variable, n4 = e6.theme;
                return m2.a.createElement("div", { className: "click-to-edit", style: { verticalAlign: "top", display: a3.state.hovered ? "inline-block" : "none" } }, m2.a.createElement(Ee2, Object.assign({ className: "click-to-edit-icon" }, A2(n4, "editVarIcon"), { onClick: function() {
                  a3.prepopInput(t4);
                } })));
              }, a3.prepopInput = function(e6) {
                if (false !== a3.props.onEdit) {
                  var t4 = function(e7) {
                    var t5;
                    switch (_2(e7)) {
                      case "undefined":
                        t5 = "undefined";
                        break;
                      case "nan":
                        t5 = "NaN";
                        break;
                      case "string":
                        t5 = e7;
                        break;
                      case "date":
                      case "function":
                      case "regexp":
                        t5 = e7.toString();
                        break;
                      default:
                        try {
                          t5 = JSON.stringify(e7, null, "  ");
                        } catch (e8) {
                          t5 = "";
                        }
                    }
                    return t5;
                  }(e6.value), n4 = ce2(t4);
                  a3.setState({ editMode: true, editValue: t4, parsedInput: { type: n4.type, value: n4.value } });
                }
              }, a3.getRemoveIcon = function() {
                var e6 = a3.props, t4 = e6.variable, n4 = e6.namespace, r3 = e6.theme, o3 = e6.rjvId;
                return m2.a.createElement("div", { className: "click-to-remove", style: { verticalAlign: "top", display: a3.state.hovered ? "inline-block" : "none" } }, m2.a.createElement(me2, Object.assign({ className: "click-to-remove-icon" }, A2(r3, "removeVarIcon"), { onClick: function() {
                  z2.dispatch({ name: "VARIABLE_REMOVED", rjvId: o3, data: { name: t4.name, namespace: n4, existing_value: t4.value, variable_removed: true } });
                } })));
              }, a3.getValue = function(e6, t4) {
                var n4 = !t4 && e6.type, r3 = d2(a3).props;
                switch (n4) {
                  case false:
                    return a3.getEditInput();
                  case "string":
                    return m2.a.createElement(G2, Object.assign({ value: e6.value }, r3));
                  case "integer":
                    return m2.a.createElement(H2, Object.assign({ value: e6.value }, r3));
                  case "float":
                    return m2.a.createElement(D2, Object.assign({ value: e6.value }, r3));
                  case "boolean":
                    return m2.a.createElement(P2, Object.assign({ value: e6.value }, r3));
                  case "function":
                    return m2.a.createElement(V2, Object.assign({ value: e6.value }, r3));
                  case "null":
                    return m2.a.createElement(W2, r3);
                  case "nan":
                    return m2.a.createElement(K2, r3);
                  case "undefined":
                    return m2.a.createElement(J2, r3);
                  case "date":
                    return m2.a.createElement(F2, Object.assign({ value: e6.value }, r3));
                  case "regexp":
                    return m2.a.createElement(U2, Object.assign({ value: e6.value }, r3));
                  default:
                    return m2.a.createElement("div", { className: "object-value" }, JSON.stringify(e6.value));
                }
              }, a3.getEditInput = function() {
                var e6 = a3.props.theme, t4 = a3.state.editValue;
                return m2.a.createElement("div", null, m2.a.createElement(se2, Object.assign({ type: "text", inputRef: function(e7) {
                  return e7 && e7.focus();
                }, value: t4, className: "variable-editor", onChange: function(e7) {
                  var t5 = e7.target.value, n4 = ce2(t5);
                  a3.setState({ editValue: t5, parsedInput: { type: n4.type, value: n4.value } });
                }, onKeyDown: function(e7) {
                  switch (e7.key) {
                    case "Escape":
                      a3.setState({ editMode: false, editValue: "" });
                      break;
                    case "Enter":
                      (e7.ctrlKey || e7.metaKey) && a3.submitEdit(true);
                  }
                  e7.stopPropagation();
                }, placeholder: "update this value", minRows: 2 }, A2(e6, "edit-input"))), m2.a.createElement("div", A2(e6, "edit-icon-container"), m2.a.createElement(me2, Object.assign({ className: "edit-cancel" }, A2(e6, "cancel-icon"), { onClick: function() {
                  a3.setState({ editMode: false, editValue: "" });
                } })), m2.a.createElement(je2, Object.assign({ className: "edit-check string-value" }, A2(e6, "check-icon"), { onClick: function() {
                  a3.submitEdit();
                } })), m2.a.createElement("div", null, a3.showDetected())));
              }, a3.submitEdit = function(e6) {
                var t4 = a3.props, n4 = t4.variable, r3 = t4.namespace, o3 = t4.rjvId, i3 = a3.state, s3 = i3.editValue, c3 = i3.parsedInput, l3 = s3;
                e6 && c3.type && (l3 = c3.value), a3.setState({ editMode: false }), z2.dispatch({ name: "VARIABLE_UPDATED", rjvId: o3, data: { name: n4.name, namespace: r3, existing_value: n4.value, new_value: l3, variable_removed: false } });
              }, a3.showDetected = function() {
                var e6 = a3.props, t4 = e6.theme, n4 = (e6.variable, e6.namespace, e6.rjvId, a3.state.parsedInput), r3 = (n4.type, n4.value, a3.getDetectedInput());
                if (r3)
                  return m2.a.createElement("div", null, m2.a.createElement("div", A2(t4, "detected-row"), r3, m2.a.createElement(je2, { className: "edit-check detected", style: o2({ verticalAlign: "top", paddingLeft: "3px" }, A2(t4, "check-icon").style), onClick: function() {
                    a3.submitEdit(true);
                  } })));
              }, a3.getDetectedInput = function() {
                var e6 = a3.state.parsedInput, t4 = e6.type, n4 = e6.value, r3 = d2(a3).props, i3 = r3.theme;
                if (false !== t4)
                  switch (t4.toLowerCase()) {
                    case "object":
                      return m2.a.createElement("span", null, m2.a.createElement("span", { style: o2(o2({}, A2(i3, "brace").style), {}, { cursor: "default" }) }, "{"), m2.a.createElement("span", { style: o2(o2({}, A2(i3, "ellipsis").style), {}, { cursor: "default" }) }, "..."), m2.a.createElement("span", { style: o2(o2({}, A2(i3, "brace").style), {}, { cursor: "default" }) }, "}"));
                    case "array":
                      return m2.a.createElement("span", null, m2.a.createElement("span", { style: o2(o2({}, A2(i3, "brace").style), {}, { cursor: "default" }) }, "["), m2.a.createElement("span", { style: o2(o2({}, A2(i3, "ellipsis").style), {}, { cursor: "default" }) }, "..."), m2.a.createElement("span", { style: o2(o2({}, A2(i3, "brace").style), {}, { cursor: "default" }) }, "]"));
                    case "string":
                      return m2.a.createElement(G2, Object.assign({ value: n4 }, r3));
                    case "integer":
                      return m2.a.createElement(H2, Object.assign({ value: n4 }, r3));
                    case "float":
                      return m2.a.createElement(D2, Object.assign({ value: n4 }, r3));
                    case "boolean":
                      return m2.a.createElement(P2, Object.assign({ value: n4 }, r3));
                    case "function":
                      return m2.a.createElement(V2, Object.assign({ value: n4 }, r3));
                    case "null":
                      return m2.a.createElement(W2, r3);
                    case "nan":
                      return m2.a.createElement(K2, r3);
                    case "undefined":
                      return m2.a.createElement(J2, r3);
                    case "date":
                      return m2.a.createElement(F2, Object.assign({ value: new Date(n4) }, r3));
                  }
              }, a3.state = { editMode: false, editValue: "", hovered: false, renameKey: false, parsedInput: { type: false, value: null } }, a3;
            }
            return c2(n3, [{ key: "render", value: function() {
              var e5 = this, t4 = this.props, n4 = t4.variable, a3 = t4.singleIndent, r3 = t4.type, i3 = t4.theme, s3 = t4.namespace, c3 = t4.indentWidth, l3 = t4.enableClipboard, u3 = t4.onEdit, f3 = t4.onDelete, p3 = t4.onSelect, d3 = t4.displayArrayKey, b3 = t4.quotesOnKeys, h3 = this.state.editMode;
              return m2.a.createElement("div", Object.assign({}, A2(i3, "objectKeyVal", { paddingLeft: c3 * a3 }), { onMouseEnter: function() {
                return e5.setState(o2(o2({}, e5.state), {}, { hovered: true }));
              }, onMouseLeave: function() {
                return e5.setState(o2(o2({}, e5.state), {}, { hovered: false }));
              }, className: "variable-row", key: n4.name }), "array" == r3 ? d3 ? m2.a.createElement("span", Object.assign({}, A2(i3, "array-key"), { key: n4.name + "_" + s3 }), n4.name, m2.a.createElement("div", A2(i3, "colon"), ":")) : null : m2.a.createElement("span", null, m2.a.createElement("span", Object.assign({}, A2(i3, "object-name"), { className: "object-key", key: n4.name + "_" + s3 }), !!b3 && m2.a.createElement("span", { style: { verticalAlign: "top" } }, '"'), m2.a.createElement("span", { style: { display: "inline-block" } }, n4.name), !!b3 && m2.a.createElement("span", { style: { verticalAlign: "top" } }, '"')), m2.a.createElement("span", A2(i3, "colon"), ":")), m2.a.createElement("div", Object.assign({ className: "variable-value", onClick: false === p3 && false === u3 ? null : function(t5) {
                var a4 = B2(s3);
                (t5.ctrlKey || t5.metaKey) && false !== u3 ? e5.prepopInput(n4) : false !== p3 && (a4.shift(), p3(o2(o2({}, n4), {}, { namespace: a4 })));
              } }, A2(i3, "variableValue", { cursor: false === p3 ? "default" : "pointer" })), this.getValue(n4, h3)), l3 ? m2.a.createElement(_e, { rowHovered: this.state.hovered, hidden: h3, src: n4.value, clickCallback: l3, theme: i3, namespace: [].concat(B2(s3), [n4.name]) }) : null, false !== u3 && 0 == h3 ? this.getEditIcon() : null, false !== f3 && 0 == h3 ? this.getRemoveIcon() : null);
            } }]), n3;
          }(m2.a.PureComponent), Oe2 = function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3() {
              var e5;
              i2(this, n3);
              for (var a3 = arguments.length, r3 = new Array(a3), s3 = 0; s3 < a3; s3++)
                r3[s3] = arguments[s3];
              return (e5 = t3.call.apply(t3, [this].concat(r3))).getObjectSize = function() {
                var t4 = e5.props, n4 = t4.size, a4 = t4.theme;
                if (t4.displayObjectSize)
                  return m2.a.createElement("span", Object.assign({ className: "object-size" }, A2(a4, "object-size")), n4, " item", 1 === n4 ? "" : "s");
              }, e5.getAddAttribute = function(t4) {
                var n4 = e5.props, a4 = n4.theme, r4 = n4.namespace, i3 = n4.name, s4 = n4.src, c3 = n4.rjvId, l3 = n4.depth;
                return m2.a.createElement("span", { className: "click-to-add", style: { verticalAlign: "top", display: t4 ? "inline-block" : "none" } }, m2.a.createElement(ye2, Object.assign({ className: "click-to-add-icon" }, A2(a4, "addVarIcon"), { onClick: function() {
                  var e6 = { name: l3 > 0 ? i3 : null, namespace: r4.splice(0, r4.length - 1), existing_value: s4, variable_removed: false, key_name: null };
                  "object" === _2(s4) ? z2.dispatch({ name: "ADD_VARIABLE_KEY_REQUEST", rjvId: c3, data: e6 }) : z2.dispatch({ name: "VARIABLE_ADDED", rjvId: c3, data: o2(o2({}, e6), {}, { new_value: [].concat(B2(s4), [null]) }) });
                } })));
              }, e5.getRemoveObject = function(t4) {
                var n4 = e5.props, a4 = n4.theme, r4 = (n4.hover, n4.namespace), o3 = n4.name, i3 = n4.src, s4 = n4.rjvId;
                if (1 !== r4.length)
                  return m2.a.createElement("span", { className: "click-to-remove", style: { display: t4 ? "inline-block" : "none" } }, m2.a.createElement(me2, Object.assign({ className: "click-to-remove-icon" }, A2(a4, "removeVarIcon"), { onClick: function() {
                    z2.dispatch({ name: "VARIABLE_REMOVED", rjvId: s4, data: { name: o3, namespace: r4.splice(0, r4.length - 1), existing_value: i3, variable_removed: true } });
                  } })));
              }, e5.render = function() {
                var t4 = e5.props, n4 = t4.theme, a4 = t4.onDelete, r4 = t4.onAdd, o3 = t4.enableClipboard, i3 = t4.src, s4 = t4.namespace, c3 = t4.rowHovered;
                return m2.a.createElement("div", Object.assign({}, A2(n4, "object-meta-data"), { className: "object-meta-data", onClick: function(e6) {
                  e6.stopPropagation();
                } }), e5.getObjectSize(), o3 ? m2.a.createElement(_e, { rowHovered: c3, clickCallback: o3, src: i3, theme: n4, namespace: s4 }) : null, false !== r4 ? e5.getAddAttribute(c3) : null, false !== a4 ? e5.getRemoveObject(c3) : null);
              }, e5;
            }
            return n3;
          }(m2.a.PureComponent);
          function Ce2(e4) {
            var t3 = e4.parent_type, n3 = e4.namespace, a3 = e4.quotesOnKeys, r3 = e4.theme, o3 = e4.jsvRoot, i3 = e4.name, s3 = e4.displayArrayKey, c3 = e4.name ? e4.name : "";
            return !o3 || false !== i3 && null !== i3 ? "array" == t3 ? s3 ? m2.a.createElement("span", Object.assign({}, A2(r3, "array-key"), { key: n3 }), m2.a.createElement("span", { className: "array-key" }, c3), m2.a.createElement("span", A2(r3, "colon"), ":")) : m2.a.createElement("span", null) : m2.a.createElement("span", Object.assign({}, A2(r3, "object-name"), { key: n3 }), m2.a.createElement("span", { className: "object-key" }, a3 && m2.a.createElement("span", { style: { verticalAlign: "top" } }, '"'), m2.a.createElement("span", null, c3), a3 && m2.a.createElement("span", { style: { verticalAlign: "top" } }, '"')), m2.a.createElement("span", A2(r3, "colon"), ":")) : m2.a.createElement("span", null);
          }
          function Se2(e4) {
            var t3 = e4.theme;
            switch (e4.iconStyle) {
              case "triangle":
                return m2.a.createElement(he2, Object.assign({}, A2(t3, "expanded-icon"), { className: "expanded-icon" }));
              case "square":
                return m2.a.createElement(pe2, Object.assign({}, A2(t3, "expanded-icon"), { className: "expanded-icon" }));
              default:
                return m2.a.createElement(ue2, Object.assign({}, A2(t3, "expanded-icon"), { className: "expanded-icon" }));
            }
          }
          function we2(e4) {
            var t3 = e4.theme;
            switch (e4.iconStyle) {
              case "triangle":
                return m2.a.createElement(be2, Object.assign({}, A2(t3, "collapsed-icon"), { className: "collapsed-icon" }));
              case "square":
                return m2.a.createElement(de2, Object.assign({}, A2(t3, "collapsed-icon"), { className: "collapsed-icon" }));
              default:
                return m2.a.createElement(fe2, Object.assign({}, A2(t3, "collapsed-icon"), { className: "collapsed-icon" }));
            }
          }
          var Ae2 = function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3(e5) {
              var a3;
              return i2(this, n3), (a3 = t3.call(this, e5)).toggleCollapsed = function(e6) {
                var t4 = [];
                for (var n4 in a3.state.expanded)
                  t4.push(a3.state.expanded[n4]);
                t4[e6] = !t4[e6], a3.setState({ expanded: t4 });
              }, a3.state = { expanded: [] }, a3;
            }
            return c2(n3, [{ key: "getExpandedIcon", value: function(e5) {
              var t4 = this.props, n4 = t4.theme, a3 = t4.iconStyle;
              return this.state.expanded[e5] ? m2.a.createElement(Se2, { theme: n4, iconStyle: a3 }) : m2.a.createElement(we2, { theme: n4, iconStyle: a3 });
            } }, { key: "render", value: function() {
              var e5 = this, t4 = this.props, n4 = t4.src, a3 = t4.groupArraysAfterLength, r3 = (t4.depth, t4.name), o3 = t4.theme, i3 = t4.jsvRoot, s3 = t4.namespace, c3 = (t4.parent_type, x2(t4, ["src", "groupArraysAfterLength", "depth", "name", "theme", "jsvRoot", "namespace", "parent_type"])), l3 = 0, u3 = 5 * this.props.indentWidth;
              i3 || (l3 = 5 * this.props.indentWidth);
              var f3 = a3, p3 = Math.ceil(n4.length / f3);
              return m2.a.createElement("div", Object.assign({ className: "object-key-val" }, A2(o3, i3 ? "jsv-root" : "objectKeyVal", { paddingLeft: l3 })), m2.a.createElement(Ce2, this.props), m2.a.createElement("span", null, m2.a.createElement(Oe2, Object.assign({ size: n4.length }, this.props))), B2(Array(p3)).map(function(t5, a4) {
                return m2.a.createElement("div", Object.assign({ key: a4, className: "object-key-val array-group" }, A2(o3, "objectKeyVal", { marginLeft: 6, paddingLeft: u3 })), m2.a.createElement("span", A2(o3, "brace-row"), m2.a.createElement("div", Object.assign({ className: "icon-container" }, A2(o3, "icon-container"), { onClick: function(t6) {
                  e5.toggleCollapsed(a4);
                } }), e5.getExpandedIcon(a4)), e5.state.expanded[a4] ? m2.a.createElement(Fe2, Object.assign({ key: r3 + a4, depth: 0, name: false, collapsed: false, groupArraysAfterLength: f3, index_offset: a4 * f3, src: n4.slice(a4 * f3, a4 * f3 + f3), namespace: s3, type: "array", parent_type: "array_group", theme: o3 }, c3)) : m2.a.createElement("span", Object.assign({}, A2(o3, "brace"), { onClick: function(t6) {
                  e5.toggleCollapsed(a4);
                }, className: "array-group-brace" }), "[", m2.a.createElement("div", Object.assign({}, A2(o3, "array-group-meta-data"), { className: "array-group-meta-data" }), m2.a.createElement("span", Object.assign({ className: "object-size" }, A2(o3, "object-size")), a4 * f3, " - ", a4 * f3 + f3 > n4.length ? n4.length : a4 * f3 + f3)), "]")));
              }));
            } }]), n3;
          }(m2.a.PureComponent), Me2 = function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3(e5) {
              var a3;
              i2(this, n3), (a3 = t3.call(this, e5)).toggleCollapsed = function() {
                a3.setState({ expanded: !a3.state.expanded }, function() {
                  q2.set(a3.props.rjvId, a3.props.namespace, "expanded", a3.state.expanded);
                });
              }, a3.getObjectContent = function(e6, t4, n4) {
                return m2.a.createElement("div", { className: "pushed-content object-container" }, m2.a.createElement("div", Object.assign({ className: "object-content" }, A2(a3.props.theme, "pushed-content")), a3.renderObjectContents(t4, n4)));
              }, a3.getEllipsis = function() {
                return 0 === a3.state.size ? null : m2.a.createElement("div", Object.assign({}, A2(a3.props.theme, "ellipsis"), { className: "node-ellipsis", onClick: a3.toggleCollapsed }), "...");
              }, a3.getObjectMetaData = function(e6) {
                var t4 = a3.props, n4 = (t4.rjvId, t4.theme, a3.state), r4 = n4.size, o3 = n4.hovered;
                return m2.a.createElement(Oe2, Object.assign({ rowHovered: o3, size: r4 }, a3.props));
              }, a3.renderObjectContents = function(e6, t4) {
                var n4, r4 = a3.props, o3 = r4.depth, i3 = r4.parent_type, s3 = r4.index_offset, c3 = r4.groupArraysAfterLength, l3 = r4.namespace, u3 = a3.state.object_type, f3 = [], p3 = Object.keys(e6 || {});
                return a3.props.sortKeys && "array" !== u3 && (p3 = p3.sort()), p3.forEach(function(r5) {
                  if (n4 = new Pe2(r5, e6[r5]), "array_group" === i3 && s3 && (n4.name = parseInt(n4.name) + s3), e6.hasOwnProperty(r5))
                    if ("object" === n4.type)
                      f3.push(m2.a.createElement(Fe2, Object.assign({ key: n4.name, depth: o3 + 1, name: n4.name, src: n4.value, namespace: l3.concat(n4.name), parent_type: u3 }, t4)));
                    else if ("array" === n4.type) {
                      var p4 = Fe2;
                      c3 && n4.value.length > c3 && (p4 = Ae2), f3.push(m2.a.createElement(p4, Object.assign({ key: n4.name, depth: o3 + 1, name: n4.name, src: n4.value, namespace: l3.concat(n4.name), type: "array", parent_type: u3 }, t4)));
                    } else
                      f3.push(m2.a.createElement(ke2, Object.assign({ key: n4.name + "_" + l3, variable: n4, singleIndent: 5, namespace: l3, type: a3.props.type }, t4)));
                }), f3;
              };
              var r3 = n3.getState(e5);
              return a3.state = o2(o2({}, r3), {}, { prevProps: {} }), a3;
            }
            return c2(n3, [{ key: "getBraceStart", value: function(e5, t4) {
              var n4 = this, a3 = this.props, r3 = a3.src, o3 = a3.theme, i3 = a3.iconStyle;
              if ("array_group" === a3.parent_type)
                return m2.a.createElement("span", null, m2.a.createElement("span", A2(o3, "brace"), "array" === e5 ? "[" : "{"), t4 ? this.getObjectMetaData(r3) : null);
              var s3 = t4 ? Se2 : we2;
              return m2.a.createElement("span", null, m2.a.createElement("span", Object.assign({ onClick: function(e6) {
                n4.toggleCollapsed();
              } }, A2(o3, "brace-row")), m2.a.createElement("div", Object.assign({ className: "icon-container" }, A2(o3, "icon-container")), m2.a.createElement(s3, { theme: o3, iconStyle: i3 })), m2.a.createElement(Ce2, this.props), m2.a.createElement("span", A2(o3, "brace"), "array" === e5 ? "[" : "{")), t4 ? this.getObjectMetaData(r3) : null);
            } }, { key: "render", value: function() {
              var e5 = this, t4 = this.props, n4 = t4.depth, a3 = t4.src, r3 = (t4.namespace, t4.name, t4.type, t4.parent_type), i3 = t4.theme, s3 = t4.jsvRoot, c3 = t4.iconStyle, l3 = x2(t4, ["depth", "src", "namespace", "name", "type", "parent_type", "theme", "jsvRoot", "iconStyle"]), u3 = this.state, f3 = u3.object_type, p3 = u3.expanded, d3 = {};
              return s3 || "array_group" === r3 ? "array_group" === r3 && (d3.borderLeft = 0, d3.display = "inline") : d3.paddingLeft = 5 * this.props.indentWidth, m2.a.createElement("div", Object.assign({ className: "object-key-val", onMouseEnter: function() {
                return e5.setState(o2(o2({}, e5.state), {}, { hovered: true }));
              }, onMouseLeave: function() {
                return e5.setState(o2(o2({}, e5.state), {}, { hovered: false }));
              } }, A2(i3, s3 ? "jsv-root" : "objectKeyVal", d3)), this.getBraceStart(f3, p3), p3 ? this.getObjectContent(n4, a3, o2({ theme: i3, iconStyle: c3 }, l3)) : this.getEllipsis(), m2.a.createElement("span", { className: "brace-row" }, m2.a.createElement("span", { style: o2(o2({}, A2(i3, "brace").style), {}, { paddingLeft: p3 ? "3px" : "0px" }) }, "array" === f3 ? "]" : "}"), p3 ? null : this.getObjectMetaData(a3)));
            } }], [{ key: "getDerivedStateFromProps", value: function(e5, t4) {
              var a3 = t4.prevProps;
              return e5.src !== a3.src || e5.collapsed !== a3.collapsed || e5.name !== a3.name || e5.namespace !== a3.namespace || e5.rjvId !== a3.rjvId ? o2(o2({}, n3.getState(e5)), {}, { prevProps: e5 }) : null;
            } }]), n3;
          }(m2.a.PureComponent);
          Me2.getState = function(e4) {
            var t3 = Object.keys(e4.src).length, n3 = (false === e4.collapsed || true !== e4.collapsed && e4.collapsed > e4.depth) && (!e4.shouldCollapse || false === e4.shouldCollapse({ name: e4.name, src: e4.src, type: _2(e4.src), namespace: e4.namespace })) && 0 !== t3;
            return { expanded: q2.get(e4.rjvId, e4.namespace, "expanded", n3), object_type: "array" === e4.type ? "array" : "object", parent_type: "array" === e4.type ? "array" : "object", size: t3, hovered: false };
          };
          var Pe2 = function e4(t3, n3) {
            i2(this, e4), this.name = t3, this.value = n3, this.type = _2(n3);
          };
          j(Me2);
          var Fe2 = Me2, De2 = function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3() {
              var e5;
              i2(this, n3);
              for (var a3 = arguments.length, r3 = new Array(a3), o3 = 0; o3 < a3; o3++)
                r3[o3] = arguments[o3];
              return (e5 = t3.call.apply(t3, [this].concat(r3))).render = function() {
                var t4 = d2(e5).props, n4 = [t4.name], a4 = Fe2;
                return Array.isArray(t4.src) && t4.groupArraysAfterLength && t4.src.length > t4.groupArraysAfterLength && (a4 = Ae2), m2.a.createElement("div", { className: "pretty-json-container object-container" }, m2.a.createElement("div", { className: "object-content" }, m2.a.createElement(a4, Object.assign({ namespace: n4, depth: 0, jsvRoot: true }, t4))));
              }, e5;
            }
            return n3;
          }(m2.a.PureComponent), Ie2 = function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3(e5) {
              var a3;
              return i2(this, n3), (a3 = t3.call(this, e5)).closeModal = function() {
                z2.dispatch({ rjvId: a3.props.rjvId, name: "RESET" });
              }, a3.submit = function() {
                a3.props.submit(a3.state.input);
              }, a3.state = { input: e5.input ? e5.input : "" }, a3;
            }
            return c2(n3, [{ key: "render", value: function() {
              var e5 = this, t4 = this.props, n4 = t4.theme, a3 = t4.rjvId, r3 = t4.isValid, o3 = this.state.input, i3 = r3(o3);
              return m2.a.createElement("div", Object.assign({ className: "key-modal-request" }, A2(n4, "key-modal-request"), { onClick: this.closeModal }), m2.a.createElement("div", Object.assign({}, A2(n4, "key-modal"), { onClick: function(e6) {
                e6.stopPropagation();
              } }), m2.a.createElement("div", A2(n4, "key-modal-label"), "Key Name:"), m2.a.createElement("div", { style: { position: "relative" } }, m2.a.createElement("input", Object.assign({}, A2(n4, "key-modal-input"), { className: "key-modal-input", ref: function(e6) {
                return e6 && e6.focus();
              }, spellCheck: false, value: o3, placeholder: "...", onChange: function(t5) {
                e5.setState({ input: t5.target.value });
              }, onKeyPress: function(t5) {
                i3 && "Enter" === t5.key ? e5.submit() : "Escape" === t5.key && e5.closeModal();
              } })), i3 ? m2.a.createElement(je2, Object.assign({}, A2(n4, "key-modal-submit"), { className: "key-modal-submit", onClick: function(t5) {
                return e5.submit();
              } })) : null), m2.a.createElement("span", A2(n4, "key-modal-cancel"), m2.a.createElement(ge2, Object.assign({}, A2(n4, "key-modal-cancel-icon"), { className: "key-modal-cancel", onClick: function() {
                z2.dispatch({ rjvId: a3, name: "RESET" });
              } })))));
            } }]), n3;
          }(m2.a.PureComponent), Re2 = function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3() {
              var e5;
              i2(this, n3);
              for (var a3 = arguments.length, r3 = new Array(a3), s3 = 0; s3 < a3; s3++)
                r3[s3] = arguments[s3];
              return (e5 = t3.call.apply(t3, [this].concat(r3))).isValid = function(t4) {
                var n4 = e5.props.rjvId, a4 = q2.get(n4, "action", "new-key-request");
                return "" != t4 && -1 === Object.keys(a4.existing_value).indexOf(t4);
              }, e5.submit = function(t4) {
                var n4 = e5.props.rjvId, a4 = q2.get(n4, "action", "new-key-request");
                a4.new_value = o2({}, a4.existing_value), a4.new_value[t4] = e5.props.defaultValue, z2.dispatch({ name: "VARIABLE_ADDED", rjvId: n4, data: a4 });
              }, e5;
            }
            return c2(n3, [{ key: "render", value: function() {
              var e5 = this.props, t4 = e5.active, n4 = e5.theme, a3 = e5.rjvId;
              return t4 ? m2.a.createElement(Ie2, { rjvId: a3, theme: n4, isValid: this.isValid, submit: this.submit }) : null;
            } }]), n3;
          }(m2.a.PureComponent), Le2 = function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3() {
              return i2(this, n3), t3.apply(this, arguments);
            }
            return c2(n3, [{ key: "render", value: function() {
              var e5 = this.props, t4 = e5.message, n4 = e5.active, a3 = e5.theme, r3 = e5.rjvId;
              return n4 ? m2.a.createElement("div", Object.assign({ className: "validation-failure" }, A2(a3, "validation-failure"), { onClick: function() {
                z2.dispatch({ rjvId: r3, name: "RESET" });
              } }), m2.a.createElement("span", A2(a3, "validation-failure-label"), t4), m2.a.createElement(ge2, A2(a3, "validation-failure-clear"))) : null;
            } }]), n3;
          }(m2.a.PureComponent), Be2 = function(e4) {
            u2(n3, e4);
            var t3 = h2(n3);
            function n3(e5) {
              var a3;
              return i2(this, n3), (a3 = t3.call(this, e5)).rjvId = Date.now().toString(), a3.getListeners = function() {
                return { reset: a3.resetState, "variable-update": a3.updateSrc, "add-key-request": a3.addKeyRequest };
              }, a3.updateSrc = function() {
                var e6, t4 = q2.get(a3.rjvId, "action", "variable-update"), n4 = t4.name, r3 = t4.namespace, o3 = t4.new_value, i3 = t4.existing_value, s3 = (t4.variable_removed, t4.updated_src), c3 = t4.type, l3 = a3.props, u3 = l3.onEdit, f3 = l3.onDelete, p3 = l3.onAdd, d3 = { existing_src: a3.state.src, new_value: o3, updated_src: s3, name: n4, namespace: r3, existing_value: i3 };
                switch (c3) {
                  case "variable-added":
                    e6 = p3(d3);
                    break;
                  case "variable-edited":
                    e6 = u3(d3);
                    break;
                  case "variable-removed":
                    e6 = f3(d3);
                }
                false !== e6 ? (q2.set(a3.rjvId, "global", "src", s3), a3.setState({ src: s3 })) : a3.setState({ validationFailure: true });
              }, a3.addKeyRequest = function() {
                a3.setState({ addKeyRequest: true });
              }, a3.resetState = function() {
                a3.setState({ validationFailure: false, addKeyRequest: false });
              }, a3.state = { addKeyRequest: false, editKeyRequest: false, validationFailure: false, src: n3.defaultProps.src, name: n3.defaultProps.name, theme: n3.defaultProps.theme, validationMessage: n3.defaultProps.validationMessage, prevSrc: n3.defaultProps.src, prevName: n3.defaultProps.name, prevTheme: n3.defaultProps.theme }, a3;
            }
            return c2(n3, [{ key: "componentDidMount", value: function() {
              q2.set(this.rjvId, "global", "src", this.state.src);
              var e5 = this.getListeners();
              for (var t4 in e5)
                q2.on(t4 + "-" + this.rjvId, e5[t4]);
              this.setState({ addKeyRequest: false, editKeyRequest: false });
            } }, { key: "componentDidUpdate", value: function(e5, t4) {
              false !== t4.addKeyRequest && this.setState({ addKeyRequest: false }), false !== t4.editKeyRequest && this.setState({ editKeyRequest: false }), e5.src !== this.state.src && q2.set(this.rjvId, "global", "src", this.state.src);
            } }, { key: "componentWillUnmount", value: function() {
              var e5 = this.getListeners();
              for (var t4 in e5)
                q2.removeListener(t4 + "-" + this.rjvId, e5[t4]);
            } }, { key: "render", value: function() {
              var e5 = this.state, t4 = e5.validationFailure, n4 = e5.validationMessage, a3 = e5.addKeyRequest, r3 = e5.theme, i3 = e5.src, s3 = e5.name, c3 = this.props, l3 = c3.style, u3 = c3.defaultValue;
              return m2.a.createElement("div", { className: "react-json-view", style: o2(o2({}, A2(r3, "app-container").style), l3) }, m2.a.createElement(Le2, { message: n4, active: t4, theme: r3, rjvId: this.rjvId }), m2.a.createElement(De2, Object.assign({}, this.props, { src: i3, name: s3, theme: r3, type: _2(i3), rjvId: this.rjvId })), m2.a.createElement(Re2, { active: a3, theme: r3, rjvId: this.rjvId, defaultValue: u3 }));
            } }], [{ key: "getDerivedStateFromProps", value: function(e5, t4) {
              if (e5.src !== t4.prevSrc || e5.name !== t4.prevName || e5.theme !== t4.prevTheme) {
                var a3 = { src: e5.src, name: e5.name, theme: e5.theme, validationMessage: e5.validationMessage, prevSrc: e5.src, prevName: e5.name, prevTheme: e5.theme };
                return n3.validateState(a3);
              }
              return null;
            } }]), n3;
          }(m2.a.PureComponent);
          Be2.defaultProps = { src: {}, name: "root", theme: "rjv-default", collapsed: false, collapseStringsAfterLength: false, shouldCollapse: false, sortKeys: false, quotesOnKeys: true, groupArraysAfterLength: 100, indentWidth: 4, enableClipboard: true, displayObjectSize: true, displayDataTypes: true, onEdit: false, onDelete: false, onAdd: false, onSelect: false, iconStyle: "triangle", style: {}, validationMessage: "Validation Error", defaultValue: null, displayArrayKey: true }, Be2.validateState = function(e4) {
            var t3 = {};
            return "object" !== _2(e4.theme) || function(e5) {
              var t4 = ["base00", "base01", "base02", "base03", "base04", "base05", "base06", "base07", "base08", "base09", "base0A", "base0B", "base0C", "base0D", "base0E", "base0F"];
              if ("object" === _2(e5)) {
                for (var n3 = 0; n3 < t4.length; n3++)
                  if (!(t4[n3] in e5))
                    return false;
                return true;
              }
              return false;
            }(e4.theme) || (console.error("react-json-view error:", "theme prop must be a theme name or valid base-16 theme object.", 'defaulting to "rjv-default" theme'), t3.theme = "rjv-default"), "object" !== _2(e4.src) && "array" !== _2(e4.src) && (console.error("react-json-view error:", "src property must be a valid json object"), t3.name = "ERROR", t3.src = { message: "src property must be a valid json object" }), o2(o2({}, e4), t3);
          }, j(Be2);
          t2.default = Be2;
        }]);
      });
    })(main);
    var mainExports = main.exports;
    const ReactJson = /* @__PURE__ */ getDefaultExportFromCjs(mainExports);
    const okaidia = {
      'code[class*="language-"]': {
        "color": "#f8f8f2",
        "background": "none",
        "textShadow": "0 1px rgba(0, 0, 0, 0.3)",
        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "fontSize": "1em",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none"
      },
      'pre[class*="language-"]': {
        "color": "#f8f8f2",
        "background": "#272822",
        "textShadow": "0 1px rgba(0, 0, 0, 0.3)",
        "fontFamily": "Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",
        "fontSize": "1em",
        "textAlign": "left",
        "whiteSpace": "pre",
        "wordSpacing": "normal",
        "wordBreak": "normal",
        "wordWrap": "normal",
        "lineHeight": "1.5",
        "MozTabSize": "4",
        "OTabSize": "4",
        "tabSize": "4",
        "WebkitHyphens": "none",
        "MozHyphens": "none",
        "msHyphens": "none",
        "hyphens": "none",
        "padding": "1em",
        "margin": ".5em 0",
        "overflow": "auto",
        "borderRadius": "0.3em"
      },
      ':not(pre) > code[class*="language-"]': {
        "background": "#272822",
        "padding": ".1em",
        "borderRadius": ".3em",
        "whiteSpace": "normal"
      },
      "comment": {
        "color": "#8292a2"
      },
      "prolog": {
        "color": "#8292a2"
      },
      "doctype": {
        "color": "#8292a2"
      },
      "cdata": {
        "color": "#8292a2"
      },
      "punctuation": {
        "color": "#f8f8f2"
      },
      "namespace": {
        "Opacity": ".7"
      },
      "property": {
        "color": "#f92672"
      },
      "tag": {
        "color": "#f92672"
      },
      "constant": {
        "color": "#f92672"
      },
      "symbol": {
        "color": "#f92672"
      },
      "deleted": {
        "color": "#f92672"
      },
      "boolean": {
        "color": "#ae81ff"
      },
      "number": {
        "color": "#ae81ff"
      },
      "selector": {
        "color": "#a6e22e"
      },
      "attr-name": {
        "color": "#a6e22e"
      },
      "string": {
        "color": "#a6e22e"
      },
      "char": {
        "color": "#a6e22e"
      },
      "builtin": {
        "color": "#a6e22e"
      },
      "inserted": {
        "color": "#a6e22e"
      },
      "operator": {
        "color": "#f8f8f2"
      },
      "entity": {
        "color": "#f8f8f2",
        "cursor": "help"
      },
      "url": {
        "color": "#f8f8f2"
      },
      ".language-css .token.string": {
        "color": "#f8f8f2"
      },
      ".style .token.string": {
        "color": "#f8f8f2"
      },
      "variable": {
        "color": "#f8f8f2"
      },
      "atrule": {
        "color": "#e6db74"
      },
      "attr-value": {
        "color": "#e6db74"
      },
      "function": {
        "color": "#e6db74"
      },
      "class-name": {
        "color": "#e6db74"
      },
      "keyword": {
        "color": "#66d9ef"
      },
      "regex": {
        "color": "#fd971f"
      },
      "important": {
        "color": "#fd971f",
        "fontWeight": "bold"
      },
      "bold": {
        "fontWeight": "bold"
      },
      "italic": {
        "fontStyle": "italic"
      }
    };
    var unicode$3 = {};
    const UNDEFINED_CODE_POINTS = [
      65534,
      65535,
      131070,
      131071,
      196606,
      196607,
      262142,
      262143,
      327678,
      327679,
      393214,
      393215,
      458750,
      458751,
      524286,
      524287,
      589822,
      589823,
      655358,
      655359,
      720894,
      720895,
      786430,
      786431,
      851966,
      851967,
      917502,
      917503,
      983038,
      983039,
      1048574,
      1048575,
      1114110,
      1114111
    ];
    unicode$3.REPLACEMENT_CHARACTER = "�";
    unicode$3.CODE_POINTS = {
      EOF: -1,
      NULL: 0,
      TABULATION: 9,
      CARRIAGE_RETURN: 13,
      LINE_FEED: 10,
      FORM_FEED: 12,
      SPACE: 32,
      EXCLAMATION_MARK: 33,
      QUOTATION_MARK: 34,
      NUMBER_SIGN: 35,
      AMPERSAND: 38,
      APOSTROPHE: 39,
      HYPHEN_MINUS: 45,
      SOLIDUS: 47,
      DIGIT_0: 48,
      DIGIT_9: 57,
      SEMICOLON: 59,
      LESS_THAN_SIGN: 60,
      EQUALS_SIGN: 61,
      GREATER_THAN_SIGN: 62,
      QUESTION_MARK: 63,
      LATIN_CAPITAL_A: 65,
      LATIN_CAPITAL_F: 70,
      LATIN_CAPITAL_X: 88,
      LATIN_CAPITAL_Z: 90,
      RIGHT_SQUARE_BRACKET: 93,
      GRAVE_ACCENT: 96,
      LATIN_SMALL_A: 97,
      LATIN_SMALL_F: 102,
      LATIN_SMALL_X: 120,
      LATIN_SMALL_Z: 122,
      REPLACEMENT_CHARACTER: 65533
    };
    unicode$3.CODE_POINT_SEQUENCES = {
      DASH_DASH_STRING: [45, 45],
      //--
      DOCTYPE_STRING: [68, 79, 67, 84, 89, 80, 69],
      //DOCTYPE
      CDATA_START_STRING: [91, 67, 68, 65, 84, 65, 91],
      //[CDATA[
      SCRIPT_STRING: [115, 99, 114, 105, 112, 116],
      //script
      PUBLIC_STRING: [80, 85, 66, 76, 73, 67],
      //PUBLIC
      SYSTEM_STRING: [83, 89, 83, 84, 69, 77]
      //SYSTEM
    };
    unicode$3.isSurrogate = function(cp) {
      return cp >= 55296 && cp <= 57343;
    };
    unicode$3.isSurrogatePair = function(cp) {
      return cp >= 56320 && cp <= 57343;
    };
    unicode$3.getSurrogatePairCodePoint = function(cp1, cp2) {
      return (cp1 - 55296) * 1024 + 9216 + cp2;
    };
    unicode$3.isControlCodePoint = function(cp) {
      return cp !== 32 && cp !== 10 && cp !== 13 && cp !== 9 && cp !== 12 && cp >= 1 && cp <= 31 || cp >= 127 && cp <= 159;
    };
    unicode$3.isUndefinedCodePoint = function(cp) {
      return cp >= 64976 && cp <= 65007 || UNDEFINED_CODE_POINTS.indexOf(cp) > -1;
    };
    var errorCodes = {
      controlCharacterInInputStream: "control-character-in-input-stream",
      noncharacterInInputStream: "noncharacter-in-input-stream",
      surrogateInInputStream: "surrogate-in-input-stream",
      nonVoidHtmlElementStartTagWithTrailingSolidus: "non-void-html-element-start-tag-with-trailing-solidus",
      endTagWithAttributes: "end-tag-with-attributes",
      endTagWithTrailingSolidus: "end-tag-with-trailing-solidus",
      unexpectedSolidusInTag: "unexpected-solidus-in-tag",
      unexpectedNullCharacter: "unexpected-null-character",
      unexpectedQuestionMarkInsteadOfTagName: "unexpected-question-mark-instead-of-tag-name",
      invalidFirstCharacterOfTagName: "invalid-first-character-of-tag-name",
      unexpectedEqualsSignBeforeAttributeName: "unexpected-equals-sign-before-attribute-name",
      missingEndTagName: "missing-end-tag-name",
      unexpectedCharacterInAttributeName: "unexpected-character-in-attribute-name",
      unknownNamedCharacterReference: "unknown-named-character-reference",
      missingSemicolonAfterCharacterReference: "missing-semicolon-after-character-reference",
      unexpectedCharacterAfterDoctypeSystemIdentifier: "unexpected-character-after-doctype-system-identifier",
      unexpectedCharacterInUnquotedAttributeValue: "unexpected-character-in-unquoted-attribute-value",
      eofBeforeTagName: "eof-before-tag-name",
      eofInTag: "eof-in-tag",
      missingAttributeValue: "missing-attribute-value",
      missingWhitespaceBetweenAttributes: "missing-whitespace-between-attributes",
      missingWhitespaceAfterDoctypePublicKeyword: "missing-whitespace-after-doctype-public-keyword",
      missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers: "missing-whitespace-between-doctype-public-and-system-identifiers",
      missingWhitespaceAfterDoctypeSystemKeyword: "missing-whitespace-after-doctype-system-keyword",
      missingQuoteBeforeDoctypePublicIdentifier: "missing-quote-before-doctype-public-identifier",
      missingQuoteBeforeDoctypeSystemIdentifier: "missing-quote-before-doctype-system-identifier",
      missingDoctypePublicIdentifier: "missing-doctype-public-identifier",
      missingDoctypeSystemIdentifier: "missing-doctype-system-identifier",
      abruptDoctypePublicIdentifier: "abrupt-doctype-public-identifier",
      abruptDoctypeSystemIdentifier: "abrupt-doctype-system-identifier",
      cdataInHtmlContent: "cdata-in-html-content",
      incorrectlyOpenedComment: "incorrectly-opened-comment",
      eofInScriptHtmlCommentLikeText: "eof-in-script-html-comment-like-text",
      eofInDoctype: "eof-in-doctype",
      nestedComment: "nested-comment",
      abruptClosingOfEmptyComment: "abrupt-closing-of-empty-comment",
      eofInComment: "eof-in-comment",
      incorrectlyClosedComment: "incorrectly-closed-comment",
      eofInCdata: "eof-in-cdata",
      absenceOfDigitsInNumericCharacterReference: "absence-of-digits-in-numeric-character-reference",
      nullCharacterReference: "null-character-reference",
      surrogateCharacterReference: "surrogate-character-reference",
      characterReferenceOutsideUnicodeRange: "character-reference-outside-unicode-range",
      controlCharacterReference: "control-character-reference",
      noncharacterCharacterReference: "noncharacter-character-reference",
      missingWhitespaceBeforeDoctypeName: "missing-whitespace-before-doctype-name",
      missingDoctypeName: "missing-doctype-name",
      invalidCharacterSequenceAfterDoctypeName: "invalid-character-sequence-after-doctype-name",
      duplicateAttribute: "duplicate-attribute",
      nonConformingDoctype: "non-conforming-doctype",
      missingDoctype: "missing-doctype",
      misplacedDoctype: "misplaced-doctype",
      endTagWithoutMatchingOpenElement: "end-tag-without-matching-open-element",
      closingOfElementWithOpenChildElements: "closing-of-element-with-open-child-elements",
      disallowedContentInNoscriptInHead: "disallowed-content-in-noscript-in-head",
      openElementsLeftAfterEof: "open-elements-left-after-eof",
      abandonedHeadElementChild: "abandoned-head-element-child",
      misplacedStartTagForHeadElement: "misplaced-start-tag-for-head-element",
      nestedNoscriptInHead: "nested-noscript-in-head",
      eofInElementThatCanContainOnlyText: "eof-in-element-that-can-contain-only-text"
    };
    const unicode$2 = unicode$3;
    const ERR$2 = errorCodes;
    const $$6 = unicode$2.CODE_POINTS;
    const DEFAULT_BUFFER_WATERLINE = 1 << 16;
    let Preprocessor$1 = class Preprocessor {
      constructor() {
        this.html = null;
        this.pos = -1;
        this.lastGapPos = -1;
        this.lastCharPos = -1;
        this.gapStack = [];
        this.skipNextNewLine = false;
        this.lastChunkWritten = false;
        this.endOfChunkHit = false;
        this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;
      }
      _err() {
      }
      _addGap() {
        this.gapStack.push(this.lastGapPos);
        this.lastGapPos = this.pos;
      }
      _processSurrogate(cp) {
        if (this.pos !== this.lastCharPos) {
          const nextCp = this.html.charCodeAt(this.pos + 1);
          if (unicode$2.isSurrogatePair(nextCp)) {
            this.pos++;
            this._addGap();
            return unicode$2.getSurrogatePairCodePoint(cp, nextCp);
          }
        } else if (!this.lastChunkWritten) {
          this.endOfChunkHit = true;
          return $$6.EOF;
        }
        this._err(ERR$2.surrogateInInputStream);
        return cp;
      }
      dropParsedChunk() {
        if (this.pos > this.bufferWaterline) {
          this.lastCharPos -= this.pos;
          this.html = this.html.substring(this.pos);
          this.pos = 0;
          this.lastGapPos = -1;
          this.gapStack = [];
        }
      }
      write(chunk, isLastChunk) {
        if (this.html) {
          this.html += chunk;
        } else {
          this.html = chunk;
        }
        this.lastCharPos = this.html.length - 1;
        this.endOfChunkHit = false;
        this.lastChunkWritten = isLastChunk;
      }
      insertHtmlAtCurrentPos(chunk) {
        this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1, this.html.length);
        this.lastCharPos = this.html.length - 1;
        this.endOfChunkHit = false;
      }
      advance() {
        this.pos++;
        if (this.pos > this.lastCharPos) {
          this.endOfChunkHit = !this.lastChunkWritten;
          return $$6.EOF;
        }
        let cp = this.html.charCodeAt(this.pos);
        if (this.skipNextNewLine && cp === $$6.LINE_FEED) {
          this.skipNextNewLine = false;
          this._addGap();
          return this.advance();
        }
        if (cp === $$6.CARRIAGE_RETURN) {
          this.skipNextNewLine = true;
          return $$6.LINE_FEED;
        }
        this.skipNextNewLine = false;
        if (unicode$2.isSurrogate(cp)) {
          cp = this._processSurrogate(cp);
        }
        const isCommonValidRange = cp > 31 && cp < 127 || cp === $$6.LINE_FEED || cp === $$6.CARRIAGE_RETURN || cp > 159 && cp < 64976;
        if (!isCommonValidRange) {
          this._checkForProblematicCharacters(cp);
        }
        return cp;
      }
      _checkForProblematicCharacters(cp) {
        if (unicode$2.isControlCodePoint(cp)) {
          this._err(ERR$2.controlCharacterInInputStream);
        } else if (unicode$2.isUndefinedCodePoint(cp)) {
          this._err(ERR$2.noncharacterInInputStream);
        }
      }
      retreat() {
        if (this.pos === this.lastGapPos) {
          this.lastGapPos = this.gapStack.pop();
          this.pos--;
        }
        this.pos--;
      }
    };
    var preprocessor = Preprocessor$1;
    var namedEntityData = new Uint16Array([4, 52, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 106, 303, 412, 810, 1432, 1701, 1796, 1987, 2114, 2360, 2420, 2484, 3170, 3251, 4140, 4393, 4575, 4610, 5106, 5512, 5728, 6117, 6274, 6315, 6345, 6427, 6516, 7002, 7910, 8733, 9323, 9870, 10170, 10631, 10893, 11318, 11386, 11467, 12773, 13092, 14474, 14922, 15448, 15542, 16419, 17666, 18166, 18611, 19004, 19095, 19298, 19397, 4, 16, 69, 77, 97, 98, 99, 102, 103, 108, 109, 110, 111, 112, 114, 115, 116, 117, 140, 150, 158, 169, 176, 194, 199, 210, 216, 222, 226, 242, 256, 266, 283, 294, 108, 105, 103, 5, 198, 1, 59, 148, 1, 198, 80, 5, 38, 1, 59, 156, 1, 38, 99, 117, 116, 101, 5, 193, 1, 59, 167, 1, 193, 114, 101, 118, 101, 59, 1, 258, 4, 2, 105, 121, 182, 191, 114, 99, 5, 194, 1, 59, 189, 1, 194, 59, 1, 1040, 114, 59, 3, 55349, 56580, 114, 97, 118, 101, 5, 192, 1, 59, 208, 1, 192, 112, 104, 97, 59, 1, 913, 97, 99, 114, 59, 1, 256, 100, 59, 1, 10835, 4, 2, 103, 112, 232, 237, 111, 110, 59, 1, 260, 102, 59, 3, 55349, 56632, 112, 108, 121, 70, 117, 110, 99, 116, 105, 111, 110, 59, 1, 8289, 105, 110, 103, 5, 197, 1, 59, 264, 1, 197, 4, 2, 99, 115, 272, 277, 114, 59, 3, 55349, 56476, 105, 103, 110, 59, 1, 8788, 105, 108, 100, 101, 5, 195, 1, 59, 292, 1, 195, 109, 108, 5, 196, 1, 59, 301, 1, 196, 4, 8, 97, 99, 101, 102, 111, 114, 115, 117, 321, 350, 354, 383, 388, 394, 400, 405, 4, 2, 99, 114, 327, 336, 107, 115, 108, 97, 115, 104, 59, 1, 8726, 4, 2, 118, 119, 342, 345, 59, 1, 10983, 101, 100, 59, 1, 8966, 121, 59, 1, 1041, 4, 3, 99, 114, 116, 362, 369, 379, 97, 117, 115, 101, 59, 1, 8757, 110, 111, 117, 108, 108, 105, 115, 59, 1, 8492, 97, 59, 1, 914, 114, 59, 3, 55349, 56581, 112, 102, 59, 3, 55349, 56633, 101, 118, 101, 59, 1, 728, 99, 114, 59, 1, 8492, 109, 112, 101, 113, 59, 1, 8782, 4, 14, 72, 79, 97, 99, 100, 101, 102, 104, 105, 108, 111, 114, 115, 117, 442, 447, 456, 504, 542, 547, 569, 573, 577, 616, 678, 784, 790, 796, 99, 121, 59, 1, 1063, 80, 89, 5, 169, 1, 59, 454, 1, 169, 4, 3, 99, 112, 121, 464, 470, 497, 117, 116, 101, 59, 1, 262, 4, 2, 59, 105, 476, 478, 1, 8914, 116, 97, 108, 68, 105, 102, 102, 101, 114, 101, 110, 116, 105, 97, 108, 68, 59, 1, 8517, 108, 101, 121, 115, 59, 1, 8493, 4, 4, 97, 101, 105, 111, 514, 520, 530, 535, 114, 111, 110, 59, 1, 268, 100, 105, 108, 5, 199, 1, 59, 528, 1, 199, 114, 99, 59, 1, 264, 110, 105, 110, 116, 59, 1, 8752, 111, 116, 59, 1, 266, 4, 2, 100, 110, 553, 560, 105, 108, 108, 97, 59, 1, 184, 116, 101, 114, 68, 111, 116, 59, 1, 183, 114, 59, 1, 8493, 105, 59, 1, 935, 114, 99, 108, 101, 4, 4, 68, 77, 80, 84, 591, 596, 603, 609, 111, 116, 59, 1, 8857, 105, 110, 117, 115, 59, 1, 8854, 108, 117, 115, 59, 1, 8853, 105, 109, 101, 115, 59, 1, 8855, 111, 4, 2, 99, 115, 623, 646, 107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8754, 101, 67, 117, 114, 108, 121, 4, 2, 68, 81, 658, 671, 111, 117, 98, 108, 101, 81, 117, 111, 116, 101, 59, 1, 8221, 117, 111, 116, 101, 59, 1, 8217, 4, 4, 108, 110, 112, 117, 688, 701, 736, 753, 111, 110, 4, 2, 59, 101, 696, 698, 1, 8759, 59, 1, 10868, 4, 3, 103, 105, 116, 709, 717, 722, 114, 117, 101, 110, 116, 59, 1, 8801, 110, 116, 59, 1, 8751, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8750, 4, 2, 102, 114, 742, 745, 59, 1, 8450, 111, 100, 117, 99, 116, 59, 1, 8720, 110, 116, 101, 114, 67, 108, 111, 99, 107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8755, 111, 115, 115, 59, 1, 10799, 99, 114, 59, 3, 55349, 56478, 112, 4, 2, 59, 67, 803, 805, 1, 8915, 97, 112, 59, 1, 8781, 4, 11, 68, 74, 83, 90, 97, 99, 101, 102, 105, 111, 115, 834, 850, 855, 860, 865, 888, 903, 916, 921, 1011, 1415, 4, 2, 59, 111, 840, 842, 1, 8517, 116, 114, 97, 104, 100, 59, 1, 10513, 99, 121, 59, 1, 1026, 99, 121, 59, 1, 1029, 99, 121, 59, 1, 1039, 4, 3, 103, 114, 115, 873, 879, 883, 103, 101, 114, 59, 1, 8225, 114, 59, 1, 8609, 104, 118, 59, 1, 10980, 4, 2, 97, 121, 894, 900, 114, 111, 110, 59, 1, 270, 59, 1, 1044, 108, 4, 2, 59, 116, 910, 912, 1, 8711, 97, 59, 1, 916, 114, 59, 3, 55349, 56583, 4, 2, 97, 102, 927, 998, 4, 2, 99, 109, 933, 992, 114, 105, 116, 105, 99, 97, 108, 4, 4, 65, 68, 71, 84, 950, 957, 978, 985, 99, 117, 116, 101, 59, 1, 180, 111, 4, 2, 116, 117, 964, 967, 59, 1, 729, 98, 108, 101, 65, 99, 117, 116, 101, 59, 1, 733, 114, 97, 118, 101, 59, 1, 96, 105, 108, 100, 101, 59, 1, 732, 111, 110, 100, 59, 1, 8900, 102, 101, 114, 101, 110, 116, 105, 97, 108, 68, 59, 1, 8518, 4, 4, 112, 116, 117, 119, 1021, 1026, 1048, 1249, 102, 59, 3, 55349, 56635, 4, 3, 59, 68, 69, 1034, 1036, 1041, 1, 168, 111, 116, 59, 1, 8412, 113, 117, 97, 108, 59, 1, 8784, 98, 108, 101, 4, 6, 67, 68, 76, 82, 85, 86, 1065, 1082, 1101, 1189, 1211, 1236, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8751, 111, 4, 2, 116, 119, 1089, 1092, 59, 1, 168, 110, 65, 114, 114, 111, 119, 59, 1, 8659, 4, 2, 101, 111, 1107, 1141, 102, 116, 4, 3, 65, 82, 84, 1117, 1124, 1136, 114, 114, 111, 119, 59, 1, 8656, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8660, 101, 101, 59, 1, 10980, 110, 103, 4, 2, 76, 82, 1149, 1177, 101, 102, 116, 4, 2, 65, 82, 1158, 1165, 114, 114, 111, 119, 59, 1, 10232, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10234, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10233, 105, 103, 104, 116, 4, 2, 65, 84, 1199, 1206, 114, 114, 111, 119, 59, 1, 8658, 101, 101, 59, 1, 8872, 112, 4, 2, 65, 68, 1218, 1225, 114, 114, 111, 119, 59, 1, 8657, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8661, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 1, 8741, 110, 4, 6, 65, 66, 76, 82, 84, 97, 1264, 1292, 1299, 1352, 1391, 1408, 114, 114, 111, 119, 4, 3, 59, 66, 85, 1276, 1278, 1283, 1, 8595, 97, 114, 59, 1, 10515, 112, 65, 114, 114, 111, 119, 59, 1, 8693, 114, 101, 118, 101, 59, 1, 785, 101, 102, 116, 4, 3, 82, 84, 86, 1310, 1323, 1334, 105, 103, 104, 116, 86, 101, 99, 116, 111, 114, 59, 1, 10576, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10590, 101, 99, 116, 111, 114, 4, 2, 59, 66, 1345, 1347, 1, 8637, 97, 114, 59, 1, 10582, 105, 103, 104, 116, 4, 2, 84, 86, 1362, 1373, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10591, 101, 99, 116, 111, 114, 4, 2, 59, 66, 1384, 1386, 1, 8641, 97, 114, 59, 1, 10583, 101, 101, 4, 2, 59, 65, 1399, 1401, 1, 8868, 114, 114, 111, 119, 59, 1, 8615, 114, 114, 111, 119, 59, 1, 8659, 4, 2, 99, 116, 1421, 1426, 114, 59, 3, 55349, 56479, 114, 111, 107, 59, 1, 272, 4, 16, 78, 84, 97, 99, 100, 102, 103, 108, 109, 111, 112, 113, 115, 116, 117, 120, 1466, 1470, 1478, 1489, 1515, 1520, 1525, 1536, 1544, 1593, 1609, 1617, 1650, 1664, 1668, 1677, 71, 59, 1, 330, 72, 5, 208, 1, 59, 1476, 1, 208, 99, 117, 116, 101, 5, 201, 1, 59, 1487, 1, 201, 4, 3, 97, 105, 121, 1497, 1503, 1512, 114, 111, 110, 59, 1, 282, 114, 99, 5, 202, 1, 59, 1510, 1, 202, 59, 1, 1069, 111, 116, 59, 1, 278, 114, 59, 3, 55349, 56584, 114, 97, 118, 101, 5, 200, 1, 59, 1534, 1, 200, 101, 109, 101, 110, 116, 59, 1, 8712, 4, 2, 97, 112, 1550, 1555, 99, 114, 59, 1, 274, 116, 121, 4, 2, 83, 86, 1563, 1576, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9723, 101, 114, 121, 83, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9643, 4, 2, 103, 112, 1599, 1604, 111, 110, 59, 1, 280, 102, 59, 3, 55349, 56636, 115, 105, 108, 111, 110, 59, 1, 917, 117, 4, 2, 97, 105, 1624, 1640, 108, 4, 2, 59, 84, 1631, 1633, 1, 10869, 105, 108, 100, 101, 59, 1, 8770, 108, 105, 98, 114, 105, 117, 109, 59, 1, 8652, 4, 2, 99, 105, 1656, 1660, 114, 59, 1, 8496, 109, 59, 1, 10867, 97, 59, 1, 919, 109, 108, 5, 203, 1, 59, 1675, 1, 203, 4, 2, 105, 112, 1683, 1689, 115, 116, 115, 59, 1, 8707, 111, 110, 101, 110, 116, 105, 97, 108, 69, 59, 1, 8519, 4, 5, 99, 102, 105, 111, 115, 1713, 1717, 1722, 1762, 1791, 121, 59, 1, 1060, 114, 59, 3, 55349, 56585, 108, 108, 101, 100, 4, 2, 83, 86, 1732, 1745, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9724, 101, 114, 121, 83, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9642, 4, 3, 112, 114, 117, 1770, 1775, 1781, 102, 59, 3, 55349, 56637, 65, 108, 108, 59, 1, 8704, 114, 105, 101, 114, 116, 114, 102, 59, 1, 8497, 99, 114, 59, 1, 8497, 4, 12, 74, 84, 97, 98, 99, 100, 102, 103, 111, 114, 115, 116, 1822, 1827, 1834, 1848, 1855, 1877, 1882, 1887, 1890, 1896, 1978, 1984, 99, 121, 59, 1, 1027, 5, 62, 1, 59, 1832, 1, 62, 109, 109, 97, 4, 2, 59, 100, 1843, 1845, 1, 915, 59, 1, 988, 114, 101, 118, 101, 59, 1, 286, 4, 3, 101, 105, 121, 1863, 1869, 1874, 100, 105, 108, 59, 1, 290, 114, 99, 59, 1, 284, 59, 1, 1043, 111, 116, 59, 1, 288, 114, 59, 3, 55349, 56586, 59, 1, 8921, 112, 102, 59, 3, 55349, 56638, 101, 97, 116, 101, 114, 4, 6, 69, 70, 71, 76, 83, 84, 1915, 1933, 1944, 1953, 1959, 1971, 113, 117, 97, 108, 4, 2, 59, 76, 1925, 1927, 1, 8805, 101, 115, 115, 59, 1, 8923, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8807, 114, 101, 97, 116, 101, 114, 59, 1, 10914, 101, 115, 115, 59, 1, 8823, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 10878, 105, 108, 100, 101, 59, 1, 8819, 99, 114, 59, 3, 55349, 56482, 59, 1, 8811, 4, 8, 65, 97, 99, 102, 105, 111, 115, 117, 2005, 2012, 2026, 2032, 2036, 2049, 2073, 2089, 82, 68, 99, 121, 59, 1, 1066, 4, 2, 99, 116, 2018, 2023, 101, 107, 59, 1, 711, 59, 1, 94, 105, 114, 99, 59, 1, 292, 114, 59, 1, 8460, 108, 98, 101, 114, 116, 83, 112, 97, 99, 101, 59, 1, 8459, 4, 2, 112, 114, 2055, 2059, 102, 59, 1, 8461, 105, 122, 111, 110, 116, 97, 108, 76, 105, 110, 101, 59, 1, 9472, 4, 2, 99, 116, 2079, 2083, 114, 59, 1, 8459, 114, 111, 107, 59, 1, 294, 109, 112, 4, 2, 68, 69, 2097, 2107, 111, 119, 110, 72, 117, 109, 112, 59, 1, 8782, 113, 117, 97, 108, 59, 1, 8783, 4, 14, 69, 74, 79, 97, 99, 100, 102, 103, 109, 110, 111, 115, 116, 117, 2144, 2149, 2155, 2160, 2171, 2189, 2194, 2198, 2209, 2245, 2307, 2329, 2334, 2341, 99, 121, 59, 1, 1045, 108, 105, 103, 59, 1, 306, 99, 121, 59, 1, 1025, 99, 117, 116, 101, 5, 205, 1, 59, 2169, 1, 205, 4, 2, 105, 121, 2177, 2186, 114, 99, 5, 206, 1, 59, 2184, 1, 206, 59, 1, 1048, 111, 116, 59, 1, 304, 114, 59, 1, 8465, 114, 97, 118, 101, 5, 204, 1, 59, 2207, 1, 204, 4, 3, 59, 97, 112, 2217, 2219, 2238, 1, 8465, 4, 2, 99, 103, 2225, 2229, 114, 59, 1, 298, 105, 110, 97, 114, 121, 73, 59, 1, 8520, 108, 105, 101, 115, 59, 1, 8658, 4, 2, 116, 118, 2251, 2281, 4, 2, 59, 101, 2257, 2259, 1, 8748, 4, 2, 103, 114, 2265, 2271, 114, 97, 108, 59, 1, 8747, 115, 101, 99, 116, 105, 111, 110, 59, 1, 8898, 105, 115, 105, 98, 108, 101, 4, 2, 67, 84, 2293, 2300, 111, 109, 109, 97, 59, 1, 8291, 105, 109, 101, 115, 59, 1, 8290, 4, 3, 103, 112, 116, 2315, 2320, 2325, 111, 110, 59, 1, 302, 102, 59, 3, 55349, 56640, 97, 59, 1, 921, 99, 114, 59, 1, 8464, 105, 108, 100, 101, 59, 1, 296, 4, 2, 107, 109, 2347, 2352, 99, 121, 59, 1, 1030, 108, 5, 207, 1, 59, 2358, 1, 207, 4, 5, 99, 102, 111, 115, 117, 2372, 2386, 2391, 2397, 2414, 4, 2, 105, 121, 2378, 2383, 114, 99, 59, 1, 308, 59, 1, 1049, 114, 59, 3, 55349, 56589, 112, 102, 59, 3, 55349, 56641, 4, 2, 99, 101, 2403, 2408, 114, 59, 3, 55349, 56485, 114, 99, 121, 59, 1, 1032, 107, 99, 121, 59, 1, 1028, 4, 7, 72, 74, 97, 99, 102, 111, 115, 2436, 2441, 2446, 2452, 2467, 2472, 2478, 99, 121, 59, 1, 1061, 99, 121, 59, 1, 1036, 112, 112, 97, 59, 1, 922, 4, 2, 101, 121, 2458, 2464, 100, 105, 108, 59, 1, 310, 59, 1, 1050, 114, 59, 3, 55349, 56590, 112, 102, 59, 3, 55349, 56642, 99, 114, 59, 3, 55349, 56486, 4, 11, 74, 84, 97, 99, 101, 102, 108, 109, 111, 115, 116, 2508, 2513, 2520, 2562, 2585, 2981, 2986, 3004, 3011, 3146, 3167, 99, 121, 59, 1, 1033, 5, 60, 1, 59, 2518, 1, 60, 4, 5, 99, 109, 110, 112, 114, 2532, 2538, 2544, 2548, 2558, 117, 116, 101, 59, 1, 313, 98, 100, 97, 59, 1, 923, 103, 59, 1, 10218, 108, 97, 99, 101, 116, 114, 102, 59, 1, 8466, 114, 59, 1, 8606, 4, 3, 97, 101, 121, 2570, 2576, 2582, 114, 111, 110, 59, 1, 317, 100, 105, 108, 59, 1, 315, 59, 1, 1051, 4, 2, 102, 115, 2591, 2907, 116, 4, 10, 65, 67, 68, 70, 82, 84, 85, 86, 97, 114, 2614, 2663, 2672, 2728, 2735, 2760, 2820, 2870, 2888, 2895, 4, 2, 110, 114, 2620, 2633, 103, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10216, 114, 111, 119, 4, 3, 59, 66, 82, 2644, 2646, 2651, 1, 8592, 97, 114, 59, 1, 8676, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8646, 101, 105, 108, 105, 110, 103, 59, 1, 8968, 111, 4, 2, 117, 119, 2679, 2692, 98, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10214, 110, 4, 2, 84, 86, 2699, 2710, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10593, 101, 99, 116, 111, 114, 4, 2, 59, 66, 2721, 2723, 1, 8643, 97, 114, 59, 1, 10585, 108, 111, 111, 114, 59, 1, 8970, 105, 103, 104, 116, 4, 2, 65, 86, 2745, 2752, 114, 114, 111, 119, 59, 1, 8596, 101, 99, 116, 111, 114, 59, 1, 10574, 4, 2, 101, 114, 2766, 2792, 101, 4, 3, 59, 65, 86, 2775, 2777, 2784, 1, 8867, 114, 114, 111, 119, 59, 1, 8612, 101, 99, 116, 111, 114, 59, 1, 10586, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 2806, 2808, 2813, 1, 8882, 97, 114, 59, 1, 10703, 113, 117, 97, 108, 59, 1, 8884, 112, 4, 3, 68, 84, 86, 2829, 2841, 2852, 111, 119, 110, 86, 101, 99, 116, 111, 114, 59, 1, 10577, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10592, 101, 99, 116, 111, 114, 4, 2, 59, 66, 2863, 2865, 1, 8639, 97, 114, 59, 1, 10584, 101, 99, 116, 111, 114, 4, 2, 59, 66, 2881, 2883, 1, 8636, 97, 114, 59, 1, 10578, 114, 114, 111, 119, 59, 1, 8656, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8660, 115, 4, 6, 69, 70, 71, 76, 83, 84, 2922, 2936, 2947, 2956, 2962, 2974, 113, 117, 97, 108, 71, 114, 101, 97, 116, 101, 114, 59, 1, 8922, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8806, 114, 101, 97, 116, 101, 114, 59, 1, 8822, 101, 115, 115, 59, 1, 10913, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 10877, 105, 108, 100, 101, 59, 1, 8818, 114, 59, 3, 55349, 56591, 4, 2, 59, 101, 2992, 2994, 1, 8920, 102, 116, 97, 114, 114, 111, 119, 59, 1, 8666, 105, 100, 111, 116, 59, 1, 319, 4, 3, 110, 112, 119, 3019, 3110, 3115, 103, 4, 4, 76, 82, 108, 114, 3030, 3058, 3070, 3098, 101, 102, 116, 4, 2, 65, 82, 3039, 3046, 114, 114, 111, 119, 59, 1, 10229, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10231, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10230, 101, 102, 116, 4, 2, 97, 114, 3079, 3086, 114, 114, 111, 119, 59, 1, 10232, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10234, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10233, 102, 59, 3, 55349, 56643, 101, 114, 4, 2, 76, 82, 3123, 3134, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8601, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8600, 4, 3, 99, 104, 116, 3154, 3158, 3161, 114, 59, 1, 8466, 59, 1, 8624, 114, 111, 107, 59, 1, 321, 59, 1, 8810, 4, 8, 97, 99, 101, 102, 105, 111, 115, 117, 3188, 3192, 3196, 3222, 3227, 3237, 3243, 3248, 112, 59, 1, 10501, 121, 59, 1, 1052, 4, 2, 100, 108, 3202, 3213, 105, 117, 109, 83, 112, 97, 99, 101, 59, 1, 8287, 108, 105, 110, 116, 114, 102, 59, 1, 8499, 114, 59, 3, 55349, 56592, 110, 117, 115, 80, 108, 117, 115, 59, 1, 8723, 112, 102, 59, 3, 55349, 56644, 99, 114, 59, 1, 8499, 59, 1, 924, 4, 9, 74, 97, 99, 101, 102, 111, 115, 116, 117, 3271, 3276, 3283, 3306, 3422, 3427, 4120, 4126, 4137, 99, 121, 59, 1, 1034, 99, 117, 116, 101, 59, 1, 323, 4, 3, 97, 101, 121, 3291, 3297, 3303, 114, 111, 110, 59, 1, 327, 100, 105, 108, 59, 1, 325, 59, 1, 1053, 4, 3, 103, 115, 119, 3314, 3380, 3415, 97, 116, 105, 118, 101, 4, 3, 77, 84, 86, 3327, 3340, 3365, 101, 100, 105, 117, 109, 83, 112, 97, 99, 101, 59, 1, 8203, 104, 105, 4, 2, 99, 110, 3348, 3357, 107, 83, 112, 97, 99, 101, 59, 1, 8203, 83, 112, 97, 99, 101, 59, 1, 8203, 101, 114, 121, 84, 104, 105, 110, 83, 112, 97, 99, 101, 59, 1, 8203, 116, 101, 100, 4, 2, 71, 76, 3389, 3405, 114, 101, 97, 116, 101, 114, 71, 114, 101, 97, 116, 101, 114, 59, 1, 8811, 101, 115, 115, 76, 101, 115, 115, 59, 1, 8810, 76, 105, 110, 101, 59, 1, 10, 114, 59, 3, 55349, 56593, 4, 4, 66, 110, 112, 116, 3437, 3444, 3460, 3464, 114, 101, 97, 107, 59, 1, 8288, 66, 114, 101, 97, 107, 105, 110, 103, 83, 112, 97, 99, 101, 59, 1, 160, 102, 59, 1, 8469, 4, 13, 59, 67, 68, 69, 71, 72, 76, 78, 80, 82, 83, 84, 86, 3492, 3494, 3517, 3536, 3578, 3657, 3685, 3784, 3823, 3860, 3915, 4066, 4107, 1, 10988, 4, 2, 111, 117, 3500, 3510, 110, 103, 114, 117, 101, 110, 116, 59, 1, 8802, 112, 67, 97, 112, 59, 1, 8813, 111, 117, 98, 108, 101, 86, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 1, 8742, 4, 3, 108, 113, 120, 3544, 3552, 3571, 101, 109, 101, 110, 116, 59, 1, 8713, 117, 97, 108, 4, 2, 59, 84, 3561, 3563, 1, 8800, 105, 108, 100, 101, 59, 3, 8770, 824, 105, 115, 116, 115, 59, 1, 8708, 114, 101, 97, 116, 101, 114, 4, 7, 59, 69, 70, 71, 76, 83, 84, 3600, 3602, 3609, 3621, 3631, 3637, 3650, 1, 8815, 113, 117, 97, 108, 59, 1, 8817, 117, 108, 108, 69, 113, 117, 97, 108, 59, 3, 8807, 824, 114, 101, 97, 116, 101, 114, 59, 3, 8811, 824, 101, 115, 115, 59, 1, 8825, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 3, 10878, 824, 105, 108, 100, 101, 59, 1, 8821, 117, 109, 112, 4, 2, 68, 69, 3666, 3677, 111, 119, 110, 72, 117, 109, 112, 59, 3, 8782, 824, 113, 117, 97, 108, 59, 3, 8783, 824, 101, 4, 2, 102, 115, 3692, 3724, 116, 84, 114, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 3709, 3711, 3717, 1, 8938, 97, 114, 59, 3, 10703, 824, 113, 117, 97, 108, 59, 1, 8940, 115, 4, 6, 59, 69, 71, 76, 83, 84, 3739, 3741, 3748, 3757, 3764, 3777, 1, 8814, 113, 117, 97, 108, 59, 1, 8816, 114, 101, 97, 116, 101, 114, 59, 1, 8824, 101, 115, 115, 59, 3, 8810, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 3, 10877, 824, 105, 108, 100, 101, 59, 1, 8820, 101, 115, 116, 101, 100, 4, 2, 71, 76, 3795, 3812, 114, 101, 97, 116, 101, 114, 71, 114, 101, 97, 116, 101, 114, 59, 3, 10914, 824, 101, 115, 115, 76, 101, 115, 115, 59, 3, 10913, 824, 114, 101, 99, 101, 100, 101, 115, 4, 3, 59, 69, 83, 3838, 3840, 3848, 1, 8832, 113, 117, 97, 108, 59, 3, 10927, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8928, 4, 2, 101, 105, 3866, 3881, 118, 101, 114, 115, 101, 69, 108, 101, 109, 101, 110, 116, 59, 1, 8716, 103, 104, 116, 84, 114, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 3900, 3902, 3908, 1, 8939, 97, 114, 59, 3, 10704, 824, 113, 117, 97, 108, 59, 1, 8941, 4, 2, 113, 117, 3921, 3973, 117, 97, 114, 101, 83, 117, 4, 2, 98, 112, 3933, 3952, 115, 101, 116, 4, 2, 59, 69, 3942, 3945, 3, 8847, 824, 113, 117, 97, 108, 59, 1, 8930, 101, 114, 115, 101, 116, 4, 2, 59, 69, 3963, 3966, 3, 8848, 824, 113, 117, 97, 108, 59, 1, 8931, 4, 3, 98, 99, 112, 3981, 4e3, 4045, 115, 101, 116, 4, 2, 59, 69, 3990, 3993, 3, 8834, 8402, 113, 117, 97, 108, 59, 1, 8840, 99, 101, 101, 100, 115, 4, 4, 59, 69, 83, 84, 4015, 4017, 4025, 4037, 1, 8833, 113, 117, 97, 108, 59, 3, 10928, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8929, 105, 108, 100, 101, 59, 3, 8831, 824, 101, 114, 115, 101, 116, 4, 2, 59, 69, 4056, 4059, 3, 8835, 8402, 113, 117, 97, 108, 59, 1, 8841, 105, 108, 100, 101, 4, 4, 59, 69, 70, 84, 4080, 4082, 4089, 4100, 1, 8769, 113, 117, 97, 108, 59, 1, 8772, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8775, 105, 108, 100, 101, 59, 1, 8777, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 1, 8740, 99, 114, 59, 3, 55349, 56489, 105, 108, 100, 101, 5, 209, 1, 59, 4135, 1, 209, 59, 1, 925, 4, 14, 69, 97, 99, 100, 102, 103, 109, 111, 112, 114, 115, 116, 117, 118, 4170, 4176, 4187, 4205, 4212, 4217, 4228, 4253, 4259, 4292, 4295, 4316, 4337, 4346, 108, 105, 103, 59, 1, 338, 99, 117, 116, 101, 5, 211, 1, 59, 4185, 1, 211, 4, 2, 105, 121, 4193, 4202, 114, 99, 5, 212, 1, 59, 4200, 1, 212, 59, 1, 1054, 98, 108, 97, 99, 59, 1, 336, 114, 59, 3, 55349, 56594, 114, 97, 118, 101, 5, 210, 1, 59, 4226, 1, 210, 4, 3, 97, 101, 105, 4236, 4241, 4246, 99, 114, 59, 1, 332, 103, 97, 59, 1, 937, 99, 114, 111, 110, 59, 1, 927, 112, 102, 59, 3, 55349, 56646, 101, 110, 67, 117, 114, 108, 121, 4, 2, 68, 81, 4272, 4285, 111, 117, 98, 108, 101, 81, 117, 111, 116, 101, 59, 1, 8220, 117, 111, 116, 101, 59, 1, 8216, 59, 1, 10836, 4, 2, 99, 108, 4301, 4306, 114, 59, 3, 55349, 56490, 97, 115, 104, 5, 216, 1, 59, 4314, 1, 216, 105, 4, 2, 108, 109, 4323, 4332, 100, 101, 5, 213, 1, 59, 4330, 1, 213, 101, 115, 59, 1, 10807, 109, 108, 5, 214, 1, 59, 4344, 1, 214, 101, 114, 4, 2, 66, 80, 4354, 4380, 4, 2, 97, 114, 4360, 4364, 114, 59, 1, 8254, 97, 99, 4, 2, 101, 107, 4372, 4375, 59, 1, 9182, 101, 116, 59, 1, 9140, 97, 114, 101, 110, 116, 104, 101, 115, 105, 115, 59, 1, 9180, 4, 9, 97, 99, 102, 104, 105, 108, 111, 114, 115, 4413, 4422, 4426, 4431, 4435, 4438, 4448, 4471, 4561, 114, 116, 105, 97, 108, 68, 59, 1, 8706, 121, 59, 1, 1055, 114, 59, 3, 55349, 56595, 105, 59, 1, 934, 59, 1, 928, 117, 115, 77, 105, 110, 117, 115, 59, 1, 177, 4, 2, 105, 112, 4454, 4467, 110, 99, 97, 114, 101, 112, 108, 97, 110, 101, 59, 1, 8460, 102, 59, 1, 8473, 4, 4, 59, 101, 105, 111, 4481, 4483, 4526, 4531, 1, 10939, 99, 101, 100, 101, 115, 4, 4, 59, 69, 83, 84, 4498, 4500, 4507, 4519, 1, 8826, 113, 117, 97, 108, 59, 1, 10927, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8828, 105, 108, 100, 101, 59, 1, 8830, 109, 101, 59, 1, 8243, 4, 2, 100, 112, 4537, 4543, 117, 99, 116, 59, 1, 8719, 111, 114, 116, 105, 111, 110, 4, 2, 59, 97, 4555, 4557, 1, 8759, 108, 59, 1, 8733, 4, 2, 99, 105, 4567, 4572, 114, 59, 3, 55349, 56491, 59, 1, 936, 4, 4, 85, 102, 111, 115, 4585, 4594, 4599, 4604, 79, 84, 5, 34, 1, 59, 4592, 1, 34, 114, 59, 3, 55349, 56596, 112, 102, 59, 1, 8474, 99, 114, 59, 3, 55349, 56492, 4, 12, 66, 69, 97, 99, 101, 102, 104, 105, 111, 114, 115, 117, 4636, 4642, 4650, 4681, 4704, 4763, 4767, 4771, 5047, 5069, 5081, 5094, 97, 114, 114, 59, 1, 10512, 71, 5, 174, 1, 59, 4648, 1, 174, 4, 3, 99, 110, 114, 4658, 4664, 4668, 117, 116, 101, 59, 1, 340, 103, 59, 1, 10219, 114, 4, 2, 59, 116, 4675, 4677, 1, 8608, 108, 59, 1, 10518, 4, 3, 97, 101, 121, 4689, 4695, 4701, 114, 111, 110, 59, 1, 344, 100, 105, 108, 59, 1, 342, 59, 1, 1056, 4, 2, 59, 118, 4710, 4712, 1, 8476, 101, 114, 115, 101, 4, 2, 69, 85, 4722, 4748, 4, 2, 108, 113, 4728, 4736, 101, 109, 101, 110, 116, 59, 1, 8715, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 1, 8651, 112, 69, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 1, 10607, 114, 59, 1, 8476, 111, 59, 1, 929, 103, 104, 116, 4, 8, 65, 67, 68, 70, 84, 85, 86, 97, 4792, 4840, 4849, 4905, 4912, 4972, 5022, 5040, 4, 2, 110, 114, 4798, 4811, 103, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10217, 114, 111, 119, 4, 3, 59, 66, 76, 4822, 4824, 4829, 1, 8594, 97, 114, 59, 1, 8677, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8644, 101, 105, 108, 105, 110, 103, 59, 1, 8969, 111, 4, 2, 117, 119, 4856, 4869, 98, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10215, 110, 4, 2, 84, 86, 4876, 4887, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10589, 101, 99, 116, 111, 114, 4, 2, 59, 66, 4898, 4900, 1, 8642, 97, 114, 59, 1, 10581, 108, 111, 111, 114, 59, 1, 8971, 4, 2, 101, 114, 4918, 4944, 101, 4, 3, 59, 65, 86, 4927, 4929, 4936, 1, 8866, 114, 114, 111, 119, 59, 1, 8614, 101, 99, 116, 111, 114, 59, 1, 10587, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 4958, 4960, 4965, 1, 8883, 97, 114, 59, 1, 10704, 113, 117, 97, 108, 59, 1, 8885, 112, 4, 3, 68, 84, 86, 4981, 4993, 5004, 111, 119, 110, 86, 101, 99, 116, 111, 114, 59, 1, 10575, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10588, 101, 99, 116, 111, 114, 4, 2, 59, 66, 5015, 5017, 1, 8638, 97, 114, 59, 1, 10580, 101, 99, 116, 111, 114, 4, 2, 59, 66, 5033, 5035, 1, 8640, 97, 114, 59, 1, 10579, 114, 114, 111, 119, 59, 1, 8658, 4, 2, 112, 117, 5053, 5057, 102, 59, 1, 8477, 110, 100, 73, 109, 112, 108, 105, 101, 115, 59, 1, 10608, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8667, 4, 2, 99, 104, 5087, 5091, 114, 59, 1, 8475, 59, 1, 8625, 108, 101, 68, 101, 108, 97, 121, 101, 100, 59, 1, 10740, 4, 13, 72, 79, 97, 99, 102, 104, 105, 109, 111, 113, 115, 116, 117, 5134, 5150, 5157, 5164, 5198, 5203, 5259, 5265, 5277, 5283, 5374, 5380, 5385, 4, 2, 67, 99, 5140, 5146, 72, 99, 121, 59, 1, 1065, 121, 59, 1, 1064, 70, 84, 99, 121, 59, 1, 1068, 99, 117, 116, 101, 59, 1, 346, 4, 5, 59, 97, 101, 105, 121, 5176, 5178, 5184, 5190, 5195, 1, 10940, 114, 111, 110, 59, 1, 352, 100, 105, 108, 59, 1, 350, 114, 99, 59, 1, 348, 59, 1, 1057, 114, 59, 3, 55349, 56598, 111, 114, 116, 4, 4, 68, 76, 82, 85, 5216, 5227, 5238, 5250, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8595, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8592, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8594, 112, 65, 114, 114, 111, 119, 59, 1, 8593, 103, 109, 97, 59, 1, 931, 97, 108, 108, 67, 105, 114, 99, 108, 101, 59, 1, 8728, 112, 102, 59, 3, 55349, 56650, 4, 2, 114, 117, 5289, 5293, 116, 59, 1, 8730, 97, 114, 101, 4, 4, 59, 73, 83, 85, 5306, 5308, 5322, 5367, 1, 9633, 110, 116, 101, 114, 115, 101, 99, 116, 105, 111, 110, 59, 1, 8851, 117, 4, 2, 98, 112, 5329, 5347, 115, 101, 116, 4, 2, 59, 69, 5338, 5340, 1, 8847, 113, 117, 97, 108, 59, 1, 8849, 101, 114, 115, 101, 116, 4, 2, 59, 69, 5358, 5360, 1, 8848, 113, 117, 97, 108, 59, 1, 8850, 110, 105, 111, 110, 59, 1, 8852, 99, 114, 59, 3, 55349, 56494, 97, 114, 59, 1, 8902, 4, 4, 98, 99, 109, 112, 5395, 5420, 5475, 5478, 4, 2, 59, 115, 5401, 5403, 1, 8912, 101, 116, 4, 2, 59, 69, 5411, 5413, 1, 8912, 113, 117, 97, 108, 59, 1, 8838, 4, 2, 99, 104, 5426, 5468, 101, 101, 100, 115, 4, 4, 59, 69, 83, 84, 5440, 5442, 5449, 5461, 1, 8827, 113, 117, 97, 108, 59, 1, 10928, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8829, 105, 108, 100, 101, 59, 1, 8831, 84, 104, 97, 116, 59, 1, 8715, 59, 1, 8721, 4, 3, 59, 101, 115, 5486, 5488, 5507, 1, 8913, 114, 115, 101, 116, 4, 2, 59, 69, 5498, 5500, 1, 8835, 113, 117, 97, 108, 59, 1, 8839, 101, 116, 59, 1, 8913, 4, 11, 72, 82, 83, 97, 99, 102, 104, 105, 111, 114, 115, 5536, 5546, 5552, 5567, 5579, 5602, 5607, 5655, 5695, 5701, 5711, 79, 82, 78, 5, 222, 1, 59, 5544, 1, 222, 65, 68, 69, 59, 1, 8482, 4, 2, 72, 99, 5558, 5563, 99, 121, 59, 1, 1035, 121, 59, 1, 1062, 4, 2, 98, 117, 5573, 5576, 59, 1, 9, 59, 1, 932, 4, 3, 97, 101, 121, 5587, 5593, 5599, 114, 111, 110, 59, 1, 356, 100, 105, 108, 59, 1, 354, 59, 1, 1058, 114, 59, 3, 55349, 56599, 4, 2, 101, 105, 5613, 5631, 4, 2, 114, 116, 5619, 5627, 101, 102, 111, 114, 101, 59, 1, 8756, 97, 59, 1, 920, 4, 2, 99, 110, 5637, 5647, 107, 83, 112, 97, 99, 101, 59, 3, 8287, 8202, 83, 112, 97, 99, 101, 59, 1, 8201, 108, 100, 101, 4, 4, 59, 69, 70, 84, 5668, 5670, 5677, 5688, 1, 8764, 113, 117, 97, 108, 59, 1, 8771, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8773, 105, 108, 100, 101, 59, 1, 8776, 112, 102, 59, 3, 55349, 56651, 105, 112, 108, 101, 68, 111, 116, 59, 1, 8411, 4, 2, 99, 116, 5717, 5722, 114, 59, 3, 55349, 56495, 114, 111, 107, 59, 1, 358, 4, 14, 97, 98, 99, 100, 102, 103, 109, 110, 111, 112, 114, 115, 116, 117, 5758, 5789, 5805, 5823, 5830, 5835, 5846, 5852, 5921, 5937, 6089, 6095, 6101, 6108, 4, 2, 99, 114, 5764, 5774, 117, 116, 101, 5, 218, 1, 59, 5772, 1, 218, 114, 4, 2, 59, 111, 5781, 5783, 1, 8607, 99, 105, 114, 59, 1, 10569, 114, 4, 2, 99, 101, 5796, 5800, 121, 59, 1, 1038, 118, 101, 59, 1, 364, 4, 2, 105, 121, 5811, 5820, 114, 99, 5, 219, 1, 59, 5818, 1, 219, 59, 1, 1059, 98, 108, 97, 99, 59, 1, 368, 114, 59, 3, 55349, 56600, 114, 97, 118, 101, 5, 217, 1, 59, 5844, 1, 217, 97, 99, 114, 59, 1, 362, 4, 2, 100, 105, 5858, 5905, 101, 114, 4, 2, 66, 80, 5866, 5892, 4, 2, 97, 114, 5872, 5876, 114, 59, 1, 95, 97, 99, 4, 2, 101, 107, 5884, 5887, 59, 1, 9183, 101, 116, 59, 1, 9141, 97, 114, 101, 110, 116, 104, 101, 115, 105, 115, 59, 1, 9181, 111, 110, 4, 2, 59, 80, 5913, 5915, 1, 8899, 108, 117, 115, 59, 1, 8846, 4, 2, 103, 112, 5927, 5932, 111, 110, 59, 1, 370, 102, 59, 3, 55349, 56652, 4, 8, 65, 68, 69, 84, 97, 100, 112, 115, 5955, 5985, 5996, 6009, 6026, 6033, 6044, 6075, 114, 114, 111, 119, 4, 3, 59, 66, 68, 5967, 5969, 5974, 1, 8593, 97, 114, 59, 1, 10514, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8645, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8597, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 1, 10606, 101, 101, 4, 2, 59, 65, 6017, 6019, 1, 8869, 114, 114, 111, 119, 59, 1, 8613, 114, 114, 111, 119, 59, 1, 8657, 111, 119, 110, 97, 114, 114, 111, 119, 59, 1, 8661, 101, 114, 4, 2, 76, 82, 6052, 6063, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8598, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8599, 105, 4, 2, 59, 108, 6082, 6084, 1, 978, 111, 110, 59, 1, 933, 105, 110, 103, 59, 1, 366, 99, 114, 59, 3, 55349, 56496, 105, 108, 100, 101, 59, 1, 360, 109, 108, 5, 220, 1, 59, 6115, 1, 220, 4, 9, 68, 98, 99, 100, 101, 102, 111, 115, 118, 6137, 6143, 6148, 6152, 6166, 6250, 6255, 6261, 6267, 97, 115, 104, 59, 1, 8875, 97, 114, 59, 1, 10987, 121, 59, 1, 1042, 97, 115, 104, 4, 2, 59, 108, 6161, 6163, 1, 8873, 59, 1, 10982, 4, 2, 101, 114, 6172, 6175, 59, 1, 8897, 4, 3, 98, 116, 121, 6183, 6188, 6238, 97, 114, 59, 1, 8214, 4, 2, 59, 105, 6194, 6196, 1, 8214, 99, 97, 108, 4, 4, 66, 76, 83, 84, 6209, 6214, 6220, 6231, 97, 114, 59, 1, 8739, 105, 110, 101, 59, 1, 124, 101, 112, 97, 114, 97, 116, 111, 114, 59, 1, 10072, 105, 108, 100, 101, 59, 1, 8768, 84, 104, 105, 110, 83, 112, 97, 99, 101, 59, 1, 8202, 114, 59, 3, 55349, 56601, 112, 102, 59, 3, 55349, 56653, 99, 114, 59, 3, 55349, 56497, 100, 97, 115, 104, 59, 1, 8874, 4, 5, 99, 101, 102, 111, 115, 6286, 6292, 6298, 6303, 6309, 105, 114, 99, 59, 1, 372, 100, 103, 101, 59, 1, 8896, 114, 59, 3, 55349, 56602, 112, 102, 59, 3, 55349, 56654, 99, 114, 59, 3, 55349, 56498, 4, 4, 102, 105, 111, 115, 6325, 6330, 6333, 6339, 114, 59, 3, 55349, 56603, 59, 1, 926, 112, 102, 59, 3, 55349, 56655, 99, 114, 59, 3, 55349, 56499, 4, 9, 65, 73, 85, 97, 99, 102, 111, 115, 117, 6365, 6370, 6375, 6380, 6391, 6405, 6410, 6416, 6422, 99, 121, 59, 1, 1071, 99, 121, 59, 1, 1031, 99, 121, 59, 1, 1070, 99, 117, 116, 101, 5, 221, 1, 59, 6389, 1, 221, 4, 2, 105, 121, 6397, 6402, 114, 99, 59, 1, 374, 59, 1, 1067, 114, 59, 3, 55349, 56604, 112, 102, 59, 3, 55349, 56656, 99, 114, 59, 3, 55349, 56500, 109, 108, 59, 1, 376, 4, 8, 72, 97, 99, 100, 101, 102, 111, 115, 6445, 6450, 6457, 6472, 6477, 6501, 6505, 6510, 99, 121, 59, 1, 1046, 99, 117, 116, 101, 59, 1, 377, 4, 2, 97, 121, 6463, 6469, 114, 111, 110, 59, 1, 381, 59, 1, 1047, 111, 116, 59, 1, 379, 4, 2, 114, 116, 6483, 6497, 111, 87, 105, 100, 116, 104, 83, 112, 97, 99, 101, 59, 1, 8203, 97, 59, 1, 918, 114, 59, 1, 8488, 112, 102, 59, 1, 8484, 99, 114, 59, 3, 55349, 56501, 4, 16, 97, 98, 99, 101, 102, 103, 108, 109, 110, 111, 112, 114, 115, 116, 117, 119, 6550, 6561, 6568, 6612, 6622, 6634, 6645, 6672, 6699, 6854, 6870, 6923, 6933, 6963, 6974, 6983, 99, 117, 116, 101, 5, 225, 1, 59, 6559, 1, 225, 114, 101, 118, 101, 59, 1, 259, 4, 6, 59, 69, 100, 105, 117, 121, 6582, 6584, 6588, 6591, 6600, 6609, 1, 8766, 59, 3, 8766, 819, 59, 1, 8767, 114, 99, 5, 226, 1, 59, 6598, 1, 226, 116, 101, 5, 180, 1, 59, 6607, 1, 180, 59, 1, 1072, 108, 105, 103, 5, 230, 1, 59, 6620, 1, 230, 4, 2, 59, 114, 6628, 6630, 1, 8289, 59, 3, 55349, 56606, 114, 97, 118, 101, 5, 224, 1, 59, 6643, 1, 224, 4, 2, 101, 112, 6651, 6667, 4, 2, 102, 112, 6657, 6663, 115, 121, 109, 59, 1, 8501, 104, 59, 1, 8501, 104, 97, 59, 1, 945, 4, 2, 97, 112, 6678, 6692, 4, 2, 99, 108, 6684, 6688, 114, 59, 1, 257, 103, 59, 1, 10815, 5, 38, 1, 59, 6697, 1, 38, 4, 2, 100, 103, 6705, 6737, 4, 5, 59, 97, 100, 115, 118, 6717, 6719, 6724, 6727, 6734, 1, 8743, 110, 100, 59, 1, 10837, 59, 1, 10844, 108, 111, 112, 101, 59, 1, 10840, 59, 1, 10842, 4, 7, 59, 101, 108, 109, 114, 115, 122, 6753, 6755, 6758, 6762, 6814, 6835, 6848, 1, 8736, 59, 1, 10660, 101, 59, 1, 8736, 115, 100, 4, 2, 59, 97, 6770, 6772, 1, 8737, 4, 8, 97, 98, 99, 100, 101, 102, 103, 104, 6790, 6793, 6796, 6799, 6802, 6805, 6808, 6811, 59, 1, 10664, 59, 1, 10665, 59, 1, 10666, 59, 1, 10667, 59, 1, 10668, 59, 1, 10669, 59, 1, 10670, 59, 1, 10671, 116, 4, 2, 59, 118, 6821, 6823, 1, 8735, 98, 4, 2, 59, 100, 6830, 6832, 1, 8894, 59, 1, 10653, 4, 2, 112, 116, 6841, 6845, 104, 59, 1, 8738, 59, 1, 197, 97, 114, 114, 59, 1, 9084, 4, 2, 103, 112, 6860, 6865, 111, 110, 59, 1, 261, 102, 59, 3, 55349, 56658, 4, 7, 59, 69, 97, 101, 105, 111, 112, 6886, 6888, 6891, 6897, 6900, 6904, 6908, 1, 8776, 59, 1, 10864, 99, 105, 114, 59, 1, 10863, 59, 1, 8778, 100, 59, 1, 8779, 115, 59, 1, 39, 114, 111, 120, 4, 2, 59, 101, 6917, 6919, 1, 8776, 113, 59, 1, 8778, 105, 110, 103, 5, 229, 1, 59, 6931, 1, 229, 4, 3, 99, 116, 121, 6941, 6946, 6949, 114, 59, 3, 55349, 56502, 59, 1, 42, 109, 112, 4, 2, 59, 101, 6957, 6959, 1, 8776, 113, 59, 1, 8781, 105, 108, 100, 101, 5, 227, 1, 59, 6972, 1, 227, 109, 108, 5, 228, 1, 59, 6981, 1, 228, 4, 2, 99, 105, 6989, 6997, 111, 110, 105, 110, 116, 59, 1, 8755, 110, 116, 59, 1, 10769, 4, 16, 78, 97, 98, 99, 100, 101, 102, 105, 107, 108, 110, 111, 112, 114, 115, 117, 7036, 7041, 7119, 7135, 7149, 7155, 7219, 7224, 7347, 7354, 7463, 7489, 7786, 7793, 7814, 7866, 111, 116, 59, 1, 10989, 4, 2, 99, 114, 7047, 7094, 107, 4, 4, 99, 101, 112, 115, 7058, 7064, 7073, 7080, 111, 110, 103, 59, 1, 8780, 112, 115, 105, 108, 111, 110, 59, 1, 1014, 114, 105, 109, 101, 59, 1, 8245, 105, 109, 4, 2, 59, 101, 7088, 7090, 1, 8765, 113, 59, 1, 8909, 4, 2, 118, 119, 7100, 7105, 101, 101, 59, 1, 8893, 101, 100, 4, 2, 59, 103, 7113, 7115, 1, 8965, 101, 59, 1, 8965, 114, 107, 4, 2, 59, 116, 7127, 7129, 1, 9141, 98, 114, 107, 59, 1, 9142, 4, 2, 111, 121, 7141, 7146, 110, 103, 59, 1, 8780, 59, 1, 1073, 113, 117, 111, 59, 1, 8222, 4, 5, 99, 109, 112, 114, 116, 7167, 7181, 7188, 7193, 7199, 97, 117, 115, 4, 2, 59, 101, 7176, 7178, 1, 8757, 59, 1, 8757, 112, 116, 121, 118, 59, 1, 10672, 115, 105, 59, 1, 1014, 110, 111, 117, 59, 1, 8492, 4, 3, 97, 104, 119, 7207, 7210, 7213, 59, 1, 946, 59, 1, 8502, 101, 101, 110, 59, 1, 8812, 114, 59, 3, 55349, 56607, 103, 4, 7, 99, 111, 115, 116, 117, 118, 119, 7241, 7262, 7288, 7305, 7328, 7335, 7340, 4, 3, 97, 105, 117, 7249, 7253, 7258, 112, 59, 1, 8898, 114, 99, 59, 1, 9711, 112, 59, 1, 8899, 4, 3, 100, 112, 116, 7270, 7275, 7281, 111, 116, 59, 1, 10752, 108, 117, 115, 59, 1, 10753, 105, 109, 101, 115, 59, 1, 10754, 4, 2, 113, 116, 7294, 7300, 99, 117, 112, 59, 1, 10758, 97, 114, 59, 1, 9733, 114, 105, 97, 110, 103, 108, 101, 4, 2, 100, 117, 7318, 7324, 111, 119, 110, 59, 1, 9661, 112, 59, 1, 9651, 112, 108, 117, 115, 59, 1, 10756, 101, 101, 59, 1, 8897, 101, 100, 103, 101, 59, 1, 8896, 97, 114, 111, 119, 59, 1, 10509, 4, 3, 97, 107, 111, 7362, 7436, 7458, 4, 2, 99, 110, 7368, 7432, 107, 4, 3, 108, 115, 116, 7377, 7386, 7394, 111, 122, 101, 110, 103, 101, 59, 1, 10731, 113, 117, 97, 114, 101, 59, 1, 9642, 114, 105, 97, 110, 103, 108, 101, 4, 4, 59, 100, 108, 114, 7411, 7413, 7419, 7425, 1, 9652, 111, 119, 110, 59, 1, 9662, 101, 102, 116, 59, 1, 9666, 105, 103, 104, 116, 59, 1, 9656, 107, 59, 1, 9251, 4, 2, 49, 51, 7442, 7454, 4, 2, 50, 52, 7448, 7451, 59, 1, 9618, 59, 1, 9617, 52, 59, 1, 9619, 99, 107, 59, 1, 9608, 4, 2, 101, 111, 7469, 7485, 4, 2, 59, 113, 7475, 7478, 3, 61, 8421, 117, 105, 118, 59, 3, 8801, 8421, 116, 59, 1, 8976, 4, 4, 112, 116, 119, 120, 7499, 7504, 7517, 7523, 102, 59, 3, 55349, 56659, 4, 2, 59, 116, 7510, 7512, 1, 8869, 111, 109, 59, 1, 8869, 116, 105, 101, 59, 1, 8904, 4, 12, 68, 72, 85, 86, 98, 100, 104, 109, 112, 116, 117, 118, 7549, 7571, 7597, 7619, 7655, 7660, 7682, 7708, 7715, 7721, 7728, 7750, 4, 4, 76, 82, 108, 114, 7559, 7562, 7565, 7568, 59, 1, 9559, 59, 1, 9556, 59, 1, 9558, 59, 1, 9555, 4, 5, 59, 68, 85, 100, 117, 7583, 7585, 7588, 7591, 7594, 1, 9552, 59, 1, 9574, 59, 1, 9577, 59, 1, 9572, 59, 1, 9575, 4, 4, 76, 82, 108, 114, 7607, 7610, 7613, 7616, 59, 1, 9565, 59, 1, 9562, 59, 1, 9564, 59, 1, 9561, 4, 7, 59, 72, 76, 82, 104, 108, 114, 7635, 7637, 7640, 7643, 7646, 7649, 7652, 1, 9553, 59, 1, 9580, 59, 1, 9571, 59, 1, 9568, 59, 1, 9579, 59, 1, 9570, 59, 1, 9567, 111, 120, 59, 1, 10697, 4, 4, 76, 82, 108, 114, 7670, 7673, 7676, 7679, 59, 1, 9557, 59, 1, 9554, 59, 1, 9488, 59, 1, 9484, 4, 5, 59, 68, 85, 100, 117, 7694, 7696, 7699, 7702, 7705, 1, 9472, 59, 1, 9573, 59, 1, 9576, 59, 1, 9516, 59, 1, 9524, 105, 110, 117, 115, 59, 1, 8863, 108, 117, 115, 59, 1, 8862, 105, 109, 101, 115, 59, 1, 8864, 4, 4, 76, 82, 108, 114, 7738, 7741, 7744, 7747, 59, 1, 9563, 59, 1, 9560, 59, 1, 9496, 59, 1, 9492, 4, 7, 59, 72, 76, 82, 104, 108, 114, 7766, 7768, 7771, 7774, 7777, 7780, 7783, 1, 9474, 59, 1, 9578, 59, 1, 9569, 59, 1, 9566, 59, 1, 9532, 59, 1, 9508, 59, 1, 9500, 114, 105, 109, 101, 59, 1, 8245, 4, 2, 101, 118, 7799, 7804, 118, 101, 59, 1, 728, 98, 97, 114, 5, 166, 1, 59, 7812, 1, 166, 4, 4, 99, 101, 105, 111, 7824, 7829, 7834, 7846, 114, 59, 3, 55349, 56503, 109, 105, 59, 1, 8271, 109, 4, 2, 59, 101, 7841, 7843, 1, 8765, 59, 1, 8909, 108, 4, 3, 59, 98, 104, 7855, 7857, 7860, 1, 92, 59, 1, 10693, 115, 117, 98, 59, 1, 10184, 4, 2, 108, 109, 7872, 7885, 108, 4, 2, 59, 101, 7879, 7881, 1, 8226, 116, 59, 1, 8226, 112, 4, 3, 59, 69, 101, 7894, 7896, 7899, 1, 8782, 59, 1, 10926, 4, 2, 59, 113, 7905, 7907, 1, 8783, 59, 1, 8783, 4, 15, 97, 99, 100, 101, 102, 104, 105, 108, 111, 114, 115, 116, 117, 119, 121, 7942, 8021, 8075, 8080, 8121, 8126, 8157, 8279, 8295, 8430, 8446, 8485, 8491, 8707, 8726, 4, 3, 99, 112, 114, 7950, 7956, 8007, 117, 116, 101, 59, 1, 263, 4, 6, 59, 97, 98, 99, 100, 115, 7970, 7972, 7977, 7984, 7998, 8003, 1, 8745, 110, 100, 59, 1, 10820, 114, 99, 117, 112, 59, 1, 10825, 4, 2, 97, 117, 7990, 7994, 112, 59, 1, 10827, 112, 59, 1, 10823, 111, 116, 59, 1, 10816, 59, 3, 8745, 65024, 4, 2, 101, 111, 8013, 8017, 116, 59, 1, 8257, 110, 59, 1, 711, 4, 4, 97, 101, 105, 117, 8031, 8046, 8056, 8061, 4, 2, 112, 114, 8037, 8041, 115, 59, 1, 10829, 111, 110, 59, 1, 269, 100, 105, 108, 5, 231, 1, 59, 8054, 1, 231, 114, 99, 59, 1, 265, 112, 115, 4, 2, 59, 115, 8069, 8071, 1, 10828, 109, 59, 1, 10832, 111, 116, 59, 1, 267, 4, 3, 100, 109, 110, 8088, 8097, 8104, 105, 108, 5, 184, 1, 59, 8095, 1, 184, 112, 116, 121, 118, 59, 1, 10674, 116, 5, 162, 2, 59, 101, 8112, 8114, 1, 162, 114, 100, 111, 116, 59, 1, 183, 114, 59, 3, 55349, 56608, 4, 3, 99, 101, 105, 8134, 8138, 8154, 121, 59, 1, 1095, 99, 107, 4, 2, 59, 109, 8146, 8148, 1, 10003, 97, 114, 107, 59, 1, 10003, 59, 1, 967, 114, 4, 7, 59, 69, 99, 101, 102, 109, 115, 8174, 8176, 8179, 8258, 8261, 8268, 8273, 1, 9675, 59, 1, 10691, 4, 3, 59, 101, 108, 8187, 8189, 8193, 1, 710, 113, 59, 1, 8791, 101, 4, 2, 97, 100, 8200, 8223, 114, 114, 111, 119, 4, 2, 108, 114, 8210, 8216, 101, 102, 116, 59, 1, 8634, 105, 103, 104, 116, 59, 1, 8635, 4, 5, 82, 83, 97, 99, 100, 8235, 8238, 8241, 8246, 8252, 59, 1, 174, 59, 1, 9416, 115, 116, 59, 1, 8859, 105, 114, 99, 59, 1, 8858, 97, 115, 104, 59, 1, 8861, 59, 1, 8791, 110, 105, 110, 116, 59, 1, 10768, 105, 100, 59, 1, 10991, 99, 105, 114, 59, 1, 10690, 117, 98, 115, 4, 2, 59, 117, 8288, 8290, 1, 9827, 105, 116, 59, 1, 9827, 4, 4, 108, 109, 110, 112, 8305, 8326, 8376, 8400, 111, 110, 4, 2, 59, 101, 8313, 8315, 1, 58, 4, 2, 59, 113, 8321, 8323, 1, 8788, 59, 1, 8788, 4, 2, 109, 112, 8332, 8344, 97, 4, 2, 59, 116, 8339, 8341, 1, 44, 59, 1, 64, 4, 3, 59, 102, 108, 8352, 8354, 8358, 1, 8705, 110, 59, 1, 8728, 101, 4, 2, 109, 120, 8365, 8371, 101, 110, 116, 59, 1, 8705, 101, 115, 59, 1, 8450, 4, 2, 103, 105, 8382, 8395, 4, 2, 59, 100, 8388, 8390, 1, 8773, 111, 116, 59, 1, 10861, 110, 116, 59, 1, 8750, 4, 3, 102, 114, 121, 8408, 8412, 8417, 59, 3, 55349, 56660, 111, 100, 59, 1, 8720, 5, 169, 2, 59, 115, 8424, 8426, 1, 169, 114, 59, 1, 8471, 4, 2, 97, 111, 8436, 8441, 114, 114, 59, 1, 8629, 115, 115, 59, 1, 10007, 4, 2, 99, 117, 8452, 8457, 114, 59, 3, 55349, 56504, 4, 2, 98, 112, 8463, 8474, 4, 2, 59, 101, 8469, 8471, 1, 10959, 59, 1, 10961, 4, 2, 59, 101, 8480, 8482, 1, 10960, 59, 1, 10962, 100, 111, 116, 59, 1, 8943, 4, 7, 100, 101, 108, 112, 114, 118, 119, 8507, 8522, 8536, 8550, 8600, 8697, 8702, 97, 114, 114, 4, 2, 108, 114, 8516, 8519, 59, 1, 10552, 59, 1, 10549, 4, 2, 112, 115, 8528, 8532, 114, 59, 1, 8926, 99, 59, 1, 8927, 97, 114, 114, 4, 2, 59, 112, 8545, 8547, 1, 8630, 59, 1, 10557, 4, 6, 59, 98, 99, 100, 111, 115, 8564, 8566, 8573, 8587, 8592, 8596, 1, 8746, 114, 99, 97, 112, 59, 1, 10824, 4, 2, 97, 117, 8579, 8583, 112, 59, 1, 10822, 112, 59, 1, 10826, 111, 116, 59, 1, 8845, 114, 59, 1, 10821, 59, 3, 8746, 65024, 4, 4, 97, 108, 114, 118, 8610, 8623, 8663, 8672, 114, 114, 4, 2, 59, 109, 8618, 8620, 1, 8631, 59, 1, 10556, 121, 4, 3, 101, 118, 119, 8632, 8651, 8656, 113, 4, 2, 112, 115, 8639, 8645, 114, 101, 99, 59, 1, 8926, 117, 99, 99, 59, 1, 8927, 101, 101, 59, 1, 8910, 101, 100, 103, 101, 59, 1, 8911, 101, 110, 5, 164, 1, 59, 8670, 1, 164, 101, 97, 114, 114, 111, 119, 4, 2, 108, 114, 8684, 8690, 101, 102, 116, 59, 1, 8630, 105, 103, 104, 116, 59, 1, 8631, 101, 101, 59, 1, 8910, 101, 100, 59, 1, 8911, 4, 2, 99, 105, 8713, 8721, 111, 110, 105, 110, 116, 59, 1, 8754, 110, 116, 59, 1, 8753, 108, 99, 116, 121, 59, 1, 9005, 4, 19, 65, 72, 97, 98, 99, 100, 101, 102, 104, 105, 106, 108, 111, 114, 115, 116, 117, 119, 122, 8773, 8778, 8783, 8821, 8839, 8854, 8887, 8914, 8930, 8944, 9036, 9041, 9058, 9197, 9227, 9258, 9281, 9297, 9305, 114, 114, 59, 1, 8659, 97, 114, 59, 1, 10597, 4, 4, 103, 108, 114, 115, 8793, 8799, 8805, 8809, 103, 101, 114, 59, 1, 8224, 101, 116, 104, 59, 1, 8504, 114, 59, 1, 8595, 104, 4, 2, 59, 118, 8816, 8818, 1, 8208, 59, 1, 8867, 4, 2, 107, 108, 8827, 8834, 97, 114, 111, 119, 59, 1, 10511, 97, 99, 59, 1, 733, 4, 2, 97, 121, 8845, 8851, 114, 111, 110, 59, 1, 271, 59, 1, 1076, 4, 3, 59, 97, 111, 8862, 8864, 8880, 1, 8518, 4, 2, 103, 114, 8870, 8876, 103, 101, 114, 59, 1, 8225, 114, 59, 1, 8650, 116, 115, 101, 113, 59, 1, 10871, 4, 3, 103, 108, 109, 8895, 8902, 8907, 5, 176, 1, 59, 8900, 1, 176, 116, 97, 59, 1, 948, 112, 116, 121, 118, 59, 1, 10673, 4, 2, 105, 114, 8920, 8926, 115, 104, 116, 59, 1, 10623, 59, 3, 55349, 56609, 97, 114, 4, 2, 108, 114, 8938, 8941, 59, 1, 8643, 59, 1, 8642, 4, 5, 97, 101, 103, 115, 118, 8956, 8986, 8989, 8996, 9001, 109, 4, 3, 59, 111, 115, 8965, 8967, 8983, 1, 8900, 110, 100, 4, 2, 59, 115, 8975, 8977, 1, 8900, 117, 105, 116, 59, 1, 9830, 59, 1, 9830, 59, 1, 168, 97, 109, 109, 97, 59, 1, 989, 105, 110, 59, 1, 8946, 4, 3, 59, 105, 111, 9009, 9011, 9031, 1, 247, 100, 101, 5, 247, 2, 59, 111, 9020, 9022, 1, 247, 110, 116, 105, 109, 101, 115, 59, 1, 8903, 110, 120, 59, 1, 8903, 99, 121, 59, 1, 1106, 99, 4, 2, 111, 114, 9048, 9053, 114, 110, 59, 1, 8990, 111, 112, 59, 1, 8973, 4, 5, 108, 112, 116, 117, 119, 9070, 9076, 9081, 9130, 9144, 108, 97, 114, 59, 1, 36, 102, 59, 3, 55349, 56661, 4, 5, 59, 101, 109, 112, 115, 9093, 9095, 9109, 9116, 9122, 1, 729, 113, 4, 2, 59, 100, 9102, 9104, 1, 8784, 111, 116, 59, 1, 8785, 105, 110, 117, 115, 59, 1, 8760, 108, 117, 115, 59, 1, 8724, 113, 117, 97, 114, 101, 59, 1, 8865, 98, 108, 101, 98, 97, 114, 119, 101, 100, 103, 101, 59, 1, 8966, 110, 4, 3, 97, 100, 104, 9153, 9160, 9172, 114, 114, 111, 119, 59, 1, 8595, 111, 119, 110, 97, 114, 114, 111, 119, 115, 59, 1, 8650, 97, 114, 112, 111, 111, 110, 4, 2, 108, 114, 9184, 9190, 101, 102, 116, 59, 1, 8643, 105, 103, 104, 116, 59, 1, 8642, 4, 2, 98, 99, 9203, 9211, 107, 97, 114, 111, 119, 59, 1, 10512, 4, 2, 111, 114, 9217, 9222, 114, 110, 59, 1, 8991, 111, 112, 59, 1, 8972, 4, 3, 99, 111, 116, 9235, 9248, 9252, 4, 2, 114, 121, 9241, 9245, 59, 3, 55349, 56505, 59, 1, 1109, 108, 59, 1, 10742, 114, 111, 107, 59, 1, 273, 4, 2, 100, 114, 9264, 9269, 111, 116, 59, 1, 8945, 105, 4, 2, 59, 102, 9276, 9278, 1, 9663, 59, 1, 9662, 4, 2, 97, 104, 9287, 9292, 114, 114, 59, 1, 8693, 97, 114, 59, 1, 10607, 97, 110, 103, 108, 101, 59, 1, 10662, 4, 2, 99, 105, 9311, 9315, 121, 59, 1, 1119, 103, 114, 97, 114, 114, 59, 1, 10239, 4, 18, 68, 97, 99, 100, 101, 102, 103, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 120, 9361, 9376, 9398, 9439, 9444, 9447, 9462, 9495, 9531, 9585, 9598, 9614, 9659, 9755, 9771, 9792, 9808, 9826, 4, 2, 68, 111, 9367, 9372, 111, 116, 59, 1, 10871, 116, 59, 1, 8785, 4, 2, 99, 115, 9382, 9392, 117, 116, 101, 5, 233, 1, 59, 9390, 1, 233, 116, 101, 114, 59, 1, 10862, 4, 4, 97, 105, 111, 121, 9408, 9414, 9430, 9436, 114, 111, 110, 59, 1, 283, 114, 4, 2, 59, 99, 9421, 9423, 1, 8790, 5, 234, 1, 59, 9428, 1, 234, 108, 111, 110, 59, 1, 8789, 59, 1, 1101, 111, 116, 59, 1, 279, 59, 1, 8519, 4, 2, 68, 114, 9453, 9458, 111, 116, 59, 1, 8786, 59, 3, 55349, 56610, 4, 3, 59, 114, 115, 9470, 9472, 9482, 1, 10906, 97, 118, 101, 5, 232, 1, 59, 9480, 1, 232, 4, 2, 59, 100, 9488, 9490, 1, 10902, 111, 116, 59, 1, 10904, 4, 4, 59, 105, 108, 115, 9505, 9507, 9515, 9518, 1, 10905, 110, 116, 101, 114, 115, 59, 1, 9191, 59, 1, 8467, 4, 2, 59, 100, 9524, 9526, 1, 10901, 111, 116, 59, 1, 10903, 4, 3, 97, 112, 115, 9539, 9544, 9564, 99, 114, 59, 1, 275, 116, 121, 4, 3, 59, 115, 118, 9554, 9556, 9561, 1, 8709, 101, 116, 59, 1, 8709, 59, 1, 8709, 112, 4, 2, 49, 59, 9571, 9583, 4, 2, 51, 52, 9577, 9580, 59, 1, 8196, 59, 1, 8197, 1, 8195, 4, 2, 103, 115, 9591, 9594, 59, 1, 331, 112, 59, 1, 8194, 4, 2, 103, 112, 9604, 9609, 111, 110, 59, 1, 281, 102, 59, 3, 55349, 56662, 4, 3, 97, 108, 115, 9622, 9635, 9640, 114, 4, 2, 59, 115, 9629, 9631, 1, 8917, 108, 59, 1, 10723, 117, 115, 59, 1, 10865, 105, 4, 3, 59, 108, 118, 9649, 9651, 9656, 1, 949, 111, 110, 59, 1, 949, 59, 1, 1013, 4, 4, 99, 115, 117, 118, 9669, 9686, 9716, 9747, 4, 2, 105, 111, 9675, 9680, 114, 99, 59, 1, 8790, 108, 111, 110, 59, 1, 8789, 4, 2, 105, 108, 9692, 9696, 109, 59, 1, 8770, 97, 110, 116, 4, 2, 103, 108, 9705, 9710, 116, 114, 59, 1, 10902, 101, 115, 115, 59, 1, 10901, 4, 3, 97, 101, 105, 9724, 9729, 9734, 108, 115, 59, 1, 61, 115, 116, 59, 1, 8799, 118, 4, 2, 59, 68, 9741, 9743, 1, 8801, 68, 59, 1, 10872, 112, 97, 114, 115, 108, 59, 1, 10725, 4, 2, 68, 97, 9761, 9766, 111, 116, 59, 1, 8787, 114, 114, 59, 1, 10609, 4, 3, 99, 100, 105, 9779, 9783, 9788, 114, 59, 1, 8495, 111, 116, 59, 1, 8784, 109, 59, 1, 8770, 4, 2, 97, 104, 9798, 9801, 59, 1, 951, 5, 240, 1, 59, 9806, 1, 240, 4, 2, 109, 114, 9814, 9822, 108, 5, 235, 1, 59, 9820, 1, 235, 111, 59, 1, 8364, 4, 3, 99, 105, 112, 9834, 9838, 9843, 108, 59, 1, 33, 115, 116, 59, 1, 8707, 4, 2, 101, 111, 9849, 9859, 99, 116, 97, 116, 105, 111, 110, 59, 1, 8496, 110, 101, 110, 116, 105, 97, 108, 101, 59, 1, 8519, 4, 12, 97, 99, 101, 102, 105, 106, 108, 110, 111, 112, 114, 115, 9896, 9910, 9914, 9921, 9954, 9960, 9967, 9989, 9994, 10027, 10036, 10164, 108, 108, 105, 110, 103, 100, 111, 116, 115, 101, 113, 59, 1, 8786, 121, 59, 1, 1092, 109, 97, 108, 101, 59, 1, 9792, 4, 3, 105, 108, 114, 9929, 9935, 9950, 108, 105, 103, 59, 1, 64259, 4, 2, 105, 108, 9941, 9945, 103, 59, 1, 64256, 105, 103, 59, 1, 64260, 59, 3, 55349, 56611, 108, 105, 103, 59, 1, 64257, 108, 105, 103, 59, 3, 102, 106, 4, 3, 97, 108, 116, 9975, 9979, 9984, 116, 59, 1, 9837, 105, 103, 59, 1, 64258, 110, 115, 59, 1, 9649, 111, 102, 59, 1, 402, 4, 2, 112, 114, 1e4, 10005, 102, 59, 3, 55349, 56663, 4, 2, 97, 107, 10011, 10016, 108, 108, 59, 1, 8704, 4, 2, 59, 118, 10022, 10024, 1, 8916, 59, 1, 10969, 97, 114, 116, 105, 110, 116, 59, 1, 10765, 4, 2, 97, 111, 10042, 10159, 4, 2, 99, 115, 10048, 10155, 4, 6, 49, 50, 51, 52, 53, 55, 10062, 10102, 10114, 10135, 10139, 10151, 4, 6, 50, 51, 52, 53, 54, 56, 10076, 10083, 10086, 10093, 10096, 10099, 5, 189, 1, 59, 10081, 1, 189, 59, 1, 8531, 5, 188, 1, 59, 10091, 1, 188, 59, 1, 8533, 59, 1, 8537, 59, 1, 8539, 4, 2, 51, 53, 10108, 10111, 59, 1, 8532, 59, 1, 8534, 4, 3, 52, 53, 56, 10122, 10129, 10132, 5, 190, 1, 59, 10127, 1, 190, 59, 1, 8535, 59, 1, 8540, 53, 59, 1, 8536, 4, 2, 54, 56, 10145, 10148, 59, 1, 8538, 59, 1, 8541, 56, 59, 1, 8542, 108, 59, 1, 8260, 119, 110, 59, 1, 8994, 99, 114, 59, 3, 55349, 56507, 4, 17, 69, 97, 98, 99, 100, 101, 102, 103, 105, 106, 108, 110, 111, 114, 115, 116, 118, 10206, 10217, 10247, 10254, 10268, 10273, 10358, 10363, 10374, 10380, 10385, 10406, 10458, 10464, 10470, 10497, 10610, 4, 2, 59, 108, 10212, 10214, 1, 8807, 59, 1, 10892, 4, 3, 99, 109, 112, 10225, 10231, 10244, 117, 116, 101, 59, 1, 501, 109, 97, 4, 2, 59, 100, 10239, 10241, 1, 947, 59, 1, 989, 59, 1, 10886, 114, 101, 118, 101, 59, 1, 287, 4, 2, 105, 121, 10260, 10265, 114, 99, 59, 1, 285, 59, 1, 1075, 111, 116, 59, 1, 289, 4, 4, 59, 108, 113, 115, 10283, 10285, 10288, 10308, 1, 8805, 59, 1, 8923, 4, 3, 59, 113, 115, 10296, 10298, 10301, 1, 8805, 59, 1, 8807, 108, 97, 110, 116, 59, 1, 10878, 4, 4, 59, 99, 100, 108, 10318, 10320, 10324, 10345, 1, 10878, 99, 59, 1, 10921, 111, 116, 4, 2, 59, 111, 10332, 10334, 1, 10880, 4, 2, 59, 108, 10340, 10342, 1, 10882, 59, 1, 10884, 4, 2, 59, 101, 10351, 10354, 3, 8923, 65024, 115, 59, 1, 10900, 114, 59, 3, 55349, 56612, 4, 2, 59, 103, 10369, 10371, 1, 8811, 59, 1, 8921, 109, 101, 108, 59, 1, 8503, 99, 121, 59, 1, 1107, 4, 4, 59, 69, 97, 106, 10395, 10397, 10400, 10403, 1, 8823, 59, 1, 10898, 59, 1, 10917, 59, 1, 10916, 4, 4, 69, 97, 101, 115, 10416, 10419, 10434, 10453, 59, 1, 8809, 112, 4, 2, 59, 112, 10426, 10428, 1, 10890, 114, 111, 120, 59, 1, 10890, 4, 2, 59, 113, 10440, 10442, 1, 10888, 4, 2, 59, 113, 10448, 10450, 1, 10888, 59, 1, 8809, 105, 109, 59, 1, 8935, 112, 102, 59, 3, 55349, 56664, 97, 118, 101, 59, 1, 96, 4, 2, 99, 105, 10476, 10480, 114, 59, 1, 8458, 109, 4, 3, 59, 101, 108, 10489, 10491, 10494, 1, 8819, 59, 1, 10894, 59, 1, 10896, 5, 62, 6, 59, 99, 100, 108, 113, 114, 10512, 10514, 10527, 10532, 10538, 10545, 1, 62, 4, 2, 99, 105, 10520, 10523, 59, 1, 10919, 114, 59, 1, 10874, 111, 116, 59, 1, 8919, 80, 97, 114, 59, 1, 10645, 117, 101, 115, 116, 59, 1, 10876, 4, 5, 97, 100, 101, 108, 115, 10557, 10574, 10579, 10599, 10605, 4, 2, 112, 114, 10563, 10570, 112, 114, 111, 120, 59, 1, 10886, 114, 59, 1, 10616, 111, 116, 59, 1, 8919, 113, 4, 2, 108, 113, 10586, 10592, 101, 115, 115, 59, 1, 8923, 108, 101, 115, 115, 59, 1, 10892, 101, 115, 115, 59, 1, 8823, 105, 109, 59, 1, 8819, 4, 2, 101, 110, 10616, 10626, 114, 116, 110, 101, 113, 113, 59, 3, 8809, 65024, 69, 59, 3, 8809, 65024, 4, 10, 65, 97, 98, 99, 101, 102, 107, 111, 115, 121, 10653, 10658, 10713, 10718, 10724, 10760, 10765, 10786, 10850, 10875, 114, 114, 59, 1, 8660, 4, 4, 105, 108, 109, 114, 10668, 10674, 10678, 10684, 114, 115, 112, 59, 1, 8202, 102, 59, 1, 189, 105, 108, 116, 59, 1, 8459, 4, 2, 100, 114, 10690, 10695, 99, 121, 59, 1, 1098, 4, 3, 59, 99, 119, 10703, 10705, 10710, 1, 8596, 105, 114, 59, 1, 10568, 59, 1, 8621, 97, 114, 59, 1, 8463, 105, 114, 99, 59, 1, 293, 4, 3, 97, 108, 114, 10732, 10748, 10754, 114, 116, 115, 4, 2, 59, 117, 10741, 10743, 1, 9829, 105, 116, 59, 1, 9829, 108, 105, 112, 59, 1, 8230, 99, 111, 110, 59, 1, 8889, 114, 59, 3, 55349, 56613, 115, 4, 2, 101, 119, 10772, 10779, 97, 114, 111, 119, 59, 1, 10533, 97, 114, 111, 119, 59, 1, 10534, 4, 5, 97, 109, 111, 112, 114, 10798, 10803, 10809, 10839, 10844, 114, 114, 59, 1, 8703, 116, 104, 116, 59, 1, 8763, 107, 4, 2, 108, 114, 10816, 10827, 101, 102, 116, 97, 114, 114, 111, 119, 59, 1, 8617, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8618, 102, 59, 3, 55349, 56665, 98, 97, 114, 59, 1, 8213, 4, 3, 99, 108, 116, 10858, 10863, 10869, 114, 59, 3, 55349, 56509, 97, 115, 104, 59, 1, 8463, 114, 111, 107, 59, 1, 295, 4, 2, 98, 112, 10881, 10887, 117, 108, 108, 59, 1, 8259, 104, 101, 110, 59, 1, 8208, 4, 15, 97, 99, 101, 102, 103, 105, 106, 109, 110, 111, 112, 113, 115, 116, 117, 10925, 10936, 10958, 10977, 10990, 11001, 11039, 11045, 11101, 11192, 11220, 11226, 11237, 11285, 11299, 99, 117, 116, 101, 5, 237, 1, 59, 10934, 1, 237, 4, 3, 59, 105, 121, 10944, 10946, 10955, 1, 8291, 114, 99, 5, 238, 1, 59, 10953, 1, 238, 59, 1, 1080, 4, 2, 99, 120, 10964, 10968, 121, 59, 1, 1077, 99, 108, 5, 161, 1, 59, 10975, 1, 161, 4, 2, 102, 114, 10983, 10986, 59, 1, 8660, 59, 3, 55349, 56614, 114, 97, 118, 101, 5, 236, 1, 59, 10999, 1, 236, 4, 4, 59, 105, 110, 111, 11011, 11013, 11028, 11034, 1, 8520, 4, 2, 105, 110, 11019, 11024, 110, 116, 59, 1, 10764, 116, 59, 1, 8749, 102, 105, 110, 59, 1, 10716, 116, 97, 59, 1, 8489, 108, 105, 103, 59, 1, 307, 4, 3, 97, 111, 112, 11053, 11092, 11096, 4, 3, 99, 103, 116, 11061, 11065, 11088, 114, 59, 1, 299, 4, 3, 101, 108, 112, 11073, 11076, 11082, 59, 1, 8465, 105, 110, 101, 59, 1, 8464, 97, 114, 116, 59, 1, 8465, 104, 59, 1, 305, 102, 59, 1, 8887, 101, 100, 59, 1, 437, 4, 5, 59, 99, 102, 111, 116, 11113, 11115, 11121, 11136, 11142, 1, 8712, 97, 114, 101, 59, 1, 8453, 105, 110, 4, 2, 59, 116, 11129, 11131, 1, 8734, 105, 101, 59, 1, 10717, 100, 111, 116, 59, 1, 305, 4, 5, 59, 99, 101, 108, 112, 11154, 11156, 11161, 11179, 11186, 1, 8747, 97, 108, 59, 1, 8890, 4, 2, 103, 114, 11167, 11173, 101, 114, 115, 59, 1, 8484, 99, 97, 108, 59, 1, 8890, 97, 114, 104, 107, 59, 1, 10775, 114, 111, 100, 59, 1, 10812, 4, 4, 99, 103, 112, 116, 11202, 11206, 11211, 11216, 121, 59, 1, 1105, 111, 110, 59, 1, 303, 102, 59, 3, 55349, 56666, 97, 59, 1, 953, 114, 111, 100, 59, 1, 10812, 117, 101, 115, 116, 5, 191, 1, 59, 11235, 1, 191, 4, 2, 99, 105, 11243, 11248, 114, 59, 3, 55349, 56510, 110, 4, 5, 59, 69, 100, 115, 118, 11261, 11263, 11266, 11271, 11282, 1, 8712, 59, 1, 8953, 111, 116, 59, 1, 8949, 4, 2, 59, 118, 11277, 11279, 1, 8948, 59, 1, 8947, 59, 1, 8712, 4, 2, 59, 105, 11291, 11293, 1, 8290, 108, 100, 101, 59, 1, 297, 4, 2, 107, 109, 11305, 11310, 99, 121, 59, 1, 1110, 108, 5, 239, 1, 59, 11316, 1, 239, 4, 6, 99, 102, 109, 111, 115, 117, 11332, 11346, 11351, 11357, 11363, 11380, 4, 2, 105, 121, 11338, 11343, 114, 99, 59, 1, 309, 59, 1, 1081, 114, 59, 3, 55349, 56615, 97, 116, 104, 59, 1, 567, 112, 102, 59, 3, 55349, 56667, 4, 2, 99, 101, 11369, 11374, 114, 59, 3, 55349, 56511, 114, 99, 121, 59, 1, 1112, 107, 99, 121, 59, 1, 1108, 4, 8, 97, 99, 102, 103, 104, 106, 111, 115, 11404, 11418, 11433, 11438, 11445, 11450, 11455, 11461, 112, 112, 97, 4, 2, 59, 118, 11413, 11415, 1, 954, 59, 1, 1008, 4, 2, 101, 121, 11424, 11430, 100, 105, 108, 59, 1, 311, 59, 1, 1082, 114, 59, 3, 55349, 56616, 114, 101, 101, 110, 59, 1, 312, 99, 121, 59, 1, 1093, 99, 121, 59, 1, 1116, 112, 102, 59, 3, 55349, 56668, 99, 114, 59, 3, 55349, 56512, 4, 23, 65, 66, 69, 72, 97, 98, 99, 100, 101, 102, 103, 104, 106, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 11515, 11538, 11544, 11555, 11560, 11721, 11780, 11818, 11868, 12136, 12160, 12171, 12203, 12208, 12246, 12275, 12327, 12509, 12523, 12569, 12641, 12732, 12752, 4, 3, 97, 114, 116, 11523, 11528, 11532, 114, 114, 59, 1, 8666, 114, 59, 1, 8656, 97, 105, 108, 59, 1, 10523, 97, 114, 114, 59, 1, 10510, 4, 2, 59, 103, 11550, 11552, 1, 8806, 59, 1, 10891, 97, 114, 59, 1, 10594, 4, 9, 99, 101, 103, 109, 110, 112, 113, 114, 116, 11580, 11586, 11594, 11600, 11606, 11624, 11627, 11636, 11694, 117, 116, 101, 59, 1, 314, 109, 112, 116, 121, 118, 59, 1, 10676, 114, 97, 110, 59, 1, 8466, 98, 100, 97, 59, 1, 955, 103, 4, 3, 59, 100, 108, 11615, 11617, 11620, 1, 10216, 59, 1, 10641, 101, 59, 1, 10216, 59, 1, 10885, 117, 111, 5, 171, 1, 59, 11634, 1, 171, 114, 4, 8, 59, 98, 102, 104, 108, 112, 115, 116, 11655, 11657, 11669, 11673, 11677, 11681, 11685, 11690, 1, 8592, 4, 2, 59, 102, 11663, 11665, 1, 8676, 115, 59, 1, 10527, 115, 59, 1, 10525, 107, 59, 1, 8617, 112, 59, 1, 8619, 108, 59, 1, 10553, 105, 109, 59, 1, 10611, 108, 59, 1, 8610, 4, 3, 59, 97, 101, 11702, 11704, 11709, 1, 10923, 105, 108, 59, 1, 10521, 4, 2, 59, 115, 11715, 11717, 1, 10925, 59, 3, 10925, 65024, 4, 3, 97, 98, 114, 11729, 11734, 11739, 114, 114, 59, 1, 10508, 114, 107, 59, 1, 10098, 4, 2, 97, 107, 11745, 11758, 99, 4, 2, 101, 107, 11752, 11755, 59, 1, 123, 59, 1, 91, 4, 2, 101, 115, 11764, 11767, 59, 1, 10635, 108, 4, 2, 100, 117, 11774, 11777, 59, 1, 10639, 59, 1, 10637, 4, 4, 97, 101, 117, 121, 11790, 11796, 11811, 11815, 114, 111, 110, 59, 1, 318, 4, 2, 100, 105, 11802, 11807, 105, 108, 59, 1, 316, 108, 59, 1, 8968, 98, 59, 1, 123, 59, 1, 1083, 4, 4, 99, 113, 114, 115, 11828, 11832, 11845, 11864, 97, 59, 1, 10550, 117, 111, 4, 2, 59, 114, 11840, 11842, 1, 8220, 59, 1, 8222, 4, 2, 100, 117, 11851, 11857, 104, 97, 114, 59, 1, 10599, 115, 104, 97, 114, 59, 1, 10571, 104, 59, 1, 8626, 4, 5, 59, 102, 103, 113, 115, 11880, 11882, 12008, 12011, 12031, 1, 8804, 116, 4, 5, 97, 104, 108, 114, 116, 11895, 11913, 11935, 11947, 11996, 114, 114, 111, 119, 4, 2, 59, 116, 11905, 11907, 1, 8592, 97, 105, 108, 59, 1, 8610, 97, 114, 112, 111, 111, 110, 4, 2, 100, 117, 11925, 11931, 111, 119, 110, 59, 1, 8637, 112, 59, 1, 8636, 101, 102, 116, 97, 114, 114, 111, 119, 115, 59, 1, 8647, 105, 103, 104, 116, 4, 3, 97, 104, 115, 11959, 11974, 11984, 114, 114, 111, 119, 4, 2, 59, 115, 11969, 11971, 1, 8596, 59, 1, 8646, 97, 114, 112, 111, 111, 110, 115, 59, 1, 8651, 113, 117, 105, 103, 97, 114, 114, 111, 119, 59, 1, 8621, 104, 114, 101, 101, 116, 105, 109, 101, 115, 59, 1, 8907, 59, 1, 8922, 4, 3, 59, 113, 115, 12019, 12021, 12024, 1, 8804, 59, 1, 8806, 108, 97, 110, 116, 59, 1, 10877, 4, 5, 59, 99, 100, 103, 115, 12043, 12045, 12049, 12070, 12083, 1, 10877, 99, 59, 1, 10920, 111, 116, 4, 2, 59, 111, 12057, 12059, 1, 10879, 4, 2, 59, 114, 12065, 12067, 1, 10881, 59, 1, 10883, 4, 2, 59, 101, 12076, 12079, 3, 8922, 65024, 115, 59, 1, 10899, 4, 5, 97, 100, 101, 103, 115, 12095, 12103, 12108, 12126, 12131, 112, 112, 114, 111, 120, 59, 1, 10885, 111, 116, 59, 1, 8918, 113, 4, 2, 103, 113, 12115, 12120, 116, 114, 59, 1, 8922, 103, 116, 114, 59, 1, 10891, 116, 114, 59, 1, 8822, 105, 109, 59, 1, 8818, 4, 3, 105, 108, 114, 12144, 12150, 12156, 115, 104, 116, 59, 1, 10620, 111, 111, 114, 59, 1, 8970, 59, 3, 55349, 56617, 4, 2, 59, 69, 12166, 12168, 1, 8822, 59, 1, 10897, 4, 2, 97, 98, 12177, 12198, 114, 4, 2, 100, 117, 12184, 12187, 59, 1, 8637, 4, 2, 59, 108, 12193, 12195, 1, 8636, 59, 1, 10602, 108, 107, 59, 1, 9604, 99, 121, 59, 1, 1113, 4, 5, 59, 97, 99, 104, 116, 12220, 12222, 12227, 12235, 12241, 1, 8810, 114, 114, 59, 1, 8647, 111, 114, 110, 101, 114, 59, 1, 8990, 97, 114, 100, 59, 1, 10603, 114, 105, 59, 1, 9722, 4, 2, 105, 111, 12252, 12258, 100, 111, 116, 59, 1, 320, 117, 115, 116, 4, 2, 59, 97, 12267, 12269, 1, 9136, 99, 104, 101, 59, 1, 9136, 4, 4, 69, 97, 101, 115, 12285, 12288, 12303, 12322, 59, 1, 8808, 112, 4, 2, 59, 112, 12295, 12297, 1, 10889, 114, 111, 120, 59, 1, 10889, 4, 2, 59, 113, 12309, 12311, 1, 10887, 4, 2, 59, 113, 12317, 12319, 1, 10887, 59, 1, 8808, 105, 109, 59, 1, 8934, 4, 8, 97, 98, 110, 111, 112, 116, 119, 122, 12345, 12359, 12364, 12421, 12446, 12467, 12474, 12490, 4, 2, 110, 114, 12351, 12355, 103, 59, 1, 10220, 114, 59, 1, 8701, 114, 107, 59, 1, 10214, 103, 4, 3, 108, 109, 114, 12373, 12401, 12409, 101, 102, 116, 4, 2, 97, 114, 12382, 12389, 114, 114, 111, 119, 59, 1, 10229, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10231, 97, 112, 115, 116, 111, 59, 1, 10236, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10230, 112, 97, 114, 114, 111, 119, 4, 2, 108, 114, 12433, 12439, 101, 102, 116, 59, 1, 8619, 105, 103, 104, 116, 59, 1, 8620, 4, 3, 97, 102, 108, 12454, 12458, 12462, 114, 59, 1, 10629, 59, 3, 55349, 56669, 117, 115, 59, 1, 10797, 105, 109, 101, 115, 59, 1, 10804, 4, 2, 97, 98, 12480, 12485, 115, 116, 59, 1, 8727, 97, 114, 59, 1, 95, 4, 3, 59, 101, 102, 12498, 12500, 12506, 1, 9674, 110, 103, 101, 59, 1, 9674, 59, 1, 10731, 97, 114, 4, 2, 59, 108, 12517, 12519, 1, 40, 116, 59, 1, 10643, 4, 5, 97, 99, 104, 109, 116, 12535, 12540, 12548, 12561, 12564, 114, 114, 59, 1, 8646, 111, 114, 110, 101, 114, 59, 1, 8991, 97, 114, 4, 2, 59, 100, 12556, 12558, 1, 8651, 59, 1, 10605, 59, 1, 8206, 114, 105, 59, 1, 8895, 4, 6, 97, 99, 104, 105, 113, 116, 12583, 12589, 12594, 12597, 12614, 12635, 113, 117, 111, 59, 1, 8249, 114, 59, 3, 55349, 56513, 59, 1, 8624, 109, 4, 3, 59, 101, 103, 12606, 12608, 12611, 1, 8818, 59, 1, 10893, 59, 1, 10895, 4, 2, 98, 117, 12620, 12623, 59, 1, 91, 111, 4, 2, 59, 114, 12630, 12632, 1, 8216, 59, 1, 8218, 114, 111, 107, 59, 1, 322, 5, 60, 8, 59, 99, 100, 104, 105, 108, 113, 114, 12660, 12662, 12675, 12680, 12686, 12692, 12698, 12705, 1, 60, 4, 2, 99, 105, 12668, 12671, 59, 1, 10918, 114, 59, 1, 10873, 111, 116, 59, 1, 8918, 114, 101, 101, 59, 1, 8907, 109, 101, 115, 59, 1, 8905, 97, 114, 114, 59, 1, 10614, 117, 101, 115, 116, 59, 1, 10875, 4, 2, 80, 105, 12711, 12716, 97, 114, 59, 1, 10646, 4, 3, 59, 101, 102, 12724, 12726, 12729, 1, 9667, 59, 1, 8884, 59, 1, 9666, 114, 4, 2, 100, 117, 12739, 12746, 115, 104, 97, 114, 59, 1, 10570, 104, 97, 114, 59, 1, 10598, 4, 2, 101, 110, 12758, 12768, 114, 116, 110, 101, 113, 113, 59, 3, 8808, 65024, 69, 59, 3, 8808, 65024, 4, 14, 68, 97, 99, 100, 101, 102, 104, 105, 108, 110, 111, 112, 115, 117, 12803, 12809, 12893, 12908, 12914, 12928, 12933, 12937, 13011, 13025, 13032, 13049, 13052, 13069, 68, 111, 116, 59, 1, 8762, 4, 4, 99, 108, 112, 114, 12819, 12827, 12849, 12887, 114, 5, 175, 1, 59, 12825, 1, 175, 4, 2, 101, 116, 12833, 12836, 59, 1, 9794, 4, 2, 59, 101, 12842, 12844, 1, 10016, 115, 101, 59, 1, 10016, 4, 2, 59, 115, 12855, 12857, 1, 8614, 116, 111, 4, 4, 59, 100, 108, 117, 12869, 12871, 12877, 12883, 1, 8614, 111, 119, 110, 59, 1, 8615, 101, 102, 116, 59, 1, 8612, 112, 59, 1, 8613, 107, 101, 114, 59, 1, 9646, 4, 2, 111, 121, 12899, 12905, 109, 109, 97, 59, 1, 10793, 59, 1, 1084, 97, 115, 104, 59, 1, 8212, 97, 115, 117, 114, 101, 100, 97, 110, 103, 108, 101, 59, 1, 8737, 114, 59, 3, 55349, 56618, 111, 59, 1, 8487, 4, 3, 99, 100, 110, 12945, 12954, 12985, 114, 111, 5, 181, 1, 59, 12952, 1, 181, 4, 4, 59, 97, 99, 100, 12964, 12966, 12971, 12976, 1, 8739, 115, 116, 59, 1, 42, 105, 114, 59, 1, 10992, 111, 116, 5, 183, 1, 59, 12983, 1, 183, 117, 115, 4, 3, 59, 98, 100, 12995, 12997, 13e3, 1, 8722, 59, 1, 8863, 4, 2, 59, 117, 13006, 13008, 1, 8760, 59, 1, 10794, 4, 2, 99, 100, 13017, 13021, 112, 59, 1, 10971, 114, 59, 1, 8230, 112, 108, 117, 115, 59, 1, 8723, 4, 2, 100, 112, 13038, 13044, 101, 108, 115, 59, 1, 8871, 102, 59, 3, 55349, 56670, 59, 1, 8723, 4, 2, 99, 116, 13058, 13063, 114, 59, 3, 55349, 56514, 112, 111, 115, 59, 1, 8766, 4, 3, 59, 108, 109, 13077, 13079, 13087, 1, 956, 116, 105, 109, 97, 112, 59, 1, 8888, 97, 112, 59, 1, 8888, 4, 24, 71, 76, 82, 86, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 108, 109, 111, 112, 114, 115, 116, 117, 118, 119, 13142, 13165, 13217, 13229, 13247, 13330, 13359, 13414, 13420, 13508, 13513, 13579, 13602, 13626, 13631, 13762, 13767, 13855, 13936, 13995, 14214, 14285, 14312, 14432, 4, 2, 103, 116, 13148, 13152, 59, 3, 8921, 824, 4, 2, 59, 118, 13158, 13161, 3, 8811, 8402, 59, 3, 8811, 824, 4, 3, 101, 108, 116, 13173, 13200, 13204, 102, 116, 4, 2, 97, 114, 13181, 13188, 114, 114, 111, 119, 59, 1, 8653, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8654, 59, 3, 8920, 824, 4, 2, 59, 118, 13210, 13213, 3, 8810, 8402, 59, 3, 8810, 824, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8655, 4, 2, 68, 100, 13235, 13241, 97, 115, 104, 59, 1, 8879, 97, 115, 104, 59, 1, 8878, 4, 5, 98, 99, 110, 112, 116, 13259, 13264, 13270, 13275, 13308, 108, 97, 59, 1, 8711, 117, 116, 101, 59, 1, 324, 103, 59, 3, 8736, 8402, 4, 5, 59, 69, 105, 111, 112, 13287, 13289, 13293, 13298, 13302, 1, 8777, 59, 3, 10864, 824, 100, 59, 3, 8779, 824, 115, 59, 1, 329, 114, 111, 120, 59, 1, 8777, 117, 114, 4, 2, 59, 97, 13316, 13318, 1, 9838, 108, 4, 2, 59, 115, 13325, 13327, 1, 9838, 59, 1, 8469, 4, 2, 115, 117, 13336, 13344, 112, 5, 160, 1, 59, 13342, 1, 160, 109, 112, 4, 2, 59, 101, 13352, 13355, 3, 8782, 824, 59, 3, 8783, 824, 4, 5, 97, 101, 111, 117, 121, 13371, 13385, 13391, 13407, 13411, 4, 2, 112, 114, 13377, 13380, 59, 1, 10819, 111, 110, 59, 1, 328, 100, 105, 108, 59, 1, 326, 110, 103, 4, 2, 59, 100, 13399, 13401, 1, 8775, 111, 116, 59, 3, 10861, 824, 112, 59, 1, 10818, 59, 1, 1085, 97, 115, 104, 59, 1, 8211, 4, 7, 59, 65, 97, 100, 113, 115, 120, 13436, 13438, 13443, 13466, 13472, 13478, 13494, 1, 8800, 114, 114, 59, 1, 8663, 114, 4, 2, 104, 114, 13450, 13454, 107, 59, 1, 10532, 4, 2, 59, 111, 13460, 13462, 1, 8599, 119, 59, 1, 8599, 111, 116, 59, 3, 8784, 824, 117, 105, 118, 59, 1, 8802, 4, 2, 101, 105, 13484, 13489, 97, 114, 59, 1, 10536, 109, 59, 3, 8770, 824, 105, 115, 116, 4, 2, 59, 115, 13503, 13505, 1, 8708, 59, 1, 8708, 114, 59, 3, 55349, 56619, 4, 4, 69, 101, 115, 116, 13523, 13527, 13563, 13568, 59, 3, 8807, 824, 4, 3, 59, 113, 115, 13535, 13537, 13559, 1, 8817, 4, 3, 59, 113, 115, 13545, 13547, 13551, 1, 8817, 59, 3, 8807, 824, 108, 97, 110, 116, 59, 3, 10878, 824, 59, 3, 10878, 824, 105, 109, 59, 1, 8821, 4, 2, 59, 114, 13574, 13576, 1, 8815, 59, 1, 8815, 4, 3, 65, 97, 112, 13587, 13592, 13597, 114, 114, 59, 1, 8654, 114, 114, 59, 1, 8622, 97, 114, 59, 1, 10994, 4, 3, 59, 115, 118, 13610, 13612, 13623, 1, 8715, 4, 2, 59, 100, 13618, 13620, 1, 8956, 59, 1, 8954, 59, 1, 8715, 99, 121, 59, 1, 1114, 4, 7, 65, 69, 97, 100, 101, 115, 116, 13647, 13652, 13656, 13661, 13665, 13737, 13742, 114, 114, 59, 1, 8653, 59, 3, 8806, 824, 114, 114, 59, 1, 8602, 114, 59, 1, 8229, 4, 4, 59, 102, 113, 115, 13675, 13677, 13703, 13725, 1, 8816, 116, 4, 2, 97, 114, 13684, 13691, 114, 114, 111, 119, 59, 1, 8602, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8622, 4, 3, 59, 113, 115, 13711, 13713, 13717, 1, 8816, 59, 3, 8806, 824, 108, 97, 110, 116, 59, 3, 10877, 824, 4, 2, 59, 115, 13731, 13734, 3, 10877, 824, 59, 1, 8814, 105, 109, 59, 1, 8820, 4, 2, 59, 114, 13748, 13750, 1, 8814, 105, 4, 2, 59, 101, 13757, 13759, 1, 8938, 59, 1, 8940, 105, 100, 59, 1, 8740, 4, 2, 112, 116, 13773, 13778, 102, 59, 3, 55349, 56671, 5, 172, 3, 59, 105, 110, 13787, 13789, 13829, 1, 172, 110, 4, 4, 59, 69, 100, 118, 13800, 13802, 13806, 13812, 1, 8713, 59, 3, 8953, 824, 111, 116, 59, 3, 8949, 824, 4, 3, 97, 98, 99, 13820, 13823, 13826, 59, 1, 8713, 59, 1, 8951, 59, 1, 8950, 105, 4, 2, 59, 118, 13836, 13838, 1, 8716, 4, 3, 97, 98, 99, 13846, 13849, 13852, 59, 1, 8716, 59, 1, 8958, 59, 1, 8957, 4, 3, 97, 111, 114, 13863, 13892, 13899, 114, 4, 4, 59, 97, 115, 116, 13874, 13876, 13883, 13888, 1, 8742, 108, 108, 101, 108, 59, 1, 8742, 108, 59, 3, 11005, 8421, 59, 3, 8706, 824, 108, 105, 110, 116, 59, 1, 10772, 4, 3, 59, 99, 101, 13907, 13909, 13914, 1, 8832, 117, 101, 59, 1, 8928, 4, 2, 59, 99, 13920, 13923, 3, 10927, 824, 4, 2, 59, 101, 13929, 13931, 1, 8832, 113, 59, 3, 10927, 824, 4, 4, 65, 97, 105, 116, 13946, 13951, 13971, 13982, 114, 114, 59, 1, 8655, 114, 114, 4, 3, 59, 99, 119, 13961, 13963, 13967, 1, 8603, 59, 3, 10547, 824, 59, 3, 8605, 824, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8603, 114, 105, 4, 2, 59, 101, 13990, 13992, 1, 8939, 59, 1, 8941, 4, 7, 99, 104, 105, 109, 112, 113, 117, 14011, 14036, 14060, 14080, 14085, 14090, 14106, 4, 4, 59, 99, 101, 114, 14021, 14023, 14028, 14032, 1, 8833, 117, 101, 59, 1, 8929, 59, 3, 10928, 824, 59, 3, 55349, 56515, 111, 114, 116, 4, 2, 109, 112, 14045, 14050, 105, 100, 59, 1, 8740, 97, 114, 97, 108, 108, 101, 108, 59, 1, 8742, 109, 4, 2, 59, 101, 14067, 14069, 1, 8769, 4, 2, 59, 113, 14075, 14077, 1, 8772, 59, 1, 8772, 105, 100, 59, 1, 8740, 97, 114, 59, 1, 8742, 115, 117, 4, 2, 98, 112, 14098, 14102, 101, 59, 1, 8930, 101, 59, 1, 8931, 4, 3, 98, 99, 112, 14114, 14157, 14171, 4, 4, 59, 69, 101, 115, 14124, 14126, 14130, 14133, 1, 8836, 59, 3, 10949, 824, 59, 1, 8840, 101, 116, 4, 2, 59, 101, 14141, 14144, 3, 8834, 8402, 113, 4, 2, 59, 113, 14151, 14153, 1, 8840, 59, 3, 10949, 824, 99, 4, 2, 59, 101, 14164, 14166, 1, 8833, 113, 59, 3, 10928, 824, 4, 4, 59, 69, 101, 115, 14181, 14183, 14187, 14190, 1, 8837, 59, 3, 10950, 824, 59, 1, 8841, 101, 116, 4, 2, 59, 101, 14198, 14201, 3, 8835, 8402, 113, 4, 2, 59, 113, 14208, 14210, 1, 8841, 59, 3, 10950, 824, 4, 4, 103, 105, 108, 114, 14224, 14228, 14238, 14242, 108, 59, 1, 8825, 108, 100, 101, 5, 241, 1, 59, 14236, 1, 241, 103, 59, 1, 8824, 105, 97, 110, 103, 108, 101, 4, 2, 108, 114, 14254, 14269, 101, 102, 116, 4, 2, 59, 101, 14263, 14265, 1, 8938, 113, 59, 1, 8940, 105, 103, 104, 116, 4, 2, 59, 101, 14279, 14281, 1, 8939, 113, 59, 1, 8941, 4, 2, 59, 109, 14291, 14293, 1, 957, 4, 3, 59, 101, 115, 14301, 14303, 14308, 1, 35, 114, 111, 59, 1, 8470, 112, 59, 1, 8199, 4, 9, 68, 72, 97, 100, 103, 105, 108, 114, 115, 14332, 14338, 14344, 14349, 14355, 14369, 14376, 14408, 14426, 97, 115, 104, 59, 1, 8877, 97, 114, 114, 59, 1, 10500, 112, 59, 3, 8781, 8402, 97, 115, 104, 59, 1, 8876, 4, 2, 101, 116, 14361, 14365, 59, 3, 8805, 8402, 59, 3, 62, 8402, 110, 102, 105, 110, 59, 1, 10718, 4, 3, 65, 101, 116, 14384, 14389, 14393, 114, 114, 59, 1, 10498, 59, 3, 8804, 8402, 4, 2, 59, 114, 14399, 14402, 3, 60, 8402, 105, 101, 59, 3, 8884, 8402, 4, 2, 65, 116, 14414, 14419, 114, 114, 59, 1, 10499, 114, 105, 101, 59, 3, 8885, 8402, 105, 109, 59, 3, 8764, 8402, 4, 3, 65, 97, 110, 14440, 14445, 14468, 114, 114, 59, 1, 8662, 114, 4, 2, 104, 114, 14452, 14456, 107, 59, 1, 10531, 4, 2, 59, 111, 14462, 14464, 1, 8598, 119, 59, 1, 8598, 101, 97, 114, 59, 1, 10535, 4, 18, 83, 97, 99, 100, 101, 102, 103, 104, 105, 108, 109, 111, 112, 114, 115, 116, 117, 118, 14512, 14515, 14535, 14560, 14597, 14603, 14618, 14643, 14657, 14662, 14701, 14741, 14747, 14769, 14851, 14877, 14907, 14916, 59, 1, 9416, 4, 2, 99, 115, 14521, 14531, 117, 116, 101, 5, 243, 1, 59, 14529, 1, 243, 116, 59, 1, 8859, 4, 2, 105, 121, 14541, 14557, 114, 4, 2, 59, 99, 14548, 14550, 1, 8858, 5, 244, 1, 59, 14555, 1, 244, 59, 1, 1086, 4, 5, 97, 98, 105, 111, 115, 14572, 14577, 14583, 14587, 14591, 115, 104, 59, 1, 8861, 108, 97, 99, 59, 1, 337, 118, 59, 1, 10808, 116, 59, 1, 8857, 111, 108, 100, 59, 1, 10684, 108, 105, 103, 59, 1, 339, 4, 2, 99, 114, 14609, 14614, 105, 114, 59, 1, 10687, 59, 3, 55349, 56620, 4, 3, 111, 114, 116, 14626, 14630, 14640, 110, 59, 1, 731, 97, 118, 101, 5, 242, 1, 59, 14638, 1, 242, 59, 1, 10689, 4, 2, 98, 109, 14649, 14654, 97, 114, 59, 1, 10677, 59, 1, 937, 110, 116, 59, 1, 8750, 4, 4, 97, 99, 105, 116, 14672, 14677, 14693, 14698, 114, 114, 59, 1, 8634, 4, 2, 105, 114, 14683, 14687, 114, 59, 1, 10686, 111, 115, 115, 59, 1, 10683, 110, 101, 59, 1, 8254, 59, 1, 10688, 4, 3, 97, 101, 105, 14709, 14714, 14719, 99, 114, 59, 1, 333, 103, 97, 59, 1, 969, 4, 3, 99, 100, 110, 14727, 14733, 14736, 114, 111, 110, 59, 1, 959, 59, 1, 10678, 117, 115, 59, 1, 8854, 112, 102, 59, 3, 55349, 56672, 4, 3, 97, 101, 108, 14755, 14759, 14764, 114, 59, 1, 10679, 114, 112, 59, 1, 10681, 117, 115, 59, 1, 8853, 4, 7, 59, 97, 100, 105, 111, 115, 118, 14785, 14787, 14792, 14831, 14837, 14841, 14848, 1, 8744, 114, 114, 59, 1, 8635, 4, 4, 59, 101, 102, 109, 14802, 14804, 14817, 14824, 1, 10845, 114, 4, 2, 59, 111, 14811, 14813, 1, 8500, 102, 59, 1, 8500, 5, 170, 1, 59, 14822, 1, 170, 5, 186, 1, 59, 14829, 1, 186, 103, 111, 102, 59, 1, 8886, 114, 59, 1, 10838, 108, 111, 112, 101, 59, 1, 10839, 59, 1, 10843, 4, 3, 99, 108, 111, 14859, 14863, 14873, 114, 59, 1, 8500, 97, 115, 104, 5, 248, 1, 59, 14871, 1, 248, 108, 59, 1, 8856, 105, 4, 2, 108, 109, 14884, 14893, 100, 101, 5, 245, 1, 59, 14891, 1, 245, 101, 115, 4, 2, 59, 97, 14901, 14903, 1, 8855, 115, 59, 1, 10806, 109, 108, 5, 246, 1, 59, 14914, 1, 246, 98, 97, 114, 59, 1, 9021, 4, 12, 97, 99, 101, 102, 104, 105, 108, 109, 111, 114, 115, 117, 14948, 14992, 14996, 15033, 15038, 15068, 15090, 15189, 15192, 15222, 15427, 15441, 114, 4, 4, 59, 97, 115, 116, 14959, 14961, 14976, 14989, 1, 8741, 5, 182, 2, 59, 108, 14968, 14970, 1, 182, 108, 101, 108, 59, 1, 8741, 4, 2, 105, 108, 14982, 14986, 109, 59, 1, 10995, 59, 1, 11005, 59, 1, 8706, 121, 59, 1, 1087, 114, 4, 5, 99, 105, 109, 112, 116, 15009, 15014, 15019, 15024, 15027, 110, 116, 59, 1, 37, 111, 100, 59, 1, 46, 105, 108, 59, 1, 8240, 59, 1, 8869, 101, 110, 107, 59, 1, 8241, 114, 59, 3, 55349, 56621, 4, 3, 105, 109, 111, 15046, 15057, 15063, 4, 2, 59, 118, 15052, 15054, 1, 966, 59, 1, 981, 109, 97, 116, 59, 1, 8499, 110, 101, 59, 1, 9742, 4, 3, 59, 116, 118, 15076, 15078, 15087, 1, 960, 99, 104, 102, 111, 114, 107, 59, 1, 8916, 59, 1, 982, 4, 2, 97, 117, 15096, 15119, 110, 4, 2, 99, 107, 15103, 15115, 107, 4, 2, 59, 104, 15110, 15112, 1, 8463, 59, 1, 8462, 118, 59, 1, 8463, 115, 4, 9, 59, 97, 98, 99, 100, 101, 109, 115, 116, 15140, 15142, 15148, 15151, 15156, 15168, 15171, 15179, 15184, 1, 43, 99, 105, 114, 59, 1, 10787, 59, 1, 8862, 105, 114, 59, 1, 10786, 4, 2, 111, 117, 15162, 15165, 59, 1, 8724, 59, 1, 10789, 59, 1, 10866, 110, 5, 177, 1, 59, 15177, 1, 177, 105, 109, 59, 1, 10790, 119, 111, 59, 1, 10791, 59, 1, 177, 4, 3, 105, 112, 117, 15200, 15208, 15213, 110, 116, 105, 110, 116, 59, 1, 10773, 102, 59, 3, 55349, 56673, 110, 100, 5, 163, 1, 59, 15220, 1, 163, 4, 10, 59, 69, 97, 99, 101, 105, 110, 111, 115, 117, 15244, 15246, 15249, 15253, 15258, 15334, 15347, 15367, 15416, 15421, 1, 8826, 59, 1, 10931, 112, 59, 1, 10935, 117, 101, 59, 1, 8828, 4, 2, 59, 99, 15264, 15266, 1, 10927, 4, 6, 59, 97, 99, 101, 110, 115, 15280, 15282, 15290, 15299, 15303, 15329, 1, 8826, 112, 112, 114, 111, 120, 59, 1, 10935, 117, 114, 108, 121, 101, 113, 59, 1, 8828, 113, 59, 1, 10927, 4, 3, 97, 101, 115, 15311, 15319, 15324, 112, 112, 114, 111, 120, 59, 1, 10937, 113, 113, 59, 1, 10933, 105, 109, 59, 1, 8936, 105, 109, 59, 1, 8830, 109, 101, 4, 2, 59, 115, 15342, 15344, 1, 8242, 59, 1, 8473, 4, 3, 69, 97, 115, 15355, 15358, 15362, 59, 1, 10933, 112, 59, 1, 10937, 105, 109, 59, 1, 8936, 4, 3, 100, 102, 112, 15375, 15378, 15404, 59, 1, 8719, 4, 3, 97, 108, 115, 15386, 15392, 15398, 108, 97, 114, 59, 1, 9006, 105, 110, 101, 59, 1, 8978, 117, 114, 102, 59, 1, 8979, 4, 2, 59, 116, 15410, 15412, 1, 8733, 111, 59, 1, 8733, 105, 109, 59, 1, 8830, 114, 101, 108, 59, 1, 8880, 4, 2, 99, 105, 15433, 15438, 114, 59, 3, 55349, 56517, 59, 1, 968, 110, 99, 115, 112, 59, 1, 8200, 4, 6, 102, 105, 111, 112, 115, 117, 15462, 15467, 15472, 15478, 15485, 15491, 114, 59, 3, 55349, 56622, 110, 116, 59, 1, 10764, 112, 102, 59, 3, 55349, 56674, 114, 105, 109, 101, 59, 1, 8279, 99, 114, 59, 3, 55349, 56518, 4, 3, 97, 101, 111, 15499, 15520, 15534, 116, 4, 2, 101, 105, 15506, 15515, 114, 110, 105, 111, 110, 115, 59, 1, 8461, 110, 116, 59, 1, 10774, 115, 116, 4, 2, 59, 101, 15528, 15530, 1, 63, 113, 59, 1, 8799, 116, 5, 34, 1, 59, 15540, 1, 34, 4, 21, 65, 66, 72, 97, 98, 99, 100, 101, 102, 104, 105, 108, 109, 110, 111, 112, 114, 115, 116, 117, 120, 15586, 15609, 15615, 15620, 15796, 15855, 15893, 15931, 15977, 16001, 16039, 16183, 16204, 16222, 16228, 16285, 16312, 16318, 16363, 16408, 16416, 4, 3, 97, 114, 116, 15594, 15599, 15603, 114, 114, 59, 1, 8667, 114, 59, 1, 8658, 97, 105, 108, 59, 1, 10524, 97, 114, 114, 59, 1, 10511, 97, 114, 59, 1, 10596, 4, 7, 99, 100, 101, 110, 113, 114, 116, 15636, 15651, 15656, 15664, 15687, 15696, 15770, 4, 2, 101, 117, 15642, 15646, 59, 3, 8765, 817, 116, 101, 59, 1, 341, 105, 99, 59, 1, 8730, 109, 112, 116, 121, 118, 59, 1, 10675, 103, 4, 4, 59, 100, 101, 108, 15675, 15677, 15680, 15683, 1, 10217, 59, 1, 10642, 59, 1, 10661, 101, 59, 1, 10217, 117, 111, 5, 187, 1, 59, 15694, 1, 187, 114, 4, 11, 59, 97, 98, 99, 102, 104, 108, 112, 115, 116, 119, 15721, 15723, 15727, 15739, 15742, 15746, 15750, 15754, 15758, 15763, 15767, 1, 8594, 112, 59, 1, 10613, 4, 2, 59, 102, 15733, 15735, 1, 8677, 115, 59, 1, 10528, 59, 1, 10547, 115, 59, 1, 10526, 107, 59, 1, 8618, 112, 59, 1, 8620, 108, 59, 1, 10565, 105, 109, 59, 1, 10612, 108, 59, 1, 8611, 59, 1, 8605, 4, 2, 97, 105, 15776, 15781, 105, 108, 59, 1, 10522, 111, 4, 2, 59, 110, 15788, 15790, 1, 8758, 97, 108, 115, 59, 1, 8474, 4, 3, 97, 98, 114, 15804, 15809, 15814, 114, 114, 59, 1, 10509, 114, 107, 59, 1, 10099, 4, 2, 97, 107, 15820, 15833, 99, 4, 2, 101, 107, 15827, 15830, 59, 1, 125, 59, 1, 93, 4, 2, 101, 115, 15839, 15842, 59, 1, 10636, 108, 4, 2, 100, 117, 15849, 15852, 59, 1, 10638, 59, 1, 10640, 4, 4, 97, 101, 117, 121, 15865, 15871, 15886, 15890, 114, 111, 110, 59, 1, 345, 4, 2, 100, 105, 15877, 15882, 105, 108, 59, 1, 343, 108, 59, 1, 8969, 98, 59, 1, 125, 59, 1, 1088, 4, 4, 99, 108, 113, 115, 15903, 15907, 15914, 15927, 97, 59, 1, 10551, 100, 104, 97, 114, 59, 1, 10601, 117, 111, 4, 2, 59, 114, 15922, 15924, 1, 8221, 59, 1, 8221, 104, 59, 1, 8627, 4, 3, 97, 99, 103, 15939, 15966, 15970, 108, 4, 4, 59, 105, 112, 115, 15950, 15952, 15957, 15963, 1, 8476, 110, 101, 59, 1, 8475, 97, 114, 116, 59, 1, 8476, 59, 1, 8477, 116, 59, 1, 9645, 5, 174, 1, 59, 15975, 1, 174, 4, 3, 105, 108, 114, 15985, 15991, 15997, 115, 104, 116, 59, 1, 10621, 111, 111, 114, 59, 1, 8971, 59, 3, 55349, 56623, 4, 2, 97, 111, 16007, 16028, 114, 4, 2, 100, 117, 16014, 16017, 59, 1, 8641, 4, 2, 59, 108, 16023, 16025, 1, 8640, 59, 1, 10604, 4, 2, 59, 118, 16034, 16036, 1, 961, 59, 1, 1009, 4, 3, 103, 110, 115, 16047, 16167, 16171, 104, 116, 4, 6, 97, 104, 108, 114, 115, 116, 16063, 16081, 16103, 16130, 16143, 16155, 114, 114, 111, 119, 4, 2, 59, 116, 16073, 16075, 1, 8594, 97, 105, 108, 59, 1, 8611, 97, 114, 112, 111, 111, 110, 4, 2, 100, 117, 16093, 16099, 111, 119, 110, 59, 1, 8641, 112, 59, 1, 8640, 101, 102, 116, 4, 2, 97, 104, 16112, 16120, 114, 114, 111, 119, 115, 59, 1, 8644, 97, 114, 112, 111, 111, 110, 115, 59, 1, 8652, 105, 103, 104, 116, 97, 114, 114, 111, 119, 115, 59, 1, 8649, 113, 117, 105, 103, 97, 114, 114, 111, 119, 59, 1, 8605, 104, 114, 101, 101, 116, 105, 109, 101, 115, 59, 1, 8908, 103, 59, 1, 730, 105, 110, 103, 100, 111, 116, 115, 101, 113, 59, 1, 8787, 4, 3, 97, 104, 109, 16191, 16196, 16201, 114, 114, 59, 1, 8644, 97, 114, 59, 1, 8652, 59, 1, 8207, 111, 117, 115, 116, 4, 2, 59, 97, 16214, 16216, 1, 9137, 99, 104, 101, 59, 1, 9137, 109, 105, 100, 59, 1, 10990, 4, 4, 97, 98, 112, 116, 16238, 16252, 16257, 16278, 4, 2, 110, 114, 16244, 16248, 103, 59, 1, 10221, 114, 59, 1, 8702, 114, 107, 59, 1, 10215, 4, 3, 97, 102, 108, 16265, 16269, 16273, 114, 59, 1, 10630, 59, 3, 55349, 56675, 117, 115, 59, 1, 10798, 105, 109, 101, 115, 59, 1, 10805, 4, 2, 97, 112, 16291, 16304, 114, 4, 2, 59, 103, 16298, 16300, 1, 41, 116, 59, 1, 10644, 111, 108, 105, 110, 116, 59, 1, 10770, 97, 114, 114, 59, 1, 8649, 4, 4, 97, 99, 104, 113, 16328, 16334, 16339, 16342, 113, 117, 111, 59, 1, 8250, 114, 59, 3, 55349, 56519, 59, 1, 8625, 4, 2, 98, 117, 16348, 16351, 59, 1, 93, 111, 4, 2, 59, 114, 16358, 16360, 1, 8217, 59, 1, 8217, 4, 3, 104, 105, 114, 16371, 16377, 16383, 114, 101, 101, 59, 1, 8908, 109, 101, 115, 59, 1, 8906, 105, 4, 4, 59, 101, 102, 108, 16394, 16396, 16399, 16402, 1, 9657, 59, 1, 8885, 59, 1, 9656, 116, 114, 105, 59, 1, 10702, 108, 117, 104, 97, 114, 59, 1, 10600, 59, 1, 8478, 4, 19, 97, 98, 99, 100, 101, 102, 104, 105, 108, 109, 111, 112, 113, 114, 115, 116, 117, 119, 122, 16459, 16466, 16472, 16572, 16590, 16672, 16687, 16746, 16844, 16850, 16924, 16963, 16988, 17115, 17121, 17154, 17206, 17614, 17656, 99, 117, 116, 101, 59, 1, 347, 113, 117, 111, 59, 1, 8218, 4, 10, 59, 69, 97, 99, 101, 105, 110, 112, 115, 121, 16494, 16496, 16499, 16513, 16518, 16531, 16536, 16556, 16564, 16569, 1, 8827, 59, 1, 10932, 4, 2, 112, 114, 16505, 16508, 59, 1, 10936, 111, 110, 59, 1, 353, 117, 101, 59, 1, 8829, 4, 2, 59, 100, 16524, 16526, 1, 10928, 105, 108, 59, 1, 351, 114, 99, 59, 1, 349, 4, 3, 69, 97, 115, 16544, 16547, 16551, 59, 1, 10934, 112, 59, 1, 10938, 105, 109, 59, 1, 8937, 111, 108, 105, 110, 116, 59, 1, 10771, 105, 109, 59, 1, 8831, 59, 1, 1089, 111, 116, 4, 3, 59, 98, 101, 16582, 16584, 16587, 1, 8901, 59, 1, 8865, 59, 1, 10854, 4, 7, 65, 97, 99, 109, 115, 116, 120, 16606, 16611, 16634, 16642, 16646, 16652, 16668, 114, 114, 59, 1, 8664, 114, 4, 2, 104, 114, 16618, 16622, 107, 59, 1, 10533, 4, 2, 59, 111, 16628, 16630, 1, 8600, 119, 59, 1, 8600, 116, 5, 167, 1, 59, 16640, 1, 167, 105, 59, 1, 59, 119, 97, 114, 59, 1, 10537, 109, 4, 2, 105, 110, 16659, 16665, 110, 117, 115, 59, 1, 8726, 59, 1, 8726, 116, 59, 1, 10038, 114, 4, 2, 59, 111, 16679, 16682, 3, 55349, 56624, 119, 110, 59, 1, 8994, 4, 4, 97, 99, 111, 121, 16697, 16702, 16716, 16739, 114, 112, 59, 1, 9839, 4, 2, 104, 121, 16708, 16713, 99, 121, 59, 1, 1097, 59, 1, 1096, 114, 116, 4, 2, 109, 112, 16724, 16729, 105, 100, 59, 1, 8739, 97, 114, 97, 108, 108, 101, 108, 59, 1, 8741, 5, 173, 1, 59, 16744, 1, 173, 4, 2, 103, 109, 16752, 16770, 109, 97, 4, 3, 59, 102, 118, 16762, 16764, 16767, 1, 963, 59, 1, 962, 59, 1, 962, 4, 8, 59, 100, 101, 103, 108, 110, 112, 114, 16788, 16790, 16795, 16806, 16817, 16828, 16832, 16838, 1, 8764, 111, 116, 59, 1, 10858, 4, 2, 59, 113, 16801, 16803, 1, 8771, 59, 1, 8771, 4, 2, 59, 69, 16812, 16814, 1, 10910, 59, 1, 10912, 4, 2, 59, 69, 16823, 16825, 1, 10909, 59, 1, 10911, 101, 59, 1, 8774, 108, 117, 115, 59, 1, 10788, 97, 114, 114, 59, 1, 10610, 97, 114, 114, 59, 1, 8592, 4, 4, 97, 101, 105, 116, 16860, 16883, 16891, 16904, 4, 2, 108, 115, 16866, 16878, 108, 115, 101, 116, 109, 105, 110, 117, 115, 59, 1, 8726, 104, 112, 59, 1, 10803, 112, 97, 114, 115, 108, 59, 1, 10724, 4, 2, 100, 108, 16897, 16900, 59, 1, 8739, 101, 59, 1, 8995, 4, 2, 59, 101, 16910, 16912, 1, 10922, 4, 2, 59, 115, 16918, 16920, 1, 10924, 59, 3, 10924, 65024, 4, 3, 102, 108, 112, 16932, 16938, 16958, 116, 99, 121, 59, 1, 1100, 4, 2, 59, 98, 16944, 16946, 1, 47, 4, 2, 59, 97, 16952, 16954, 1, 10692, 114, 59, 1, 9023, 102, 59, 3, 55349, 56676, 97, 4, 2, 100, 114, 16970, 16985, 101, 115, 4, 2, 59, 117, 16978, 16980, 1, 9824, 105, 116, 59, 1, 9824, 59, 1, 8741, 4, 3, 99, 115, 117, 16996, 17028, 17089, 4, 2, 97, 117, 17002, 17015, 112, 4, 2, 59, 115, 17009, 17011, 1, 8851, 59, 3, 8851, 65024, 112, 4, 2, 59, 115, 17022, 17024, 1, 8852, 59, 3, 8852, 65024, 117, 4, 2, 98, 112, 17035, 17062, 4, 3, 59, 101, 115, 17043, 17045, 17048, 1, 8847, 59, 1, 8849, 101, 116, 4, 2, 59, 101, 17056, 17058, 1, 8847, 113, 59, 1, 8849, 4, 3, 59, 101, 115, 17070, 17072, 17075, 1, 8848, 59, 1, 8850, 101, 116, 4, 2, 59, 101, 17083, 17085, 1, 8848, 113, 59, 1, 8850, 4, 3, 59, 97, 102, 17097, 17099, 17112, 1, 9633, 114, 4, 2, 101, 102, 17106, 17109, 59, 1, 9633, 59, 1, 9642, 59, 1, 9642, 97, 114, 114, 59, 1, 8594, 4, 4, 99, 101, 109, 116, 17131, 17136, 17142, 17148, 114, 59, 3, 55349, 56520, 116, 109, 110, 59, 1, 8726, 105, 108, 101, 59, 1, 8995, 97, 114, 102, 59, 1, 8902, 4, 2, 97, 114, 17160, 17172, 114, 4, 2, 59, 102, 17167, 17169, 1, 9734, 59, 1, 9733, 4, 2, 97, 110, 17178, 17202, 105, 103, 104, 116, 4, 2, 101, 112, 17188, 17197, 112, 115, 105, 108, 111, 110, 59, 1, 1013, 104, 105, 59, 1, 981, 115, 59, 1, 175, 4, 5, 98, 99, 109, 110, 112, 17218, 17351, 17420, 17423, 17427, 4, 9, 59, 69, 100, 101, 109, 110, 112, 114, 115, 17238, 17240, 17243, 17248, 17261, 17267, 17279, 17285, 17291, 1, 8834, 59, 1, 10949, 111, 116, 59, 1, 10941, 4, 2, 59, 100, 17254, 17256, 1, 8838, 111, 116, 59, 1, 10947, 117, 108, 116, 59, 1, 10945, 4, 2, 69, 101, 17273, 17276, 59, 1, 10955, 59, 1, 8842, 108, 117, 115, 59, 1, 10943, 97, 114, 114, 59, 1, 10617, 4, 3, 101, 105, 117, 17299, 17335, 17339, 116, 4, 3, 59, 101, 110, 17308, 17310, 17322, 1, 8834, 113, 4, 2, 59, 113, 17317, 17319, 1, 8838, 59, 1, 10949, 101, 113, 4, 2, 59, 113, 17330, 17332, 1, 8842, 59, 1, 10955, 109, 59, 1, 10951, 4, 2, 98, 112, 17345, 17348, 59, 1, 10965, 59, 1, 10963, 99, 4, 6, 59, 97, 99, 101, 110, 115, 17366, 17368, 17376, 17385, 17389, 17415, 1, 8827, 112, 112, 114, 111, 120, 59, 1, 10936, 117, 114, 108, 121, 101, 113, 59, 1, 8829, 113, 59, 1, 10928, 4, 3, 97, 101, 115, 17397, 17405, 17410, 112, 112, 114, 111, 120, 59, 1, 10938, 113, 113, 59, 1, 10934, 105, 109, 59, 1, 8937, 105, 109, 59, 1, 8831, 59, 1, 8721, 103, 59, 1, 9834, 4, 13, 49, 50, 51, 59, 69, 100, 101, 104, 108, 109, 110, 112, 115, 17455, 17462, 17469, 17476, 17478, 17481, 17496, 17509, 17524, 17530, 17536, 17548, 17554, 5, 185, 1, 59, 17460, 1, 185, 5, 178, 1, 59, 17467, 1, 178, 5, 179, 1, 59, 17474, 1, 179, 1, 8835, 59, 1, 10950, 4, 2, 111, 115, 17487, 17491, 116, 59, 1, 10942, 117, 98, 59, 1, 10968, 4, 2, 59, 100, 17502, 17504, 1, 8839, 111, 116, 59, 1, 10948, 115, 4, 2, 111, 117, 17516, 17520, 108, 59, 1, 10185, 98, 59, 1, 10967, 97, 114, 114, 59, 1, 10619, 117, 108, 116, 59, 1, 10946, 4, 2, 69, 101, 17542, 17545, 59, 1, 10956, 59, 1, 8843, 108, 117, 115, 59, 1, 10944, 4, 3, 101, 105, 117, 17562, 17598, 17602, 116, 4, 3, 59, 101, 110, 17571, 17573, 17585, 1, 8835, 113, 4, 2, 59, 113, 17580, 17582, 1, 8839, 59, 1, 10950, 101, 113, 4, 2, 59, 113, 17593, 17595, 1, 8843, 59, 1, 10956, 109, 59, 1, 10952, 4, 2, 98, 112, 17608, 17611, 59, 1, 10964, 59, 1, 10966, 4, 3, 65, 97, 110, 17622, 17627, 17650, 114, 114, 59, 1, 8665, 114, 4, 2, 104, 114, 17634, 17638, 107, 59, 1, 10534, 4, 2, 59, 111, 17644, 17646, 1, 8601, 119, 59, 1, 8601, 119, 97, 114, 59, 1, 10538, 108, 105, 103, 5, 223, 1, 59, 17664, 1, 223, 4, 13, 97, 98, 99, 100, 101, 102, 104, 105, 111, 112, 114, 115, 119, 17694, 17709, 17714, 17737, 17742, 17749, 17754, 17860, 17905, 17957, 17964, 18090, 18122, 4, 2, 114, 117, 17700, 17706, 103, 101, 116, 59, 1, 8982, 59, 1, 964, 114, 107, 59, 1, 9140, 4, 3, 97, 101, 121, 17722, 17728, 17734, 114, 111, 110, 59, 1, 357, 100, 105, 108, 59, 1, 355, 59, 1, 1090, 111, 116, 59, 1, 8411, 108, 114, 101, 99, 59, 1, 8981, 114, 59, 3, 55349, 56625, 4, 4, 101, 105, 107, 111, 17764, 17805, 17836, 17851, 4, 2, 114, 116, 17770, 17786, 101, 4, 2, 52, 102, 17777, 17780, 59, 1, 8756, 111, 114, 101, 59, 1, 8756, 97, 4, 3, 59, 115, 118, 17795, 17797, 17802, 1, 952, 121, 109, 59, 1, 977, 59, 1, 977, 4, 2, 99, 110, 17811, 17831, 107, 4, 2, 97, 115, 17818, 17826, 112, 112, 114, 111, 120, 59, 1, 8776, 105, 109, 59, 1, 8764, 115, 112, 59, 1, 8201, 4, 2, 97, 115, 17842, 17846, 112, 59, 1, 8776, 105, 109, 59, 1, 8764, 114, 110, 5, 254, 1, 59, 17858, 1, 254, 4, 3, 108, 109, 110, 17868, 17873, 17901, 100, 101, 59, 1, 732, 101, 115, 5, 215, 3, 59, 98, 100, 17884, 17886, 17898, 1, 215, 4, 2, 59, 97, 17892, 17894, 1, 8864, 114, 59, 1, 10801, 59, 1, 10800, 116, 59, 1, 8749, 4, 3, 101, 112, 115, 17913, 17917, 17953, 97, 59, 1, 10536, 4, 4, 59, 98, 99, 102, 17927, 17929, 17934, 17939, 1, 8868, 111, 116, 59, 1, 9014, 105, 114, 59, 1, 10993, 4, 2, 59, 111, 17945, 17948, 3, 55349, 56677, 114, 107, 59, 1, 10970, 97, 59, 1, 10537, 114, 105, 109, 101, 59, 1, 8244, 4, 3, 97, 105, 112, 17972, 17977, 18082, 100, 101, 59, 1, 8482, 4, 7, 97, 100, 101, 109, 112, 115, 116, 17993, 18051, 18056, 18059, 18066, 18072, 18076, 110, 103, 108, 101, 4, 5, 59, 100, 108, 113, 114, 18009, 18011, 18017, 18032, 18035, 1, 9653, 111, 119, 110, 59, 1, 9663, 101, 102, 116, 4, 2, 59, 101, 18026, 18028, 1, 9667, 113, 59, 1, 8884, 59, 1, 8796, 105, 103, 104, 116, 4, 2, 59, 101, 18045, 18047, 1, 9657, 113, 59, 1, 8885, 111, 116, 59, 1, 9708, 59, 1, 8796, 105, 110, 117, 115, 59, 1, 10810, 108, 117, 115, 59, 1, 10809, 98, 59, 1, 10701, 105, 109, 101, 59, 1, 10811, 101, 122, 105, 117, 109, 59, 1, 9186, 4, 3, 99, 104, 116, 18098, 18111, 18116, 4, 2, 114, 121, 18104, 18108, 59, 3, 55349, 56521, 59, 1, 1094, 99, 121, 59, 1, 1115, 114, 111, 107, 59, 1, 359, 4, 2, 105, 111, 18128, 18133, 120, 116, 59, 1, 8812, 104, 101, 97, 100, 4, 2, 108, 114, 18143, 18154, 101, 102, 116, 97, 114, 114, 111, 119, 59, 1, 8606, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8608, 4, 18, 65, 72, 97, 98, 99, 100, 102, 103, 104, 108, 109, 111, 112, 114, 115, 116, 117, 119, 18204, 18209, 18214, 18234, 18250, 18268, 18292, 18308, 18319, 18343, 18379, 18397, 18413, 18504, 18547, 18553, 18584, 18603, 114, 114, 59, 1, 8657, 97, 114, 59, 1, 10595, 4, 2, 99, 114, 18220, 18230, 117, 116, 101, 5, 250, 1, 59, 18228, 1, 250, 114, 59, 1, 8593, 114, 4, 2, 99, 101, 18241, 18245, 121, 59, 1, 1118, 118, 101, 59, 1, 365, 4, 2, 105, 121, 18256, 18265, 114, 99, 5, 251, 1, 59, 18263, 1, 251, 59, 1, 1091, 4, 3, 97, 98, 104, 18276, 18281, 18287, 114, 114, 59, 1, 8645, 108, 97, 99, 59, 1, 369, 97, 114, 59, 1, 10606, 4, 2, 105, 114, 18298, 18304, 115, 104, 116, 59, 1, 10622, 59, 3, 55349, 56626, 114, 97, 118, 101, 5, 249, 1, 59, 18317, 1, 249, 4, 2, 97, 98, 18325, 18338, 114, 4, 2, 108, 114, 18332, 18335, 59, 1, 8639, 59, 1, 8638, 108, 107, 59, 1, 9600, 4, 2, 99, 116, 18349, 18374, 4, 2, 111, 114, 18355, 18369, 114, 110, 4, 2, 59, 101, 18363, 18365, 1, 8988, 114, 59, 1, 8988, 111, 112, 59, 1, 8975, 114, 105, 59, 1, 9720, 4, 2, 97, 108, 18385, 18390, 99, 114, 59, 1, 363, 5, 168, 1, 59, 18395, 1, 168, 4, 2, 103, 112, 18403, 18408, 111, 110, 59, 1, 371, 102, 59, 3, 55349, 56678, 4, 6, 97, 100, 104, 108, 115, 117, 18427, 18434, 18445, 18470, 18475, 18494, 114, 114, 111, 119, 59, 1, 8593, 111, 119, 110, 97, 114, 114, 111, 119, 59, 1, 8597, 97, 114, 112, 111, 111, 110, 4, 2, 108, 114, 18457, 18463, 101, 102, 116, 59, 1, 8639, 105, 103, 104, 116, 59, 1, 8638, 117, 115, 59, 1, 8846, 105, 4, 3, 59, 104, 108, 18484, 18486, 18489, 1, 965, 59, 1, 978, 111, 110, 59, 1, 965, 112, 97, 114, 114, 111, 119, 115, 59, 1, 8648, 4, 3, 99, 105, 116, 18512, 18537, 18542, 4, 2, 111, 114, 18518, 18532, 114, 110, 4, 2, 59, 101, 18526, 18528, 1, 8989, 114, 59, 1, 8989, 111, 112, 59, 1, 8974, 110, 103, 59, 1, 367, 114, 105, 59, 1, 9721, 99, 114, 59, 3, 55349, 56522, 4, 3, 100, 105, 114, 18561, 18566, 18572, 111, 116, 59, 1, 8944, 108, 100, 101, 59, 1, 361, 105, 4, 2, 59, 102, 18579, 18581, 1, 9653, 59, 1, 9652, 4, 2, 97, 109, 18590, 18595, 114, 114, 59, 1, 8648, 108, 5, 252, 1, 59, 18601, 1, 252, 97, 110, 103, 108, 101, 59, 1, 10663, 4, 15, 65, 66, 68, 97, 99, 100, 101, 102, 108, 110, 111, 112, 114, 115, 122, 18643, 18648, 18661, 18667, 18847, 18851, 18857, 18904, 18909, 18915, 18931, 18937, 18943, 18949, 18996, 114, 114, 59, 1, 8661, 97, 114, 4, 2, 59, 118, 18656, 18658, 1, 10984, 59, 1, 10985, 97, 115, 104, 59, 1, 8872, 4, 2, 110, 114, 18673, 18679, 103, 114, 116, 59, 1, 10652, 4, 7, 101, 107, 110, 112, 114, 115, 116, 18695, 18704, 18711, 18720, 18742, 18754, 18810, 112, 115, 105, 108, 111, 110, 59, 1, 1013, 97, 112, 112, 97, 59, 1, 1008, 111, 116, 104, 105, 110, 103, 59, 1, 8709, 4, 3, 104, 105, 114, 18728, 18732, 18735, 105, 59, 1, 981, 59, 1, 982, 111, 112, 116, 111, 59, 1, 8733, 4, 2, 59, 104, 18748, 18750, 1, 8597, 111, 59, 1, 1009, 4, 2, 105, 117, 18760, 18766, 103, 109, 97, 59, 1, 962, 4, 2, 98, 112, 18772, 18791, 115, 101, 116, 110, 101, 113, 4, 2, 59, 113, 18784, 18787, 3, 8842, 65024, 59, 3, 10955, 65024, 115, 101, 116, 110, 101, 113, 4, 2, 59, 113, 18803, 18806, 3, 8843, 65024, 59, 3, 10956, 65024, 4, 2, 104, 114, 18816, 18822, 101, 116, 97, 59, 1, 977, 105, 97, 110, 103, 108, 101, 4, 2, 108, 114, 18834, 18840, 101, 102, 116, 59, 1, 8882, 105, 103, 104, 116, 59, 1, 8883, 121, 59, 1, 1074, 97, 115, 104, 59, 1, 8866, 4, 3, 101, 108, 114, 18865, 18884, 18890, 4, 3, 59, 98, 101, 18873, 18875, 18880, 1, 8744, 97, 114, 59, 1, 8891, 113, 59, 1, 8794, 108, 105, 112, 59, 1, 8942, 4, 2, 98, 116, 18896, 18901, 97, 114, 59, 1, 124, 59, 1, 124, 114, 59, 3, 55349, 56627, 116, 114, 105, 59, 1, 8882, 115, 117, 4, 2, 98, 112, 18923, 18927, 59, 3, 8834, 8402, 59, 3, 8835, 8402, 112, 102, 59, 3, 55349, 56679, 114, 111, 112, 59, 1, 8733, 116, 114, 105, 59, 1, 8883, 4, 2, 99, 117, 18955, 18960, 114, 59, 3, 55349, 56523, 4, 2, 98, 112, 18966, 18981, 110, 4, 2, 69, 101, 18973, 18977, 59, 3, 10955, 65024, 59, 3, 8842, 65024, 110, 4, 2, 69, 101, 18988, 18992, 59, 3, 10956, 65024, 59, 3, 8843, 65024, 105, 103, 122, 97, 103, 59, 1, 10650, 4, 7, 99, 101, 102, 111, 112, 114, 115, 19020, 19026, 19061, 19066, 19072, 19075, 19089, 105, 114, 99, 59, 1, 373, 4, 2, 100, 105, 19032, 19055, 4, 2, 98, 103, 19038, 19043, 97, 114, 59, 1, 10847, 101, 4, 2, 59, 113, 19050, 19052, 1, 8743, 59, 1, 8793, 101, 114, 112, 59, 1, 8472, 114, 59, 3, 55349, 56628, 112, 102, 59, 3, 55349, 56680, 59, 1, 8472, 4, 2, 59, 101, 19081, 19083, 1, 8768, 97, 116, 104, 59, 1, 8768, 99, 114, 59, 3, 55349, 56524, 4, 14, 99, 100, 102, 104, 105, 108, 109, 110, 111, 114, 115, 117, 118, 119, 19125, 19146, 19152, 19157, 19173, 19176, 19192, 19197, 19202, 19236, 19252, 19269, 19286, 19291, 4, 3, 97, 105, 117, 19133, 19137, 19142, 112, 59, 1, 8898, 114, 99, 59, 1, 9711, 112, 59, 1, 8899, 116, 114, 105, 59, 1, 9661, 114, 59, 3, 55349, 56629, 4, 2, 65, 97, 19163, 19168, 114, 114, 59, 1, 10234, 114, 114, 59, 1, 10231, 59, 1, 958, 4, 2, 65, 97, 19182, 19187, 114, 114, 59, 1, 10232, 114, 114, 59, 1, 10229, 97, 112, 59, 1, 10236, 105, 115, 59, 1, 8955, 4, 3, 100, 112, 116, 19210, 19215, 19230, 111, 116, 59, 1, 10752, 4, 2, 102, 108, 19221, 19225, 59, 3, 55349, 56681, 117, 115, 59, 1, 10753, 105, 109, 101, 59, 1, 10754, 4, 2, 65, 97, 19242, 19247, 114, 114, 59, 1, 10233, 114, 114, 59, 1, 10230, 4, 2, 99, 113, 19258, 19263, 114, 59, 3, 55349, 56525, 99, 117, 112, 59, 1, 10758, 4, 2, 112, 116, 19275, 19281, 108, 117, 115, 59, 1, 10756, 114, 105, 59, 1, 9651, 101, 101, 59, 1, 8897, 101, 100, 103, 101, 59, 1, 8896, 4, 8, 97, 99, 101, 102, 105, 111, 115, 117, 19316, 19335, 19349, 19357, 19362, 19367, 19373, 19379, 99, 4, 2, 117, 121, 19323, 19332, 116, 101, 5, 253, 1, 59, 19330, 1, 253, 59, 1, 1103, 4, 2, 105, 121, 19341, 19346, 114, 99, 59, 1, 375, 59, 1, 1099, 110, 5, 165, 1, 59, 19355, 1, 165, 114, 59, 3, 55349, 56630, 99, 121, 59, 1, 1111, 112, 102, 59, 3, 55349, 56682, 99, 114, 59, 3, 55349, 56526, 4, 2, 99, 109, 19385, 19389, 121, 59, 1, 1102, 108, 5, 255, 1, 59, 19395, 1, 255, 4, 10, 97, 99, 100, 101, 102, 104, 105, 111, 115, 119, 19419, 19426, 19441, 19446, 19462, 19467, 19472, 19480, 19486, 19492, 99, 117, 116, 101, 59, 1, 378, 4, 2, 97, 121, 19432, 19438, 114, 111, 110, 59, 1, 382, 59, 1, 1079, 111, 116, 59, 1, 380, 4, 2, 101, 116, 19452, 19458, 116, 114, 102, 59, 1, 8488, 97, 59, 1, 950, 114, 59, 3, 55349, 56631, 99, 121, 59, 1, 1078, 103, 114, 97, 114, 114, 59, 1, 8669, 112, 102, 59, 3, 55349, 56683, 99, 114, 59, 3, 55349, 56527, 4, 2, 106, 110, 19498, 19501, 59, 1, 8205, 106, 59, 1, 8204]);
    const Preprocessor = preprocessor;
    const unicode$1 = unicode$3;
    const neTree = namedEntityData;
    const ERR$1 = errorCodes;
    const $$5 = unicode$1.CODE_POINTS;
    const $$ = unicode$1.CODE_POINT_SEQUENCES;
    const C1_CONTROLS_REFERENCE_REPLACEMENTS = {
      128: 8364,
      130: 8218,
      131: 402,
      132: 8222,
      133: 8230,
      134: 8224,
      135: 8225,
      136: 710,
      137: 8240,
      138: 352,
      139: 8249,
      140: 338,
      142: 381,
      145: 8216,
      146: 8217,
      147: 8220,
      148: 8221,
      149: 8226,
      150: 8211,
      151: 8212,
      152: 732,
      153: 8482,
      154: 353,
      155: 8250,
      156: 339,
      158: 382,
      159: 376
    };
    const HAS_DATA_FLAG = 1 << 0;
    const DATA_DUPLET_FLAG = 1 << 1;
    const HAS_BRANCHES_FLAG = 1 << 2;
    const MAX_BRANCH_MARKER_VALUE = HAS_DATA_FLAG | DATA_DUPLET_FLAG | HAS_BRANCHES_FLAG;
    const DATA_STATE = "DATA_STATE";
    const RCDATA_STATE = "RCDATA_STATE";
    const RAWTEXT_STATE = "RAWTEXT_STATE";
    const SCRIPT_DATA_STATE = "SCRIPT_DATA_STATE";
    const PLAINTEXT_STATE = "PLAINTEXT_STATE";
    const TAG_OPEN_STATE = "TAG_OPEN_STATE";
    const END_TAG_OPEN_STATE = "END_TAG_OPEN_STATE";
    const TAG_NAME_STATE = "TAG_NAME_STATE";
    const RCDATA_LESS_THAN_SIGN_STATE = "RCDATA_LESS_THAN_SIGN_STATE";
    const RCDATA_END_TAG_OPEN_STATE = "RCDATA_END_TAG_OPEN_STATE";
    const RCDATA_END_TAG_NAME_STATE = "RCDATA_END_TAG_NAME_STATE";
    const RAWTEXT_LESS_THAN_SIGN_STATE = "RAWTEXT_LESS_THAN_SIGN_STATE";
    const RAWTEXT_END_TAG_OPEN_STATE = "RAWTEXT_END_TAG_OPEN_STATE";
    const RAWTEXT_END_TAG_NAME_STATE = "RAWTEXT_END_TAG_NAME_STATE";
    const SCRIPT_DATA_LESS_THAN_SIGN_STATE = "SCRIPT_DATA_LESS_THAN_SIGN_STATE";
    const SCRIPT_DATA_END_TAG_OPEN_STATE = "SCRIPT_DATA_END_TAG_OPEN_STATE";
    const SCRIPT_DATA_END_TAG_NAME_STATE = "SCRIPT_DATA_END_TAG_NAME_STATE";
    const SCRIPT_DATA_ESCAPE_START_STATE = "SCRIPT_DATA_ESCAPE_START_STATE";
    const SCRIPT_DATA_ESCAPE_START_DASH_STATE = "SCRIPT_DATA_ESCAPE_START_DASH_STATE";
    const SCRIPT_DATA_ESCAPED_STATE = "SCRIPT_DATA_ESCAPED_STATE";
    const SCRIPT_DATA_ESCAPED_DASH_STATE = "SCRIPT_DATA_ESCAPED_DASH_STATE";
    const SCRIPT_DATA_ESCAPED_DASH_DASH_STATE = "SCRIPT_DATA_ESCAPED_DASH_DASH_STATE";
    const SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE";
    const SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE";
    const SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE = "SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE";
    const SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE = "SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE";
    const SCRIPT_DATA_DOUBLE_ESCAPED_STATE = "SCRIPT_DATA_DOUBLE_ESCAPED_STATE";
    const SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE";
    const SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE";
    const SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE";
    const SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE = "SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE";
    const BEFORE_ATTRIBUTE_NAME_STATE = "BEFORE_ATTRIBUTE_NAME_STATE";
    const ATTRIBUTE_NAME_STATE = "ATTRIBUTE_NAME_STATE";
    const AFTER_ATTRIBUTE_NAME_STATE = "AFTER_ATTRIBUTE_NAME_STATE";
    const BEFORE_ATTRIBUTE_VALUE_STATE = "BEFORE_ATTRIBUTE_VALUE_STATE";
    const ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE = "ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE";
    const ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE = "ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE";
    const ATTRIBUTE_VALUE_UNQUOTED_STATE = "ATTRIBUTE_VALUE_UNQUOTED_STATE";
    const AFTER_ATTRIBUTE_VALUE_QUOTED_STATE = "AFTER_ATTRIBUTE_VALUE_QUOTED_STATE";
    const SELF_CLOSING_START_TAG_STATE = "SELF_CLOSING_START_TAG_STATE";
    const BOGUS_COMMENT_STATE = "BOGUS_COMMENT_STATE";
    const MARKUP_DECLARATION_OPEN_STATE = "MARKUP_DECLARATION_OPEN_STATE";
    const COMMENT_START_STATE = "COMMENT_START_STATE";
    const COMMENT_START_DASH_STATE = "COMMENT_START_DASH_STATE";
    const COMMENT_STATE = "COMMENT_STATE";
    const COMMENT_LESS_THAN_SIGN_STATE = "COMMENT_LESS_THAN_SIGN_STATE";
    const COMMENT_LESS_THAN_SIGN_BANG_STATE = "COMMENT_LESS_THAN_SIGN_BANG_STATE";
    const COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE = "COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE";
    const COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE";
    const COMMENT_END_DASH_STATE = "COMMENT_END_DASH_STATE";
    const COMMENT_END_STATE = "COMMENT_END_STATE";
    const COMMENT_END_BANG_STATE = "COMMENT_END_BANG_STATE";
    const DOCTYPE_STATE = "DOCTYPE_STATE";
    const BEFORE_DOCTYPE_NAME_STATE = "BEFORE_DOCTYPE_NAME_STATE";
    const DOCTYPE_NAME_STATE = "DOCTYPE_NAME_STATE";
    const AFTER_DOCTYPE_NAME_STATE = "AFTER_DOCTYPE_NAME_STATE";
    const AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE = "AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE";
    const BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE";
    const DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE";
    const DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE";
    const AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE";
    const BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE";
    const AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE = "AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE";
    const BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE";
    const DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE";
    const DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE";
    const AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE";
    const BOGUS_DOCTYPE_STATE = "BOGUS_DOCTYPE_STATE";
    const CDATA_SECTION_STATE = "CDATA_SECTION_STATE";
    const CDATA_SECTION_BRACKET_STATE = "CDATA_SECTION_BRACKET_STATE";
    const CDATA_SECTION_END_STATE = "CDATA_SECTION_END_STATE";
    const CHARACTER_REFERENCE_STATE = "CHARACTER_REFERENCE_STATE";
    const NAMED_CHARACTER_REFERENCE_STATE = "NAMED_CHARACTER_REFERENCE_STATE";
    const AMBIGUOUS_AMPERSAND_STATE = "AMBIGUOS_AMPERSAND_STATE";
    const NUMERIC_CHARACTER_REFERENCE_STATE = "NUMERIC_CHARACTER_REFERENCE_STATE";
    const HEXADEMICAL_CHARACTER_REFERENCE_START_STATE = "HEXADEMICAL_CHARACTER_REFERENCE_START_STATE";
    const DECIMAL_CHARACTER_REFERENCE_START_STATE = "DECIMAL_CHARACTER_REFERENCE_START_STATE";
    const HEXADEMICAL_CHARACTER_REFERENCE_STATE = "HEXADEMICAL_CHARACTER_REFERENCE_STATE";
    const DECIMAL_CHARACTER_REFERENCE_STATE = "DECIMAL_CHARACTER_REFERENCE_STATE";
    const NUMERIC_CHARACTER_REFERENCE_END_STATE = "NUMERIC_CHARACTER_REFERENCE_END_STATE";
    function isWhitespace(cp) {
      return cp === $$5.SPACE || cp === $$5.LINE_FEED || cp === $$5.TABULATION || cp === $$5.FORM_FEED;
    }
    function isAsciiDigit(cp) {
      return cp >= $$5.DIGIT_0 && cp <= $$5.DIGIT_9;
    }
    function isAsciiUpper(cp) {
      return cp >= $$5.LATIN_CAPITAL_A && cp <= $$5.LATIN_CAPITAL_Z;
    }
    function isAsciiLower(cp) {
      return cp >= $$5.LATIN_SMALL_A && cp <= $$5.LATIN_SMALL_Z;
    }
    function isAsciiLetter(cp) {
      return isAsciiLower(cp) || isAsciiUpper(cp);
    }
    function isAsciiAlphaNumeric(cp) {
      return isAsciiLetter(cp) || isAsciiDigit(cp);
    }
    function isAsciiUpperHexDigit(cp) {
      return cp >= $$5.LATIN_CAPITAL_A && cp <= $$5.LATIN_CAPITAL_F;
    }
    function isAsciiLowerHexDigit(cp) {
      return cp >= $$5.LATIN_SMALL_A && cp <= $$5.LATIN_SMALL_F;
    }
    function isAsciiHexDigit(cp) {
      return isAsciiDigit(cp) || isAsciiUpperHexDigit(cp) || isAsciiLowerHexDigit(cp);
    }
    function toAsciiLowerCodePoint(cp) {
      return cp + 32;
    }
    function toChar(cp) {
      if (cp <= 65535) {
        return String.fromCharCode(cp);
      }
      cp -= 65536;
      return String.fromCharCode(cp >>> 10 & 1023 | 55296) + String.fromCharCode(56320 | cp & 1023);
    }
    function toAsciiLowerChar(cp) {
      return String.fromCharCode(toAsciiLowerCodePoint(cp));
    }
    function findNamedEntityTreeBranch(nodeIx, cp) {
      const branchCount = neTree[++nodeIx];
      let lo = ++nodeIx;
      let hi2 = lo + branchCount - 1;
      while (lo <= hi2) {
        const mid = lo + hi2 >>> 1;
        const midCp = neTree[mid];
        if (midCp < cp) {
          lo = mid + 1;
        } else if (midCp > cp) {
          hi2 = mid - 1;
        } else {
          return neTree[mid + branchCount];
        }
      }
      return -1;
    }
    let Tokenizer$4 = class Tokenizer2 {
      constructor() {
        this.preprocessor = new Preprocessor();
        this.tokenQueue = [];
        this.allowCDATA = false;
        this.state = DATA_STATE;
        this.returnState = "";
        this.charRefCode = -1;
        this.tempBuff = [];
        this.lastStartTagName = "";
        this.consumedAfterSnapshot = -1;
        this.active = false;
        this.currentCharacterToken = null;
        this.currentToken = null;
        this.currentAttr = null;
      }
      //Errors
      _err() {
      }
      _errOnNextCodePoint(err) {
        this._consume();
        this._err(err);
        this._unconsume();
      }
      //API
      getNextToken() {
        while (!this.tokenQueue.length && this.active) {
          this.consumedAfterSnapshot = 0;
          const cp = this._consume();
          if (!this._ensureHibernation()) {
            this[this.state](cp);
          }
        }
        return this.tokenQueue.shift();
      }
      write(chunk, isLastChunk) {
        this.active = true;
        this.preprocessor.write(chunk, isLastChunk);
      }
      insertHtmlAtCurrentPos(chunk) {
        this.active = true;
        this.preprocessor.insertHtmlAtCurrentPos(chunk);
      }
      //Hibernation
      _ensureHibernation() {
        if (this.preprocessor.endOfChunkHit) {
          for (; this.consumedAfterSnapshot > 0; this.consumedAfterSnapshot--) {
            this.preprocessor.retreat();
          }
          this.active = false;
          this.tokenQueue.push({ type: Tokenizer2.HIBERNATION_TOKEN });
          return true;
        }
        return false;
      }
      //Consumption
      _consume() {
        this.consumedAfterSnapshot++;
        return this.preprocessor.advance();
      }
      _unconsume() {
        this.consumedAfterSnapshot--;
        this.preprocessor.retreat();
      }
      _reconsumeInState(state) {
        this.state = state;
        this._unconsume();
      }
      _consumeSequenceIfMatch(pattern, startCp, caseSensitive) {
        let consumedCount = 0;
        let isMatch = true;
        const patternLength = pattern.length;
        let patternPos = 0;
        let cp = startCp;
        let patternCp = void 0;
        for (; patternPos < patternLength; patternPos++) {
          if (patternPos > 0) {
            cp = this._consume();
            consumedCount++;
          }
          if (cp === $$5.EOF) {
            isMatch = false;
            break;
          }
          patternCp = pattern[patternPos];
          if (cp !== patternCp && (caseSensitive || cp !== toAsciiLowerCodePoint(patternCp))) {
            isMatch = false;
            break;
          }
        }
        if (!isMatch) {
          while (consumedCount--) {
            this._unconsume();
          }
        }
        return isMatch;
      }
      //Temp buffer
      _isTempBufferEqualToScriptString() {
        if (this.tempBuff.length !== $$.SCRIPT_STRING.length) {
          return false;
        }
        for (let i2 = 0; i2 < this.tempBuff.length; i2++) {
          if (this.tempBuff[i2] !== $$.SCRIPT_STRING[i2]) {
            return false;
          }
        }
        return true;
      }
      //Token creation
      _createStartTagToken() {
        this.currentToken = {
          type: Tokenizer2.START_TAG_TOKEN,
          tagName: "",
          selfClosing: false,
          ackSelfClosing: false,
          attrs: []
        };
      }
      _createEndTagToken() {
        this.currentToken = {
          type: Tokenizer2.END_TAG_TOKEN,
          tagName: "",
          selfClosing: false,
          attrs: []
        };
      }
      _createCommentToken() {
        this.currentToken = {
          type: Tokenizer2.COMMENT_TOKEN,
          data: ""
        };
      }
      _createDoctypeToken(initialName) {
        this.currentToken = {
          type: Tokenizer2.DOCTYPE_TOKEN,
          name: initialName,
          forceQuirks: false,
          publicId: null,
          systemId: null
        };
      }
      _createCharacterToken(type, ch2) {
        this.currentCharacterToken = {
          type,
          chars: ch2
        };
      }
      _createEOFToken() {
        this.currentToken = { type: Tokenizer2.EOF_TOKEN };
      }
      //Tag attributes
      _createAttr(attrNameFirstCh) {
        this.currentAttr = {
          name: attrNameFirstCh,
          value: ""
        };
      }
      _leaveAttrName(toState) {
        if (Tokenizer2.getTokenAttr(this.currentToken, this.currentAttr.name) === null) {
          this.currentToken.attrs.push(this.currentAttr);
        } else {
          this._err(ERR$1.duplicateAttribute);
        }
        this.state = toState;
      }
      _leaveAttrValue(toState) {
        this.state = toState;
      }
      //Token emission
      _emitCurrentToken() {
        this._emitCurrentCharacterToken();
        const ct = this.currentToken;
        this.currentToken = null;
        if (ct.type === Tokenizer2.START_TAG_TOKEN) {
          this.lastStartTagName = ct.tagName;
        } else if (ct.type === Tokenizer2.END_TAG_TOKEN) {
          if (ct.attrs.length > 0) {
            this._err(ERR$1.endTagWithAttributes);
          }
          if (ct.selfClosing) {
            this._err(ERR$1.endTagWithTrailingSolidus);
          }
        }
        this.tokenQueue.push(ct);
      }
      _emitCurrentCharacterToken() {
        if (this.currentCharacterToken) {
          this.tokenQueue.push(this.currentCharacterToken);
          this.currentCharacterToken = null;
        }
      }
      _emitEOFToken() {
        this._createEOFToken();
        this._emitCurrentToken();
      }
      //Characters emission
      //OPTIMIZATION: specification uses only one type of character tokens (one token per character).
      //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
      //If we have a sequence of characters that belong to the same group, parser can process it
      //as a single solid character token.
      //So, there are 3 types of character tokens in parse5:
      //1)NULL_CHARACTER_TOKEN - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
      //2)WHITESPACE_CHARACTER_TOKEN - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
      //3)CHARACTER_TOKEN - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
      _appendCharToCurrentCharacterToken(type, ch2) {
        if (this.currentCharacterToken && this.currentCharacterToken.type !== type) {
          this._emitCurrentCharacterToken();
        }
        if (this.currentCharacterToken) {
          this.currentCharacterToken.chars += ch2;
        } else {
          this._createCharacterToken(type, ch2);
        }
      }
      _emitCodePoint(cp) {
        let type = Tokenizer2.CHARACTER_TOKEN;
        if (isWhitespace(cp)) {
          type = Tokenizer2.WHITESPACE_CHARACTER_TOKEN;
        } else if (cp === $$5.NULL) {
          type = Tokenizer2.NULL_CHARACTER_TOKEN;
        }
        this._appendCharToCurrentCharacterToken(type, toChar(cp));
      }
      _emitSeveralCodePoints(codePoints) {
        for (let i2 = 0; i2 < codePoints.length; i2++) {
          this._emitCodePoint(codePoints[i2]);
        }
      }
      //NOTE: used then we emit character explicitly. This is always a non-whitespace and a non-null character.
      //So we can avoid additional checks here.
      _emitChars(ch2) {
        this._appendCharToCurrentCharacterToken(Tokenizer2.CHARACTER_TOKEN, ch2);
      }
      // Character reference helpers
      _matchNamedCharacterReference(startCp) {
        let result = null;
        let excess = 1;
        let i2 = findNamedEntityTreeBranch(0, startCp);
        this.tempBuff.push(startCp);
        while (i2 > -1) {
          const current = neTree[i2];
          const inNode = current < MAX_BRANCH_MARKER_VALUE;
          const nodeWithData = inNode && current & HAS_DATA_FLAG;
          if (nodeWithData) {
            result = current & DATA_DUPLET_FLAG ? [neTree[++i2], neTree[++i2]] : [neTree[++i2]];
            excess = 0;
          }
          const cp = this._consume();
          this.tempBuff.push(cp);
          excess++;
          if (cp === $$5.EOF) {
            break;
          }
          if (inNode) {
            i2 = current & HAS_BRANCHES_FLAG ? findNamedEntityTreeBranch(i2, cp) : -1;
          } else {
            i2 = cp === current ? ++i2 : -1;
          }
        }
        while (excess--) {
          this.tempBuff.pop();
          this._unconsume();
        }
        return result;
      }
      _isCharacterReferenceInAttribute() {
        return this.returnState === ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE || this.returnState === ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE || this.returnState === ATTRIBUTE_VALUE_UNQUOTED_STATE;
      }
      _isCharacterReferenceAttributeQuirk(withSemicolon) {
        if (!withSemicolon && this._isCharacterReferenceInAttribute()) {
          const nextCp = this._consume();
          this._unconsume();
          return nextCp === $$5.EQUALS_SIGN || isAsciiAlphaNumeric(nextCp);
        }
        return false;
      }
      _flushCodePointsConsumedAsCharacterReference() {
        if (this._isCharacterReferenceInAttribute()) {
          for (let i2 = 0; i2 < this.tempBuff.length; i2++) {
            this.currentAttr.value += toChar(this.tempBuff[i2]);
          }
        } else {
          this._emitSeveralCodePoints(this.tempBuff);
        }
        this.tempBuff = [];
      }
      // State machine
      // Data state
      //------------------------------------------------------------------
      [DATA_STATE](cp) {
        this.preprocessor.dropParsedChunk();
        if (cp === $$5.LESS_THAN_SIGN) {
          this.state = TAG_OPEN_STATE;
        } else if (cp === $$5.AMPERSAND) {
          this.returnState = DATA_STATE;
          this.state = CHARACTER_REFERENCE_STATE;
        } else if (cp === $$5.NULL) {
          this._err(ERR$1.unexpectedNullCharacter);
          this._emitCodePoint(cp);
        } else if (cp === $$5.EOF) {
          this._emitEOFToken();
        } else {
          this._emitCodePoint(cp);
        }
      }
      //  RCDATA state
      //------------------------------------------------------------------
      [RCDATA_STATE](cp) {
        this.preprocessor.dropParsedChunk();
        if (cp === $$5.AMPERSAND) {
          this.returnState = RCDATA_STATE;
          this.state = CHARACTER_REFERENCE_STATE;
        } else if (cp === $$5.LESS_THAN_SIGN) {
          this.state = RCDATA_LESS_THAN_SIGN_STATE;
        } else if (cp === $$5.NULL) {
          this._err(ERR$1.unexpectedNullCharacter);
          this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
        } else if (cp === $$5.EOF) {
          this._emitEOFToken();
        } else {
          this._emitCodePoint(cp);
        }
      }
      // RAWTEXT state
      //------------------------------------------------------------------
      [RAWTEXT_STATE](cp) {
        this.preprocessor.dropParsedChunk();
        if (cp === $$5.LESS_THAN_SIGN) {
          this.state = RAWTEXT_LESS_THAN_SIGN_STATE;
        } else if (cp === $$5.NULL) {
          this._err(ERR$1.unexpectedNullCharacter);
          this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
        } else if (cp === $$5.EOF) {
          this._emitEOFToken();
        } else {
          this._emitCodePoint(cp);
        }
      }
      // Script data state
      //------------------------------------------------------------------
      [SCRIPT_DATA_STATE](cp) {
        this.preprocessor.dropParsedChunk();
        if (cp === $$5.LESS_THAN_SIGN) {
          this.state = SCRIPT_DATA_LESS_THAN_SIGN_STATE;
        } else if (cp === $$5.NULL) {
          this._err(ERR$1.unexpectedNullCharacter);
          this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
        } else if (cp === $$5.EOF) {
          this._emitEOFToken();
        } else {
          this._emitCodePoint(cp);
        }
      }
      // PLAINTEXT state
      //------------------------------------------------------------------
      [PLAINTEXT_STATE](cp) {
        this.preprocessor.dropParsedChunk();
        if (cp === $$5.NULL) {
          this._err(ERR$1.unexpectedNullCharacter);
          this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
        } else if (cp === $$5.EOF) {
          this._emitEOFToken();
        } else {
          this._emitCodePoint(cp);
        }
      }
      // Tag open state
      //------------------------------------------------------------------
      [TAG_OPEN_STATE](cp) {
        if (cp === $$5.EXCLAMATION_MARK) {
          this.state = MARKUP_DECLARATION_OPEN_STATE;
        } else if (cp === $$5.SOLIDUS) {
          this.state = END_TAG_OPEN_STATE;
        } else if (isAsciiLetter(cp)) {
          this._createStartTagToken();
          this._reconsumeInState(TAG_NAME_STATE);
        } else if (cp === $$5.QUESTION_MARK) {
          this._err(ERR$1.unexpectedQuestionMarkInsteadOfTagName);
          this._createCommentToken();
          this._reconsumeInState(BOGUS_COMMENT_STATE);
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofBeforeTagName);
          this._emitChars("<");
          this._emitEOFToken();
        } else {
          this._err(ERR$1.invalidFirstCharacterOfTagName);
          this._emitChars("<");
          this._reconsumeInState(DATA_STATE);
        }
      }
      // End tag open state
      //------------------------------------------------------------------
      [END_TAG_OPEN_STATE](cp) {
        if (isAsciiLetter(cp)) {
          this._createEndTagToken();
          this._reconsumeInState(TAG_NAME_STATE);
        } else if (cp === $$5.GREATER_THAN_SIGN) {
          this._err(ERR$1.missingEndTagName);
          this.state = DATA_STATE;
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofBeforeTagName);
          this._emitChars("</");
          this._emitEOFToken();
        } else {
          this._err(ERR$1.invalidFirstCharacterOfTagName);
          this._createCommentToken();
          this._reconsumeInState(BOGUS_COMMENT_STATE);
        }
      }
      // Tag name state
      //------------------------------------------------------------------
      [TAG_NAME_STATE](cp) {
        if (isWhitespace(cp)) {
          this.state = BEFORE_ATTRIBUTE_NAME_STATE;
        } else if (cp === $$5.SOLIDUS) {
          this.state = SELF_CLOSING_START_TAG_STATE;
        } else if (cp === $$5.GREATER_THAN_SIGN) {
          this.state = DATA_STATE;
          this._emitCurrentToken();
        } else if (isAsciiUpper(cp)) {
          this.currentToken.tagName += toAsciiLowerChar(cp);
        } else if (cp === $$5.NULL) {
          this._err(ERR$1.unexpectedNullCharacter);
          this.currentToken.tagName += unicode$1.REPLACEMENT_CHARACTER;
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInTag);
          this._emitEOFToken();
        } else {
          this.currentToken.tagName += toChar(cp);
        }
      }
      // RCDATA less-than sign state
      //------------------------------------------------------------------
      [RCDATA_LESS_THAN_SIGN_STATE](cp) {
        if (cp === $$5.SOLIDUS) {
          this.tempBuff = [];
          this.state = RCDATA_END_TAG_OPEN_STATE;
        } else {
          this._emitChars("<");
          this._reconsumeInState(RCDATA_STATE);
        }
      }
      // RCDATA end tag open state
      //------------------------------------------------------------------
      [RCDATA_END_TAG_OPEN_STATE](cp) {
        if (isAsciiLetter(cp)) {
          this._createEndTagToken();
          this._reconsumeInState(RCDATA_END_TAG_NAME_STATE);
        } else {
          this._emitChars("</");
          this._reconsumeInState(RCDATA_STATE);
        }
      }
      // RCDATA end tag name state
      //------------------------------------------------------------------
      [RCDATA_END_TAG_NAME_STATE](cp) {
        if (isAsciiUpper(cp)) {
          this.currentToken.tagName += toAsciiLowerChar(cp);
          this.tempBuff.push(cp);
        } else if (isAsciiLower(cp)) {
          this.currentToken.tagName += toChar(cp);
          this.tempBuff.push(cp);
        } else {
          if (this.lastStartTagName === this.currentToken.tagName) {
            if (isWhitespace(cp)) {
              this.state = BEFORE_ATTRIBUTE_NAME_STATE;
              return;
            }
            if (cp === $$5.SOLIDUS) {
              this.state = SELF_CLOSING_START_TAG_STATE;
              return;
            }
            if (cp === $$5.GREATER_THAN_SIGN) {
              this.state = DATA_STATE;
              this._emitCurrentToken();
              return;
            }
          }
          this._emitChars("</");
          this._emitSeveralCodePoints(this.tempBuff);
          this._reconsumeInState(RCDATA_STATE);
        }
      }
      // RAWTEXT less-than sign state
      //------------------------------------------------------------------
      [RAWTEXT_LESS_THAN_SIGN_STATE](cp) {
        if (cp === $$5.SOLIDUS) {
          this.tempBuff = [];
          this.state = RAWTEXT_END_TAG_OPEN_STATE;
        } else {
          this._emitChars("<");
          this._reconsumeInState(RAWTEXT_STATE);
        }
      }
      // RAWTEXT end tag open state
      //------------------------------------------------------------------
      [RAWTEXT_END_TAG_OPEN_STATE](cp) {
        if (isAsciiLetter(cp)) {
          this._createEndTagToken();
          this._reconsumeInState(RAWTEXT_END_TAG_NAME_STATE);
        } else {
          this._emitChars("</");
          this._reconsumeInState(RAWTEXT_STATE);
        }
      }
      // RAWTEXT end tag name state
      //------------------------------------------------------------------
      [RAWTEXT_END_TAG_NAME_STATE](cp) {
        if (isAsciiUpper(cp)) {
          this.currentToken.tagName += toAsciiLowerChar(cp);
          this.tempBuff.push(cp);
        } else if (isAsciiLower(cp)) {
          this.currentToken.tagName += toChar(cp);
          this.tempBuff.push(cp);
        } else {
          if (this.lastStartTagName === this.currentToken.tagName) {
            if (isWhitespace(cp)) {
              this.state = BEFORE_ATTRIBUTE_NAME_STATE;
              return;
            }
            if (cp === $$5.SOLIDUS) {
              this.state = SELF_CLOSING_START_TAG_STATE;
              return;
            }
            if (cp === $$5.GREATER_THAN_SIGN) {
              this._emitCurrentToken();
              this.state = DATA_STATE;
              return;
            }
          }
          this._emitChars("</");
          this._emitSeveralCodePoints(this.tempBuff);
          this._reconsumeInState(RAWTEXT_STATE);
        }
      }
      // Script data less-than sign state
      //------------------------------------------------------------------
      [SCRIPT_DATA_LESS_THAN_SIGN_STATE](cp) {
        if (cp === $$5.SOLIDUS) {
          this.tempBuff = [];
          this.state = SCRIPT_DATA_END_TAG_OPEN_STATE;
        } else if (cp === $$5.EXCLAMATION_MARK) {
          this.state = SCRIPT_DATA_ESCAPE_START_STATE;
          this._emitChars("<!");
        } else {
          this._emitChars("<");
          this._reconsumeInState(SCRIPT_DATA_STATE);
        }
      }
      // Script data end tag open state
      //------------------------------------------------------------------
      [SCRIPT_DATA_END_TAG_OPEN_STATE](cp) {
        if (isAsciiLetter(cp)) {
          this._createEndTagToken();
          this._reconsumeInState(SCRIPT_DATA_END_TAG_NAME_STATE);
        } else {
          this._emitChars("</");
          this._reconsumeInState(SCRIPT_DATA_STATE);
        }
      }
      // Script data end tag name state
      //------------------------------------------------------------------
      [SCRIPT_DATA_END_TAG_NAME_STATE](cp) {
        if (isAsciiUpper(cp)) {
          this.currentToken.tagName += toAsciiLowerChar(cp);
          this.tempBuff.push(cp);
        } else if (isAsciiLower(cp)) {
          this.currentToken.tagName += toChar(cp);
          this.tempBuff.push(cp);
        } else {
          if (this.lastStartTagName === this.currentToken.tagName) {
            if (isWhitespace(cp)) {
              this.state = BEFORE_ATTRIBUTE_NAME_STATE;
              return;
            } else if (cp === $$5.SOLIDUS) {
              this.state = SELF_CLOSING_START_TAG_STATE;
              return;
            } else if (cp === $$5.GREATER_THAN_SIGN) {
              this._emitCurrentToken();
              this.state = DATA_STATE;
              return;
            }
          }
          this._emitChars("</");
          this._emitSeveralCodePoints(this.tempBuff);
          this._reconsumeInState(SCRIPT_DATA_STATE);
        }
      }
      // Script data escape start state
      //------------------------------------------------------------------
      [SCRIPT_DATA_ESCAPE_START_STATE](cp) {
        if (cp === $$5.HYPHEN_MINUS) {
          this.state = SCRIPT_DATA_ESCAPE_START_DASH_STATE;
          this._emitChars("-");
        } else {
          this._reconsumeInState(SCRIPT_DATA_STATE);
        }
      }
      // Script data escape start dash state
      //------------------------------------------------------------------
      [SCRIPT_DATA_ESCAPE_START_DASH_STATE](cp) {
        if (cp === $$5.HYPHEN_MINUS) {
          this.state = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;
          this._emitChars("-");
        } else {
          this._reconsumeInState(SCRIPT_DATA_STATE);
        }
      }
      // Script data escaped state
      //------------------------------------------------------------------
      [SCRIPT_DATA_ESCAPED_STATE](cp) {
        if (cp === $$5.HYPHEN_MINUS) {
          this.state = SCRIPT_DATA_ESCAPED_DASH_STATE;
          this._emitChars("-");
        } else if (cp === $$5.LESS_THAN_SIGN) {
          this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
        } else if (cp === $$5.NULL) {
          this._err(ERR$1.unexpectedNullCharacter);
          this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInScriptHtmlCommentLikeText);
          this._emitEOFToken();
        } else {
          this._emitCodePoint(cp);
        }
      }
      // Script data escaped dash state
      //------------------------------------------------------------------
      [SCRIPT_DATA_ESCAPED_DASH_STATE](cp) {
        if (cp === $$5.HYPHEN_MINUS) {
          this.state = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;
          this._emitChars("-");
        } else if (cp === $$5.LESS_THAN_SIGN) {
          this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
        } else if (cp === $$5.NULL) {
          this._err(ERR$1.unexpectedNullCharacter);
          this.state = SCRIPT_DATA_ESCAPED_STATE;
          this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInScriptHtmlCommentLikeText);
          this._emitEOFToken();
        } else {
          this.state = SCRIPT_DATA_ESCAPED_STATE;
          this._emitCodePoint(cp);
        }
      }
      // Script data escaped dash dash state
      //------------------------------------------------------------------
      [SCRIPT_DATA_ESCAPED_DASH_DASH_STATE](cp) {
        if (cp === $$5.HYPHEN_MINUS) {
          this._emitChars("-");
        } else if (cp === $$5.LESS_THAN_SIGN) {
          this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
        } else if (cp === $$5.GREATER_THAN_SIGN) {
          this.state = SCRIPT_DATA_STATE;
          this._emitChars(">");
        } else if (cp === $$5.NULL) {
          this._err(ERR$1.unexpectedNullCharacter);
          this.state = SCRIPT_DATA_ESCAPED_STATE;
          this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInScriptHtmlCommentLikeText);
          this._emitEOFToken();
        } else {
          this.state = SCRIPT_DATA_ESCAPED_STATE;
          this._emitCodePoint(cp);
        }
      }
      // Script data escaped less-than sign state
      //------------------------------------------------------------------
      [SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE](cp) {
        if (cp === $$5.SOLIDUS) {
          this.tempBuff = [];
          this.state = SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE;
        } else if (isAsciiLetter(cp)) {
          this.tempBuff = [];
          this._emitChars("<");
          this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE);
        } else {
          this._emitChars("<");
          this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
        }
      }
      // Script data escaped end tag open state
      //------------------------------------------------------------------
      [SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE](cp) {
        if (isAsciiLetter(cp)) {
          this._createEndTagToken();
          this._reconsumeInState(SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE);
        } else {
          this._emitChars("</");
          this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
        }
      }
      // Script data escaped end tag name state
      //------------------------------------------------------------------
      [SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE](cp) {
        if (isAsciiUpper(cp)) {
          this.currentToken.tagName += toAsciiLowerChar(cp);
          this.tempBuff.push(cp);
        } else if (isAsciiLower(cp)) {
          this.currentToken.tagName += toChar(cp);
          this.tempBuff.push(cp);
        } else {
          if (this.lastStartTagName === this.currentToken.tagName) {
            if (isWhitespace(cp)) {
              this.state = BEFORE_ATTRIBUTE_NAME_STATE;
              return;
            }
            if (cp === $$5.SOLIDUS) {
              this.state = SELF_CLOSING_START_TAG_STATE;
              return;
            }
            if (cp === $$5.GREATER_THAN_SIGN) {
              this._emitCurrentToken();
              this.state = DATA_STATE;
              return;
            }
          }
          this._emitChars("</");
          this._emitSeveralCodePoints(this.tempBuff);
          this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
        }
      }
      // Script data double escape start state
      //------------------------------------------------------------------
      [SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE](cp) {
        if (isWhitespace(cp) || cp === $$5.SOLIDUS || cp === $$5.GREATER_THAN_SIGN) {
          this.state = this._isTempBufferEqualToScriptString() ? SCRIPT_DATA_DOUBLE_ESCAPED_STATE : SCRIPT_DATA_ESCAPED_STATE;
          this._emitCodePoint(cp);
        } else if (isAsciiUpper(cp)) {
          this.tempBuff.push(toAsciiLowerCodePoint(cp));
          this._emitCodePoint(cp);
        } else if (isAsciiLower(cp)) {
          this.tempBuff.push(cp);
          this._emitCodePoint(cp);
        } else {
          this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
        }
      }
      // Script data double escaped state
      //------------------------------------------------------------------
      [SCRIPT_DATA_DOUBLE_ESCAPED_STATE](cp) {
        if (cp === $$5.HYPHEN_MINUS) {
          this.state = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE;
          this._emitChars("-");
        } else if (cp === $$5.LESS_THAN_SIGN) {
          this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
          this._emitChars("<");
        } else if (cp === $$5.NULL) {
          this._err(ERR$1.unexpectedNullCharacter);
          this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInScriptHtmlCommentLikeText);
          this._emitEOFToken();
        } else {
          this._emitCodePoint(cp);
        }
      }
      // Script data double escaped dash state
      //------------------------------------------------------------------
      [SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE](cp) {
        if (cp === $$5.HYPHEN_MINUS) {
          this.state = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE;
          this._emitChars("-");
        } else if (cp === $$5.LESS_THAN_SIGN) {
          this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
          this._emitChars("<");
        } else if (cp === $$5.NULL) {
          this._err(ERR$1.unexpectedNullCharacter);
          this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
          this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInScriptHtmlCommentLikeText);
          this._emitEOFToken();
        } else {
          this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
          this._emitCodePoint(cp);
        }
      }
      // Script data double escaped dash dash state
      //------------------------------------------------------------------
      [SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE](cp) {
        if (cp === $$5.HYPHEN_MINUS) {
          this._emitChars("-");
        } else if (cp === $$5.LESS_THAN_SIGN) {
          this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
          this._emitChars("<");
        } else if (cp === $$5.GREATER_THAN_SIGN) {
          this.state = SCRIPT_DATA_STATE;
          this._emitChars(">");
        } else if (cp === $$5.NULL) {
          this._err(ERR$1.unexpectedNullCharacter);
          this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
          this._emitChars(unicode$1.REPLACEMENT_CHARACTER);
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInScriptHtmlCommentLikeText);
          this._emitEOFToken();
        } else {
          this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
          this._emitCodePoint(cp);
        }
      }
      // Script data double escaped less-than sign state
      //------------------------------------------------------------------
      [SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE](cp) {
        if (cp === $$5.SOLIDUS) {
          this.tempBuff = [];
          this.state = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE;
          this._emitChars("/");
        } else {
          this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPED_STATE);
        }
      }
      // Script data double escape end state
      //------------------------------------------------------------------
      [SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE](cp) {
        if (isWhitespace(cp) || cp === $$5.SOLIDUS || cp === $$5.GREATER_THAN_SIGN) {
          this.state = this._isTempBufferEqualToScriptString() ? SCRIPT_DATA_ESCAPED_STATE : SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
          this._emitCodePoint(cp);
        } else if (isAsciiUpper(cp)) {
          this.tempBuff.push(toAsciiLowerCodePoint(cp));
          this._emitCodePoint(cp);
        } else if (isAsciiLower(cp)) {
          this.tempBuff.push(cp);
          this._emitCodePoint(cp);
        } else {
          this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPED_STATE);
        }
      }
      // Before attribute name state
      //------------------------------------------------------------------
      [BEFORE_ATTRIBUTE_NAME_STATE](cp) {
        if (isWhitespace(cp)) {
          return;
        }
        if (cp === $$5.SOLIDUS || cp === $$5.GREATER_THAN_SIGN || cp === $$5.EOF) {
          this._reconsumeInState(AFTER_ATTRIBUTE_NAME_STATE);
        } else if (cp === $$5.EQUALS_SIGN) {
          this._err(ERR$1.unexpectedEqualsSignBeforeAttributeName);
          this._createAttr("=");
          this.state = ATTRIBUTE_NAME_STATE;
        } else {
          this._createAttr("");
          this._reconsumeInState(ATTRIBUTE_NAME_STATE);
        }
      }
      // Attribute name state
      //------------------------------------------------------------------
      [ATTRIBUTE_NAME_STATE](cp) {
        if (isWhitespace(cp) || cp === $$5.SOLIDUS || cp === $$5.GREATER_THAN_SIGN || cp === $$5.EOF) {
          this._leaveAttrName(AFTER_ATTRIBUTE_NAME_STATE);
          this._unconsume();
        } else if (cp === $$5.EQUALS_SIGN) {
          this._leaveAttrName(BEFORE_ATTRIBUTE_VALUE_STATE);
        } else if (isAsciiUpper(cp)) {
          this.currentAttr.name += toAsciiLowerChar(cp);
        } else if (cp === $$5.QUOTATION_MARK || cp === $$5.APOSTROPHE || cp === $$5.LESS_THAN_SIGN) {
          this._err(ERR$1.unexpectedCharacterInAttributeName);
          this.currentAttr.name += toChar(cp);
        } else if (cp === $$5.NULL) {
          this._err(ERR$1.unexpectedNullCharacter);
          this.currentAttr.name += unicode$1.REPLACEMENT_CHARACTER;
        } else {
          this.currentAttr.name += toChar(cp);
        }
      }
      // After attribute name state
      //------------------------------------------------------------------
      [AFTER_ATTRIBUTE_NAME_STATE](cp) {
        if (isWhitespace(cp)) {
          return;
        }
        if (cp === $$5.SOLIDUS) {
          this.state = SELF_CLOSING_START_TAG_STATE;
        } else if (cp === $$5.EQUALS_SIGN) {
          this.state = BEFORE_ATTRIBUTE_VALUE_STATE;
        } else if (cp === $$5.GREATER_THAN_SIGN) {
          this.state = DATA_STATE;
          this._emitCurrentToken();
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInTag);
          this._emitEOFToken();
        } else {
          this._createAttr("");
          this._reconsumeInState(ATTRIBUTE_NAME_STATE);
        }
      }
      // Before attribute value state
      //------------------------------------------------------------------
      [BEFORE_ATTRIBUTE_VALUE_STATE](cp) {
        if (isWhitespace(cp)) {
          return;
        }
        if (cp === $$5.QUOTATION_MARK) {
          this.state = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;
        } else if (cp === $$5.APOSTROPHE) {
          this.state = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;
        } else if (cp === $$5.GREATER_THAN_SIGN) {
          this._err(ERR$1.missingAttributeValue);
          this.state = DATA_STATE;
          this._emitCurrentToken();
        } else {
          this._reconsumeInState(ATTRIBUTE_VALUE_UNQUOTED_STATE);
        }
      }
      // Attribute value (double-quoted) state
      //------------------------------------------------------------------
      [ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE](cp) {
        if (cp === $$5.QUOTATION_MARK) {
          this.state = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;
        } else if (cp === $$5.AMPERSAND) {
          this.returnState = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;
          this.state = CHARACTER_REFERENCE_STATE;
        } else if (cp === $$5.NULL) {
          this._err(ERR$1.unexpectedNullCharacter);
          this.currentAttr.value += unicode$1.REPLACEMENT_CHARACTER;
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInTag);
          this._emitEOFToken();
        } else {
          this.currentAttr.value += toChar(cp);
        }
      }
      // Attribute value (single-quoted) state
      //------------------------------------------------------------------
      [ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE](cp) {
        if (cp === $$5.APOSTROPHE) {
          this.state = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;
        } else if (cp === $$5.AMPERSAND) {
          this.returnState = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;
          this.state = CHARACTER_REFERENCE_STATE;
        } else if (cp === $$5.NULL) {
          this._err(ERR$1.unexpectedNullCharacter);
          this.currentAttr.value += unicode$1.REPLACEMENT_CHARACTER;
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInTag);
          this._emitEOFToken();
        } else {
          this.currentAttr.value += toChar(cp);
        }
      }
      // Attribute value (unquoted) state
      //------------------------------------------------------------------
      [ATTRIBUTE_VALUE_UNQUOTED_STATE](cp) {
        if (isWhitespace(cp)) {
          this._leaveAttrValue(BEFORE_ATTRIBUTE_NAME_STATE);
        } else if (cp === $$5.AMPERSAND) {
          this.returnState = ATTRIBUTE_VALUE_UNQUOTED_STATE;
          this.state = CHARACTER_REFERENCE_STATE;
        } else if (cp === $$5.GREATER_THAN_SIGN) {
          this._leaveAttrValue(DATA_STATE);
          this._emitCurrentToken();
        } else if (cp === $$5.NULL) {
          this._err(ERR$1.unexpectedNullCharacter);
          this.currentAttr.value += unicode$1.REPLACEMENT_CHARACTER;
        } else if (cp === $$5.QUOTATION_MARK || cp === $$5.APOSTROPHE || cp === $$5.LESS_THAN_SIGN || cp === $$5.EQUALS_SIGN || cp === $$5.GRAVE_ACCENT) {
          this._err(ERR$1.unexpectedCharacterInUnquotedAttributeValue);
          this.currentAttr.value += toChar(cp);
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInTag);
          this._emitEOFToken();
        } else {
          this.currentAttr.value += toChar(cp);
        }
      }
      // After attribute value (quoted) state
      //------------------------------------------------------------------
      [AFTER_ATTRIBUTE_VALUE_QUOTED_STATE](cp) {
        if (isWhitespace(cp)) {
          this._leaveAttrValue(BEFORE_ATTRIBUTE_NAME_STATE);
        } else if (cp === $$5.SOLIDUS) {
          this._leaveAttrValue(SELF_CLOSING_START_TAG_STATE);
        } else if (cp === $$5.GREATER_THAN_SIGN) {
          this._leaveAttrValue(DATA_STATE);
          this._emitCurrentToken();
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInTag);
          this._emitEOFToken();
        } else {
          this._err(ERR$1.missingWhitespaceBetweenAttributes);
          this._reconsumeInState(BEFORE_ATTRIBUTE_NAME_STATE);
        }
      }
      // Self-closing start tag state
      //------------------------------------------------------------------
      [SELF_CLOSING_START_TAG_STATE](cp) {
        if (cp === $$5.GREATER_THAN_SIGN) {
          this.currentToken.selfClosing = true;
          this.state = DATA_STATE;
          this._emitCurrentToken();
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInTag);
          this._emitEOFToken();
        } else {
          this._err(ERR$1.unexpectedSolidusInTag);
          this._reconsumeInState(BEFORE_ATTRIBUTE_NAME_STATE);
        }
      }
      // Bogus comment state
      //------------------------------------------------------------------
      [BOGUS_COMMENT_STATE](cp) {
        if (cp === $$5.GREATER_THAN_SIGN) {
          this.state = DATA_STATE;
          this._emitCurrentToken();
        } else if (cp === $$5.EOF) {
          this._emitCurrentToken();
          this._emitEOFToken();
        } else if (cp === $$5.NULL) {
          this._err(ERR$1.unexpectedNullCharacter);
          this.currentToken.data += unicode$1.REPLACEMENT_CHARACTER;
        } else {
          this.currentToken.data += toChar(cp);
        }
      }
      // Markup declaration open state
      //------------------------------------------------------------------
      [MARKUP_DECLARATION_OPEN_STATE](cp) {
        if (this._consumeSequenceIfMatch($$.DASH_DASH_STRING, cp, true)) {
          this._createCommentToken();
          this.state = COMMENT_START_STATE;
        } else if (this._consumeSequenceIfMatch($$.DOCTYPE_STRING, cp, false)) {
          this.state = DOCTYPE_STATE;
        } else if (this._consumeSequenceIfMatch($$.CDATA_START_STRING, cp, true)) {
          if (this.allowCDATA) {
            this.state = CDATA_SECTION_STATE;
          } else {
            this._err(ERR$1.cdataInHtmlContent);
            this._createCommentToken();
            this.currentToken.data = "[CDATA[";
            this.state = BOGUS_COMMENT_STATE;
          }
        } else if (!this._ensureHibernation()) {
          this._err(ERR$1.incorrectlyOpenedComment);
          this._createCommentToken();
          this._reconsumeInState(BOGUS_COMMENT_STATE);
        }
      }
      // Comment start state
      //------------------------------------------------------------------
      [COMMENT_START_STATE](cp) {
        if (cp === $$5.HYPHEN_MINUS) {
          this.state = COMMENT_START_DASH_STATE;
        } else if (cp === $$5.GREATER_THAN_SIGN) {
          this._err(ERR$1.abruptClosingOfEmptyComment);
          this.state = DATA_STATE;
          this._emitCurrentToken();
        } else {
          this._reconsumeInState(COMMENT_STATE);
        }
      }
      // Comment start dash state
      //------------------------------------------------------------------
      [COMMENT_START_DASH_STATE](cp) {
        if (cp === $$5.HYPHEN_MINUS) {
          this.state = COMMENT_END_STATE;
        } else if (cp === $$5.GREATER_THAN_SIGN) {
          this._err(ERR$1.abruptClosingOfEmptyComment);
          this.state = DATA_STATE;
          this._emitCurrentToken();
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInComment);
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this.currentToken.data += "-";
          this._reconsumeInState(COMMENT_STATE);
        }
      }
      // Comment state
      //------------------------------------------------------------------
      [COMMENT_STATE](cp) {
        if (cp === $$5.HYPHEN_MINUS) {
          this.state = COMMENT_END_DASH_STATE;
        } else if (cp === $$5.LESS_THAN_SIGN) {
          this.currentToken.data += "<";
          this.state = COMMENT_LESS_THAN_SIGN_STATE;
        } else if (cp === $$5.NULL) {
          this._err(ERR$1.unexpectedNullCharacter);
          this.currentToken.data += unicode$1.REPLACEMENT_CHARACTER;
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInComment);
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this.currentToken.data += toChar(cp);
        }
      }
      // Comment less-than sign state
      //------------------------------------------------------------------
      [COMMENT_LESS_THAN_SIGN_STATE](cp) {
        if (cp === $$5.EXCLAMATION_MARK) {
          this.currentToken.data += "!";
          this.state = COMMENT_LESS_THAN_SIGN_BANG_STATE;
        } else if (cp === $$5.LESS_THAN_SIGN) {
          this.currentToken.data += "!";
        } else {
          this._reconsumeInState(COMMENT_STATE);
        }
      }
      // Comment less-than sign bang state
      //------------------------------------------------------------------
      [COMMENT_LESS_THAN_SIGN_BANG_STATE](cp) {
        if (cp === $$5.HYPHEN_MINUS) {
          this.state = COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE;
        } else {
          this._reconsumeInState(COMMENT_STATE);
        }
      }
      // Comment less-than sign bang dash state
      //------------------------------------------------------------------
      [COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE](cp) {
        if (cp === $$5.HYPHEN_MINUS) {
          this.state = COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE;
        } else {
          this._reconsumeInState(COMMENT_END_DASH_STATE);
        }
      }
      // Comment less-than sign bang dash dash state
      //------------------------------------------------------------------
      [COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE](cp) {
        if (cp !== $$5.GREATER_THAN_SIGN && cp !== $$5.EOF) {
          this._err(ERR$1.nestedComment);
        }
        this._reconsumeInState(COMMENT_END_STATE);
      }
      // Comment end dash state
      //------------------------------------------------------------------
      [COMMENT_END_DASH_STATE](cp) {
        if (cp === $$5.HYPHEN_MINUS) {
          this.state = COMMENT_END_STATE;
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInComment);
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this.currentToken.data += "-";
          this._reconsumeInState(COMMENT_STATE);
        }
      }
      // Comment end state
      //------------------------------------------------------------------
      [COMMENT_END_STATE](cp) {
        if (cp === $$5.GREATER_THAN_SIGN) {
          this.state = DATA_STATE;
          this._emitCurrentToken();
        } else if (cp === $$5.EXCLAMATION_MARK) {
          this.state = COMMENT_END_BANG_STATE;
        } else if (cp === $$5.HYPHEN_MINUS) {
          this.currentToken.data += "-";
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInComment);
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this.currentToken.data += "--";
          this._reconsumeInState(COMMENT_STATE);
        }
      }
      // Comment end bang state
      //------------------------------------------------------------------
      [COMMENT_END_BANG_STATE](cp) {
        if (cp === $$5.HYPHEN_MINUS) {
          this.currentToken.data += "--!";
          this.state = COMMENT_END_DASH_STATE;
        } else if (cp === $$5.GREATER_THAN_SIGN) {
          this._err(ERR$1.incorrectlyClosedComment);
          this.state = DATA_STATE;
          this._emitCurrentToken();
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInComment);
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this.currentToken.data += "--!";
          this._reconsumeInState(COMMENT_STATE);
        }
      }
      // DOCTYPE state
      //------------------------------------------------------------------
      [DOCTYPE_STATE](cp) {
        if (isWhitespace(cp)) {
          this.state = BEFORE_DOCTYPE_NAME_STATE;
        } else if (cp === $$5.GREATER_THAN_SIGN) {
          this._reconsumeInState(BEFORE_DOCTYPE_NAME_STATE);
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInDoctype);
          this._createDoctypeToken(null);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this._err(ERR$1.missingWhitespaceBeforeDoctypeName);
          this._reconsumeInState(BEFORE_DOCTYPE_NAME_STATE);
        }
      }
      // Before DOCTYPE name state
      //------------------------------------------------------------------
      [BEFORE_DOCTYPE_NAME_STATE](cp) {
        if (isWhitespace(cp)) {
          return;
        }
        if (isAsciiUpper(cp)) {
          this._createDoctypeToken(toAsciiLowerChar(cp));
          this.state = DOCTYPE_NAME_STATE;
        } else if (cp === $$5.NULL) {
          this._err(ERR$1.unexpectedNullCharacter);
          this._createDoctypeToken(unicode$1.REPLACEMENT_CHARACTER);
          this.state = DOCTYPE_NAME_STATE;
        } else if (cp === $$5.GREATER_THAN_SIGN) {
          this._err(ERR$1.missingDoctypeName);
          this._createDoctypeToken(null);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this.state = DATA_STATE;
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInDoctype);
          this._createDoctypeToken(null);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this._createDoctypeToken(toChar(cp));
          this.state = DOCTYPE_NAME_STATE;
        }
      }
      // DOCTYPE name state
      //------------------------------------------------------------------
      [DOCTYPE_NAME_STATE](cp) {
        if (isWhitespace(cp)) {
          this.state = AFTER_DOCTYPE_NAME_STATE;
        } else if (cp === $$5.GREATER_THAN_SIGN) {
          this.state = DATA_STATE;
          this._emitCurrentToken();
        } else if (isAsciiUpper(cp)) {
          this.currentToken.name += toAsciiLowerChar(cp);
        } else if (cp === $$5.NULL) {
          this._err(ERR$1.unexpectedNullCharacter);
          this.currentToken.name += unicode$1.REPLACEMENT_CHARACTER;
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInDoctype);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this.currentToken.name += toChar(cp);
        }
      }
      // After DOCTYPE name state
      //------------------------------------------------------------------
      [AFTER_DOCTYPE_NAME_STATE](cp) {
        if (isWhitespace(cp)) {
          return;
        }
        if (cp === $$5.GREATER_THAN_SIGN) {
          this.state = DATA_STATE;
          this._emitCurrentToken();
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInDoctype);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this._emitEOFToken();
        } else if (this._consumeSequenceIfMatch($$.PUBLIC_STRING, cp, false)) {
          this.state = AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE;
        } else if (this._consumeSequenceIfMatch($$.SYSTEM_STRING, cp, false)) {
          this.state = AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE;
        } else if (!this._ensureHibernation()) {
          this._err(ERR$1.invalidCharacterSequenceAfterDoctypeName);
          this.currentToken.forceQuirks = true;
          this._reconsumeInState(BOGUS_DOCTYPE_STATE);
        }
      }
      // After DOCTYPE public keyword state
      //------------------------------------------------------------------
      [AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE](cp) {
        if (isWhitespace(cp)) {
          this.state = BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
        } else if (cp === $$5.QUOTATION_MARK) {
          this._err(ERR$1.missingWhitespaceAfterDoctypePublicKeyword);
          this.currentToken.publicId = "";
          this.state = DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE;
        } else if (cp === $$5.APOSTROPHE) {
          this._err(ERR$1.missingWhitespaceAfterDoctypePublicKeyword);
          this.currentToken.publicId = "";
          this.state = DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE;
        } else if (cp === $$5.GREATER_THAN_SIGN) {
          this._err(ERR$1.missingDoctypePublicIdentifier);
          this.currentToken.forceQuirks = true;
          this.state = DATA_STATE;
          this._emitCurrentToken();
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInDoctype);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this._err(ERR$1.missingQuoteBeforeDoctypePublicIdentifier);
          this.currentToken.forceQuirks = true;
          this._reconsumeInState(BOGUS_DOCTYPE_STATE);
        }
      }
      // Before DOCTYPE public identifier state
      //------------------------------------------------------------------
      [BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE](cp) {
        if (isWhitespace(cp)) {
          return;
        }
        if (cp === $$5.QUOTATION_MARK) {
          this.currentToken.publicId = "";
          this.state = DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE;
        } else if (cp === $$5.APOSTROPHE) {
          this.currentToken.publicId = "";
          this.state = DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE;
        } else if (cp === $$5.GREATER_THAN_SIGN) {
          this._err(ERR$1.missingDoctypePublicIdentifier);
          this.currentToken.forceQuirks = true;
          this.state = DATA_STATE;
          this._emitCurrentToken();
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInDoctype);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this._err(ERR$1.missingQuoteBeforeDoctypePublicIdentifier);
          this.currentToken.forceQuirks = true;
          this._reconsumeInState(BOGUS_DOCTYPE_STATE);
        }
      }
      // DOCTYPE public identifier (double-quoted) state
      //------------------------------------------------------------------
      [DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE](cp) {
        if (cp === $$5.QUOTATION_MARK) {
          this.state = AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
        } else if (cp === $$5.NULL) {
          this._err(ERR$1.unexpectedNullCharacter);
          this.currentToken.publicId += unicode$1.REPLACEMENT_CHARACTER;
        } else if (cp === $$5.GREATER_THAN_SIGN) {
          this._err(ERR$1.abruptDoctypePublicIdentifier);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this.state = DATA_STATE;
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInDoctype);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this.currentToken.publicId += toChar(cp);
        }
      }
      // DOCTYPE public identifier (single-quoted) state
      //------------------------------------------------------------------
      [DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE](cp) {
        if (cp === $$5.APOSTROPHE) {
          this.state = AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
        } else if (cp === $$5.NULL) {
          this._err(ERR$1.unexpectedNullCharacter);
          this.currentToken.publicId += unicode$1.REPLACEMENT_CHARACTER;
        } else if (cp === $$5.GREATER_THAN_SIGN) {
          this._err(ERR$1.abruptDoctypePublicIdentifier);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this.state = DATA_STATE;
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInDoctype);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this.currentToken.publicId += toChar(cp);
        }
      }
      // After DOCTYPE public identifier state
      //------------------------------------------------------------------
      [AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE](cp) {
        if (isWhitespace(cp)) {
          this.state = BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE;
        } else if (cp === $$5.GREATER_THAN_SIGN) {
          this.state = DATA_STATE;
          this._emitCurrentToken();
        } else if (cp === $$5.QUOTATION_MARK) {
          this._err(ERR$1.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
          this.currentToken.systemId = "";
          this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
        } else if (cp === $$5.APOSTROPHE) {
          this._err(ERR$1.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
          this.currentToken.systemId = "";
          this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInDoctype);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this._err(ERR$1.missingQuoteBeforeDoctypeSystemIdentifier);
          this.currentToken.forceQuirks = true;
          this._reconsumeInState(BOGUS_DOCTYPE_STATE);
        }
      }
      // Between DOCTYPE public and system identifiers state
      //------------------------------------------------------------------
      [BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE](cp) {
        if (isWhitespace(cp)) {
          return;
        }
        if (cp === $$5.GREATER_THAN_SIGN) {
          this._emitCurrentToken();
          this.state = DATA_STATE;
        } else if (cp === $$5.QUOTATION_MARK) {
          this.currentToken.systemId = "";
          this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
        } else if (cp === $$5.APOSTROPHE) {
          this.currentToken.systemId = "";
          this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInDoctype);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this._err(ERR$1.missingQuoteBeforeDoctypeSystemIdentifier);
          this.currentToken.forceQuirks = true;
          this._reconsumeInState(BOGUS_DOCTYPE_STATE);
        }
      }
      // After DOCTYPE system keyword state
      //------------------------------------------------------------------
      [AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE](cp) {
        if (isWhitespace(cp)) {
          this.state = BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
        } else if (cp === $$5.QUOTATION_MARK) {
          this._err(ERR$1.missingWhitespaceAfterDoctypeSystemKeyword);
          this.currentToken.systemId = "";
          this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
        } else if (cp === $$5.APOSTROPHE) {
          this._err(ERR$1.missingWhitespaceAfterDoctypeSystemKeyword);
          this.currentToken.systemId = "";
          this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
        } else if (cp === $$5.GREATER_THAN_SIGN) {
          this._err(ERR$1.missingDoctypeSystemIdentifier);
          this.currentToken.forceQuirks = true;
          this.state = DATA_STATE;
          this._emitCurrentToken();
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInDoctype);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this._err(ERR$1.missingQuoteBeforeDoctypeSystemIdentifier);
          this.currentToken.forceQuirks = true;
          this._reconsumeInState(BOGUS_DOCTYPE_STATE);
        }
      }
      // Before DOCTYPE system identifier state
      //------------------------------------------------------------------
      [BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE](cp) {
        if (isWhitespace(cp)) {
          return;
        }
        if (cp === $$5.QUOTATION_MARK) {
          this.currentToken.systemId = "";
          this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
        } else if (cp === $$5.APOSTROPHE) {
          this.currentToken.systemId = "";
          this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
        } else if (cp === $$5.GREATER_THAN_SIGN) {
          this._err(ERR$1.missingDoctypeSystemIdentifier);
          this.currentToken.forceQuirks = true;
          this.state = DATA_STATE;
          this._emitCurrentToken();
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInDoctype);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this._err(ERR$1.missingQuoteBeforeDoctypeSystemIdentifier);
          this.currentToken.forceQuirks = true;
          this._reconsumeInState(BOGUS_DOCTYPE_STATE);
        }
      }
      // DOCTYPE system identifier (double-quoted) state
      //------------------------------------------------------------------
      [DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE](cp) {
        if (cp === $$5.QUOTATION_MARK) {
          this.state = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
        } else if (cp === $$5.NULL) {
          this._err(ERR$1.unexpectedNullCharacter);
          this.currentToken.systemId += unicode$1.REPLACEMENT_CHARACTER;
        } else if (cp === $$5.GREATER_THAN_SIGN) {
          this._err(ERR$1.abruptDoctypeSystemIdentifier);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this.state = DATA_STATE;
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInDoctype);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this.currentToken.systemId += toChar(cp);
        }
      }
      // DOCTYPE system identifier (single-quoted) state
      //------------------------------------------------------------------
      [DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE](cp) {
        if (cp === $$5.APOSTROPHE) {
          this.state = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
        } else if (cp === $$5.NULL) {
          this._err(ERR$1.unexpectedNullCharacter);
          this.currentToken.systemId += unicode$1.REPLACEMENT_CHARACTER;
        } else if (cp === $$5.GREATER_THAN_SIGN) {
          this._err(ERR$1.abruptDoctypeSystemIdentifier);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this.state = DATA_STATE;
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInDoctype);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this.currentToken.systemId += toChar(cp);
        }
      }
      // After DOCTYPE system identifier state
      //------------------------------------------------------------------
      [AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE](cp) {
        if (isWhitespace(cp)) {
          return;
        }
        if (cp === $$5.GREATER_THAN_SIGN) {
          this._emitCurrentToken();
          this.state = DATA_STATE;
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInDoctype);
          this.currentToken.forceQuirks = true;
          this._emitCurrentToken();
          this._emitEOFToken();
        } else {
          this._err(ERR$1.unexpectedCharacterAfterDoctypeSystemIdentifier);
          this._reconsumeInState(BOGUS_DOCTYPE_STATE);
        }
      }
      // Bogus DOCTYPE state
      //------------------------------------------------------------------
      [BOGUS_DOCTYPE_STATE](cp) {
        if (cp === $$5.GREATER_THAN_SIGN) {
          this._emitCurrentToken();
          this.state = DATA_STATE;
        } else if (cp === $$5.NULL) {
          this._err(ERR$1.unexpectedNullCharacter);
        } else if (cp === $$5.EOF) {
          this._emitCurrentToken();
          this._emitEOFToken();
        }
      }
      // CDATA section state
      //------------------------------------------------------------------
      [CDATA_SECTION_STATE](cp) {
        if (cp === $$5.RIGHT_SQUARE_BRACKET) {
          this.state = CDATA_SECTION_BRACKET_STATE;
        } else if (cp === $$5.EOF) {
          this._err(ERR$1.eofInCdata);
          this._emitEOFToken();
        } else {
          this._emitCodePoint(cp);
        }
      }
      // CDATA section bracket state
      //------------------------------------------------------------------
      [CDATA_SECTION_BRACKET_STATE](cp) {
        if (cp === $$5.RIGHT_SQUARE_BRACKET) {
          this.state = CDATA_SECTION_END_STATE;
        } else {
          this._emitChars("]");
          this._reconsumeInState(CDATA_SECTION_STATE);
        }
      }
      // CDATA section end state
      //------------------------------------------------------------------
      [CDATA_SECTION_END_STATE](cp) {
        if (cp === $$5.GREATER_THAN_SIGN) {
          this.state = DATA_STATE;
        } else if (cp === $$5.RIGHT_SQUARE_BRACKET) {
          this._emitChars("]");
        } else {
          this._emitChars("]]");
          this._reconsumeInState(CDATA_SECTION_STATE);
        }
      }
      // Character reference state
      //------------------------------------------------------------------
      [CHARACTER_REFERENCE_STATE](cp) {
        this.tempBuff = [$$5.AMPERSAND];
        if (cp === $$5.NUMBER_SIGN) {
          this.tempBuff.push(cp);
          this.state = NUMERIC_CHARACTER_REFERENCE_STATE;
        } else if (isAsciiAlphaNumeric(cp)) {
          this._reconsumeInState(NAMED_CHARACTER_REFERENCE_STATE);
        } else {
          this._flushCodePointsConsumedAsCharacterReference();
          this._reconsumeInState(this.returnState);
        }
      }
      // Named character reference state
      //------------------------------------------------------------------
      [NAMED_CHARACTER_REFERENCE_STATE](cp) {
        const matchResult = this._matchNamedCharacterReference(cp);
        if (this._ensureHibernation()) {
          this.tempBuff = [$$5.AMPERSAND];
        } else if (matchResult) {
          const withSemicolon = this.tempBuff[this.tempBuff.length - 1] === $$5.SEMICOLON;
          if (!this._isCharacterReferenceAttributeQuirk(withSemicolon)) {
            if (!withSemicolon) {
              this._errOnNextCodePoint(ERR$1.missingSemicolonAfterCharacterReference);
            }
            this.tempBuff = matchResult;
          }
          this._flushCodePointsConsumedAsCharacterReference();
          this.state = this.returnState;
        } else {
          this._flushCodePointsConsumedAsCharacterReference();
          this.state = AMBIGUOUS_AMPERSAND_STATE;
        }
      }
      // Ambiguos ampersand state
      //------------------------------------------------------------------
      [AMBIGUOUS_AMPERSAND_STATE](cp) {
        if (isAsciiAlphaNumeric(cp)) {
          if (this._isCharacterReferenceInAttribute()) {
            this.currentAttr.value += toChar(cp);
          } else {
            this._emitCodePoint(cp);
          }
        } else {
          if (cp === $$5.SEMICOLON) {
            this._err(ERR$1.unknownNamedCharacterReference);
          }
          this._reconsumeInState(this.returnState);
        }
      }
      // Numeric character reference state
      //------------------------------------------------------------------
      [NUMERIC_CHARACTER_REFERENCE_STATE](cp) {
        this.charRefCode = 0;
        if (cp === $$5.LATIN_SMALL_X || cp === $$5.LATIN_CAPITAL_X) {
          this.tempBuff.push(cp);
          this.state = HEXADEMICAL_CHARACTER_REFERENCE_START_STATE;
        } else {
          this._reconsumeInState(DECIMAL_CHARACTER_REFERENCE_START_STATE);
        }
      }
      // Hexademical character reference start state
      //------------------------------------------------------------------
      [HEXADEMICAL_CHARACTER_REFERENCE_START_STATE](cp) {
        if (isAsciiHexDigit(cp)) {
          this._reconsumeInState(HEXADEMICAL_CHARACTER_REFERENCE_STATE);
        } else {
          this._err(ERR$1.absenceOfDigitsInNumericCharacterReference);
          this._flushCodePointsConsumedAsCharacterReference();
          this._reconsumeInState(this.returnState);
        }
      }
      // Decimal character reference start state
      //------------------------------------------------------------------
      [DECIMAL_CHARACTER_REFERENCE_START_STATE](cp) {
        if (isAsciiDigit(cp)) {
          this._reconsumeInState(DECIMAL_CHARACTER_REFERENCE_STATE);
        } else {
          this._err(ERR$1.absenceOfDigitsInNumericCharacterReference);
          this._flushCodePointsConsumedAsCharacterReference();
          this._reconsumeInState(this.returnState);
        }
      }
      // Hexademical character reference state
      //------------------------------------------------------------------
      [HEXADEMICAL_CHARACTER_REFERENCE_STATE](cp) {
        if (isAsciiUpperHexDigit(cp)) {
          this.charRefCode = this.charRefCode * 16 + cp - 55;
        } else if (isAsciiLowerHexDigit(cp)) {
          this.charRefCode = this.charRefCode * 16 + cp - 87;
        } else if (isAsciiDigit(cp)) {
          this.charRefCode = this.charRefCode * 16 + cp - 48;
        } else if (cp === $$5.SEMICOLON) {
          this.state = NUMERIC_CHARACTER_REFERENCE_END_STATE;
        } else {
          this._err(ERR$1.missingSemicolonAfterCharacterReference);
          this._reconsumeInState(NUMERIC_CHARACTER_REFERENCE_END_STATE);
        }
      }
      // Decimal character reference state
      //------------------------------------------------------------------
      [DECIMAL_CHARACTER_REFERENCE_STATE](cp) {
        if (isAsciiDigit(cp)) {
          this.charRefCode = this.charRefCode * 10 + cp - 48;
        } else if (cp === $$5.SEMICOLON) {
          this.state = NUMERIC_CHARACTER_REFERENCE_END_STATE;
        } else {
          this._err(ERR$1.missingSemicolonAfterCharacterReference);
          this._reconsumeInState(NUMERIC_CHARACTER_REFERENCE_END_STATE);
        }
      }
      // Numeric character reference end state
      //------------------------------------------------------------------
      [NUMERIC_CHARACTER_REFERENCE_END_STATE]() {
        if (this.charRefCode === $$5.NULL) {
          this._err(ERR$1.nullCharacterReference);
          this.charRefCode = $$5.REPLACEMENT_CHARACTER;
        } else if (this.charRefCode > 1114111) {
          this._err(ERR$1.characterReferenceOutsideUnicodeRange);
          this.charRefCode = $$5.REPLACEMENT_CHARACTER;
        } else if (unicode$1.isSurrogate(this.charRefCode)) {
          this._err(ERR$1.surrogateCharacterReference);
          this.charRefCode = $$5.REPLACEMENT_CHARACTER;
        } else if (unicode$1.isUndefinedCodePoint(this.charRefCode)) {
          this._err(ERR$1.noncharacterCharacterReference);
        } else if (unicode$1.isControlCodePoint(this.charRefCode) || this.charRefCode === $$5.CARRIAGE_RETURN) {
          this._err(ERR$1.controlCharacterReference);
          const replacement = C1_CONTROLS_REFERENCE_REPLACEMENTS[this.charRefCode];
          if (replacement) {
            this.charRefCode = replacement;
          }
        }
        this.tempBuff = [this.charRefCode];
        this._flushCodePointsConsumedAsCharacterReference();
        this._reconsumeInState(this.returnState);
      }
    };
    Tokenizer$4.CHARACTER_TOKEN = "CHARACTER_TOKEN";
    Tokenizer$4.NULL_CHARACTER_TOKEN = "NULL_CHARACTER_TOKEN";
    Tokenizer$4.WHITESPACE_CHARACTER_TOKEN = "WHITESPACE_CHARACTER_TOKEN";
    Tokenizer$4.START_TAG_TOKEN = "START_TAG_TOKEN";
    Tokenizer$4.END_TAG_TOKEN = "END_TAG_TOKEN";
    Tokenizer$4.COMMENT_TOKEN = "COMMENT_TOKEN";
    Tokenizer$4.DOCTYPE_TOKEN = "DOCTYPE_TOKEN";
    Tokenizer$4.EOF_TOKEN = "EOF_TOKEN";
    Tokenizer$4.HIBERNATION_TOKEN = "HIBERNATION_TOKEN";
    Tokenizer$4.MODE = {
      DATA: DATA_STATE,
      RCDATA: RCDATA_STATE,
      RAWTEXT: RAWTEXT_STATE,
      SCRIPT_DATA: SCRIPT_DATA_STATE,
      PLAINTEXT: PLAINTEXT_STATE
    };
    Tokenizer$4.getTokenAttr = function(token2, attrName) {
      for (let i2 = token2.attrs.length - 1; i2 >= 0; i2--) {
        if (token2.attrs[i2].name === attrName) {
          return token2.attrs[i2].value;
        }
      }
      return null;
    };
    var tokenizer = Tokenizer$4;
    var html = {};
    const NS$3 = html.NAMESPACES = {
      HTML: "http://www.w3.org/1999/xhtml",
      MATHML: "http://www.w3.org/1998/Math/MathML",
      SVG: "http://www.w3.org/2000/svg",
      XLINK: "http://www.w3.org/1999/xlink",
      XML: "http://www.w3.org/XML/1998/namespace",
      XMLNS: "http://www.w3.org/2000/xmlns/"
    };
    html.ATTRS = {
      TYPE: "type",
      ACTION: "action",
      ENCODING: "encoding",
      PROMPT: "prompt",
      NAME: "name",
      COLOR: "color",
      FACE: "face",
      SIZE: "size"
    };
    html.DOCUMENT_MODE = {
      NO_QUIRKS: "no-quirks",
      QUIRKS: "quirks",
      LIMITED_QUIRKS: "limited-quirks"
    };
    const $$4 = html.TAG_NAMES = {
      A: "a",
      ADDRESS: "address",
      ANNOTATION_XML: "annotation-xml",
      APPLET: "applet",
      AREA: "area",
      ARTICLE: "article",
      ASIDE: "aside",
      B: "b",
      BASE: "base",
      BASEFONT: "basefont",
      BGSOUND: "bgsound",
      BIG: "big",
      BLOCKQUOTE: "blockquote",
      BODY: "body",
      BR: "br",
      BUTTON: "button",
      CAPTION: "caption",
      CENTER: "center",
      CODE: "code",
      COL: "col",
      COLGROUP: "colgroup",
      DD: "dd",
      DESC: "desc",
      DETAILS: "details",
      DIALOG: "dialog",
      DIR: "dir",
      DIV: "div",
      DL: "dl",
      DT: "dt",
      EM: "em",
      EMBED: "embed",
      FIELDSET: "fieldset",
      FIGCAPTION: "figcaption",
      FIGURE: "figure",
      FONT: "font",
      FOOTER: "footer",
      FOREIGN_OBJECT: "foreignObject",
      FORM: "form",
      FRAME: "frame",
      FRAMESET: "frameset",
      H1: "h1",
      H2: "h2",
      H3: "h3",
      H4: "h4",
      H5: "h5",
      H6: "h6",
      HEAD: "head",
      HEADER: "header",
      HGROUP: "hgroup",
      HR: "hr",
      HTML: "html",
      I: "i",
      IMG: "img",
      IMAGE: "image",
      INPUT: "input",
      IFRAME: "iframe",
      KEYGEN: "keygen",
      LABEL: "label",
      LI: "li",
      LINK: "link",
      LISTING: "listing",
      MAIN: "main",
      MALIGNMARK: "malignmark",
      MARQUEE: "marquee",
      MATH: "math",
      MENU: "menu",
      META: "meta",
      MGLYPH: "mglyph",
      MI: "mi",
      MO: "mo",
      MN: "mn",
      MS: "ms",
      MTEXT: "mtext",
      NAV: "nav",
      NOBR: "nobr",
      NOFRAMES: "noframes",
      NOEMBED: "noembed",
      NOSCRIPT: "noscript",
      OBJECT: "object",
      OL: "ol",
      OPTGROUP: "optgroup",
      OPTION: "option",
      P: "p",
      PARAM: "param",
      PLAINTEXT: "plaintext",
      PRE: "pre",
      RB: "rb",
      RP: "rp",
      RT: "rt",
      RTC: "rtc",
      RUBY: "ruby",
      S: "s",
      SCRIPT: "script",
      SECTION: "section",
      SELECT: "select",
      SOURCE: "source",
      SMALL: "small",
      SPAN: "span",
      STRIKE: "strike",
      STRONG: "strong",
      STYLE: "style",
      SUB: "sub",
      SUMMARY: "summary",
      SUP: "sup",
      TABLE: "table",
      TBODY: "tbody",
      TEMPLATE: "template",
      TEXTAREA: "textarea",
      TFOOT: "tfoot",
      TD: "td",
      TH: "th",
      THEAD: "thead",
      TITLE: "title",
      TR: "tr",
      TRACK: "track",
      TT: "tt",
      U: "u",
      UL: "ul",
      SVG: "svg",
      VAR: "var",
      WBR: "wbr",
      XMP: "xmp"
    };
    html.SPECIAL_ELEMENTS = {
      [NS$3.HTML]: {
        [$$4.ADDRESS]: true,
        [$$4.APPLET]: true,
        [$$4.AREA]: true,
        [$$4.ARTICLE]: true,
        [$$4.ASIDE]: true,
        [$$4.BASE]: true,
        [$$4.BASEFONT]: true,
        [$$4.BGSOUND]: true,
        [$$4.BLOCKQUOTE]: true,
        [$$4.BODY]: true,
        [$$4.BR]: true,
        [$$4.BUTTON]: true,
        [$$4.CAPTION]: true,
        [$$4.CENTER]: true,
        [$$4.COL]: true,
        [$$4.COLGROUP]: true,
        [$$4.DD]: true,
        [$$4.DETAILS]: true,
        [$$4.DIR]: true,
        [$$4.DIV]: true,
        [$$4.DL]: true,
        [$$4.DT]: true,
        [$$4.EMBED]: true,
        [$$4.FIELDSET]: true,
        [$$4.FIGCAPTION]: true,
        [$$4.FIGURE]: true,
        [$$4.FOOTER]: true,
        [$$4.FORM]: true,
        [$$4.FRAME]: true,
        [$$4.FRAMESET]: true,
        [$$4.H1]: true,
        [$$4.H2]: true,
        [$$4.H3]: true,
        [$$4.H4]: true,
        [$$4.H5]: true,
        [$$4.H6]: true,
        [$$4.HEAD]: true,
        [$$4.HEADER]: true,
        [$$4.HGROUP]: true,
        [$$4.HR]: true,
        [$$4.HTML]: true,
        [$$4.IFRAME]: true,
        [$$4.IMG]: true,
        [$$4.INPUT]: true,
        [$$4.LI]: true,
        [$$4.LINK]: true,
        [$$4.LISTING]: true,
        [$$4.MAIN]: true,
        [$$4.MARQUEE]: true,
        [$$4.MENU]: true,
        [$$4.META]: true,
        [$$4.NAV]: true,
        [$$4.NOEMBED]: true,
        [$$4.NOFRAMES]: true,
        [$$4.NOSCRIPT]: true,
        [$$4.OBJECT]: true,
        [$$4.OL]: true,
        [$$4.P]: true,
        [$$4.PARAM]: true,
        [$$4.PLAINTEXT]: true,
        [$$4.PRE]: true,
        [$$4.SCRIPT]: true,
        [$$4.SECTION]: true,
        [$$4.SELECT]: true,
        [$$4.SOURCE]: true,
        [$$4.STYLE]: true,
        [$$4.SUMMARY]: true,
        [$$4.TABLE]: true,
        [$$4.TBODY]: true,
        [$$4.TD]: true,
        [$$4.TEMPLATE]: true,
        [$$4.TEXTAREA]: true,
        [$$4.TFOOT]: true,
        [$$4.TH]: true,
        [$$4.THEAD]: true,
        [$$4.TITLE]: true,
        [$$4.TR]: true,
        [$$4.TRACK]: true,
        [$$4.UL]: true,
        [$$4.WBR]: true,
        [$$4.XMP]: true
      },
      [NS$3.MATHML]: {
        [$$4.MI]: true,
        [$$4.MO]: true,
        [$$4.MN]: true,
        [$$4.MS]: true,
        [$$4.MTEXT]: true,
        [$$4.ANNOTATION_XML]: true
      },
      [NS$3.SVG]: {
        [$$4.TITLE]: true,
        [$$4.FOREIGN_OBJECT]: true,
        [$$4.DESC]: true
      }
    };
    const HTML$3 = html;
    const $$3 = HTML$3.TAG_NAMES;
    const NS$2 = HTML$3.NAMESPACES;
    function isImpliedEndTagRequired(tn) {
      switch (tn.length) {
        case 1:
          return tn === $$3.P;
        case 2:
          return tn === $$3.RB || tn === $$3.RP || tn === $$3.RT || tn === $$3.DD || tn === $$3.DT || tn === $$3.LI;
        case 3:
          return tn === $$3.RTC;
        case 6:
          return tn === $$3.OPTION;
        case 8:
          return tn === $$3.OPTGROUP;
      }
      return false;
    }
    function isImpliedEndTagRequiredThoroughly(tn) {
      switch (tn.length) {
        case 1:
          return tn === $$3.P;
        case 2:
          return tn === $$3.RB || tn === $$3.RP || tn === $$3.RT || tn === $$3.DD || tn === $$3.DT || tn === $$3.LI || tn === $$3.TD || tn === $$3.TH || tn === $$3.TR;
        case 3:
          return tn === $$3.RTC;
        case 5:
          return tn === $$3.TBODY || tn === $$3.TFOOT || tn === $$3.THEAD;
        case 6:
          return tn === $$3.OPTION;
        case 7:
          return tn === $$3.CAPTION;
        case 8:
          return tn === $$3.OPTGROUP || tn === $$3.COLGROUP;
      }
      return false;
    }
    function isScopingElement(tn, ns2) {
      switch (tn.length) {
        case 2:
          if (tn === $$3.TD || tn === $$3.TH) {
            return ns2 === NS$2.HTML;
          } else if (tn === $$3.MI || tn === $$3.MO || tn === $$3.MN || tn === $$3.MS) {
            return ns2 === NS$2.MATHML;
          }
          break;
        case 4:
          if (tn === $$3.HTML) {
            return ns2 === NS$2.HTML;
          } else if (tn === $$3.DESC) {
            return ns2 === NS$2.SVG;
          }
          break;
        case 5:
          if (tn === $$3.TABLE) {
            return ns2 === NS$2.HTML;
          } else if (tn === $$3.MTEXT) {
            return ns2 === NS$2.MATHML;
          } else if (tn === $$3.TITLE) {
            return ns2 === NS$2.SVG;
          }
          break;
        case 6:
          return (tn === $$3.APPLET || tn === $$3.OBJECT) && ns2 === NS$2.HTML;
        case 7:
          return (tn === $$3.CAPTION || tn === $$3.MARQUEE) && ns2 === NS$2.HTML;
        case 8:
          return tn === $$3.TEMPLATE && ns2 === NS$2.HTML;
        case 13:
          return tn === $$3.FOREIGN_OBJECT && ns2 === NS$2.SVG;
        case 14:
          return tn === $$3.ANNOTATION_XML && ns2 === NS$2.MATHML;
      }
      return false;
    }
    let OpenElementStack$1 = class OpenElementStack {
      constructor(document2, treeAdapter) {
        this.stackTop = -1;
        this.items = [];
        this.current = document2;
        this.currentTagName = null;
        this.currentTmplContent = null;
        this.tmplCount = 0;
        this.treeAdapter = treeAdapter;
      }
      //Index of element
      _indexOf(element2) {
        let idx = -1;
        for (let i2 = this.stackTop; i2 >= 0; i2--) {
          if (this.items[i2] === element2) {
            idx = i2;
            break;
          }
        }
        return idx;
      }
      //Update current element
      _isInTemplate() {
        return this.currentTagName === $$3.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === NS$2.HTML;
      }
      _updateCurrentElement() {
        this.current = this.items[this.stackTop];
        this.currentTagName = this.current && this.treeAdapter.getTagName(this.current);
        this.currentTmplContent = this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : null;
      }
      //Mutations
      push(element2) {
        this.items[++this.stackTop] = element2;
        this._updateCurrentElement();
        if (this._isInTemplate()) {
          this.tmplCount++;
        }
      }
      pop() {
        this.stackTop--;
        if (this.tmplCount > 0 && this._isInTemplate()) {
          this.tmplCount--;
        }
        this._updateCurrentElement();
      }
      replace(oldElement, newElement) {
        const idx = this._indexOf(oldElement);
        this.items[idx] = newElement;
        if (idx === this.stackTop) {
          this._updateCurrentElement();
        }
      }
      insertAfter(referenceElement, newElement) {
        const insertionIdx = this._indexOf(referenceElement) + 1;
        this.items.splice(insertionIdx, 0, newElement);
        if (insertionIdx === ++this.stackTop) {
          this._updateCurrentElement();
        }
      }
      popUntilTagNamePopped(tagName) {
        while (this.stackTop > -1) {
          const tn = this.currentTagName;
          const ns2 = this.treeAdapter.getNamespaceURI(this.current);
          this.pop();
          if (tn === tagName && ns2 === NS$2.HTML) {
            break;
          }
        }
      }
      popUntilElementPopped(element2) {
        while (this.stackTop > -1) {
          const poppedElement = this.current;
          this.pop();
          if (poppedElement === element2) {
            break;
          }
        }
      }
      popUntilNumberedHeaderPopped() {
        while (this.stackTop > -1) {
          const tn = this.currentTagName;
          const ns2 = this.treeAdapter.getNamespaceURI(this.current);
          this.pop();
          if (tn === $$3.H1 || tn === $$3.H2 || tn === $$3.H3 || tn === $$3.H4 || tn === $$3.H5 || tn === $$3.H6 && ns2 === NS$2.HTML) {
            break;
          }
        }
      }
      popUntilTableCellPopped() {
        while (this.stackTop > -1) {
          const tn = this.currentTagName;
          const ns2 = this.treeAdapter.getNamespaceURI(this.current);
          this.pop();
          if (tn === $$3.TD || tn === $$3.TH && ns2 === NS$2.HTML) {
            break;
          }
        }
      }
      popAllUpToHtmlElement() {
        this.stackTop = 0;
        this._updateCurrentElement();
      }
      clearBackToTableContext() {
        while (this.currentTagName !== $$3.TABLE && this.currentTagName !== $$3.TEMPLATE && this.currentTagName !== $$3.HTML || this.treeAdapter.getNamespaceURI(this.current) !== NS$2.HTML) {
          this.pop();
        }
      }
      clearBackToTableBodyContext() {
        while (this.currentTagName !== $$3.TBODY && this.currentTagName !== $$3.TFOOT && this.currentTagName !== $$3.THEAD && this.currentTagName !== $$3.TEMPLATE && this.currentTagName !== $$3.HTML || this.treeAdapter.getNamespaceURI(this.current) !== NS$2.HTML) {
          this.pop();
        }
      }
      clearBackToTableRowContext() {
        while (this.currentTagName !== $$3.TR && this.currentTagName !== $$3.TEMPLATE && this.currentTagName !== $$3.HTML || this.treeAdapter.getNamespaceURI(this.current) !== NS$2.HTML) {
          this.pop();
        }
      }
      remove(element2) {
        for (let i2 = this.stackTop; i2 >= 0; i2--) {
          if (this.items[i2] === element2) {
            this.items.splice(i2, 1);
            this.stackTop--;
            this._updateCurrentElement();
            break;
          }
        }
      }
      //Search
      tryPeekProperlyNestedBodyElement() {
        const element2 = this.items[1];
        return element2 && this.treeAdapter.getTagName(element2) === $$3.BODY ? element2 : null;
      }
      contains(element2) {
        return this._indexOf(element2) > -1;
      }
      getCommonAncestor(element2) {
        let elementIdx = this._indexOf(element2);
        return --elementIdx >= 0 ? this.items[elementIdx] : null;
      }
      isRootHtmlElementCurrent() {
        return this.stackTop === 0 && this.currentTagName === $$3.HTML;
      }
      //Element in scope
      hasInScope(tagName) {
        for (let i2 = this.stackTop; i2 >= 0; i2--) {
          const tn = this.treeAdapter.getTagName(this.items[i2]);
          const ns2 = this.treeAdapter.getNamespaceURI(this.items[i2]);
          if (tn === tagName && ns2 === NS$2.HTML) {
            return true;
          }
          if (isScopingElement(tn, ns2)) {
            return false;
          }
        }
        return true;
      }
      hasNumberedHeaderInScope() {
        for (let i2 = this.stackTop; i2 >= 0; i2--) {
          const tn = this.treeAdapter.getTagName(this.items[i2]);
          const ns2 = this.treeAdapter.getNamespaceURI(this.items[i2]);
          if ((tn === $$3.H1 || tn === $$3.H2 || tn === $$3.H3 || tn === $$3.H4 || tn === $$3.H5 || tn === $$3.H6) && ns2 === NS$2.HTML) {
            return true;
          }
          if (isScopingElement(tn, ns2)) {
            return false;
          }
        }
        return true;
      }
      hasInListItemScope(tagName) {
        for (let i2 = this.stackTop; i2 >= 0; i2--) {
          const tn = this.treeAdapter.getTagName(this.items[i2]);
          const ns2 = this.treeAdapter.getNamespaceURI(this.items[i2]);
          if (tn === tagName && ns2 === NS$2.HTML) {
            return true;
          }
          if ((tn === $$3.UL || tn === $$3.OL) && ns2 === NS$2.HTML || isScopingElement(tn, ns2)) {
            return false;
          }
        }
        return true;
      }
      hasInButtonScope(tagName) {
        for (let i2 = this.stackTop; i2 >= 0; i2--) {
          const tn = this.treeAdapter.getTagName(this.items[i2]);
          const ns2 = this.treeAdapter.getNamespaceURI(this.items[i2]);
          if (tn === tagName && ns2 === NS$2.HTML) {
            return true;
          }
          if (tn === $$3.BUTTON && ns2 === NS$2.HTML || isScopingElement(tn, ns2)) {
            return false;
          }
        }
        return true;
      }
      hasInTableScope(tagName) {
        for (let i2 = this.stackTop; i2 >= 0; i2--) {
          const tn = this.treeAdapter.getTagName(this.items[i2]);
          const ns2 = this.treeAdapter.getNamespaceURI(this.items[i2]);
          if (ns2 !== NS$2.HTML) {
            continue;
          }
          if (tn === tagName) {
            return true;
          }
          if (tn === $$3.TABLE || tn === $$3.TEMPLATE || tn === $$3.HTML) {
            return false;
          }
        }
        return true;
      }
      hasTableBodyContextInTableScope() {
        for (let i2 = this.stackTop; i2 >= 0; i2--) {
          const tn = this.treeAdapter.getTagName(this.items[i2]);
          const ns2 = this.treeAdapter.getNamespaceURI(this.items[i2]);
          if (ns2 !== NS$2.HTML) {
            continue;
          }
          if (tn === $$3.TBODY || tn === $$3.THEAD || tn === $$3.TFOOT) {
            return true;
          }
          if (tn === $$3.TABLE || tn === $$3.HTML) {
            return false;
          }
        }
        return true;
      }
      hasInSelectScope(tagName) {
        for (let i2 = this.stackTop; i2 >= 0; i2--) {
          const tn = this.treeAdapter.getTagName(this.items[i2]);
          const ns2 = this.treeAdapter.getNamespaceURI(this.items[i2]);
          if (ns2 !== NS$2.HTML) {
            continue;
          }
          if (tn === tagName) {
            return true;
          }
          if (tn !== $$3.OPTION && tn !== $$3.OPTGROUP) {
            return false;
          }
        }
        return true;
      }
      //Implied end tags
      generateImpliedEndTags() {
        while (isImpliedEndTagRequired(this.currentTagName)) {
          this.pop();
        }
      }
      generateImpliedEndTagsThoroughly() {
        while (isImpliedEndTagRequiredThoroughly(this.currentTagName)) {
          this.pop();
        }
      }
      generateImpliedEndTagsWithExclusion(exclusionTagName) {
        while (isImpliedEndTagRequired(this.currentTagName) && this.currentTagName !== exclusionTagName) {
          this.pop();
        }
      }
    };
    var openElementStack = OpenElementStack$1;
    const NOAH_ARK_CAPACITY = 3;
    let FormattingElementList$1 = class FormattingElementList2 {
      constructor(treeAdapter) {
        this.length = 0;
        this.entries = [];
        this.treeAdapter = treeAdapter;
        this.bookmark = null;
      }
      //Noah Ark's condition
      //OPTIMIZATION: at first we try to find possible candidates for exclusion using
      //lightweight heuristics without thorough attributes check.
      _getNoahArkConditionCandidates(newElement) {
        const candidates = [];
        if (this.length >= NOAH_ARK_CAPACITY) {
          const neAttrsLength = this.treeAdapter.getAttrList(newElement).length;
          const neTagName = this.treeAdapter.getTagName(newElement);
          const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);
          for (let i2 = this.length - 1; i2 >= 0; i2--) {
            const entry = this.entries[i2];
            if (entry.type === FormattingElementList2.MARKER_ENTRY) {
              break;
            }
            const element2 = entry.element;
            const elementAttrs = this.treeAdapter.getAttrList(element2);
            const isCandidate = this.treeAdapter.getTagName(element2) === neTagName && this.treeAdapter.getNamespaceURI(element2) === neNamespaceURI && elementAttrs.length === neAttrsLength;
            if (isCandidate) {
              candidates.push({ idx: i2, attrs: elementAttrs });
            }
          }
        }
        return candidates.length < NOAH_ARK_CAPACITY ? [] : candidates;
      }
      _ensureNoahArkCondition(newElement) {
        const candidates = this._getNoahArkConditionCandidates(newElement);
        let cLength = candidates.length;
        if (cLength) {
          const neAttrs = this.treeAdapter.getAttrList(newElement);
          const neAttrsLength = neAttrs.length;
          const neAttrsMap = /* @__PURE__ */ Object.create(null);
          for (let i2 = 0; i2 < neAttrsLength; i2++) {
            const neAttr = neAttrs[i2];
            neAttrsMap[neAttr.name] = neAttr.value;
          }
          for (let i2 = 0; i2 < neAttrsLength; i2++) {
            for (let j = 0; j < cLength; j++) {
              const cAttr = candidates[j].attrs[i2];
              if (neAttrsMap[cAttr.name] !== cAttr.value) {
                candidates.splice(j, 1);
                cLength--;
              }
              if (candidates.length < NOAH_ARK_CAPACITY) {
                return;
              }
            }
          }
          for (let i2 = cLength - 1; i2 >= NOAH_ARK_CAPACITY - 1; i2--) {
            this.entries.splice(candidates[i2].idx, 1);
            this.length--;
          }
        }
      }
      //Mutations
      insertMarker() {
        this.entries.push({ type: FormattingElementList2.MARKER_ENTRY });
        this.length++;
      }
      pushElement(element2, token2) {
        this._ensureNoahArkCondition(element2);
        this.entries.push({
          type: FormattingElementList2.ELEMENT_ENTRY,
          element: element2,
          token: token2
        });
        this.length++;
      }
      insertElementAfterBookmark(element2, token2) {
        let bookmarkIdx = this.length - 1;
        for (; bookmarkIdx >= 0; bookmarkIdx--) {
          if (this.entries[bookmarkIdx] === this.bookmark) {
            break;
          }
        }
        this.entries.splice(bookmarkIdx + 1, 0, {
          type: FormattingElementList2.ELEMENT_ENTRY,
          element: element2,
          token: token2
        });
        this.length++;
      }
      removeEntry(entry) {
        for (let i2 = this.length - 1; i2 >= 0; i2--) {
          if (this.entries[i2] === entry) {
            this.entries.splice(i2, 1);
            this.length--;
            break;
          }
        }
      }
      clearToLastMarker() {
        while (this.length) {
          const entry = this.entries.pop();
          this.length--;
          if (entry.type === FormattingElementList2.MARKER_ENTRY) {
            break;
          }
        }
      }
      //Search
      getElementEntryInScopeWithTagName(tagName) {
        for (let i2 = this.length - 1; i2 >= 0; i2--) {
          const entry = this.entries[i2];
          if (entry.type === FormattingElementList2.MARKER_ENTRY) {
            return null;
          }
          if (this.treeAdapter.getTagName(entry.element) === tagName) {
            return entry;
          }
        }
        return null;
      }
      getElementEntry(element2) {
        for (let i2 = this.length - 1; i2 >= 0; i2--) {
          const entry = this.entries[i2];
          if (entry.type === FormattingElementList2.ELEMENT_ENTRY && entry.element === element2) {
            return entry;
          }
        }
        return null;
      }
    };
    FormattingElementList$1.MARKER_ENTRY = "MARKER_ENTRY";
    FormattingElementList$1.ELEMENT_ENTRY = "ELEMENT_ENTRY";
    var formattingElementList = FormattingElementList$1;
    let Mixin$9 = class Mixin {
      constructor(host) {
        const originalMethods = {};
        const overriddenMethods = this._getOverriddenMethods(this, originalMethods);
        for (const key of Object.keys(overriddenMethods)) {
          if (typeof overriddenMethods[key] === "function") {
            originalMethods[key] = host[key];
            host[key] = overriddenMethods[key];
          }
        }
      }
      _getOverriddenMethods() {
        throw new Error("Not implemented");
      }
    };
    Mixin$9.install = function(host, Ctor, opts) {
      if (!host.__mixins) {
        host.__mixins = [];
      }
      for (let i2 = 0; i2 < host.__mixins.length; i2++) {
        if (host.__mixins[i2].constructor === Ctor) {
          return host.__mixins[i2];
        }
      }
      const mixin2 = new Ctor(host, opts);
      host.__mixins.push(mixin2);
      return mixin2;
    };
    var mixin = Mixin$9;
    const Mixin$8 = mixin;
    let PositionTrackingPreprocessorMixin$2 = class PositionTrackingPreprocessorMixin extends Mixin$8 {
      constructor(preprocessor2) {
        super(preprocessor2);
        this.preprocessor = preprocessor2;
        this.isEol = false;
        this.lineStartPos = 0;
        this.droppedBufferSize = 0;
        this.offset = 0;
        this.col = 0;
        this.line = 1;
      }
      _getOverriddenMethods(mxn, orig) {
        return {
          advance() {
            const pos = this.pos + 1;
            const ch2 = this.html[pos];
            if (mxn.isEol) {
              mxn.isEol = false;
              mxn.line++;
              mxn.lineStartPos = pos;
            }
            if (ch2 === "\n" || ch2 === "\r" && this.html[pos + 1] !== "\n") {
              mxn.isEol = true;
            }
            mxn.col = pos - mxn.lineStartPos + 1;
            mxn.offset = mxn.droppedBufferSize + pos;
            return orig.advance.call(this);
          },
          retreat() {
            orig.retreat.call(this);
            mxn.isEol = false;
            mxn.col = this.pos - mxn.lineStartPos + 1;
          },
          dropParsedChunk() {
            const prevPos = this.pos;
            orig.dropParsedChunk.call(this);
            const reduction = prevPos - this.pos;
            mxn.lineStartPos -= reduction;
            mxn.droppedBufferSize += reduction;
            mxn.offset = mxn.droppedBufferSize + this.pos;
          }
        };
      }
    };
    var preprocessorMixin$1 = PositionTrackingPreprocessorMixin$2;
    const Mixin$7 = mixin;
    const Tokenizer$3 = tokenizer;
    const PositionTrackingPreprocessorMixin$1 = preprocessorMixin$1;
    let LocationInfoTokenizerMixin$2 = class LocationInfoTokenizerMixin extends Mixin$7 {
      constructor(tokenizer2) {
        super(tokenizer2);
        this.tokenizer = tokenizer2;
        this.posTracker = Mixin$7.install(tokenizer2.preprocessor, PositionTrackingPreprocessorMixin$1);
        this.currentAttrLocation = null;
        this.ctLoc = null;
      }
      _getCurrentLocation() {
        return {
          startLine: this.posTracker.line,
          startCol: this.posTracker.col,
          startOffset: this.posTracker.offset,
          endLine: -1,
          endCol: -1,
          endOffset: -1
        };
      }
      _attachCurrentAttrLocationInfo() {
        this.currentAttrLocation.endLine = this.posTracker.line;
        this.currentAttrLocation.endCol = this.posTracker.col;
        this.currentAttrLocation.endOffset = this.posTracker.offset;
        const currentToken = this.tokenizer.currentToken;
        const currentAttr = this.tokenizer.currentAttr;
        if (!currentToken.location.attrs) {
          currentToken.location.attrs = /* @__PURE__ */ Object.create(null);
        }
        currentToken.location.attrs[currentAttr.name] = this.currentAttrLocation;
      }
      _getOverriddenMethods(mxn, orig) {
        const methods = {
          _createStartTagToken() {
            orig._createStartTagToken.call(this);
            this.currentToken.location = mxn.ctLoc;
          },
          _createEndTagToken() {
            orig._createEndTagToken.call(this);
            this.currentToken.location = mxn.ctLoc;
          },
          _createCommentToken() {
            orig._createCommentToken.call(this);
            this.currentToken.location = mxn.ctLoc;
          },
          _createDoctypeToken(initialName) {
            orig._createDoctypeToken.call(this, initialName);
            this.currentToken.location = mxn.ctLoc;
          },
          _createCharacterToken(type, ch2) {
            orig._createCharacterToken.call(this, type, ch2);
            this.currentCharacterToken.location = mxn.ctLoc;
          },
          _createEOFToken() {
            orig._createEOFToken.call(this);
            this.currentToken.location = mxn._getCurrentLocation();
          },
          _createAttr(attrNameFirstCh) {
            orig._createAttr.call(this, attrNameFirstCh);
            mxn.currentAttrLocation = mxn._getCurrentLocation();
          },
          _leaveAttrName(toState) {
            orig._leaveAttrName.call(this, toState);
            mxn._attachCurrentAttrLocationInfo();
          },
          _leaveAttrValue(toState) {
            orig._leaveAttrValue.call(this, toState);
            mxn._attachCurrentAttrLocationInfo();
          },
          _emitCurrentToken() {
            const ctLoc = this.currentToken.location;
            if (this.currentCharacterToken) {
              this.currentCharacterToken.location.endLine = ctLoc.startLine;
              this.currentCharacterToken.location.endCol = ctLoc.startCol;
              this.currentCharacterToken.location.endOffset = ctLoc.startOffset;
            }
            if (this.currentToken.type === Tokenizer$3.EOF_TOKEN) {
              ctLoc.endLine = ctLoc.startLine;
              ctLoc.endCol = ctLoc.startCol;
              ctLoc.endOffset = ctLoc.startOffset;
            } else {
              ctLoc.endLine = mxn.posTracker.line;
              ctLoc.endCol = mxn.posTracker.col + 1;
              ctLoc.endOffset = mxn.posTracker.offset + 1;
            }
            orig._emitCurrentToken.call(this);
          },
          _emitCurrentCharacterToken() {
            const ctLoc = this.currentCharacterToken && this.currentCharacterToken.location;
            if (ctLoc && ctLoc.endOffset === -1) {
              ctLoc.endLine = mxn.posTracker.line;
              ctLoc.endCol = mxn.posTracker.col;
              ctLoc.endOffset = mxn.posTracker.offset;
            }
            orig._emitCurrentCharacterToken.call(this);
          }
        };
        Object.keys(Tokenizer$3.MODE).forEach((modeName) => {
          const state = Tokenizer$3.MODE[modeName];
          methods[state] = function(cp) {
            mxn.ctLoc = mxn._getCurrentLocation();
            orig[state].call(this, cp);
          };
        });
        return methods;
      }
    };
    var tokenizerMixin$1 = LocationInfoTokenizerMixin$2;
    const Mixin$6 = mixin;
    let LocationInfoOpenElementStackMixin$1 = class LocationInfoOpenElementStackMixin extends Mixin$6 {
      constructor(stack, opts) {
        super(stack);
        this.onItemPop = opts.onItemPop;
      }
      _getOverriddenMethods(mxn, orig) {
        return {
          pop() {
            mxn.onItemPop(this.current);
            orig.pop.call(this);
          },
          popAllUpToHtmlElement() {
            for (let i2 = this.stackTop; i2 > 0; i2--) {
              mxn.onItemPop(this.items[i2]);
            }
            orig.popAllUpToHtmlElement.call(this);
          },
          remove(element2) {
            mxn.onItemPop(this.current);
            orig.remove.call(this, element2);
          }
        };
      }
    };
    var openElementStackMixin = LocationInfoOpenElementStackMixin$1;
    const Mixin$5 = mixin;
    const Tokenizer$2 = tokenizer;
    const LocationInfoTokenizerMixin$1 = tokenizerMixin$1;
    const LocationInfoOpenElementStackMixin = openElementStackMixin;
    const HTML$2 = html;
    const $$2 = HTML$2.TAG_NAMES;
    let LocationInfoParserMixin$1 = class LocationInfoParserMixin extends Mixin$5 {
      constructor(parser2) {
        super(parser2);
        this.parser = parser2;
        this.treeAdapter = this.parser.treeAdapter;
        this.posTracker = null;
        this.lastStartTagToken = null;
        this.lastFosterParentingLocation = null;
        this.currentToken = null;
      }
      _setStartLocation(element2) {
        let loc = null;
        if (this.lastStartTagToken) {
          loc = Object.assign({}, this.lastStartTagToken.location);
          loc.startTag = this.lastStartTagToken.location;
        }
        this.treeAdapter.setNodeSourceCodeLocation(element2, loc);
      }
      _setEndLocation(element2, closingToken) {
        const loc = this.treeAdapter.getNodeSourceCodeLocation(element2);
        if (loc) {
          if (closingToken.location) {
            const ctLoc = closingToken.location;
            const tn = this.treeAdapter.getTagName(element2);
            const isClosingEndTag = closingToken.type === Tokenizer$2.END_TAG_TOKEN && tn === closingToken.tagName;
            const endLoc = {};
            if (isClosingEndTag) {
              endLoc.endTag = Object.assign({}, ctLoc);
              endLoc.endLine = ctLoc.endLine;
              endLoc.endCol = ctLoc.endCol;
              endLoc.endOffset = ctLoc.endOffset;
            } else {
              endLoc.endLine = ctLoc.startLine;
              endLoc.endCol = ctLoc.startCol;
              endLoc.endOffset = ctLoc.startOffset;
            }
            this.treeAdapter.updateNodeSourceCodeLocation(element2, endLoc);
          }
        }
      }
      _getOverriddenMethods(mxn, orig) {
        return {
          _bootstrap(document2, fragmentContext) {
            orig._bootstrap.call(this, document2, fragmentContext);
            mxn.lastStartTagToken = null;
            mxn.lastFosterParentingLocation = null;
            mxn.currentToken = null;
            const tokenizerMixin2 = Mixin$5.install(this.tokenizer, LocationInfoTokenizerMixin$1);
            mxn.posTracker = tokenizerMixin2.posTracker;
            Mixin$5.install(this.openElements, LocationInfoOpenElementStackMixin, {
              onItemPop: function(element2) {
                mxn._setEndLocation(element2, mxn.currentToken);
              }
            });
          },
          _runParsingLoop(scriptHandler) {
            orig._runParsingLoop.call(this, scriptHandler);
            for (let i2 = this.openElements.stackTop; i2 >= 0; i2--) {
              mxn._setEndLocation(this.openElements.items[i2], mxn.currentToken);
            }
          },
          //Token processing
          _processTokenInForeignContent(token2) {
            mxn.currentToken = token2;
            orig._processTokenInForeignContent.call(this, token2);
          },
          _processToken(token2) {
            mxn.currentToken = token2;
            orig._processToken.call(this, token2);
            const requireExplicitUpdate = token2.type === Tokenizer$2.END_TAG_TOKEN && (token2.tagName === $$2.HTML || token2.tagName === $$2.BODY && this.openElements.hasInScope($$2.BODY));
            if (requireExplicitUpdate) {
              for (let i2 = this.openElements.stackTop; i2 >= 0; i2--) {
                const element2 = this.openElements.items[i2];
                if (this.treeAdapter.getTagName(element2) === token2.tagName) {
                  mxn._setEndLocation(element2, token2);
                  break;
                }
              }
            }
          },
          //Doctype
          _setDocumentType(token2) {
            orig._setDocumentType.call(this, token2);
            const documentChildren = this.treeAdapter.getChildNodes(this.document);
            const cnLength = documentChildren.length;
            for (let i2 = 0; i2 < cnLength; i2++) {
              const node2 = documentChildren[i2];
              if (this.treeAdapter.isDocumentTypeNode(node2)) {
                this.treeAdapter.setNodeSourceCodeLocation(node2, token2.location);
                break;
              }
            }
          },
          //Elements
          _attachElementToTree(element2) {
            mxn._setStartLocation(element2);
            mxn.lastStartTagToken = null;
            orig._attachElementToTree.call(this, element2);
          },
          _appendElement(token2, namespaceURI) {
            mxn.lastStartTagToken = token2;
            orig._appendElement.call(this, token2, namespaceURI);
          },
          _insertElement(token2, namespaceURI) {
            mxn.lastStartTagToken = token2;
            orig._insertElement.call(this, token2, namespaceURI);
          },
          _insertTemplate(token2) {
            mxn.lastStartTagToken = token2;
            orig._insertTemplate.call(this, token2);
            const tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);
            this.treeAdapter.setNodeSourceCodeLocation(tmplContent, null);
          },
          _insertFakeRootElement() {
            orig._insertFakeRootElement.call(this);
            this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current, null);
          },
          //Comments
          _appendCommentNode(token2, parent) {
            orig._appendCommentNode.call(this, token2, parent);
            const children = this.treeAdapter.getChildNodes(parent);
            const commentNode = children[children.length - 1];
            this.treeAdapter.setNodeSourceCodeLocation(commentNode, token2.location);
          },
          //Text
          _findFosterParentingLocation() {
            mxn.lastFosterParentingLocation = orig._findFosterParentingLocation.call(this);
            return mxn.lastFosterParentingLocation;
          },
          _insertCharacters(token2) {
            orig._insertCharacters.call(this, token2);
            const hasFosterParent = this._shouldFosterParentOnInsertion();
            const parent = hasFosterParent && mxn.lastFosterParentingLocation.parent || this.openElements.currentTmplContent || this.openElements.current;
            const siblings = this.treeAdapter.getChildNodes(parent);
            const textNodeIdx = hasFosterParent && mxn.lastFosterParentingLocation.beforeElement ? siblings.indexOf(mxn.lastFosterParentingLocation.beforeElement) - 1 : siblings.length - 1;
            const textNode = siblings[textNodeIdx];
            const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);
            if (tnLoc) {
              const { endLine, endCol, endOffset } = token2.location;
              this.treeAdapter.updateNodeSourceCodeLocation(textNode, { endLine, endCol, endOffset });
            } else {
              this.treeAdapter.setNodeSourceCodeLocation(textNode, token2.location);
            }
          }
        };
      }
    };
    var parserMixin$1 = LocationInfoParserMixin$1;
    const Mixin$4 = mixin;
    let ErrorReportingMixinBase$3 = class ErrorReportingMixinBase extends Mixin$4 {
      constructor(host, opts) {
        super(host);
        this.posTracker = null;
        this.onParseError = opts.onParseError;
      }
      _setErrorLocation(err) {
        err.startLine = err.endLine = this.posTracker.line;
        err.startCol = err.endCol = this.posTracker.col;
        err.startOffset = err.endOffset = this.posTracker.offset;
      }
      _reportError(code2) {
        const err = {
          code: code2,
          startLine: -1,
          startCol: -1,
          startOffset: -1,
          endLine: -1,
          endCol: -1,
          endOffset: -1
        };
        this._setErrorLocation(err);
        this.onParseError(err);
      }
      _getOverriddenMethods(mxn) {
        return {
          _err(code2) {
            mxn._reportError(code2);
          }
        };
      }
    };
    var mixinBase = ErrorReportingMixinBase$3;
    const ErrorReportingMixinBase$2 = mixinBase;
    const PositionTrackingPreprocessorMixin = preprocessorMixin$1;
    const Mixin$3 = mixin;
    let ErrorReportingPreprocessorMixin$1 = class ErrorReportingPreprocessorMixin extends ErrorReportingMixinBase$2 {
      constructor(preprocessor2, opts) {
        super(preprocessor2, opts);
        this.posTracker = Mixin$3.install(preprocessor2, PositionTrackingPreprocessorMixin);
        this.lastErrOffset = -1;
      }
      _reportError(code2) {
        if (this.lastErrOffset !== this.posTracker.offset) {
          this.lastErrOffset = this.posTracker.offset;
          super._reportError(code2);
        }
      }
    };
    var preprocessorMixin = ErrorReportingPreprocessorMixin$1;
    const ErrorReportingMixinBase$1 = mixinBase;
    const ErrorReportingPreprocessorMixin = preprocessorMixin;
    const Mixin$2 = mixin;
    let ErrorReportingTokenizerMixin$1 = class ErrorReportingTokenizerMixin extends ErrorReportingMixinBase$1 {
      constructor(tokenizer2, opts) {
        super(tokenizer2, opts);
        const preprocessorMixin2 = Mixin$2.install(tokenizer2.preprocessor, ErrorReportingPreprocessorMixin, opts);
        this.posTracker = preprocessorMixin2.posTracker;
      }
    };
    var tokenizerMixin = ErrorReportingTokenizerMixin$1;
    const ErrorReportingMixinBase = mixinBase;
    const ErrorReportingTokenizerMixin = tokenizerMixin;
    const LocationInfoTokenizerMixin = tokenizerMixin$1;
    const Mixin$1 = mixin;
    let ErrorReportingParserMixin$1 = class ErrorReportingParserMixin extends ErrorReportingMixinBase {
      constructor(parser2, opts) {
        super(parser2, opts);
        this.opts = opts;
        this.ctLoc = null;
        this.locBeforeToken = false;
      }
      _setErrorLocation(err) {
        if (this.ctLoc) {
          err.startLine = this.ctLoc.startLine;
          err.startCol = this.ctLoc.startCol;
          err.startOffset = this.ctLoc.startOffset;
          err.endLine = this.locBeforeToken ? this.ctLoc.startLine : this.ctLoc.endLine;
          err.endCol = this.locBeforeToken ? this.ctLoc.startCol : this.ctLoc.endCol;
          err.endOffset = this.locBeforeToken ? this.ctLoc.startOffset : this.ctLoc.endOffset;
        }
      }
      _getOverriddenMethods(mxn, orig) {
        return {
          _bootstrap(document2, fragmentContext) {
            orig._bootstrap.call(this, document2, fragmentContext);
            Mixin$1.install(this.tokenizer, ErrorReportingTokenizerMixin, mxn.opts);
            Mixin$1.install(this.tokenizer, LocationInfoTokenizerMixin);
          },
          _processInputToken(token2) {
            mxn.ctLoc = token2.location;
            orig._processInputToken.call(this, token2);
          },
          _err(code2, options) {
            mxn.locBeforeToken = options && options.beforeToken;
            mxn._reportError(code2);
          }
        };
      }
    };
    var parserMixin = ErrorReportingParserMixin$1;
    var _default = {};
    const { DOCUMENT_MODE: DOCUMENT_MODE$1 } = html;
    _default.createDocument = function() {
      return {
        nodeName: "#document",
        mode: DOCUMENT_MODE$1.NO_QUIRKS,
        childNodes: []
      };
    };
    _default.createDocumentFragment = function() {
      return {
        nodeName: "#document-fragment",
        childNodes: []
      };
    };
    _default.createElement = function(tagName, namespaceURI, attrs) {
      return {
        nodeName: tagName,
        tagName,
        attrs,
        namespaceURI,
        childNodes: [],
        parentNode: null
      };
    };
    _default.createCommentNode = function(data) {
      return {
        nodeName: "#comment",
        data,
        parentNode: null
      };
    };
    const createTextNode = function(value) {
      return {
        nodeName: "#text",
        value,
        parentNode: null
      };
    };
    const appendChild = _default.appendChild = function(parentNode, newNode) {
      parentNode.childNodes.push(newNode);
      newNode.parentNode = parentNode;
    };
    const insertBefore = _default.insertBefore = function(parentNode, newNode, referenceNode) {
      const insertionIdx = parentNode.childNodes.indexOf(referenceNode);
      parentNode.childNodes.splice(insertionIdx, 0, newNode);
      newNode.parentNode = parentNode;
    };
    _default.setTemplateContent = function(templateElement, contentElement) {
      templateElement.content = contentElement;
    };
    _default.getTemplateContent = function(templateElement) {
      return templateElement.content;
    };
    _default.setDocumentType = function(document2, name2, publicId, systemId) {
      let doctypeNode = null;
      for (let i2 = 0; i2 < document2.childNodes.length; i2++) {
        if (document2.childNodes[i2].nodeName === "#documentType") {
          doctypeNode = document2.childNodes[i2];
          break;
        }
      }
      if (doctypeNode) {
        doctypeNode.name = name2;
        doctypeNode.publicId = publicId;
        doctypeNode.systemId = systemId;
      } else {
        appendChild(document2, {
          nodeName: "#documentType",
          name: name2,
          publicId,
          systemId
        });
      }
    };
    _default.setDocumentMode = function(document2, mode) {
      document2.mode = mode;
    };
    _default.getDocumentMode = function(document2) {
      return document2.mode;
    };
    _default.detachNode = function(node2) {
      if (node2.parentNode) {
        const idx = node2.parentNode.childNodes.indexOf(node2);
        node2.parentNode.childNodes.splice(idx, 1);
        node2.parentNode = null;
      }
    };
    _default.insertText = function(parentNode, text2) {
      if (parentNode.childNodes.length) {
        const prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];
        if (prevNode.nodeName === "#text") {
          prevNode.value += text2;
          return;
        }
      }
      appendChild(parentNode, createTextNode(text2));
    };
    _default.insertTextBefore = function(parentNode, text2, referenceNode) {
      const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];
      if (prevNode && prevNode.nodeName === "#text") {
        prevNode.value += text2;
      } else {
        insertBefore(parentNode, createTextNode(text2), referenceNode);
      }
    };
    _default.adoptAttributes = function(recipient, attrs) {
      const recipientAttrsMap = [];
      for (let i2 = 0; i2 < recipient.attrs.length; i2++) {
        recipientAttrsMap.push(recipient.attrs[i2].name);
      }
      for (let j = 0; j < attrs.length; j++) {
        if (recipientAttrsMap.indexOf(attrs[j].name) === -1) {
          recipient.attrs.push(attrs[j]);
        }
      }
    };
    _default.getFirstChild = function(node2) {
      return node2.childNodes[0];
    };
    _default.getChildNodes = function(node2) {
      return node2.childNodes;
    };
    _default.getParentNode = function(node2) {
      return node2.parentNode;
    };
    _default.getAttrList = function(element2) {
      return element2.attrs;
    };
    _default.getTagName = function(element2) {
      return element2.tagName;
    };
    _default.getNamespaceURI = function(element2) {
      return element2.namespaceURI;
    };
    _default.getTextNodeContent = function(textNode) {
      return textNode.value;
    };
    _default.getCommentNodeContent = function(commentNode) {
      return commentNode.data;
    };
    _default.getDocumentTypeNodeName = function(doctypeNode) {
      return doctypeNode.name;
    };
    _default.getDocumentTypeNodePublicId = function(doctypeNode) {
      return doctypeNode.publicId;
    };
    _default.getDocumentTypeNodeSystemId = function(doctypeNode) {
      return doctypeNode.systemId;
    };
    _default.isTextNode = function(node2) {
      return node2.nodeName === "#text";
    };
    _default.isCommentNode = function(node2) {
      return node2.nodeName === "#comment";
    };
    _default.isDocumentTypeNode = function(node2) {
      return node2.nodeName === "#documentType";
    };
    _default.isElementNode = function(node2) {
      return !!node2.tagName;
    };
    _default.setNodeSourceCodeLocation = function(node2, location2) {
      node2.sourceCodeLocation = location2;
    };
    _default.getNodeSourceCodeLocation = function(node2) {
      return node2.sourceCodeLocation;
    };
    _default.updateNodeSourceCodeLocation = function(node2, endLocation) {
      node2.sourceCodeLocation = Object.assign(node2.sourceCodeLocation, endLocation);
    };
    var mergeOptions$1 = function mergeOptions2(defaults2, options) {
      options = options || /* @__PURE__ */ Object.create(null);
      return [defaults2, options].reduce((merged, optObj) => {
        Object.keys(optObj).forEach((key) => {
          merged[key] = optObj[key];
        });
        return merged;
      }, /* @__PURE__ */ Object.create(null));
    };
    var doctype$3 = {};
    const { DOCUMENT_MODE } = html;
    const VALID_DOCTYPE_NAME = "html";
    const VALID_SYSTEM_ID = "about:legacy-compat";
    const QUIRKS_MODE_SYSTEM_ID = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd";
    const QUIRKS_MODE_PUBLIC_ID_PREFIXES = [
      "+//silmaril//dtd html pro v0r11 19970101//",
      "-//as//dtd html 3.0 aswedit + extensions//",
      "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
      "-//ietf//dtd html 2.0 level 1//",
      "-//ietf//dtd html 2.0 level 2//",
      "-//ietf//dtd html 2.0 strict level 1//",
      "-//ietf//dtd html 2.0 strict level 2//",
      "-//ietf//dtd html 2.0 strict//",
      "-//ietf//dtd html 2.0//",
      "-//ietf//dtd html 2.1e//",
      "-//ietf//dtd html 3.0//",
      "-//ietf//dtd html 3.2 final//",
      "-//ietf//dtd html 3.2//",
      "-//ietf//dtd html 3//",
      "-//ietf//dtd html level 0//",
      "-//ietf//dtd html level 1//",
      "-//ietf//dtd html level 2//",
      "-//ietf//dtd html level 3//",
      "-//ietf//dtd html strict level 0//",
      "-//ietf//dtd html strict level 1//",
      "-//ietf//dtd html strict level 2//",
      "-//ietf//dtd html strict level 3//",
      "-//ietf//dtd html strict//",
      "-//ietf//dtd html//",
      "-//metrius//dtd metrius presentational//",
      "-//microsoft//dtd internet explorer 2.0 html strict//",
      "-//microsoft//dtd internet explorer 2.0 html//",
      "-//microsoft//dtd internet explorer 2.0 tables//",
      "-//microsoft//dtd internet explorer 3.0 html strict//",
      "-//microsoft//dtd internet explorer 3.0 html//",
      "-//microsoft//dtd internet explorer 3.0 tables//",
      "-//netscape comm. corp.//dtd html//",
      "-//netscape comm. corp.//dtd strict html//",
      "-//o'reilly and associates//dtd html 2.0//",
      "-//o'reilly and associates//dtd html extended 1.0//",
      "-//o'reilly and associates//dtd html extended relaxed 1.0//",
      "-//sq//dtd html 2.0 hotmetal + extensions//",
      "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
      "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
      "-//spyglass//dtd html 2.0 extended//",
      "-//sun microsystems corp.//dtd hotjava html//",
      "-//sun microsystems corp.//dtd hotjava strict html//",
      "-//w3c//dtd html 3 1995-03-24//",
      "-//w3c//dtd html 3.2 draft//",
      "-//w3c//dtd html 3.2 final//",
      "-//w3c//dtd html 3.2//",
      "-//w3c//dtd html 3.2s draft//",
      "-//w3c//dtd html 4.0 frameset//",
      "-//w3c//dtd html 4.0 transitional//",
      "-//w3c//dtd html experimental 19960712//",
      "-//w3c//dtd html experimental 970421//",
      "-//w3c//dtd w3 html//",
      "-//w3o//dtd w3 html 3.0//",
      "-//webtechs//dtd mozilla html 2.0//",
      "-//webtechs//dtd mozilla html//"
    ];
    const QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = QUIRKS_MODE_PUBLIC_ID_PREFIXES.concat([
      "-//w3c//dtd html 4.01 frameset//",
      "-//w3c//dtd html 4.01 transitional//"
    ]);
    const QUIRKS_MODE_PUBLIC_IDS = ["-//w3o//dtd w3 html strict 3.0//en//", "-/w3c/dtd html 4.0 transitional/en", "html"];
    const LIMITED_QUIRKS_PUBLIC_ID_PREFIXES = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"];
    const LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES = LIMITED_QUIRKS_PUBLIC_ID_PREFIXES.concat([
      "-//w3c//dtd html 4.01 frameset//",
      "-//w3c//dtd html 4.01 transitional//"
    ]);
    function enquoteDoctypeId(id2) {
      const quote = id2.indexOf('"') !== -1 ? "'" : '"';
      return quote + id2 + quote;
    }
    function hasPrefix(publicId, prefixes) {
      for (let i2 = 0; i2 < prefixes.length; i2++) {
        if (publicId.indexOf(prefixes[i2]) === 0) {
          return true;
        }
      }
      return false;
    }
    doctype$3.isConforming = function(token2) {
      return token2.name === VALID_DOCTYPE_NAME && token2.publicId === null && (token2.systemId === null || token2.systemId === VALID_SYSTEM_ID);
    };
    doctype$3.getDocumentMode = function(token2) {
      if (token2.name !== VALID_DOCTYPE_NAME) {
        return DOCUMENT_MODE.QUIRKS;
      }
      const systemId = token2.systemId;
      if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID) {
        return DOCUMENT_MODE.QUIRKS;
      }
      let publicId = token2.publicId;
      if (publicId !== null) {
        publicId = publicId.toLowerCase();
        if (QUIRKS_MODE_PUBLIC_IDS.indexOf(publicId) > -1) {
          return DOCUMENT_MODE.QUIRKS;
        }
        let prefixes = systemId === null ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES : QUIRKS_MODE_PUBLIC_ID_PREFIXES;
        if (hasPrefix(publicId, prefixes)) {
          return DOCUMENT_MODE.QUIRKS;
        }
        prefixes = systemId === null ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES;
        if (hasPrefix(publicId, prefixes)) {
          return DOCUMENT_MODE.LIMITED_QUIRKS;
        }
      }
      return DOCUMENT_MODE.NO_QUIRKS;
    };
    doctype$3.serializeContent = function(name2, publicId, systemId) {
      let str = "!DOCTYPE ";
      if (name2) {
        str += name2;
      }
      if (publicId) {
        str += " PUBLIC " + enquoteDoctypeId(publicId);
      } else if (systemId) {
        str += " SYSTEM";
      }
      if (systemId !== null) {
        str += " " + enquoteDoctypeId(systemId);
      }
      return str;
    };
    var foreignContent$1 = {};
    const Tokenizer$1 = tokenizer;
    const HTML$1 = html;
    const $$1 = HTML$1.TAG_NAMES;
    const NS$1 = HTML$1.NAMESPACES;
    const ATTRS$1 = HTML$1.ATTRS;
    const MIME_TYPES = {
      TEXT_HTML: "text/html",
      APPLICATION_XML: "application/xhtml+xml"
    };
    const DEFINITION_URL_ATTR = "definitionurl";
    const ADJUSTED_DEFINITION_URL_ATTR = "definitionURL";
    const SVG_ATTRS_ADJUSTMENT_MAP = {
      attributename: "attributeName",
      attributetype: "attributeType",
      basefrequency: "baseFrequency",
      baseprofile: "baseProfile",
      calcmode: "calcMode",
      clippathunits: "clipPathUnits",
      diffuseconstant: "diffuseConstant",
      edgemode: "edgeMode",
      filterunits: "filterUnits",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      limitingconeangle: "limitingConeAngle",
      markerheight: "markerHeight",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      numoctaves: "numOctaves",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      refx: "refX",
      refy: "refY",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stitchtiles: "stitchTiles",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textlength: "textLength",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      xchannelselector: "xChannelSelector",
      ychannelselector: "yChannelSelector",
      zoomandpan: "zoomAndPan"
    };
    const XML_ATTRS_ADJUSTMENT_MAP = {
      "xlink:actuate": { prefix: "xlink", name: "actuate", namespace: NS$1.XLINK },
      "xlink:arcrole": { prefix: "xlink", name: "arcrole", namespace: NS$1.XLINK },
      "xlink:href": { prefix: "xlink", name: "href", namespace: NS$1.XLINK },
      "xlink:role": { prefix: "xlink", name: "role", namespace: NS$1.XLINK },
      "xlink:show": { prefix: "xlink", name: "show", namespace: NS$1.XLINK },
      "xlink:title": { prefix: "xlink", name: "title", namespace: NS$1.XLINK },
      "xlink:type": { prefix: "xlink", name: "type", namespace: NS$1.XLINK },
      "xml:base": { prefix: "xml", name: "base", namespace: NS$1.XML },
      "xml:lang": { prefix: "xml", name: "lang", namespace: NS$1.XML },
      "xml:space": { prefix: "xml", name: "space", namespace: NS$1.XML },
      xmlns: { prefix: "", name: "xmlns", namespace: NS$1.XMLNS },
      "xmlns:xlink": { prefix: "xmlns", name: "xlink", namespace: NS$1.XMLNS }
    };
    const SVG_TAG_NAMES_ADJUSTMENT_MAP = foreignContent$1.SVG_TAG_NAMES_ADJUSTMENT_MAP = {
      altglyph: "altGlyph",
      altglyphdef: "altGlyphDef",
      altglyphitem: "altGlyphItem",
      animatecolor: "animateColor",
      animatemotion: "animateMotion",
      animatetransform: "animateTransform",
      clippath: "clipPath",
      feblend: "feBlend",
      fecolormatrix: "feColorMatrix",
      fecomponenttransfer: "feComponentTransfer",
      fecomposite: "feComposite",
      feconvolvematrix: "feConvolveMatrix",
      fediffuselighting: "feDiffuseLighting",
      fedisplacementmap: "feDisplacementMap",
      fedistantlight: "feDistantLight",
      feflood: "feFlood",
      fefunca: "feFuncA",
      fefuncb: "feFuncB",
      fefuncg: "feFuncG",
      fefuncr: "feFuncR",
      fegaussianblur: "feGaussianBlur",
      feimage: "feImage",
      femerge: "feMerge",
      femergenode: "feMergeNode",
      femorphology: "feMorphology",
      feoffset: "feOffset",
      fepointlight: "fePointLight",
      fespecularlighting: "feSpecularLighting",
      fespotlight: "feSpotLight",
      fetile: "feTile",
      feturbulence: "feTurbulence",
      foreignobject: "foreignObject",
      glyphref: "glyphRef",
      lineargradient: "linearGradient",
      radialgradient: "radialGradient",
      textpath: "textPath"
    };
    const EXITS_FOREIGN_CONTENT = {
      [$$1.B]: true,
      [$$1.BIG]: true,
      [$$1.BLOCKQUOTE]: true,
      [$$1.BODY]: true,
      [$$1.BR]: true,
      [$$1.CENTER]: true,
      [$$1.CODE]: true,
      [$$1.DD]: true,
      [$$1.DIV]: true,
      [$$1.DL]: true,
      [$$1.DT]: true,
      [$$1.EM]: true,
      [$$1.EMBED]: true,
      [$$1.H1]: true,
      [$$1.H2]: true,
      [$$1.H3]: true,
      [$$1.H4]: true,
      [$$1.H5]: true,
      [$$1.H6]: true,
      [$$1.HEAD]: true,
      [$$1.HR]: true,
      [$$1.I]: true,
      [$$1.IMG]: true,
      [$$1.LI]: true,
      [$$1.LISTING]: true,
      [$$1.MENU]: true,
      [$$1.META]: true,
      [$$1.NOBR]: true,
      [$$1.OL]: true,
      [$$1.P]: true,
      [$$1.PRE]: true,
      [$$1.RUBY]: true,
      [$$1.S]: true,
      [$$1.SMALL]: true,
      [$$1.SPAN]: true,
      [$$1.STRONG]: true,
      [$$1.STRIKE]: true,
      [$$1.SUB]: true,
      [$$1.SUP]: true,
      [$$1.TABLE]: true,
      [$$1.TT]: true,
      [$$1.U]: true,
      [$$1.UL]: true,
      [$$1.VAR]: true
    };
    foreignContent$1.causesExit = function(startTagToken2) {
      const tn = startTagToken2.tagName;
      const isFontWithAttrs = tn === $$1.FONT && (Tokenizer$1.getTokenAttr(startTagToken2, ATTRS$1.COLOR) !== null || Tokenizer$1.getTokenAttr(startTagToken2, ATTRS$1.SIZE) !== null || Tokenizer$1.getTokenAttr(startTagToken2, ATTRS$1.FACE) !== null);
      return isFontWithAttrs ? true : EXITS_FOREIGN_CONTENT[tn];
    };
    foreignContent$1.adjustTokenMathMLAttrs = function(token2) {
      for (let i2 = 0; i2 < token2.attrs.length; i2++) {
        if (token2.attrs[i2].name === DEFINITION_URL_ATTR) {
          token2.attrs[i2].name = ADJUSTED_DEFINITION_URL_ATTR;
          break;
        }
      }
    };
    foreignContent$1.adjustTokenSVGAttrs = function(token2) {
      for (let i2 = 0; i2 < token2.attrs.length; i2++) {
        const adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP[token2.attrs[i2].name];
        if (adjustedAttrName) {
          token2.attrs[i2].name = adjustedAttrName;
        }
      }
    };
    foreignContent$1.adjustTokenXMLAttrs = function(token2) {
      for (let i2 = 0; i2 < token2.attrs.length; i2++) {
        const adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP[token2.attrs[i2].name];
        if (adjustedAttrEntry) {
          token2.attrs[i2].prefix = adjustedAttrEntry.prefix;
          token2.attrs[i2].name = adjustedAttrEntry.name;
          token2.attrs[i2].namespace = adjustedAttrEntry.namespace;
        }
      }
    };
    foreignContent$1.adjustTokenSVGTagName = function(token2) {
      const adjustedTagName = SVG_TAG_NAMES_ADJUSTMENT_MAP[token2.tagName];
      if (adjustedTagName) {
        token2.tagName = adjustedTagName;
      }
    };
    function isMathMLTextIntegrationPoint(tn, ns2) {
      return ns2 === NS$1.MATHML && (tn === $$1.MI || tn === $$1.MO || tn === $$1.MN || tn === $$1.MS || tn === $$1.MTEXT);
    }
    function isHtmlIntegrationPoint(tn, ns2, attrs) {
      if (ns2 === NS$1.MATHML && tn === $$1.ANNOTATION_XML) {
        for (let i2 = 0; i2 < attrs.length; i2++) {
          if (attrs[i2].name === ATTRS$1.ENCODING) {
            const value = attrs[i2].value.toLowerCase();
            return value === MIME_TYPES.TEXT_HTML || value === MIME_TYPES.APPLICATION_XML;
          }
        }
      }
      return ns2 === NS$1.SVG && (tn === $$1.FOREIGN_OBJECT || tn === $$1.DESC || tn === $$1.TITLE);
    }
    foreignContent$1.isIntegrationPoint = function(tn, ns2, attrs, foreignNS) {
      if ((!foreignNS || foreignNS === NS$1.HTML) && isHtmlIntegrationPoint(tn, ns2, attrs)) {
        return true;
      }
      if ((!foreignNS || foreignNS === NS$1.MATHML) && isMathMLTextIntegrationPoint(tn, ns2)) {
        return true;
      }
      return false;
    };
    const Tokenizer = tokenizer;
    const OpenElementStack = openElementStack;
    const FormattingElementList = formattingElementList;
    const LocationInfoParserMixin = parserMixin$1;
    const ErrorReportingParserMixin = parserMixin;
    const Mixin = mixin;
    const defaultTreeAdapter = _default;
    const mergeOptions = mergeOptions$1;
    const doctype$2 = doctype$3;
    const foreignContent = foreignContent$1;
    const ERR = errorCodes;
    const unicode = unicode$3;
    const HTML = html;
    const $ = HTML.TAG_NAMES;
    const NS = HTML.NAMESPACES;
    const ATTRS = HTML.ATTRS;
    const DEFAULT_OPTIONS = {
      scriptingEnabled: true,
      sourceCodeLocationInfo: false,
      onParseError: null,
      treeAdapter: defaultTreeAdapter
    };
    const HIDDEN_INPUT_TYPE = "hidden";
    const AA_OUTER_LOOP_ITER = 8;
    const AA_INNER_LOOP_ITER = 3;
    const INITIAL_MODE = "INITIAL_MODE";
    const BEFORE_HTML_MODE = "BEFORE_HTML_MODE";
    const BEFORE_HEAD_MODE = "BEFORE_HEAD_MODE";
    const IN_HEAD_MODE = "IN_HEAD_MODE";
    const IN_HEAD_NO_SCRIPT_MODE = "IN_HEAD_NO_SCRIPT_MODE";
    const AFTER_HEAD_MODE = "AFTER_HEAD_MODE";
    const IN_BODY_MODE = "IN_BODY_MODE";
    const TEXT_MODE = "TEXT_MODE";
    const IN_TABLE_MODE = "IN_TABLE_MODE";
    const IN_TABLE_TEXT_MODE = "IN_TABLE_TEXT_MODE";
    const IN_CAPTION_MODE = "IN_CAPTION_MODE";
    const IN_COLUMN_GROUP_MODE = "IN_COLUMN_GROUP_MODE";
    const IN_TABLE_BODY_MODE = "IN_TABLE_BODY_MODE";
    const IN_ROW_MODE = "IN_ROW_MODE";
    const IN_CELL_MODE = "IN_CELL_MODE";
    const IN_SELECT_MODE = "IN_SELECT_MODE";
    const IN_SELECT_IN_TABLE_MODE = "IN_SELECT_IN_TABLE_MODE";
    const IN_TEMPLATE_MODE = "IN_TEMPLATE_MODE";
    const AFTER_BODY_MODE = "AFTER_BODY_MODE";
    const IN_FRAMESET_MODE = "IN_FRAMESET_MODE";
    const AFTER_FRAMESET_MODE = "AFTER_FRAMESET_MODE";
    const AFTER_AFTER_BODY_MODE = "AFTER_AFTER_BODY_MODE";
    const AFTER_AFTER_FRAMESET_MODE = "AFTER_AFTER_FRAMESET_MODE";
    const INSERTION_MODE_RESET_MAP = {
      [$.TR]: IN_ROW_MODE,
      [$.TBODY]: IN_TABLE_BODY_MODE,
      [$.THEAD]: IN_TABLE_BODY_MODE,
      [$.TFOOT]: IN_TABLE_BODY_MODE,
      [$.CAPTION]: IN_CAPTION_MODE,
      [$.COLGROUP]: IN_COLUMN_GROUP_MODE,
      [$.TABLE]: IN_TABLE_MODE,
      [$.BODY]: IN_BODY_MODE,
      [$.FRAMESET]: IN_FRAMESET_MODE
    };
    const TEMPLATE_INSERTION_MODE_SWITCH_MAP = {
      [$.CAPTION]: IN_TABLE_MODE,
      [$.COLGROUP]: IN_TABLE_MODE,
      [$.TBODY]: IN_TABLE_MODE,
      [$.TFOOT]: IN_TABLE_MODE,
      [$.THEAD]: IN_TABLE_MODE,
      [$.COL]: IN_COLUMN_GROUP_MODE,
      [$.TR]: IN_TABLE_BODY_MODE,
      [$.TD]: IN_ROW_MODE,
      [$.TH]: IN_ROW_MODE
    };
    const TOKEN_HANDLERS = {
      [INITIAL_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenInInitialMode,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInInitialMode,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: doctypeInInitialMode,
        [Tokenizer.START_TAG_TOKEN]: tokenInInitialMode,
        [Tokenizer.END_TAG_TOKEN]: tokenInInitialMode,
        [Tokenizer.EOF_TOKEN]: tokenInInitialMode
      },
      [BEFORE_HTML_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenBeforeHtml,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenBeforeHtml,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagBeforeHtml,
        [Tokenizer.END_TAG_TOKEN]: endTagBeforeHtml,
        [Tokenizer.EOF_TOKEN]: tokenBeforeHtml
      },
      [BEFORE_HEAD_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenBeforeHead,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenBeforeHead,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
        [Tokenizer.START_TAG_TOKEN]: startTagBeforeHead,
        [Tokenizer.END_TAG_TOKEN]: endTagBeforeHead,
        [Tokenizer.EOF_TOKEN]: tokenBeforeHead
      },
      [IN_HEAD_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenInHead,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInHead,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
        [Tokenizer.START_TAG_TOKEN]: startTagInHead,
        [Tokenizer.END_TAG_TOKEN]: endTagInHead,
        [Tokenizer.EOF_TOKEN]: tokenInHead
      },
      [IN_HEAD_NO_SCRIPT_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenInHeadNoScript,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInHeadNoScript,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
        [Tokenizer.START_TAG_TOKEN]: startTagInHeadNoScript,
        [Tokenizer.END_TAG_TOKEN]: endTagInHeadNoScript,
        [Tokenizer.EOF_TOKEN]: tokenInHeadNoScript
      },
      [AFTER_HEAD_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenAfterHead,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterHead,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
        [Tokenizer.START_TAG_TOKEN]: startTagAfterHead,
        [Tokenizer.END_TAG_TOKEN]: endTagAfterHead,
        [Tokenizer.EOF_TOKEN]: tokenAfterHead
      },
      [IN_BODY_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: characterInBody,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInBody,
        [Tokenizer.END_TAG_TOKEN]: endTagInBody,
        [Tokenizer.EOF_TOKEN]: eofInBody
      },
      [TEXT_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.NULL_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: ignoreToken,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: ignoreToken,
        [Tokenizer.END_TAG_TOKEN]: endTagInText,
        [Tokenizer.EOF_TOKEN]: eofInText
      },
      [IN_TABLE_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInTable,
        [Tokenizer.END_TAG_TOKEN]: endTagInTable,
        [Tokenizer.EOF_TOKEN]: eofInBody
      },
      [IN_TABLE_TEXT_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: characterInTableText,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInTableText,
        [Tokenizer.COMMENT_TOKEN]: tokenInTableText,
        [Tokenizer.DOCTYPE_TOKEN]: tokenInTableText,
        [Tokenizer.START_TAG_TOKEN]: tokenInTableText,
        [Tokenizer.END_TAG_TOKEN]: tokenInTableText,
        [Tokenizer.EOF_TOKEN]: tokenInTableText
      },
      [IN_CAPTION_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: characterInBody,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInCaption,
        [Tokenizer.END_TAG_TOKEN]: endTagInCaption,
        [Tokenizer.EOF_TOKEN]: eofInBody
      },
      [IN_COLUMN_GROUP_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenInColumnGroup,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInColumnGroup,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInColumnGroup,
        [Tokenizer.END_TAG_TOKEN]: endTagInColumnGroup,
        [Tokenizer.EOF_TOKEN]: eofInBody
      },
      [IN_TABLE_BODY_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInTableBody,
        [Tokenizer.END_TAG_TOKEN]: endTagInTableBody,
        [Tokenizer.EOF_TOKEN]: eofInBody
      },
      [IN_ROW_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInRow,
        [Tokenizer.END_TAG_TOKEN]: endTagInRow,
        [Tokenizer.EOF_TOKEN]: eofInBody
      },
      [IN_CELL_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: characterInBody,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInCell,
        [Tokenizer.END_TAG_TOKEN]: endTagInCell,
        [Tokenizer.EOF_TOKEN]: eofInBody
      },
      [IN_SELECT_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInSelect,
        [Tokenizer.END_TAG_TOKEN]: endTagInSelect,
        [Tokenizer.EOF_TOKEN]: eofInBody
      },
      [IN_SELECT_IN_TABLE_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInSelectInTable,
        [Tokenizer.END_TAG_TOKEN]: endTagInSelectInTable,
        [Tokenizer.EOF_TOKEN]: eofInBody
      },
      [IN_TEMPLATE_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: characterInBody,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInTemplate,
        [Tokenizer.END_TAG_TOKEN]: endTagInTemplate,
        [Tokenizer.EOF_TOKEN]: eofInTemplate
      },
      [AFTER_BODY_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenAfterBody,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterBody,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
        [Tokenizer.COMMENT_TOKEN]: appendCommentToRootHtmlElement,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagAfterBody,
        [Tokenizer.END_TAG_TOKEN]: endTagAfterBody,
        [Tokenizer.EOF_TOKEN]: stopParsing
      },
      [IN_FRAMESET_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagInFrameset,
        [Tokenizer.END_TAG_TOKEN]: endTagInFrameset,
        [Tokenizer.EOF_TOKEN]: stopParsing
      },
      [AFTER_FRAMESET_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
        [Tokenizer.COMMENT_TOKEN]: appendComment,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagAfterFrameset,
        [Tokenizer.END_TAG_TOKEN]: endTagAfterFrameset,
        [Tokenizer.EOF_TOKEN]: stopParsing
      },
      [AFTER_AFTER_BODY_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: tokenAfterAfterBody,
        [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterAfterBody,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
        [Tokenizer.COMMENT_TOKEN]: appendCommentToDocument,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagAfterAfterBody,
        [Tokenizer.END_TAG_TOKEN]: tokenAfterAfterBody,
        [Tokenizer.EOF_TOKEN]: stopParsing
      },
      [AFTER_AFTER_FRAMESET_MODE]: {
        [Tokenizer.CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
        [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
        [Tokenizer.COMMENT_TOKEN]: appendCommentToDocument,
        [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
        [Tokenizer.START_TAG_TOKEN]: startTagAfterAfterFrameset,
        [Tokenizer.END_TAG_TOKEN]: ignoreToken,
        [Tokenizer.EOF_TOKEN]: stopParsing
      }
    };
    class Parser {
      constructor(options) {
        this.options = mergeOptions(DEFAULT_OPTIONS, options);
        this.treeAdapter = this.options.treeAdapter;
        this.pendingScript = null;
        if (this.options.sourceCodeLocationInfo) {
          Mixin.install(this, LocationInfoParserMixin);
        }
        if (this.options.onParseError) {
          Mixin.install(this, ErrorReportingParserMixin, { onParseError: this.options.onParseError });
        }
      }
      // API
      parse(html2) {
        const document2 = this.treeAdapter.createDocument();
        this._bootstrap(document2, null);
        this.tokenizer.write(html2, true);
        this._runParsingLoop(null);
        return document2;
      }
      parseFragment(html2, fragmentContext) {
        if (!fragmentContext) {
          fragmentContext = this.treeAdapter.createElement($.TEMPLATE, NS.HTML, []);
        }
        const documentMock = this.treeAdapter.createElement("documentmock", NS.HTML, []);
        this._bootstrap(documentMock, fragmentContext);
        if (this.treeAdapter.getTagName(fragmentContext) === $.TEMPLATE) {
          this._pushTmplInsertionMode(IN_TEMPLATE_MODE);
        }
        this._initTokenizerForFragmentParsing();
        this._insertFakeRootElement();
        this._resetInsertionMode();
        this._findFormInFragmentContext();
        this.tokenizer.write(html2, true);
        this._runParsingLoop(null);
        const rootElement = this.treeAdapter.getFirstChild(documentMock);
        const fragment2 = this.treeAdapter.createDocumentFragment();
        this._adoptNodes(rootElement, fragment2);
        return fragment2;
      }
      //Bootstrap parser
      _bootstrap(document2, fragmentContext) {
        this.tokenizer = new Tokenizer(this.options);
        this.stopped = false;
        this.insertionMode = INITIAL_MODE;
        this.originalInsertionMode = "";
        this.document = document2;
        this.fragmentContext = fragmentContext;
        this.headElement = null;
        this.formElement = null;
        this.openElements = new OpenElementStack(this.document, this.treeAdapter);
        this.activeFormattingElements = new FormattingElementList(this.treeAdapter);
        this.tmplInsertionModeStack = [];
        this.tmplInsertionModeStackTop = -1;
        this.currentTmplInsertionMode = null;
        this.pendingCharacterTokens = [];
        this.hasNonWhitespacePendingCharacterToken = false;
        this.framesetOk = true;
        this.skipNextNewLine = false;
        this.fosterParentingEnabled = false;
      }
      //Errors
      _err() {
      }
      //Parsing loop
      _runParsingLoop(scriptHandler) {
        while (!this.stopped) {
          this._setupTokenizerCDATAMode();
          const token2 = this.tokenizer.getNextToken();
          if (token2.type === Tokenizer.HIBERNATION_TOKEN) {
            break;
          }
          if (this.skipNextNewLine) {
            this.skipNextNewLine = false;
            if (token2.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN && token2.chars[0] === "\n") {
              if (token2.chars.length === 1) {
                continue;
              }
              token2.chars = token2.chars.substr(1);
            }
          }
          this._processInputToken(token2);
          if (scriptHandler && this.pendingScript) {
            break;
          }
        }
      }
      runParsingLoopForCurrentChunk(writeCallback, scriptHandler) {
        this._runParsingLoop(scriptHandler);
        if (scriptHandler && this.pendingScript) {
          const script = this.pendingScript;
          this.pendingScript = null;
          scriptHandler(script);
          return;
        }
        if (writeCallback) {
          writeCallback();
        }
      }
      //Text parsing
      _setupTokenizerCDATAMode() {
        const current = this._getAdjustedCurrentElement();
        this.tokenizer.allowCDATA = current && current !== this.document && this.treeAdapter.getNamespaceURI(current) !== NS.HTML && !this._isIntegrationPoint(current);
      }
      _switchToTextParsing(currentToken, nextTokenizerState) {
        this._insertElement(currentToken, NS.HTML);
        this.tokenizer.state = nextTokenizerState;
        this.originalInsertionMode = this.insertionMode;
        this.insertionMode = TEXT_MODE;
      }
      switchToPlaintextParsing() {
        this.insertionMode = TEXT_MODE;
        this.originalInsertionMode = IN_BODY_MODE;
        this.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
      }
      //Fragment parsing
      _getAdjustedCurrentElement() {
        return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
      }
      _findFormInFragmentContext() {
        let node2 = this.fragmentContext;
        do {
          if (this.treeAdapter.getTagName(node2) === $.FORM) {
            this.formElement = node2;
            break;
          }
          node2 = this.treeAdapter.getParentNode(node2);
        } while (node2);
      }
      _initTokenizerForFragmentParsing() {
        if (this.treeAdapter.getNamespaceURI(this.fragmentContext) === NS.HTML) {
          const tn = this.treeAdapter.getTagName(this.fragmentContext);
          if (tn === $.TITLE || tn === $.TEXTAREA) {
            this.tokenizer.state = Tokenizer.MODE.RCDATA;
          } else if (tn === $.STYLE || tn === $.XMP || tn === $.IFRAME || tn === $.NOEMBED || tn === $.NOFRAMES || tn === $.NOSCRIPT) {
            this.tokenizer.state = Tokenizer.MODE.RAWTEXT;
          } else if (tn === $.SCRIPT) {
            this.tokenizer.state = Tokenizer.MODE.SCRIPT_DATA;
          } else if (tn === $.PLAINTEXT) {
            this.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
          }
        }
      }
      //Tree mutation
      _setDocumentType(token2) {
        const name2 = token2.name || "";
        const publicId = token2.publicId || "";
        const systemId = token2.systemId || "";
        this.treeAdapter.setDocumentType(this.document, name2, publicId, systemId);
      }
      _attachElementToTree(element2) {
        if (this._shouldFosterParentOnInsertion()) {
          this._fosterParentElement(element2);
        } else {
          const parent = this.openElements.currentTmplContent || this.openElements.current;
          this.treeAdapter.appendChild(parent, element2);
        }
      }
      _appendElement(token2, namespaceURI) {
        const element2 = this.treeAdapter.createElement(token2.tagName, namespaceURI, token2.attrs);
        this._attachElementToTree(element2);
      }
      _insertElement(token2, namespaceURI) {
        const element2 = this.treeAdapter.createElement(token2.tagName, namespaceURI, token2.attrs);
        this._attachElementToTree(element2);
        this.openElements.push(element2);
      }
      _insertFakeElement(tagName) {
        const element2 = this.treeAdapter.createElement(tagName, NS.HTML, []);
        this._attachElementToTree(element2);
        this.openElements.push(element2);
      }
      _insertTemplate(token2) {
        const tmpl = this.treeAdapter.createElement(token2.tagName, NS.HTML, token2.attrs);
        const content2 = this.treeAdapter.createDocumentFragment();
        this.treeAdapter.setTemplateContent(tmpl, content2);
        this._attachElementToTree(tmpl);
        this.openElements.push(tmpl);
      }
      _insertFakeRootElement() {
        const element2 = this.treeAdapter.createElement($.HTML, NS.HTML, []);
        this.treeAdapter.appendChild(this.openElements.current, element2);
        this.openElements.push(element2);
      }
      _appendCommentNode(token2, parent) {
        const commentNode = this.treeAdapter.createCommentNode(token2.data);
        this.treeAdapter.appendChild(parent, commentNode);
      }
      _insertCharacters(token2) {
        if (this._shouldFosterParentOnInsertion()) {
          this._fosterParentText(token2.chars);
        } else {
          const parent = this.openElements.currentTmplContent || this.openElements.current;
          this.treeAdapter.insertText(parent, token2.chars);
        }
      }
      _adoptNodes(donor, recipient) {
        for (let child = this.treeAdapter.getFirstChild(donor); child; child = this.treeAdapter.getFirstChild(donor)) {
          this.treeAdapter.detachNode(child);
          this.treeAdapter.appendChild(recipient, child);
        }
      }
      //Token processing
      _shouldProcessTokenInForeignContent(token2) {
        const current = this._getAdjustedCurrentElement();
        if (!current || current === this.document) {
          return false;
        }
        const ns2 = this.treeAdapter.getNamespaceURI(current);
        if (ns2 === NS.HTML) {
          return false;
        }
        if (this.treeAdapter.getTagName(current) === $.ANNOTATION_XML && ns2 === NS.MATHML && token2.type === Tokenizer.START_TAG_TOKEN && token2.tagName === $.SVG) {
          return false;
        }
        const isCharacterToken = token2.type === Tokenizer.CHARACTER_TOKEN || token2.type === Tokenizer.NULL_CHARACTER_TOKEN || token2.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN;
        const isMathMLTextStartTag = token2.type === Tokenizer.START_TAG_TOKEN && token2.tagName !== $.MGLYPH && token2.tagName !== $.MALIGNMARK;
        if ((isMathMLTextStartTag || isCharacterToken) && this._isIntegrationPoint(current, NS.MATHML)) {
          return false;
        }
        if ((token2.type === Tokenizer.START_TAG_TOKEN || isCharacterToken) && this._isIntegrationPoint(current, NS.HTML)) {
          return false;
        }
        return token2.type !== Tokenizer.EOF_TOKEN;
      }
      _processToken(token2) {
        TOKEN_HANDLERS[this.insertionMode][token2.type](this, token2);
      }
      _processTokenInBodyMode(token2) {
        TOKEN_HANDLERS[IN_BODY_MODE][token2.type](this, token2);
      }
      _processTokenInForeignContent(token2) {
        if (token2.type === Tokenizer.CHARACTER_TOKEN) {
          characterInForeignContent(this, token2);
        } else if (token2.type === Tokenizer.NULL_CHARACTER_TOKEN) {
          nullCharacterInForeignContent(this, token2);
        } else if (token2.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN) {
          insertCharacters(this, token2);
        } else if (token2.type === Tokenizer.COMMENT_TOKEN) {
          appendComment(this, token2);
        } else if (token2.type === Tokenizer.START_TAG_TOKEN) {
          startTagInForeignContent(this, token2);
        } else if (token2.type === Tokenizer.END_TAG_TOKEN) {
          endTagInForeignContent(this, token2);
        }
      }
      _processInputToken(token2) {
        if (this._shouldProcessTokenInForeignContent(token2)) {
          this._processTokenInForeignContent(token2);
        } else {
          this._processToken(token2);
        }
        if (token2.type === Tokenizer.START_TAG_TOKEN && token2.selfClosing && !token2.ackSelfClosing) {
          this._err(ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);
        }
      }
      //Integration points
      _isIntegrationPoint(element2, foreignNS) {
        const tn = this.treeAdapter.getTagName(element2);
        const ns2 = this.treeAdapter.getNamespaceURI(element2);
        const attrs = this.treeAdapter.getAttrList(element2);
        return foreignContent.isIntegrationPoint(tn, ns2, attrs, foreignNS);
      }
      //Active formatting elements reconstruction
      _reconstructActiveFormattingElements() {
        const listLength = this.activeFormattingElements.length;
        if (listLength) {
          let unopenIdx = listLength;
          let entry = null;
          do {
            unopenIdx--;
            entry = this.activeFormattingElements.entries[unopenIdx];
            if (entry.type === FormattingElementList.MARKER_ENTRY || this.openElements.contains(entry.element)) {
              unopenIdx++;
              break;
            }
          } while (unopenIdx > 0);
          for (let i2 = unopenIdx; i2 < listLength; i2++) {
            entry = this.activeFormattingElements.entries[i2];
            this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));
            entry.element = this.openElements.current;
          }
        }
      }
      //Close elements
      _closeTableCell() {
        this.openElements.generateImpliedEndTags();
        this.openElements.popUntilTableCellPopped();
        this.activeFormattingElements.clearToLastMarker();
        this.insertionMode = IN_ROW_MODE;
      }
      _closePElement() {
        this.openElements.generateImpliedEndTagsWithExclusion($.P);
        this.openElements.popUntilTagNamePopped($.P);
      }
      //Insertion modes
      _resetInsertionMode() {
        for (let i2 = this.openElements.stackTop, last = false; i2 >= 0; i2--) {
          let element2 = this.openElements.items[i2];
          if (i2 === 0) {
            last = true;
            if (this.fragmentContext) {
              element2 = this.fragmentContext;
            }
          }
          const tn = this.treeAdapter.getTagName(element2);
          const newInsertionMode = INSERTION_MODE_RESET_MAP[tn];
          if (newInsertionMode) {
            this.insertionMode = newInsertionMode;
            break;
          } else if (!last && (tn === $.TD || tn === $.TH)) {
            this.insertionMode = IN_CELL_MODE;
            break;
          } else if (!last && tn === $.HEAD) {
            this.insertionMode = IN_HEAD_MODE;
            break;
          } else if (tn === $.SELECT) {
            this._resetInsertionModeForSelect(i2);
            break;
          } else if (tn === $.TEMPLATE) {
            this.insertionMode = this.currentTmplInsertionMode;
            break;
          } else if (tn === $.HTML) {
            this.insertionMode = this.headElement ? AFTER_HEAD_MODE : BEFORE_HEAD_MODE;
            break;
          } else if (last) {
            this.insertionMode = IN_BODY_MODE;
            break;
          }
        }
      }
      _resetInsertionModeForSelect(selectIdx) {
        if (selectIdx > 0) {
          for (let i2 = selectIdx - 1; i2 > 0; i2--) {
            const ancestor = this.openElements.items[i2];
            const tn = this.treeAdapter.getTagName(ancestor);
            if (tn === $.TEMPLATE) {
              break;
            } else if (tn === $.TABLE) {
              this.insertionMode = IN_SELECT_IN_TABLE_MODE;
              return;
            }
          }
        }
        this.insertionMode = IN_SELECT_MODE;
      }
      _pushTmplInsertionMode(mode) {
        this.tmplInsertionModeStack.push(mode);
        this.tmplInsertionModeStackTop++;
        this.currentTmplInsertionMode = mode;
      }
      _popTmplInsertionMode() {
        this.tmplInsertionModeStack.pop();
        this.tmplInsertionModeStackTop--;
        this.currentTmplInsertionMode = this.tmplInsertionModeStack[this.tmplInsertionModeStackTop];
      }
      //Foster parenting
      _isElementCausesFosterParenting(element2) {
        const tn = this.treeAdapter.getTagName(element2);
        return tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR;
      }
      _shouldFosterParentOnInsertion() {
        return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.current);
      }
      _findFosterParentingLocation() {
        const location2 = {
          parent: null,
          beforeElement: null
        };
        for (let i2 = this.openElements.stackTop; i2 >= 0; i2--) {
          const openElement = this.openElements.items[i2];
          const tn = this.treeAdapter.getTagName(openElement);
          const ns2 = this.treeAdapter.getNamespaceURI(openElement);
          if (tn === $.TEMPLATE && ns2 === NS.HTML) {
            location2.parent = this.treeAdapter.getTemplateContent(openElement);
            break;
          } else if (tn === $.TABLE) {
            location2.parent = this.treeAdapter.getParentNode(openElement);
            if (location2.parent) {
              location2.beforeElement = openElement;
            } else {
              location2.parent = this.openElements.items[i2 - 1];
            }
            break;
          }
        }
        if (!location2.parent) {
          location2.parent = this.openElements.items[0];
        }
        return location2;
      }
      _fosterParentElement(element2) {
        const location2 = this._findFosterParentingLocation();
        if (location2.beforeElement) {
          this.treeAdapter.insertBefore(location2.parent, element2, location2.beforeElement);
        } else {
          this.treeAdapter.appendChild(location2.parent, element2);
        }
      }
      _fosterParentText(chars) {
        const location2 = this._findFosterParentingLocation();
        if (location2.beforeElement) {
          this.treeAdapter.insertTextBefore(location2.parent, chars, location2.beforeElement);
        } else {
          this.treeAdapter.insertText(location2.parent, chars);
        }
      }
      //Special elements
      _isSpecialElement(element2) {
        const tn = this.treeAdapter.getTagName(element2);
        const ns2 = this.treeAdapter.getNamespaceURI(element2);
        return HTML.SPECIAL_ELEMENTS[ns2][tn];
      }
    }
    var parser = Parser;
    function aaObtainFormattingElementEntry(p2, token2) {
      let formattingElementEntry = p2.activeFormattingElements.getElementEntryInScopeWithTagName(token2.tagName);
      if (formattingElementEntry) {
        if (!p2.openElements.contains(formattingElementEntry.element)) {
          p2.activeFormattingElements.removeEntry(formattingElementEntry);
          formattingElementEntry = null;
        } else if (!p2.openElements.hasInScope(token2.tagName)) {
          formattingElementEntry = null;
        }
      } else {
        genericEndTagInBody(p2, token2);
      }
      return formattingElementEntry;
    }
    function aaObtainFurthestBlock(p2, formattingElementEntry) {
      let furthestBlock = null;
      for (let i2 = p2.openElements.stackTop; i2 >= 0; i2--) {
        const element2 = p2.openElements.items[i2];
        if (element2 === formattingElementEntry.element) {
          break;
        }
        if (p2._isSpecialElement(element2)) {
          furthestBlock = element2;
        }
      }
      if (!furthestBlock) {
        p2.openElements.popUntilElementPopped(formattingElementEntry.element);
        p2.activeFormattingElements.removeEntry(formattingElementEntry);
      }
      return furthestBlock;
    }
    function aaInnerLoop(p2, furthestBlock, formattingElement) {
      let lastElement = furthestBlock;
      let nextElement = p2.openElements.getCommonAncestor(furthestBlock);
      for (let i2 = 0, element2 = nextElement; element2 !== formattingElement; i2++, element2 = nextElement) {
        nextElement = p2.openElements.getCommonAncestor(element2);
        const elementEntry = p2.activeFormattingElements.getElementEntry(element2);
        const counterOverflow = elementEntry && i2 >= AA_INNER_LOOP_ITER;
        const shouldRemoveFromOpenElements = !elementEntry || counterOverflow;
        if (shouldRemoveFromOpenElements) {
          if (counterOverflow) {
            p2.activeFormattingElements.removeEntry(elementEntry);
          }
          p2.openElements.remove(element2);
        } else {
          element2 = aaRecreateElementFromEntry(p2, elementEntry);
          if (lastElement === furthestBlock) {
            p2.activeFormattingElements.bookmark = elementEntry;
          }
          p2.treeAdapter.detachNode(lastElement);
          p2.treeAdapter.appendChild(element2, lastElement);
          lastElement = element2;
        }
      }
      return lastElement;
    }
    function aaRecreateElementFromEntry(p2, elementEntry) {
      const ns2 = p2.treeAdapter.getNamespaceURI(elementEntry.element);
      const newElement = p2.treeAdapter.createElement(elementEntry.token.tagName, ns2, elementEntry.token.attrs);
      p2.openElements.replace(elementEntry.element, newElement);
      elementEntry.element = newElement;
      return newElement;
    }
    function aaInsertLastNodeInCommonAncestor(p2, commonAncestor, lastElement) {
      if (p2._isElementCausesFosterParenting(commonAncestor)) {
        p2._fosterParentElement(lastElement);
      } else {
        const tn = p2.treeAdapter.getTagName(commonAncestor);
        const ns2 = p2.treeAdapter.getNamespaceURI(commonAncestor);
        if (tn === $.TEMPLATE && ns2 === NS.HTML) {
          commonAncestor = p2.treeAdapter.getTemplateContent(commonAncestor);
        }
        p2.treeAdapter.appendChild(commonAncestor, lastElement);
      }
    }
    function aaReplaceFormattingElement(p2, furthestBlock, formattingElementEntry) {
      const ns2 = p2.treeAdapter.getNamespaceURI(formattingElementEntry.element);
      const token2 = formattingElementEntry.token;
      const newElement = p2.treeAdapter.createElement(token2.tagName, ns2, token2.attrs);
      p2._adoptNodes(furthestBlock, newElement);
      p2.treeAdapter.appendChild(furthestBlock, newElement);
      p2.activeFormattingElements.insertElementAfterBookmark(newElement, formattingElementEntry.token);
      p2.activeFormattingElements.removeEntry(formattingElementEntry);
      p2.openElements.remove(formattingElementEntry.element);
      p2.openElements.insertAfter(furthestBlock, newElement);
    }
    function callAdoptionAgency(p2, token2) {
      let formattingElementEntry;
      for (let i2 = 0; i2 < AA_OUTER_LOOP_ITER; i2++) {
        formattingElementEntry = aaObtainFormattingElementEntry(p2, token2);
        if (!formattingElementEntry) {
          break;
        }
        const furthestBlock = aaObtainFurthestBlock(p2, formattingElementEntry);
        if (!furthestBlock) {
          break;
        }
        p2.activeFormattingElements.bookmark = formattingElementEntry;
        const lastElement = aaInnerLoop(p2, furthestBlock, formattingElementEntry.element);
        const commonAncestor = p2.openElements.getCommonAncestor(formattingElementEntry.element);
        p2.treeAdapter.detachNode(lastElement);
        aaInsertLastNodeInCommonAncestor(p2, commonAncestor, lastElement);
        aaReplaceFormattingElement(p2, furthestBlock, formattingElementEntry);
      }
    }
    function ignoreToken() {
    }
    function misplacedDoctype(p2) {
      p2._err(ERR.misplacedDoctype);
    }
    function appendComment(p2, token2) {
      p2._appendCommentNode(token2, p2.openElements.currentTmplContent || p2.openElements.current);
    }
    function appendCommentToRootHtmlElement(p2, token2) {
      p2._appendCommentNode(token2, p2.openElements.items[0]);
    }
    function appendCommentToDocument(p2, token2) {
      p2._appendCommentNode(token2, p2.document);
    }
    function insertCharacters(p2, token2) {
      p2._insertCharacters(token2);
    }
    function stopParsing(p2) {
      p2.stopped = true;
    }
    function doctypeInInitialMode(p2, token2) {
      p2._setDocumentType(token2);
      const mode = token2.forceQuirks ? HTML.DOCUMENT_MODE.QUIRKS : doctype$2.getDocumentMode(token2);
      if (!doctype$2.isConforming(token2)) {
        p2._err(ERR.nonConformingDoctype);
      }
      p2.treeAdapter.setDocumentMode(p2.document, mode);
      p2.insertionMode = BEFORE_HTML_MODE;
    }
    function tokenInInitialMode(p2, token2) {
      p2._err(ERR.missingDoctype, { beforeToken: true });
      p2.treeAdapter.setDocumentMode(p2.document, HTML.DOCUMENT_MODE.QUIRKS);
      p2.insertionMode = BEFORE_HTML_MODE;
      p2._processToken(token2);
    }
    function startTagBeforeHtml(p2, token2) {
      if (token2.tagName === $.HTML) {
        p2._insertElement(token2, NS.HTML);
        p2.insertionMode = BEFORE_HEAD_MODE;
      } else {
        tokenBeforeHtml(p2, token2);
      }
    }
    function endTagBeforeHtml(p2, token2) {
      const tn = token2.tagName;
      if (tn === $.HTML || tn === $.HEAD || tn === $.BODY || tn === $.BR) {
        tokenBeforeHtml(p2, token2);
      }
    }
    function tokenBeforeHtml(p2, token2) {
      p2._insertFakeRootElement();
      p2.insertionMode = BEFORE_HEAD_MODE;
      p2._processToken(token2);
    }
    function startTagBeforeHead(p2, token2) {
      const tn = token2.tagName;
      if (tn === $.HTML) {
        startTagInBody(p2, token2);
      } else if (tn === $.HEAD) {
        p2._insertElement(token2, NS.HTML);
        p2.headElement = p2.openElements.current;
        p2.insertionMode = IN_HEAD_MODE;
      } else {
        tokenBeforeHead(p2, token2);
      }
    }
    function endTagBeforeHead(p2, token2) {
      const tn = token2.tagName;
      if (tn === $.HEAD || tn === $.BODY || tn === $.HTML || tn === $.BR) {
        tokenBeforeHead(p2, token2);
      } else {
        p2._err(ERR.endTagWithoutMatchingOpenElement);
      }
    }
    function tokenBeforeHead(p2, token2) {
      p2._insertFakeElement($.HEAD);
      p2.headElement = p2.openElements.current;
      p2.insertionMode = IN_HEAD_MODE;
      p2._processToken(token2);
    }
    function startTagInHead(p2, token2) {
      const tn = token2.tagName;
      if (tn === $.HTML) {
        startTagInBody(p2, token2);
      } else if (tn === $.BASE || tn === $.BASEFONT || tn === $.BGSOUND || tn === $.LINK || tn === $.META) {
        p2._appendElement(token2, NS.HTML);
        token2.ackSelfClosing = true;
      } else if (tn === $.TITLE) {
        p2._switchToTextParsing(token2, Tokenizer.MODE.RCDATA);
      } else if (tn === $.NOSCRIPT) {
        if (p2.options.scriptingEnabled) {
          p2._switchToTextParsing(token2, Tokenizer.MODE.RAWTEXT);
        } else {
          p2._insertElement(token2, NS.HTML);
          p2.insertionMode = IN_HEAD_NO_SCRIPT_MODE;
        }
      } else if (tn === $.NOFRAMES || tn === $.STYLE) {
        p2._switchToTextParsing(token2, Tokenizer.MODE.RAWTEXT);
      } else if (tn === $.SCRIPT) {
        p2._switchToTextParsing(token2, Tokenizer.MODE.SCRIPT_DATA);
      } else if (tn === $.TEMPLATE) {
        p2._insertTemplate(token2, NS.HTML);
        p2.activeFormattingElements.insertMarker();
        p2.framesetOk = false;
        p2.insertionMode = IN_TEMPLATE_MODE;
        p2._pushTmplInsertionMode(IN_TEMPLATE_MODE);
      } else if (tn === $.HEAD) {
        p2._err(ERR.misplacedStartTagForHeadElement);
      } else {
        tokenInHead(p2, token2);
      }
    }
    function endTagInHead(p2, token2) {
      const tn = token2.tagName;
      if (tn === $.HEAD) {
        p2.openElements.pop();
        p2.insertionMode = AFTER_HEAD_MODE;
      } else if (tn === $.BODY || tn === $.BR || tn === $.HTML) {
        tokenInHead(p2, token2);
      } else if (tn === $.TEMPLATE) {
        if (p2.openElements.tmplCount > 0) {
          p2.openElements.generateImpliedEndTagsThoroughly();
          if (p2.openElements.currentTagName !== $.TEMPLATE) {
            p2._err(ERR.closingOfElementWithOpenChildElements);
          }
          p2.openElements.popUntilTagNamePopped($.TEMPLATE);
          p2.activeFormattingElements.clearToLastMarker();
          p2._popTmplInsertionMode();
          p2._resetInsertionMode();
        } else {
          p2._err(ERR.endTagWithoutMatchingOpenElement);
        }
      } else {
        p2._err(ERR.endTagWithoutMatchingOpenElement);
      }
    }
    function tokenInHead(p2, token2) {
      p2.openElements.pop();
      p2.insertionMode = AFTER_HEAD_MODE;
      p2._processToken(token2);
    }
    function startTagInHeadNoScript(p2, token2) {
      const tn = token2.tagName;
      if (tn === $.HTML) {
        startTagInBody(p2, token2);
      } else if (tn === $.BASEFONT || tn === $.BGSOUND || tn === $.HEAD || tn === $.LINK || tn === $.META || tn === $.NOFRAMES || tn === $.STYLE) {
        startTagInHead(p2, token2);
      } else if (tn === $.NOSCRIPT) {
        p2._err(ERR.nestedNoscriptInHead);
      } else {
        tokenInHeadNoScript(p2, token2);
      }
    }
    function endTagInHeadNoScript(p2, token2) {
      const tn = token2.tagName;
      if (tn === $.NOSCRIPT) {
        p2.openElements.pop();
        p2.insertionMode = IN_HEAD_MODE;
      } else if (tn === $.BR) {
        tokenInHeadNoScript(p2, token2);
      } else {
        p2._err(ERR.endTagWithoutMatchingOpenElement);
      }
    }
    function tokenInHeadNoScript(p2, token2) {
      const errCode = token2.type === Tokenizer.EOF_TOKEN ? ERR.openElementsLeftAfterEof : ERR.disallowedContentInNoscriptInHead;
      p2._err(errCode);
      p2.openElements.pop();
      p2.insertionMode = IN_HEAD_MODE;
      p2._processToken(token2);
    }
    function startTagAfterHead(p2, token2) {
      const tn = token2.tagName;
      if (tn === $.HTML) {
        startTagInBody(p2, token2);
      } else if (tn === $.BODY) {
        p2._insertElement(token2, NS.HTML);
        p2.framesetOk = false;
        p2.insertionMode = IN_BODY_MODE;
      } else if (tn === $.FRAMESET) {
        p2._insertElement(token2, NS.HTML);
        p2.insertionMode = IN_FRAMESET_MODE;
      } else if (tn === $.BASE || tn === $.BASEFONT || tn === $.BGSOUND || tn === $.LINK || tn === $.META || tn === $.NOFRAMES || tn === $.SCRIPT || tn === $.STYLE || tn === $.TEMPLATE || tn === $.TITLE) {
        p2._err(ERR.abandonedHeadElementChild);
        p2.openElements.push(p2.headElement);
        startTagInHead(p2, token2);
        p2.openElements.remove(p2.headElement);
      } else if (tn === $.HEAD) {
        p2._err(ERR.misplacedStartTagForHeadElement);
      } else {
        tokenAfterHead(p2, token2);
      }
    }
    function endTagAfterHead(p2, token2) {
      const tn = token2.tagName;
      if (tn === $.BODY || tn === $.HTML || tn === $.BR) {
        tokenAfterHead(p2, token2);
      } else if (tn === $.TEMPLATE) {
        endTagInHead(p2, token2);
      } else {
        p2._err(ERR.endTagWithoutMatchingOpenElement);
      }
    }
    function tokenAfterHead(p2, token2) {
      p2._insertFakeElement($.BODY);
      p2.insertionMode = IN_BODY_MODE;
      p2._processToken(token2);
    }
    function whitespaceCharacterInBody(p2, token2) {
      p2._reconstructActiveFormattingElements();
      p2._insertCharacters(token2);
    }
    function characterInBody(p2, token2) {
      p2._reconstructActiveFormattingElements();
      p2._insertCharacters(token2);
      p2.framesetOk = false;
    }
    function htmlStartTagInBody(p2, token2) {
      if (p2.openElements.tmplCount === 0) {
        p2.treeAdapter.adoptAttributes(p2.openElements.items[0], token2.attrs);
      }
    }
    function bodyStartTagInBody(p2, token2) {
      const bodyElement = p2.openElements.tryPeekProperlyNestedBodyElement();
      if (bodyElement && p2.openElements.tmplCount === 0) {
        p2.framesetOk = false;
        p2.treeAdapter.adoptAttributes(bodyElement, token2.attrs);
      }
    }
    function framesetStartTagInBody(p2, token2) {
      const bodyElement = p2.openElements.tryPeekProperlyNestedBodyElement();
      if (p2.framesetOk && bodyElement) {
        p2.treeAdapter.detachNode(bodyElement);
        p2.openElements.popAllUpToHtmlElement();
        p2._insertElement(token2, NS.HTML);
        p2.insertionMode = IN_FRAMESET_MODE;
      }
    }
    function addressStartTagInBody(p2, token2) {
      if (p2.openElements.hasInButtonScope($.P)) {
        p2._closePElement();
      }
      p2._insertElement(token2, NS.HTML);
    }
    function numberedHeaderStartTagInBody(p2, token2) {
      if (p2.openElements.hasInButtonScope($.P)) {
        p2._closePElement();
      }
      const tn = p2.openElements.currentTagName;
      if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) {
        p2.openElements.pop();
      }
      p2._insertElement(token2, NS.HTML);
    }
    function preStartTagInBody(p2, token2) {
      if (p2.openElements.hasInButtonScope($.P)) {
        p2._closePElement();
      }
      p2._insertElement(token2, NS.HTML);
      p2.skipNextNewLine = true;
      p2.framesetOk = false;
    }
    function formStartTagInBody(p2, token2) {
      const inTemplate = p2.openElements.tmplCount > 0;
      if (!p2.formElement || inTemplate) {
        if (p2.openElements.hasInButtonScope($.P)) {
          p2._closePElement();
        }
        p2._insertElement(token2, NS.HTML);
        if (!inTemplate) {
          p2.formElement = p2.openElements.current;
        }
      }
    }
    function listItemStartTagInBody(p2, token2) {
      p2.framesetOk = false;
      const tn = token2.tagName;
      for (let i2 = p2.openElements.stackTop; i2 >= 0; i2--) {
        const element2 = p2.openElements.items[i2];
        const elementTn = p2.treeAdapter.getTagName(element2);
        let closeTn = null;
        if (tn === $.LI && elementTn === $.LI) {
          closeTn = $.LI;
        } else if ((tn === $.DD || tn === $.DT) && (elementTn === $.DD || elementTn === $.DT)) {
          closeTn = elementTn;
        }
        if (closeTn) {
          p2.openElements.generateImpliedEndTagsWithExclusion(closeTn);
          p2.openElements.popUntilTagNamePopped(closeTn);
          break;
        }
        if (elementTn !== $.ADDRESS && elementTn !== $.DIV && elementTn !== $.P && p2._isSpecialElement(element2)) {
          break;
        }
      }
      if (p2.openElements.hasInButtonScope($.P)) {
        p2._closePElement();
      }
      p2._insertElement(token2, NS.HTML);
    }
    function plaintextStartTagInBody(p2, token2) {
      if (p2.openElements.hasInButtonScope($.P)) {
        p2._closePElement();
      }
      p2._insertElement(token2, NS.HTML);
      p2.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
    }
    function buttonStartTagInBody(p2, token2) {
      if (p2.openElements.hasInScope($.BUTTON)) {
        p2.openElements.generateImpliedEndTags();
        p2.openElements.popUntilTagNamePopped($.BUTTON);
      }
      p2._reconstructActiveFormattingElements();
      p2._insertElement(token2, NS.HTML);
      p2.framesetOk = false;
    }
    function aStartTagInBody(p2, token2) {
      const activeElementEntry = p2.activeFormattingElements.getElementEntryInScopeWithTagName($.A);
      if (activeElementEntry) {
        callAdoptionAgency(p2, token2);
        p2.openElements.remove(activeElementEntry.element);
        p2.activeFormattingElements.removeEntry(activeElementEntry);
      }
      p2._reconstructActiveFormattingElements();
      p2._insertElement(token2, NS.HTML);
      p2.activeFormattingElements.pushElement(p2.openElements.current, token2);
    }
    function bStartTagInBody(p2, token2) {
      p2._reconstructActiveFormattingElements();
      p2._insertElement(token2, NS.HTML);
      p2.activeFormattingElements.pushElement(p2.openElements.current, token2);
    }
    function nobrStartTagInBody(p2, token2) {
      p2._reconstructActiveFormattingElements();
      if (p2.openElements.hasInScope($.NOBR)) {
        callAdoptionAgency(p2, token2);
        p2._reconstructActiveFormattingElements();
      }
      p2._insertElement(token2, NS.HTML);
      p2.activeFormattingElements.pushElement(p2.openElements.current, token2);
    }
    function appletStartTagInBody(p2, token2) {
      p2._reconstructActiveFormattingElements();
      p2._insertElement(token2, NS.HTML);
      p2.activeFormattingElements.insertMarker();
      p2.framesetOk = false;
    }
    function tableStartTagInBody(p2, token2) {
      if (p2.treeAdapter.getDocumentMode(p2.document) !== HTML.DOCUMENT_MODE.QUIRKS && p2.openElements.hasInButtonScope($.P)) {
        p2._closePElement();
      }
      p2._insertElement(token2, NS.HTML);
      p2.framesetOk = false;
      p2.insertionMode = IN_TABLE_MODE;
    }
    function areaStartTagInBody(p2, token2) {
      p2._reconstructActiveFormattingElements();
      p2._appendElement(token2, NS.HTML);
      p2.framesetOk = false;
      token2.ackSelfClosing = true;
    }
    function inputStartTagInBody(p2, token2) {
      p2._reconstructActiveFormattingElements();
      p2._appendElement(token2, NS.HTML);
      const inputType = Tokenizer.getTokenAttr(token2, ATTRS.TYPE);
      if (!inputType || inputType.toLowerCase() !== HIDDEN_INPUT_TYPE) {
        p2.framesetOk = false;
      }
      token2.ackSelfClosing = true;
    }
    function paramStartTagInBody(p2, token2) {
      p2._appendElement(token2, NS.HTML);
      token2.ackSelfClosing = true;
    }
    function hrStartTagInBody(p2, token2) {
      if (p2.openElements.hasInButtonScope($.P)) {
        p2._closePElement();
      }
      p2._appendElement(token2, NS.HTML);
      p2.framesetOk = false;
      token2.ackSelfClosing = true;
    }
    function imageStartTagInBody(p2, token2) {
      token2.tagName = $.IMG;
      areaStartTagInBody(p2, token2);
    }
    function textareaStartTagInBody(p2, token2) {
      p2._insertElement(token2, NS.HTML);
      p2.skipNextNewLine = true;
      p2.tokenizer.state = Tokenizer.MODE.RCDATA;
      p2.originalInsertionMode = p2.insertionMode;
      p2.framesetOk = false;
      p2.insertionMode = TEXT_MODE;
    }
    function xmpStartTagInBody(p2, token2) {
      if (p2.openElements.hasInButtonScope($.P)) {
        p2._closePElement();
      }
      p2._reconstructActiveFormattingElements();
      p2.framesetOk = false;
      p2._switchToTextParsing(token2, Tokenizer.MODE.RAWTEXT);
    }
    function iframeStartTagInBody(p2, token2) {
      p2.framesetOk = false;
      p2._switchToTextParsing(token2, Tokenizer.MODE.RAWTEXT);
    }
    function noembedStartTagInBody(p2, token2) {
      p2._switchToTextParsing(token2, Tokenizer.MODE.RAWTEXT);
    }
    function selectStartTagInBody(p2, token2) {
      p2._reconstructActiveFormattingElements();
      p2._insertElement(token2, NS.HTML);
      p2.framesetOk = false;
      if (p2.insertionMode === IN_TABLE_MODE || p2.insertionMode === IN_CAPTION_MODE || p2.insertionMode === IN_TABLE_BODY_MODE || p2.insertionMode === IN_ROW_MODE || p2.insertionMode === IN_CELL_MODE) {
        p2.insertionMode = IN_SELECT_IN_TABLE_MODE;
      } else {
        p2.insertionMode = IN_SELECT_MODE;
      }
    }
    function optgroupStartTagInBody(p2, token2) {
      if (p2.openElements.currentTagName === $.OPTION) {
        p2.openElements.pop();
      }
      p2._reconstructActiveFormattingElements();
      p2._insertElement(token2, NS.HTML);
    }
    function rbStartTagInBody(p2, token2) {
      if (p2.openElements.hasInScope($.RUBY)) {
        p2.openElements.generateImpliedEndTags();
      }
      p2._insertElement(token2, NS.HTML);
    }
    function rtStartTagInBody(p2, token2) {
      if (p2.openElements.hasInScope($.RUBY)) {
        p2.openElements.generateImpliedEndTagsWithExclusion($.RTC);
      }
      p2._insertElement(token2, NS.HTML);
    }
    function menuStartTagInBody(p2, token2) {
      if (p2.openElements.hasInButtonScope($.P)) {
        p2._closePElement();
      }
      p2._insertElement(token2, NS.HTML);
    }
    function mathStartTagInBody(p2, token2) {
      p2._reconstructActiveFormattingElements();
      foreignContent.adjustTokenMathMLAttrs(token2);
      foreignContent.adjustTokenXMLAttrs(token2);
      if (token2.selfClosing) {
        p2._appendElement(token2, NS.MATHML);
      } else {
        p2._insertElement(token2, NS.MATHML);
      }
      token2.ackSelfClosing = true;
    }
    function svgStartTagInBody(p2, token2) {
      p2._reconstructActiveFormattingElements();
      foreignContent.adjustTokenSVGAttrs(token2);
      foreignContent.adjustTokenXMLAttrs(token2);
      if (token2.selfClosing) {
        p2._appendElement(token2, NS.SVG);
      } else {
        p2._insertElement(token2, NS.SVG);
      }
      token2.ackSelfClosing = true;
    }
    function genericStartTagInBody(p2, token2) {
      p2._reconstructActiveFormattingElements();
      p2._insertElement(token2, NS.HTML);
    }
    function startTagInBody(p2, token2) {
      const tn = token2.tagName;
      switch (tn.length) {
        case 1:
          if (tn === $.I || tn === $.S || tn === $.B || tn === $.U) {
            bStartTagInBody(p2, token2);
          } else if (tn === $.P) {
            addressStartTagInBody(p2, token2);
          } else if (tn === $.A) {
            aStartTagInBody(p2, token2);
          } else {
            genericStartTagInBody(p2, token2);
          }
          break;
        case 2:
          if (tn === $.DL || tn === $.OL || tn === $.UL) {
            addressStartTagInBody(p2, token2);
          } else if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) {
            numberedHeaderStartTagInBody(p2, token2);
          } else if (tn === $.LI || tn === $.DD || tn === $.DT) {
            listItemStartTagInBody(p2, token2);
          } else if (tn === $.EM || tn === $.TT) {
            bStartTagInBody(p2, token2);
          } else if (tn === $.BR) {
            areaStartTagInBody(p2, token2);
          } else if (tn === $.HR) {
            hrStartTagInBody(p2, token2);
          } else if (tn === $.RB) {
            rbStartTagInBody(p2, token2);
          } else if (tn === $.RT || tn === $.RP) {
            rtStartTagInBody(p2, token2);
          } else if (tn !== $.TH && tn !== $.TD && tn !== $.TR) {
            genericStartTagInBody(p2, token2);
          }
          break;
        case 3:
          if (tn === $.DIV || tn === $.DIR || tn === $.NAV) {
            addressStartTagInBody(p2, token2);
          } else if (tn === $.PRE) {
            preStartTagInBody(p2, token2);
          } else if (tn === $.BIG) {
            bStartTagInBody(p2, token2);
          } else if (tn === $.IMG || tn === $.WBR) {
            areaStartTagInBody(p2, token2);
          } else if (tn === $.XMP) {
            xmpStartTagInBody(p2, token2);
          } else if (tn === $.SVG) {
            svgStartTagInBody(p2, token2);
          } else if (tn === $.RTC) {
            rbStartTagInBody(p2, token2);
          } else if (tn !== $.COL) {
            genericStartTagInBody(p2, token2);
          }
          break;
        case 4:
          if (tn === $.HTML) {
            htmlStartTagInBody(p2, token2);
          } else if (tn === $.BASE || tn === $.LINK || tn === $.META) {
            startTagInHead(p2, token2);
          } else if (tn === $.BODY) {
            bodyStartTagInBody(p2, token2);
          } else if (tn === $.MAIN || tn === $.MENU) {
            addressStartTagInBody(p2, token2);
          } else if (tn === $.FORM) {
            formStartTagInBody(p2, token2);
          } else if (tn === $.CODE || tn === $.FONT) {
            bStartTagInBody(p2, token2);
          } else if (tn === $.NOBR) {
            nobrStartTagInBody(p2, token2);
          } else if (tn === $.AREA) {
            areaStartTagInBody(p2, token2);
          } else if (tn === $.MATH) {
            mathStartTagInBody(p2, token2);
          } else if (tn === $.MENU) {
            menuStartTagInBody(p2, token2);
          } else if (tn !== $.HEAD) {
            genericStartTagInBody(p2, token2);
          }
          break;
        case 5:
          if (tn === $.STYLE || tn === $.TITLE) {
            startTagInHead(p2, token2);
          } else if (tn === $.ASIDE) {
            addressStartTagInBody(p2, token2);
          } else if (tn === $.SMALL) {
            bStartTagInBody(p2, token2);
          } else if (tn === $.TABLE) {
            tableStartTagInBody(p2, token2);
          } else if (tn === $.EMBED) {
            areaStartTagInBody(p2, token2);
          } else if (tn === $.INPUT) {
            inputStartTagInBody(p2, token2);
          } else if (tn === $.PARAM || tn === $.TRACK) {
            paramStartTagInBody(p2, token2);
          } else if (tn === $.IMAGE) {
            imageStartTagInBody(p2, token2);
          } else if (tn !== $.FRAME && tn !== $.TBODY && tn !== $.TFOOT && tn !== $.THEAD) {
            genericStartTagInBody(p2, token2);
          }
          break;
        case 6:
          if (tn === $.SCRIPT) {
            startTagInHead(p2, token2);
          } else if (tn === $.CENTER || tn === $.FIGURE || tn === $.FOOTER || tn === $.HEADER || tn === $.HGROUP || tn === $.DIALOG) {
            addressStartTagInBody(p2, token2);
          } else if (tn === $.BUTTON) {
            buttonStartTagInBody(p2, token2);
          } else if (tn === $.STRIKE || tn === $.STRONG) {
            bStartTagInBody(p2, token2);
          } else if (tn === $.APPLET || tn === $.OBJECT) {
            appletStartTagInBody(p2, token2);
          } else if (tn === $.KEYGEN) {
            areaStartTagInBody(p2, token2);
          } else if (tn === $.SOURCE) {
            paramStartTagInBody(p2, token2);
          } else if (tn === $.IFRAME) {
            iframeStartTagInBody(p2, token2);
          } else if (tn === $.SELECT) {
            selectStartTagInBody(p2, token2);
          } else if (tn === $.OPTION) {
            optgroupStartTagInBody(p2, token2);
          } else {
            genericStartTagInBody(p2, token2);
          }
          break;
        case 7:
          if (tn === $.BGSOUND) {
            startTagInHead(p2, token2);
          } else if (tn === $.DETAILS || tn === $.ADDRESS || tn === $.ARTICLE || tn === $.SECTION || tn === $.SUMMARY) {
            addressStartTagInBody(p2, token2);
          } else if (tn === $.LISTING) {
            preStartTagInBody(p2, token2);
          } else if (tn === $.MARQUEE) {
            appletStartTagInBody(p2, token2);
          } else if (tn === $.NOEMBED) {
            noembedStartTagInBody(p2, token2);
          } else if (tn !== $.CAPTION) {
            genericStartTagInBody(p2, token2);
          }
          break;
        case 8:
          if (tn === $.BASEFONT) {
            startTagInHead(p2, token2);
          } else if (tn === $.FRAMESET) {
            framesetStartTagInBody(p2, token2);
          } else if (tn === $.FIELDSET) {
            addressStartTagInBody(p2, token2);
          } else if (tn === $.TEXTAREA) {
            textareaStartTagInBody(p2, token2);
          } else if (tn === $.TEMPLATE) {
            startTagInHead(p2, token2);
          } else if (tn === $.NOSCRIPT) {
            if (p2.options.scriptingEnabled) {
              noembedStartTagInBody(p2, token2);
            } else {
              genericStartTagInBody(p2, token2);
            }
          } else if (tn === $.OPTGROUP) {
            optgroupStartTagInBody(p2, token2);
          } else if (tn !== $.COLGROUP) {
            genericStartTagInBody(p2, token2);
          }
          break;
        case 9:
          if (tn === $.PLAINTEXT) {
            plaintextStartTagInBody(p2, token2);
          } else {
            genericStartTagInBody(p2, token2);
          }
          break;
        case 10:
          if (tn === $.BLOCKQUOTE || tn === $.FIGCAPTION) {
            addressStartTagInBody(p2, token2);
          } else {
            genericStartTagInBody(p2, token2);
          }
          break;
        default:
          genericStartTagInBody(p2, token2);
      }
    }
    function bodyEndTagInBody(p2) {
      if (p2.openElements.hasInScope($.BODY)) {
        p2.insertionMode = AFTER_BODY_MODE;
      }
    }
    function htmlEndTagInBody(p2, token2) {
      if (p2.openElements.hasInScope($.BODY)) {
        p2.insertionMode = AFTER_BODY_MODE;
        p2._processToken(token2);
      }
    }
    function addressEndTagInBody(p2, token2) {
      const tn = token2.tagName;
      if (p2.openElements.hasInScope(tn)) {
        p2.openElements.generateImpliedEndTags();
        p2.openElements.popUntilTagNamePopped(tn);
      }
    }
    function formEndTagInBody(p2) {
      const inTemplate = p2.openElements.tmplCount > 0;
      const formElement = p2.formElement;
      if (!inTemplate) {
        p2.formElement = null;
      }
      if ((formElement || inTemplate) && p2.openElements.hasInScope($.FORM)) {
        p2.openElements.generateImpliedEndTags();
        if (inTemplate) {
          p2.openElements.popUntilTagNamePopped($.FORM);
        } else {
          p2.openElements.remove(formElement);
        }
      }
    }
    function pEndTagInBody(p2) {
      if (!p2.openElements.hasInButtonScope($.P)) {
        p2._insertFakeElement($.P);
      }
      p2._closePElement();
    }
    function liEndTagInBody(p2) {
      if (p2.openElements.hasInListItemScope($.LI)) {
        p2.openElements.generateImpliedEndTagsWithExclusion($.LI);
        p2.openElements.popUntilTagNamePopped($.LI);
      }
    }
    function ddEndTagInBody(p2, token2) {
      const tn = token2.tagName;
      if (p2.openElements.hasInScope(tn)) {
        p2.openElements.generateImpliedEndTagsWithExclusion(tn);
        p2.openElements.popUntilTagNamePopped(tn);
      }
    }
    function numberedHeaderEndTagInBody(p2) {
      if (p2.openElements.hasNumberedHeaderInScope()) {
        p2.openElements.generateImpliedEndTags();
        p2.openElements.popUntilNumberedHeaderPopped();
      }
    }
    function appletEndTagInBody(p2, token2) {
      const tn = token2.tagName;
      if (p2.openElements.hasInScope(tn)) {
        p2.openElements.generateImpliedEndTags();
        p2.openElements.popUntilTagNamePopped(tn);
        p2.activeFormattingElements.clearToLastMarker();
      }
    }
    function brEndTagInBody(p2) {
      p2._reconstructActiveFormattingElements();
      p2._insertFakeElement($.BR);
      p2.openElements.pop();
      p2.framesetOk = false;
    }
    function genericEndTagInBody(p2, token2) {
      const tn = token2.tagName;
      for (let i2 = p2.openElements.stackTop; i2 > 0; i2--) {
        const element2 = p2.openElements.items[i2];
        if (p2.treeAdapter.getTagName(element2) === tn) {
          p2.openElements.generateImpliedEndTagsWithExclusion(tn);
          p2.openElements.popUntilElementPopped(element2);
          break;
        }
        if (p2._isSpecialElement(element2)) {
          break;
        }
      }
    }
    function endTagInBody(p2, token2) {
      const tn = token2.tagName;
      switch (tn.length) {
        case 1:
          if (tn === $.A || tn === $.B || tn === $.I || tn === $.S || tn === $.U) {
            callAdoptionAgency(p2, token2);
          } else if (tn === $.P) {
            pEndTagInBody(p2);
          } else {
            genericEndTagInBody(p2, token2);
          }
          break;
        case 2:
          if (tn === $.DL || tn === $.UL || tn === $.OL) {
            addressEndTagInBody(p2, token2);
          } else if (tn === $.LI) {
            liEndTagInBody(p2);
          } else if (tn === $.DD || tn === $.DT) {
            ddEndTagInBody(p2, token2);
          } else if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) {
            numberedHeaderEndTagInBody(p2);
          } else if (tn === $.BR) {
            brEndTagInBody(p2);
          } else if (tn === $.EM || tn === $.TT) {
            callAdoptionAgency(p2, token2);
          } else {
            genericEndTagInBody(p2, token2);
          }
          break;
        case 3:
          if (tn === $.BIG) {
            callAdoptionAgency(p2, token2);
          } else if (tn === $.DIR || tn === $.DIV || tn === $.NAV || tn === $.PRE) {
            addressEndTagInBody(p2, token2);
          } else {
            genericEndTagInBody(p2, token2);
          }
          break;
        case 4:
          if (tn === $.BODY) {
            bodyEndTagInBody(p2);
          } else if (tn === $.HTML) {
            htmlEndTagInBody(p2, token2);
          } else if (tn === $.FORM) {
            formEndTagInBody(p2);
          } else if (tn === $.CODE || tn === $.FONT || tn === $.NOBR) {
            callAdoptionAgency(p2, token2);
          } else if (tn === $.MAIN || tn === $.MENU) {
            addressEndTagInBody(p2, token2);
          } else {
            genericEndTagInBody(p2, token2);
          }
          break;
        case 5:
          if (tn === $.ASIDE) {
            addressEndTagInBody(p2, token2);
          } else if (tn === $.SMALL) {
            callAdoptionAgency(p2, token2);
          } else {
            genericEndTagInBody(p2, token2);
          }
          break;
        case 6:
          if (tn === $.CENTER || tn === $.FIGURE || tn === $.FOOTER || tn === $.HEADER || tn === $.HGROUP || tn === $.DIALOG) {
            addressEndTagInBody(p2, token2);
          } else if (tn === $.APPLET || tn === $.OBJECT) {
            appletEndTagInBody(p2, token2);
          } else if (tn === $.STRIKE || tn === $.STRONG) {
            callAdoptionAgency(p2, token2);
          } else {
            genericEndTagInBody(p2, token2);
          }
          break;
        case 7:
          if (tn === $.ADDRESS || tn === $.ARTICLE || tn === $.DETAILS || tn === $.SECTION || tn === $.SUMMARY || tn === $.LISTING) {
            addressEndTagInBody(p2, token2);
          } else if (tn === $.MARQUEE) {
            appletEndTagInBody(p2, token2);
          } else {
            genericEndTagInBody(p2, token2);
          }
          break;
        case 8:
          if (tn === $.FIELDSET) {
            addressEndTagInBody(p2, token2);
          } else if (tn === $.TEMPLATE) {
            endTagInHead(p2, token2);
          } else {
            genericEndTagInBody(p2, token2);
          }
          break;
        case 10:
          if (tn === $.BLOCKQUOTE || tn === $.FIGCAPTION) {
            addressEndTagInBody(p2, token2);
          } else {
            genericEndTagInBody(p2, token2);
          }
          break;
        default:
          genericEndTagInBody(p2, token2);
      }
    }
    function eofInBody(p2, token2) {
      if (p2.tmplInsertionModeStackTop > -1) {
        eofInTemplate(p2, token2);
      } else {
        p2.stopped = true;
      }
    }
    function endTagInText(p2, token2) {
      if (token2.tagName === $.SCRIPT) {
        p2.pendingScript = p2.openElements.current;
      }
      p2.openElements.pop();
      p2.insertionMode = p2.originalInsertionMode;
    }
    function eofInText(p2, token2) {
      p2._err(ERR.eofInElementThatCanContainOnlyText);
      p2.openElements.pop();
      p2.insertionMode = p2.originalInsertionMode;
      p2._processToken(token2);
    }
    function characterInTable(p2, token2) {
      const curTn = p2.openElements.currentTagName;
      if (curTn === $.TABLE || curTn === $.TBODY || curTn === $.TFOOT || curTn === $.THEAD || curTn === $.TR) {
        p2.pendingCharacterTokens = [];
        p2.hasNonWhitespacePendingCharacterToken = false;
        p2.originalInsertionMode = p2.insertionMode;
        p2.insertionMode = IN_TABLE_TEXT_MODE;
        p2._processToken(token2);
      } else {
        tokenInTable(p2, token2);
      }
    }
    function captionStartTagInTable(p2, token2) {
      p2.openElements.clearBackToTableContext();
      p2.activeFormattingElements.insertMarker();
      p2._insertElement(token2, NS.HTML);
      p2.insertionMode = IN_CAPTION_MODE;
    }
    function colgroupStartTagInTable(p2, token2) {
      p2.openElements.clearBackToTableContext();
      p2._insertElement(token2, NS.HTML);
      p2.insertionMode = IN_COLUMN_GROUP_MODE;
    }
    function colStartTagInTable(p2, token2) {
      p2.openElements.clearBackToTableContext();
      p2._insertFakeElement($.COLGROUP);
      p2.insertionMode = IN_COLUMN_GROUP_MODE;
      p2._processToken(token2);
    }
    function tbodyStartTagInTable(p2, token2) {
      p2.openElements.clearBackToTableContext();
      p2._insertElement(token2, NS.HTML);
      p2.insertionMode = IN_TABLE_BODY_MODE;
    }
    function tdStartTagInTable(p2, token2) {
      p2.openElements.clearBackToTableContext();
      p2._insertFakeElement($.TBODY);
      p2.insertionMode = IN_TABLE_BODY_MODE;
      p2._processToken(token2);
    }
    function tableStartTagInTable(p2, token2) {
      if (p2.openElements.hasInTableScope($.TABLE)) {
        p2.openElements.popUntilTagNamePopped($.TABLE);
        p2._resetInsertionMode();
        p2._processToken(token2);
      }
    }
    function inputStartTagInTable(p2, token2) {
      const inputType = Tokenizer.getTokenAttr(token2, ATTRS.TYPE);
      if (inputType && inputType.toLowerCase() === HIDDEN_INPUT_TYPE) {
        p2._appendElement(token2, NS.HTML);
      } else {
        tokenInTable(p2, token2);
      }
      token2.ackSelfClosing = true;
    }
    function formStartTagInTable(p2, token2) {
      if (!p2.formElement && p2.openElements.tmplCount === 0) {
        p2._insertElement(token2, NS.HTML);
        p2.formElement = p2.openElements.current;
        p2.openElements.pop();
      }
    }
    function startTagInTable(p2, token2) {
      const tn = token2.tagName;
      switch (tn.length) {
        case 2:
          if (tn === $.TD || tn === $.TH || tn === $.TR) {
            tdStartTagInTable(p2, token2);
          } else {
            tokenInTable(p2, token2);
          }
          break;
        case 3:
          if (tn === $.COL) {
            colStartTagInTable(p2, token2);
          } else {
            tokenInTable(p2, token2);
          }
          break;
        case 4:
          if (tn === $.FORM) {
            formStartTagInTable(p2, token2);
          } else {
            tokenInTable(p2, token2);
          }
          break;
        case 5:
          if (tn === $.TABLE) {
            tableStartTagInTable(p2, token2);
          } else if (tn === $.STYLE) {
            startTagInHead(p2, token2);
          } else if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {
            tbodyStartTagInTable(p2, token2);
          } else if (tn === $.INPUT) {
            inputStartTagInTable(p2, token2);
          } else {
            tokenInTable(p2, token2);
          }
          break;
        case 6:
          if (tn === $.SCRIPT) {
            startTagInHead(p2, token2);
          } else {
            tokenInTable(p2, token2);
          }
          break;
        case 7:
          if (tn === $.CAPTION) {
            captionStartTagInTable(p2, token2);
          } else {
            tokenInTable(p2, token2);
          }
          break;
        case 8:
          if (tn === $.COLGROUP) {
            colgroupStartTagInTable(p2, token2);
          } else if (tn === $.TEMPLATE) {
            startTagInHead(p2, token2);
          } else {
            tokenInTable(p2, token2);
          }
          break;
        default:
          tokenInTable(p2, token2);
      }
    }
    function endTagInTable(p2, token2) {
      const tn = token2.tagName;
      if (tn === $.TABLE) {
        if (p2.openElements.hasInTableScope($.TABLE)) {
          p2.openElements.popUntilTagNamePopped($.TABLE);
          p2._resetInsertionMode();
        }
      } else if (tn === $.TEMPLATE) {
        endTagInHead(p2, token2);
      } else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP && tn !== $.HTML && tn !== $.TBODY && tn !== $.TD && tn !== $.TFOOT && tn !== $.TH && tn !== $.THEAD && tn !== $.TR) {
        tokenInTable(p2, token2);
      }
    }
    function tokenInTable(p2, token2) {
      const savedFosterParentingState = p2.fosterParentingEnabled;
      p2.fosterParentingEnabled = true;
      p2._processTokenInBodyMode(token2);
      p2.fosterParentingEnabled = savedFosterParentingState;
    }
    function whitespaceCharacterInTableText(p2, token2) {
      p2.pendingCharacterTokens.push(token2);
    }
    function characterInTableText(p2, token2) {
      p2.pendingCharacterTokens.push(token2);
      p2.hasNonWhitespacePendingCharacterToken = true;
    }
    function tokenInTableText(p2, token2) {
      let i2 = 0;
      if (p2.hasNonWhitespacePendingCharacterToken) {
        for (; i2 < p2.pendingCharacterTokens.length; i2++) {
          tokenInTable(p2, p2.pendingCharacterTokens[i2]);
        }
      } else {
        for (; i2 < p2.pendingCharacterTokens.length; i2++) {
          p2._insertCharacters(p2.pendingCharacterTokens[i2]);
        }
      }
      p2.insertionMode = p2.originalInsertionMode;
      p2._processToken(token2);
    }
    function startTagInCaption(p2, token2) {
      const tn = token2.tagName;
      if (tn === $.CAPTION || tn === $.COL || tn === $.COLGROUP || tn === $.TBODY || tn === $.TD || tn === $.TFOOT || tn === $.TH || tn === $.THEAD || tn === $.TR) {
        if (p2.openElements.hasInTableScope($.CAPTION)) {
          p2.openElements.generateImpliedEndTags();
          p2.openElements.popUntilTagNamePopped($.CAPTION);
          p2.activeFormattingElements.clearToLastMarker();
          p2.insertionMode = IN_TABLE_MODE;
          p2._processToken(token2);
        }
      } else {
        startTagInBody(p2, token2);
      }
    }
    function endTagInCaption(p2, token2) {
      const tn = token2.tagName;
      if (tn === $.CAPTION || tn === $.TABLE) {
        if (p2.openElements.hasInTableScope($.CAPTION)) {
          p2.openElements.generateImpliedEndTags();
          p2.openElements.popUntilTagNamePopped($.CAPTION);
          p2.activeFormattingElements.clearToLastMarker();
          p2.insertionMode = IN_TABLE_MODE;
          if (tn === $.TABLE) {
            p2._processToken(token2);
          }
        }
      } else if (tn !== $.BODY && tn !== $.COL && tn !== $.COLGROUP && tn !== $.HTML && tn !== $.TBODY && tn !== $.TD && tn !== $.TFOOT && tn !== $.TH && tn !== $.THEAD && tn !== $.TR) {
        endTagInBody(p2, token2);
      }
    }
    function startTagInColumnGroup(p2, token2) {
      const tn = token2.tagName;
      if (tn === $.HTML) {
        startTagInBody(p2, token2);
      } else if (tn === $.COL) {
        p2._appendElement(token2, NS.HTML);
        token2.ackSelfClosing = true;
      } else if (tn === $.TEMPLATE) {
        startTagInHead(p2, token2);
      } else {
        tokenInColumnGroup(p2, token2);
      }
    }
    function endTagInColumnGroup(p2, token2) {
      const tn = token2.tagName;
      if (tn === $.COLGROUP) {
        if (p2.openElements.currentTagName === $.COLGROUP) {
          p2.openElements.pop();
          p2.insertionMode = IN_TABLE_MODE;
        }
      } else if (tn === $.TEMPLATE) {
        endTagInHead(p2, token2);
      } else if (tn !== $.COL) {
        tokenInColumnGroup(p2, token2);
      }
    }
    function tokenInColumnGroup(p2, token2) {
      if (p2.openElements.currentTagName === $.COLGROUP) {
        p2.openElements.pop();
        p2.insertionMode = IN_TABLE_MODE;
        p2._processToken(token2);
      }
    }
    function startTagInTableBody(p2, token2) {
      const tn = token2.tagName;
      if (tn === $.TR) {
        p2.openElements.clearBackToTableBodyContext();
        p2._insertElement(token2, NS.HTML);
        p2.insertionMode = IN_ROW_MODE;
      } else if (tn === $.TH || tn === $.TD) {
        p2.openElements.clearBackToTableBodyContext();
        p2._insertFakeElement($.TR);
        p2.insertionMode = IN_ROW_MODE;
        p2._processToken(token2);
      } else if (tn === $.CAPTION || tn === $.COL || tn === $.COLGROUP || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {
        if (p2.openElements.hasTableBodyContextInTableScope()) {
          p2.openElements.clearBackToTableBodyContext();
          p2.openElements.pop();
          p2.insertionMode = IN_TABLE_MODE;
          p2._processToken(token2);
        }
      } else {
        startTagInTable(p2, token2);
      }
    }
    function endTagInTableBody(p2, token2) {
      const tn = token2.tagName;
      if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {
        if (p2.openElements.hasInTableScope(tn)) {
          p2.openElements.clearBackToTableBodyContext();
          p2.openElements.pop();
          p2.insertionMode = IN_TABLE_MODE;
        }
      } else if (tn === $.TABLE) {
        if (p2.openElements.hasTableBodyContextInTableScope()) {
          p2.openElements.clearBackToTableBodyContext();
          p2.openElements.pop();
          p2.insertionMode = IN_TABLE_MODE;
          p2._processToken(token2);
        }
      } else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP || tn !== $.HTML && tn !== $.TD && tn !== $.TH && tn !== $.TR) {
        endTagInTable(p2, token2);
      }
    }
    function startTagInRow(p2, token2) {
      const tn = token2.tagName;
      if (tn === $.TH || tn === $.TD) {
        p2.openElements.clearBackToTableRowContext();
        p2._insertElement(token2, NS.HTML);
        p2.insertionMode = IN_CELL_MODE;
        p2.activeFormattingElements.insertMarker();
      } else if (tn === $.CAPTION || tn === $.COL || tn === $.COLGROUP || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR) {
        if (p2.openElements.hasInTableScope($.TR)) {
          p2.openElements.clearBackToTableRowContext();
          p2.openElements.pop();
          p2.insertionMode = IN_TABLE_BODY_MODE;
          p2._processToken(token2);
        }
      } else {
        startTagInTable(p2, token2);
      }
    }
    function endTagInRow(p2, token2) {
      const tn = token2.tagName;
      if (tn === $.TR) {
        if (p2.openElements.hasInTableScope($.TR)) {
          p2.openElements.clearBackToTableRowContext();
          p2.openElements.pop();
          p2.insertionMode = IN_TABLE_BODY_MODE;
        }
      } else if (tn === $.TABLE) {
        if (p2.openElements.hasInTableScope($.TR)) {
          p2.openElements.clearBackToTableRowContext();
          p2.openElements.pop();
          p2.insertionMode = IN_TABLE_BODY_MODE;
          p2._processToken(token2);
        }
      } else if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {
        if (p2.openElements.hasInTableScope(tn) || p2.openElements.hasInTableScope($.TR)) {
          p2.openElements.clearBackToTableRowContext();
          p2.openElements.pop();
          p2.insertionMode = IN_TABLE_BODY_MODE;
          p2._processToken(token2);
        }
      } else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP || tn !== $.HTML && tn !== $.TD && tn !== $.TH) {
        endTagInTable(p2, token2);
      }
    }
    function startTagInCell(p2, token2) {
      const tn = token2.tagName;
      if (tn === $.CAPTION || tn === $.COL || tn === $.COLGROUP || tn === $.TBODY || tn === $.TD || tn === $.TFOOT || tn === $.TH || tn === $.THEAD || tn === $.TR) {
        if (p2.openElements.hasInTableScope($.TD) || p2.openElements.hasInTableScope($.TH)) {
          p2._closeTableCell();
          p2._processToken(token2);
        }
      } else {
        startTagInBody(p2, token2);
      }
    }
    function endTagInCell(p2, token2) {
      const tn = token2.tagName;
      if (tn === $.TD || tn === $.TH) {
        if (p2.openElements.hasInTableScope(tn)) {
          p2.openElements.generateImpliedEndTags();
          p2.openElements.popUntilTagNamePopped(tn);
          p2.activeFormattingElements.clearToLastMarker();
          p2.insertionMode = IN_ROW_MODE;
        }
      } else if (tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR) {
        if (p2.openElements.hasInTableScope(tn)) {
          p2._closeTableCell();
          p2._processToken(token2);
        }
      } else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP && tn !== $.HTML) {
        endTagInBody(p2, token2);
      }
    }
    function startTagInSelect(p2, token2) {
      const tn = token2.tagName;
      if (tn === $.HTML) {
        startTagInBody(p2, token2);
      } else if (tn === $.OPTION) {
        if (p2.openElements.currentTagName === $.OPTION) {
          p2.openElements.pop();
        }
        p2._insertElement(token2, NS.HTML);
      } else if (tn === $.OPTGROUP) {
        if (p2.openElements.currentTagName === $.OPTION) {
          p2.openElements.pop();
        }
        if (p2.openElements.currentTagName === $.OPTGROUP) {
          p2.openElements.pop();
        }
        p2._insertElement(token2, NS.HTML);
      } else if (tn === $.INPUT || tn === $.KEYGEN || tn === $.TEXTAREA || tn === $.SELECT) {
        if (p2.openElements.hasInSelectScope($.SELECT)) {
          p2.openElements.popUntilTagNamePopped($.SELECT);
          p2._resetInsertionMode();
          if (tn !== $.SELECT) {
            p2._processToken(token2);
          }
        }
      } else if (tn === $.SCRIPT || tn === $.TEMPLATE) {
        startTagInHead(p2, token2);
      }
    }
    function endTagInSelect(p2, token2) {
      const tn = token2.tagName;
      if (tn === $.OPTGROUP) {
        const prevOpenElement = p2.openElements.items[p2.openElements.stackTop - 1];
        const prevOpenElementTn = prevOpenElement && p2.treeAdapter.getTagName(prevOpenElement);
        if (p2.openElements.currentTagName === $.OPTION && prevOpenElementTn === $.OPTGROUP) {
          p2.openElements.pop();
        }
        if (p2.openElements.currentTagName === $.OPTGROUP) {
          p2.openElements.pop();
        }
      } else if (tn === $.OPTION) {
        if (p2.openElements.currentTagName === $.OPTION) {
          p2.openElements.pop();
        }
      } else if (tn === $.SELECT && p2.openElements.hasInSelectScope($.SELECT)) {
        p2.openElements.popUntilTagNamePopped($.SELECT);
        p2._resetInsertionMode();
      } else if (tn === $.TEMPLATE) {
        endTagInHead(p2, token2);
      }
    }
    function startTagInSelectInTable(p2, token2) {
      const tn = token2.tagName;
      if (tn === $.CAPTION || tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR || tn === $.TD || tn === $.TH) {
        p2.openElements.popUntilTagNamePopped($.SELECT);
        p2._resetInsertionMode();
        p2._processToken(token2);
      } else {
        startTagInSelect(p2, token2);
      }
    }
    function endTagInSelectInTable(p2, token2) {
      const tn = token2.tagName;
      if (tn === $.CAPTION || tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR || tn === $.TD || tn === $.TH) {
        if (p2.openElements.hasInTableScope(tn)) {
          p2.openElements.popUntilTagNamePopped($.SELECT);
          p2._resetInsertionMode();
          p2._processToken(token2);
        }
      } else {
        endTagInSelect(p2, token2);
      }
    }
    function startTagInTemplate(p2, token2) {
      const tn = token2.tagName;
      if (tn === $.BASE || tn === $.BASEFONT || tn === $.BGSOUND || tn === $.LINK || tn === $.META || tn === $.NOFRAMES || tn === $.SCRIPT || tn === $.STYLE || tn === $.TEMPLATE || tn === $.TITLE) {
        startTagInHead(p2, token2);
      } else {
        const newInsertionMode = TEMPLATE_INSERTION_MODE_SWITCH_MAP[tn] || IN_BODY_MODE;
        p2._popTmplInsertionMode();
        p2._pushTmplInsertionMode(newInsertionMode);
        p2.insertionMode = newInsertionMode;
        p2._processToken(token2);
      }
    }
    function endTagInTemplate(p2, token2) {
      if (token2.tagName === $.TEMPLATE) {
        endTagInHead(p2, token2);
      }
    }
    function eofInTemplate(p2, token2) {
      if (p2.openElements.tmplCount > 0) {
        p2.openElements.popUntilTagNamePopped($.TEMPLATE);
        p2.activeFormattingElements.clearToLastMarker();
        p2._popTmplInsertionMode();
        p2._resetInsertionMode();
        p2._processToken(token2);
      } else {
        p2.stopped = true;
      }
    }
    function startTagAfterBody(p2, token2) {
      if (token2.tagName === $.HTML) {
        startTagInBody(p2, token2);
      } else {
        tokenAfterBody(p2, token2);
      }
    }
    function endTagAfterBody(p2, token2) {
      if (token2.tagName === $.HTML) {
        if (!p2.fragmentContext) {
          p2.insertionMode = AFTER_AFTER_BODY_MODE;
        }
      } else {
        tokenAfterBody(p2, token2);
      }
    }
    function tokenAfterBody(p2, token2) {
      p2.insertionMode = IN_BODY_MODE;
      p2._processToken(token2);
    }
    function startTagInFrameset(p2, token2) {
      const tn = token2.tagName;
      if (tn === $.HTML) {
        startTagInBody(p2, token2);
      } else if (tn === $.FRAMESET) {
        p2._insertElement(token2, NS.HTML);
      } else if (tn === $.FRAME) {
        p2._appendElement(token2, NS.HTML);
        token2.ackSelfClosing = true;
      } else if (tn === $.NOFRAMES) {
        startTagInHead(p2, token2);
      }
    }
    function endTagInFrameset(p2, token2) {
      if (token2.tagName === $.FRAMESET && !p2.openElements.isRootHtmlElementCurrent()) {
        p2.openElements.pop();
        if (!p2.fragmentContext && p2.openElements.currentTagName !== $.FRAMESET) {
          p2.insertionMode = AFTER_FRAMESET_MODE;
        }
      }
    }
    function startTagAfterFrameset(p2, token2) {
      const tn = token2.tagName;
      if (tn === $.HTML) {
        startTagInBody(p2, token2);
      } else if (tn === $.NOFRAMES) {
        startTagInHead(p2, token2);
      }
    }
    function endTagAfterFrameset(p2, token2) {
      if (token2.tagName === $.HTML) {
        p2.insertionMode = AFTER_AFTER_FRAMESET_MODE;
      }
    }
    function startTagAfterAfterBody(p2, token2) {
      if (token2.tagName === $.HTML) {
        startTagInBody(p2, token2);
      } else {
        tokenAfterAfterBody(p2, token2);
      }
    }
    function tokenAfterAfterBody(p2, token2) {
      p2.insertionMode = IN_BODY_MODE;
      p2._processToken(token2);
    }
    function startTagAfterAfterFrameset(p2, token2) {
      const tn = token2.tagName;
      if (tn === $.HTML) {
        startTagInBody(p2, token2);
      } else if (tn === $.NOFRAMES) {
        startTagInHead(p2, token2);
      }
    }
    function nullCharacterInForeignContent(p2, token2) {
      token2.chars = unicode.REPLACEMENT_CHARACTER;
      p2._insertCharacters(token2);
    }
    function characterInForeignContent(p2, token2) {
      p2._insertCharacters(token2);
      p2.framesetOk = false;
    }
    function startTagInForeignContent(p2, token2) {
      if (foreignContent.causesExit(token2) && !p2.fragmentContext) {
        while (p2.treeAdapter.getNamespaceURI(p2.openElements.current) !== NS.HTML && !p2._isIntegrationPoint(p2.openElements.current)) {
          p2.openElements.pop();
        }
        p2._processToken(token2);
      } else {
        const current = p2._getAdjustedCurrentElement();
        const currentNs = p2.treeAdapter.getNamespaceURI(current);
        if (currentNs === NS.MATHML) {
          foreignContent.adjustTokenMathMLAttrs(token2);
        } else if (currentNs === NS.SVG) {
          foreignContent.adjustTokenSVGTagName(token2);
          foreignContent.adjustTokenSVGAttrs(token2);
        }
        foreignContent.adjustTokenXMLAttrs(token2);
        if (token2.selfClosing) {
          p2._appendElement(token2, currentNs);
        } else {
          p2._insertElement(token2, currentNs);
        }
        token2.ackSelfClosing = true;
      }
    }
    function endTagInForeignContent(p2, token2) {
      for (let i2 = p2.openElements.stackTop; i2 > 0; i2--) {
        const element2 = p2.openElements.items[i2];
        if (p2.treeAdapter.getNamespaceURI(element2) === NS.HTML) {
          p2._processToken(token2);
          break;
        }
        if (p2.treeAdapter.getTagName(element2).toLowerCase() === token2.tagName) {
          p2.openElements.popUntilElementPopped(element2);
          break;
        }
      }
    }
    const Parser$1 = /* @__PURE__ */ getDefaultExportFromCjs(parser);
    function location$1(file) {
      var value = String(file);
      var indices = [];
      var search2 = /\r?\n|\r/g;
      while (search2.test(value)) {
        indices.push(search2.lastIndex);
      }
      indices.push(value.length + 1);
      return { toPoint, toOffset };
      function toPoint(offset2) {
        var index2 = -1;
        if (offset2 > -1 && offset2 < indices[indices.length - 1]) {
          while (++index2 < indices.length) {
            if (indices[index2] > offset2) {
              return {
                line: index2 + 1,
                column: offset2 - (indices[index2 - 1] || 0) + 1,
                offset: offset2
              };
            }
          }
        }
        return { line: void 0, column: void 0, offset: void 0 };
      }
      function toOffset(point2) {
        var line2 = point2 && point2.line;
        var column2 = point2 && point2.column;
        var offset2;
        if (typeof line2 === "number" && typeof column2 === "number" && !Number.isNaN(line2) && !Number.isNaN(column2) && line2 - 1 in indices) {
          offset2 = (indices[line2 - 2] || 0) + column2 - 1 || 0;
        }
        return offset2 > -1 && offset2 < indices[indices.length - 1] ? offset2 : -1;
      }
    }
    var webNamespaces = {
      html: "http://www.w3.org/1999/xhtml",
      mathml: "http://www.w3.org/1998/Math/MathML",
      svg: "http://www.w3.org/2000/svg",
      xlink: "http://www.w3.org/1999/xlink",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/"
    };
    const own$5 = {}.hasOwnProperty;
    const map = {
      "#document": root$2,
      "#document-fragment": root$2,
      "#text": text$3,
      "#comment": comment$1,
      "#documentType": doctype$1
    };
    function fromParse5(ast, options = {}) {
      let settings;
      let file;
      if (isFile(options)) {
        file = options;
        settings = {};
      } else {
        file = options.file;
        settings = options;
      }
      return transform$1(
        {
          schema: settings.space === "svg" ? svg : html$1,
          file,
          verbose: settings.verbose,
          location: false
        },
        ast
      );
    }
    function transform$1(ctx, ast) {
      const schema = ctx.schema;
      const fn = own$5.call(map, ast.nodeName) ? map[ast.nodeName] : element$2;
      let children;
      if ("tagName" in ast) {
        ctx.schema = ast.namespaceURI === webNamespaces.svg ? svg : html$1;
      }
      if ("childNodes" in ast) {
        children = nodes(ctx, ast.childNodes);
      }
      const result = fn(ctx, ast, children);
      if ("sourceCodeLocation" in ast && ast.sourceCodeLocation && ctx.file) {
        const position2 = createLocation(ctx, result, ast.sourceCodeLocation);
        if (position2) {
          ctx.location = true;
          result.position = position2;
        }
      }
      ctx.schema = schema;
      return result;
    }
    function nodes(ctx, children) {
      let index2 = -1;
      const result = [];
      while (++index2 < children.length) {
        result[index2] = transform$1(ctx, children[index2]);
      }
      return result;
    }
    function root$2(ctx, ast, children) {
      const result = {
        type: "root",
        children,
        data: { quirksMode: ast.mode === "quirks" || ast.mode === "limited-quirks" }
      };
      if (ctx.file && ctx.location) {
        const doc = String(ctx.file);
        const loc = location$1(doc);
        result.position = {
          start: loc.toPoint(0),
          end: loc.toPoint(doc.length)
        };
      }
      return result;
    }
    function doctype$1() {
      return { type: "doctype" };
    }
    function text$3(_2, ast) {
      return { type: "text", value: ast.value };
    }
    function comment$1(_2, ast) {
      return { type: "comment", value: ast.data };
    }
    function element$2(ctx, ast, children) {
      const fn = ctx.schema.space === "svg" ? s : h;
      let index2 = -1;
      const props = {};
      while (++index2 < ast.attrs.length) {
        const attribute = ast.attrs[index2];
        props[(attribute.prefix ? attribute.prefix + ":" : "") + attribute.name] = attribute.value;
      }
      const result = fn(ast.tagName, props, children);
      if (result.tagName === "template" && "content" in ast) {
        const pos = ast.sourceCodeLocation;
        const startTag2 = pos && pos.startTag && position(pos.startTag);
        const endTag2 = pos && pos.endTag && position(pos.endTag);
        const content2 = transform$1(ctx, ast.content);
        if (startTag2 && endTag2 && ctx.file) {
          content2.position = { start: startTag2.end, end: endTag2.start };
        }
        result.content = content2;
      }
      return result;
    }
    function createLocation(ctx, node2, location2) {
      const result = position(location2);
      if (node2.type === "element") {
        const tail = node2.children[node2.children.length - 1];
        if (result && !location2.endTag && tail && tail.position && tail.position.end) {
          result.end = Object.assign({}, tail.position.end);
        }
        if (ctx.verbose) {
          const props = {};
          let key;
          for (key in location2.attrs) {
            if (own$5.call(location2.attrs, key)) {
              props[find(ctx.schema, key).property] = position(location2.attrs[key]);
            }
          }
          node2.data = {
            position: {
              opening: position(location2.startTag),
              closing: location2.endTag ? position(location2.endTag) : null,
              properties: props
            }
          };
        }
      }
      return result;
    }
    function position(loc) {
      const start = point({
        line: loc.startLine,
        column: loc.startCol,
        offset: loc.startOffset
      });
      const end = point({
        line: loc.endLine,
        column: loc.endCol,
        offset: loc.endOffset
      });
      return start || end ? { start, end } : null;
    }
    function point(point2) {
      return point2.line && point2.column ? point2 : null;
    }
    function isFile(value) {
      return "messages" in value;
    }
    var parse = inlineStyleParser;
    function StyleToObject(style2, iterator) {
      var output = null;
      if (!style2 || typeof style2 !== "string") {
        return output;
      }
      var declaration2;
      var declarations = parse(style2);
      var hasIterator = typeof iterator === "function";
      var property;
      var value;
      for (var i2 = 0, len = declarations.length; i2 < len; i2++) {
        declaration2 = declarations[i2];
        property = declaration2.property;
        value = declaration2.value;
        if (hasIterator) {
          iterator(property, value, declaration2);
        } else if (value) {
          output || (output = {});
          output[property] = value;
        }
      }
      return output;
    }
    var styleToObject = StyleToObject;
    const style = /* @__PURE__ */ getDefaultExportFromCjs(styleToObject);
    const ns = (
      /** @type {Record<string, string>} */
      webNamespaces
    );
    const toReact = (
      /** @type {Record<string, string>} */
      hastToReact
    );
    const own$4 = {}.hasOwnProperty;
    const root$1 = convert("root");
    const element$1 = convert("element");
    const text$2 = convert("text");
    function toH(h2, tree, options) {
      if (typeof h2 !== "function") {
        throw new TypeError("h is not a function");
      }
      const r2 = react(h2);
      const v2 = vue(h2);
      const vd2 = vdom(h2);
      let prefix2;
      let node2;
      if (typeof options === "string" || typeof options === "boolean") {
        prefix2 = options;
        options = {};
      } else {
        if (!options)
          options = {};
        prefix2 = options.prefix;
      }
      if (root$1(tree)) {
        node2 = tree.children.length === 1 && element$1(tree.children[0]) ? tree.children[0] : {
          type: "element",
          tagName: "div",
          properties: {},
          children: tree.children
        };
      } else if (element$1(tree)) {
        node2 = tree;
      } else {
        throw new Error(
          // @ts-expect-error runtime.
          "Expected root or element, not `" + (tree && tree.type || tree) + "`"
        );
      }
      return transform(h2, node2, {
        schema: options.space === "svg" ? svg : html$1,
        prefix: prefix2 === void 0 || prefix2 === null ? r2 || v2 || vd2 ? "h-" : null : typeof prefix2 === "string" ? prefix2 : prefix2 ? "h-" : null,
        key: 0,
        react: r2,
        vue: v2,
        vdom: vd2,
        hyperscript: hyperscript(h2)
      });
    }
    function transform(h2, node2, ctx) {
      const parentSchema = ctx.schema;
      let schema = parentSchema;
      let name2 = node2.tagName;
      const attributes2 = {};
      const nodes2 = [];
      let index2 = -1;
      let key;
      if (parentSchema.space === "html" && name2.toLowerCase() === "svg") {
        schema = svg;
        ctx.schema = schema;
      }
      for (key in node2.properties) {
        if (node2.properties && own$4.call(node2.properties, key)) {
          addAttribute(attributes2, key, node2.properties[key], ctx, name2);
        }
      }
      if (ctx.vdom) {
        if (schema.space === "html") {
          name2 = name2.toUpperCase();
        } else if (schema.space) {
          attributes2.namespace = ns[schema.space];
        }
      }
      if (ctx.prefix) {
        ctx.key++;
        attributes2.key = ctx.prefix + ctx.key;
      }
      if (node2.children) {
        while (++index2 < node2.children.length) {
          const value = node2.children[index2];
          if (element$1(value)) {
            nodes2.push(transform(h2, value, ctx));
          } else if (text$2(value)) {
            nodes2.push(value.value);
          }
        }
      }
      ctx.schema = parentSchema;
      return nodes2.length > 0 ? h2.call(node2, name2, attributes2, nodes2) : h2.call(node2, name2, attributes2);
    }
    function addAttribute(props, prop, value, ctx, name2) {
      const info = find(ctx.schema, prop);
      let subprop;
      if (value === void 0 || value === null || typeof value === "number" && Number.isNaN(value) || value === false && (ctx.vue || ctx.vdom || ctx.hyperscript) || !value && info.boolean && (ctx.vue || ctx.vdom || ctx.hyperscript)) {
        return;
      }
      if (Array.isArray(value)) {
        value = info.commaSeparated ? stringify$1(value) : stringify$2(value);
      }
      if (info.boolean && ctx.hyperscript) {
        value = "";
      }
      if (info.property === "style" && typeof value === "string" && (ctx.react || ctx.vue || ctx.vdom)) {
        value = parseStyle(value, name2);
      }
      if (ctx.vue) {
        if (info.property !== "style")
          subprop = "attrs";
      } else if (!info.mustUseProperty) {
        if (ctx.vdom) {
          if (info.property !== "style")
            subprop = "attributes";
        } else if (ctx.hyperscript) {
          subprop = "attrs";
        }
      }
      if (subprop) {
        props[subprop] = Object.assign(props[subprop] || {}, {
          [info.attribute]: value
        });
      } else if (info.space && ctx.react) {
        props[toReact[info.property] || info.property] = value;
      } else {
        props[info.attribute] = value;
      }
    }
    function react(h2) {
      const node2 = h2("div", {});
      return Boolean(
        node2 && // @ts-expect-error Looks like a React node.
        ("_owner" in node2 || "_store" in node2) && // @ts-expect-error Looks like a React node.
        (node2.key === void 0 || node2.key === null)
      );
    }
    function hyperscript(h2) {
      return "context" in h2 && "cleanup" in h2;
    }
    function vdom(h2) {
      const node2 = h2("div", {});
      return node2.type === "VirtualNode";
    }
    function vue(h2) {
      const node2 = h2("div", {});
      return Boolean(node2 && node2.context && node2.context._isVue);
    }
    function parseStyle(value, tagName) {
      const result = {};
      try {
        style(value, (name2, value2) => {
          if (name2.slice(0, 4) === "-ms-")
            name2 = "ms-" + name2.slice(4);
          result[name2.replace(
            /-([a-z])/g,
            /**
             * @param {string} _
             * @param {string} $1
             * @returns {string}
             */
            (_2, $1) => $1.toUpperCase()
          )] = value2;
        });
      } catch (error) {
        error.message = tagName + "[style]" + error.message.slice("undefined".length);
        throw error;
      }
      return result;
    }
    var own$3 = {}.hasOwnProperty;
    function zwitch(key, options) {
      var settings = options || {};
      function one2(value) {
        var fn = one2.invalid;
        var handlers2 = one2.handlers;
        if (value && own$3.call(value, key)) {
          fn = own$3.call(handlers2, value[key]) ? handlers2[value[key]] : one2.unknown;
        }
        if (fn) {
          return fn.apply(this, arguments);
        }
      }
      one2.handlers = settings.handlers || {};
      one2.invalid = settings.invalid;
      one2.unknown = settings.unknown;
      return one2;
    }
    var own$2 = {}.hasOwnProperty;
    var one = zwitch("type", { handlers: { root, element, text: text$1, comment, doctype } });
    function toParse5(tree, space2) {
      return one(tree, space2 === "svg" ? svg : html$1);
    }
    function root(node2, schema) {
      var p5 = {
        nodeName: "#document",
        mode: (node2.data || {}).quirksMode ? "quirks" : "no-quirks",
        childNodes: []
      };
      p5.childNodes = all(node2.children, p5, schema);
      return patch(node2, p5);
    }
    function fragment(node2, schema) {
      var p5 = { nodeName: "#document-fragment", childNodes: [] };
      p5.childNodes = all(node2.children, p5, schema);
      return patch(node2, p5);
    }
    function doctype(node2) {
      return patch(node2, {
        nodeName: "#documentType",
        name: "html",
        publicId: "",
        systemId: "",
        parentNode: void 0
      });
    }
    function text$1(node2) {
      return patch(node2, {
        nodeName: "#text",
        value: node2.value,
        parentNode: void 0
      });
    }
    function comment(node2) {
      return patch(node2, {
        nodeName: "#comment",
        data: node2.value,
        parentNode: void 0
      });
    }
    function element(node2, schema) {
      var space2 = schema.space;
      return toH(h2, Object.assign({}, node2, { children: [] }), { space: space2 });
      function h2(name2, attrs) {
        var values = [];
        var info;
        var value;
        var key;
        var index2;
        var p5;
        for (key in attrs) {
          if (!own$2.call(attrs, key) || attrs[key] === false) {
            continue;
          }
          info = find(schema, key);
          if (info.boolean && !attrs[key]) {
            continue;
          }
          value = { name: key, value: attrs[key] === true ? "" : String(attrs[key]) };
          if (info.space && info.space !== "html" && info.space !== "svg") {
            index2 = key.indexOf(":");
            if (index2 < 0) {
              value.prefix = "";
            } else {
              value.name = key.slice(index2 + 1);
              value.prefix = key.slice(0, index2);
            }
            value.namespace = webNamespaces[info.space];
          }
          values.push(value);
        }
        if (schema.space === "html" && node2.tagName === "svg")
          schema = svg;
        p5 = patch(node2, {
          nodeName: name2,
          tagName: name2,
          attrs: values,
          namespaceURI: webNamespaces[schema.space],
          childNodes: [],
          parentNode: void 0
        });
        p5.childNodes = all(node2.children, p5, schema);
        if (name2 === "template")
          p5.content = fragment(node2.content, schema);
        return p5;
      }
    }
    function all(children, p5, schema) {
      var index2 = -1;
      var result = [];
      var child;
      if (children) {
        while (++index2 < children.length) {
          child = one(children[index2], schema);
          child.parentNode = p5;
          result.push(child);
        }
      }
      return result;
    }
    function patch(node2, p5) {
      var position2 = node2.position;
      if (position2 && position2.start && position2.end) {
        p5.sourceCodeLocation = {
          startLine: position2.start.line,
          startCol: position2.start.column,
          startOffset: position2.start.offset,
          endLine: position2.end.line,
          endCol: position2.end.column,
          endOffset: position2.end.offset
        };
      }
      return p5;
    }
    var htmlVoidElements = [
      "area",
      "base",
      "basefont",
      "bgsound",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "image",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "menuitem",
      "meta",
      "nextid",
      "param",
      "source",
      "track",
      "wbr"
    ];
    const inTemplateMode = "IN_TEMPLATE_MODE";
    const dataState = "DATA_STATE";
    const characterToken = "CHARACTER_TOKEN";
    const startTagToken = "START_TAG_TOKEN";
    const endTagToken = "END_TAG_TOKEN";
    const commentToken = "COMMENT_TOKEN";
    const doctypeToken = "DOCTYPE_TOKEN";
    const parseOptions = { sourceCodeLocationInfo: true, scriptingEnabled: false };
    const raw = (
      /**
       * @type {(
       *   ((tree: Node, file: VFile|undefined, options?: Options) => Node) &
       *   ((tree: Node, options?: Options) => Node)
       * )}
       */
      /**
       * @param {Node} tree
       * @param {VFile} [file]
       * @param {Options} [options]
       */
      function(tree, file, options) {
        let index2 = -1;
        const parser2 = new Parser$1(parseOptions);
        const one2 = zwitch("type", {
          // @ts-expect-error: hush.
          handlers: { root: root2, element: element2, text: text2, comment: comment2, doctype: doctype2, raw: handleRaw },
          // @ts-expect-error: hush.
          unknown
        });
        let stitches;
        let tokenizer2;
        let preprocessor2;
        let posTracker;
        let locationTracker;
        if (isOptions(file)) {
          options = file;
          file = void 0;
        }
        if (options && options.passThrough) {
          while (++index2 < options.passThrough.length) {
            one2.handlers[options.passThrough[index2]] = stitch;
          }
        }
        const result = fromParse5(
          documentMode(tree) ? document2() : fragment2(),
          file
        );
        if (stitches) {
          visit$1(result, "comment", (node2, index3, parent) => {
            const stitch2 = (
              /** @type {Stitch} */
              /** @type {unknown} */
              node2
            );
            if (stitch2.value.stitch && parent !== null && index3 !== null) {
              parent.children[index3] = stitch2.value.stitch;
              return index3;
            }
          });
        }
        if (tree.type !== "root" && result.type === "root" && result.children.length === 1) {
          return result.children[0];
        }
        return result;
        function fragment2() {
          const context = {
            nodeName: "template",
            tagName: "template",
            attrs: [],
            namespaceURI: webNamespaces.html,
            childNodes: []
          };
          const mock = {
            nodeName: "documentmock",
            tagName: "documentmock",
            attrs: [],
            namespaceURI: webNamespaces.html,
            childNodes: []
          };
          const doc = { nodeName: "#document-fragment", childNodes: [] };
          parser2._bootstrap(mock, context);
          parser2._pushTmplInsertionMode(inTemplateMode);
          parser2._initTokenizerForFragmentParsing();
          parser2._insertFakeRootElement();
          parser2._resetInsertionMode();
          parser2._findFormInFragmentContext();
          tokenizer2 = parser2.tokenizer;
          if (!tokenizer2)
            throw new Error("Expected `tokenizer`");
          preprocessor2 = tokenizer2.preprocessor;
          locationTracker = tokenizer2.__mixins[0];
          posTracker = locationTracker.posTracker;
          one2(tree);
          parser2._adoptNodes(mock.childNodes[0], doc);
          return doc;
        }
        function document2() {
          const doc = parser2.treeAdapter.createDocument();
          parser2._bootstrap(doc, void 0);
          tokenizer2 = parser2.tokenizer;
          if (!tokenizer2)
            throw new Error("Expected `tokenizer`");
          preprocessor2 = tokenizer2.preprocessor;
          locationTracker = tokenizer2.__mixins[0];
          posTracker = locationTracker.posTracker;
          one2(tree);
          return doc;
        }
        function all2(nodes2) {
          let index3 = -1;
          if (nodes2) {
            while (++index3 < nodes2.length) {
              one2(nodes2[index3]);
            }
          }
        }
        function root2(node2) {
          all2(node2.children);
        }
        function element2(node2) {
          resetTokenizer();
          parser2._processToken(startTag(node2), webNamespaces.html);
          all2(node2.children);
          if (!htmlVoidElements.includes(node2.tagName)) {
            resetTokenizer();
            parser2._processToken(endTag(node2));
          }
        }
        function text2(node2) {
          resetTokenizer();
          parser2._processToken({
            type: characterToken,
            chars: node2.value,
            location: createParse5Location(node2)
          });
        }
        function doctype2(node2) {
          resetTokenizer();
          parser2._processToken({
            type: doctypeToken,
            name: "html",
            forceQuirks: false,
            publicId: "",
            systemId: "",
            location: createParse5Location(node2)
          });
        }
        function comment2(node2) {
          resetTokenizer();
          parser2._processToken({
            type: commentToken,
            data: node2.value,
            location: createParse5Location(node2)
          });
        }
        function handleRaw(node2) {
          const start = pointStart(node2);
          const line2 = start.line || 1;
          const column2 = start.column || 1;
          const offset2 = start.offset || 0;
          if (!preprocessor2)
            throw new Error("Expected `preprocessor`");
          if (!tokenizer2)
            throw new Error("Expected `tokenizer`");
          if (!posTracker)
            throw new Error("Expected `posTracker`");
          if (!locationTracker)
            throw new Error("Expected `locationTracker`");
          preprocessor2.html = void 0;
          preprocessor2.pos = -1;
          preprocessor2.lastGapPos = -1;
          preprocessor2.lastCharPos = -1;
          preprocessor2.gapStack = [];
          preprocessor2.skipNextNewLine = false;
          preprocessor2.lastChunkWritten = false;
          preprocessor2.endOfChunkHit = false;
          posTracker.isEol = false;
          posTracker.lineStartPos = -column2 + 1;
          posTracker.droppedBufferSize = offset2;
          posTracker.offset = 0;
          posTracker.col = 1;
          posTracker.line = line2;
          locationTracker.currentAttrLocation = void 0;
          locationTracker.ctLoc = createParse5Location(node2);
          tokenizer2.write(node2.value);
          parser2._runParsingLoop(void 0);
          const token2 = tokenizer2.currentCharacterToken;
          if (token2) {
            token2.location.endLine = posTracker.line;
            token2.location.endCol = posTracker.col + 1;
            token2.location.endOffset = posTracker.offset + 1;
            parser2._processToken(token2);
          }
        }
        function stitch(node2) {
          stitches = true;
          let clone2;
          if ("children" in node2) {
            clone2 = {
              ...node2,
              children: raw(
                { type: "root", children: node2.children },
                file,
                options
                // @ts-expect-error Assume a given parent yields a parent.
              ).children
            };
          } else {
            clone2 = { ...node2 };
          }
          comment2({ type: "comment", value: { stitch: clone2 } });
        }
        function resetTokenizer() {
          if (!tokenizer2)
            throw new Error("Expected `tokenizer`");
          tokenizer2.tokenQueue = [];
          tokenizer2.state = dataState;
          tokenizer2.returnState = "";
          tokenizer2.charRefCode = -1;
          tokenizer2.tempBuff = [];
          tokenizer2.lastStartTagName = "";
          tokenizer2.consumedAfterSnapshot = -1;
          tokenizer2.active = false;
          tokenizer2.currentCharacterToken = void 0;
          tokenizer2.currentToken = void 0;
          tokenizer2.currentAttr = void 0;
        }
      }
    );
    function startTag(node2) {
      const location2 = Object.assign(createParse5Location(node2));
      location2.startTag = Object.assign({}, location2);
      return {
        type: startTagToken,
        tagName: node2.tagName,
        selfClosing: false,
        attrs: attributes(node2),
        location: location2
      };
    }
    function attributes(node2) {
      return toParse5({
        tagName: node2.tagName,
        type: "element",
        properties: node2.properties,
        children: []
        // @ts-expect-error Assume element.
      }).attrs;
    }
    function endTag(node2) {
      const location2 = Object.assign(createParse5Location(node2));
      location2.startTag = Object.assign({}, location2);
      return {
        type: endTagToken,
        tagName: node2.tagName,
        attrs: [],
        location: location2
      };
    }
    function unknown(node2) {
      throw new Error("Cannot compile `" + node2.type + "` node");
    }
    function documentMode(node2) {
      const head = node2.type === "root" ? node2.children[0] : node2;
      return Boolean(
        head && (head.type === "doctype" || head.type === "element" && head.tagName === "html")
      );
    }
    function createParse5Location(node2) {
      const start = pointStart(node2);
      const end = pointEnd(node2);
      return {
        startLine: start.line,
        startCol: start.column,
        startOffset: start.offset,
        endLine: end.line,
        endCol: end.column,
        endOffset: end.offset
      };
    }
    function isOptions(value) {
      return Boolean(value && !("message" in value && "messages" in value));
    }
    function rehypeRaw(options = {}) {
      return (tree, file) => {
        const result = (
          /** @type {Root} */
          raw(tree, file, options)
        );
        return result;
      };
    }
    var hasOwnProperty = {}.hasOwnProperty;
    var miniflat_1 = miniflat$1;
    function miniflat$1(value) {
      return value === null || value === void 0 ? [] : "length" in value ? value : [value];
    }
    var chunkedSplice_1 = chunkedSplice$2;
    var v8MaxSafeChunkSize = 1e4;
    function chunkedSplice$2(list2, start, remove, items) {
      var end = list2.length;
      var chunkStart = 0;
      var result;
      var parameters;
      if (start < 0) {
        start = -start > end ? 0 : end + start;
      } else {
        start = start > end ? end : start;
      }
      remove = remove > 0 ? remove : 0;
      if (items.length < v8MaxSafeChunkSize) {
        parameters = Array.from(items);
        parameters.unshift(start, remove);
        return [].splice.apply(list2, parameters);
      }
      result = [].splice.apply(list2, [start, remove]);
      while (chunkStart < items.length) {
        parameters = items.slice(chunkStart, chunkStart + v8MaxSafeChunkSize);
        parameters.unshift(start, 0);
        [].splice.apply(list2, parameters);
        chunkStart += v8MaxSafeChunkSize;
        start += v8MaxSafeChunkSize;
      }
      return result;
    }
    var combineExtensions_1 = combineExtensions;
    var own$1 = hasOwnProperty;
    var miniflat = miniflat_1;
    var chunkedSplice$1 = chunkedSplice_1;
    function combineExtensions(extensions) {
      var all2 = {};
      var index2 = -1;
      while (++index2 < extensions.length) {
        extension$1(all2, extensions[index2]);
      }
      return all2;
    }
    function extension$1(all2, extension2) {
      var hook;
      var left;
      var right;
      var code2;
      for (hook in extension2) {
        left = own$1.call(all2, hook) ? all2[hook] : all2[hook] = {};
        right = extension2[hook];
        for (code2 in right) {
          left[code2] = constructs(
            miniflat(right[code2]),
            own$1.call(left, code2) ? left[code2] : []
          );
        }
      }
    }
    function constructs(list2, existing) {
      var index2 = -1;
      var before = [];
      while (++index2 < list2.length) {
        (list2[index2].add === "after" ? existing : before).push(list2[index2]);
      }
      chunkedSplice$1(existing, 0, 0, before);
      return existing;
    }
    var syntax$4 = {};
    var fromCharCode$1 = String.fromCharCode;
    var regexCheck_1 = regexCheck;
    var fromCharCode = fromCharCode$1;
    function regexCheck(regex2) {
      return check2;
      function check2(code2) {
        return regex2.test(fromCharCode(code2));
      }
    }
    var check$3 = regexCheck_1;
    var asciiAlphanumeric$1 = check$3(/[\dA-Za-z]/);
    var check$2 = regexCheck_1;
    var asciiAlpha$1 = check$2(/[A-Za-z]/);
    var asciiAlphanumeric = asciiAlphanumeric$1;
    var asciiAlpha = asciiAlpha$1;
    var domain = { tokenize: tokenizeDomain };
    var path = { tokenize: tokenizePath };
    var punctuation = { tokenize: tokenizePunctuation };
    var paren = { tokenize: tokenizeParen };
    var namedCharacterReference = { tokenize: tokenizeNamedCharacterReference };
    var wwwAutolink = { tokenize: tokenizeWwwAutolink, previous };
    var httpAutolink = { tokenize: tokenizeHttpAutolink, previous };
    var emailAutolink = { tokenize: tokenizeEmailAutolink, previous };
    var text = {};
    syntax$4.text = text;
    var code = 48;
    while (code < 123) {
      text[code] = emailAutolink;
      code++;
      if (code === 58)
        code = 65;
      else if (code === 91)
        code = 97;
    }
    text[43] = emailAutolink;
    text[45] = emailAutolink;
    text[46] = emailAutolink;
    text[95] = emailAutolink;
    text[72] = [emailAutolink, httpAutolink];
    text[104] = [emailAutolink, httpAutolink];
    text[87] = [emailAutolink, wwwAutolink];
    text[119] = [emailAutolink, wwwAutolink];
    function tokenizeEmailAutolink(effects, ok2, nok) {
      var self2 = this;
      var hasDot;
      return start;
      function start(code2) {
        if (!gfmAtext(code2) || !previous(self2.previous)) {
          return nok(code2);
        }
        effects.enter("literalAutolink");
        effects.enter("literalAutolinkEmail");
        return atext(code2);
      }
      function atext(code2) {
        if (gfmAtext(code2)) {
          effects.consume(code2);
          return atext;
        }
        if (code2 === 64) {
          effects.consume(code2);
          return label;
        }
        return nok(code2);
      }
      function label(code2) {
        if (code2 === 46) {
          return effects.check(punctuation, done, dotContinuation)(code2);
        }
        if (
          // `-`
          code2 === 45 || // `_`
          code2 === 95
        ) {
          return effects.check(punctuation, nok, dashOrUnderscoreContinuation)(code2);
        }
        if (asciiAlphanumeric(code2)) {
          effects.consume(code2);
          return label;
        }
        return done(code2);
      }
      function dotContinuation(code2) {
        effects.consume(code2);
        hasDot = true;
        return label;
      }
      function dashOrUnderscoreContinuation(code2) {
        effects.consume(code2);
        return afterDashOrUnderscore;
      }
      function afterDashOrUnderscore(code2) {
        if (code2 === 46) {
          return effects.check(punctuation, nok, dotContinuation)(code2);
        }
        return label(code2);
      }
      function done(code2) {
        if (hasDot) {
          effects.exit("literalAutolinkEmail");
          effects.exit("literalAutolink");
          return ok2(code2);
        }
        return nok(code2);
      }
    }
    function tokenizeWwwAutolink(effects, ok2, nok) {
      var self2 = this;
      return start;
      function start(code2) {
        if (code2 !== 87 && code2 - 32 !== 87 || !previous(self2.previous)) {
          return nok(code2);
        }
        effects.enter("literalAutolink");
        effects.enter("literalAutolinkWww");
        effects.consume(code2);
        return w2;
      }
      function w2(code2) {
        if (code2 === 87 || code2 - 32 === 87) {
          effects.consume(code2);
          return w3;
        }
        return nok(code2);
      }
      function w3(code2) {
        if (code2 === 87 || code2 - 32 === 87) {
          effects.consume(code2);
          return dot;
        }
        return nok(code2);
      }
      function dot(code2) {
        if (code2 === 46) {
          effects.consume(code2);
          return effects.attempt(domain, effects.attempt(path, done), nok);
        }
        return nok(code2);
      }
      function done(code2) {
        effects.exit("literalAutolinkWww");
        effects.exit("literalAutolink");
        return ok2(code2);
      }
    }
    function tokenizeHttpAutolink(effects, ok2, nok) {
      var self2 = this;
      return start;
      function start(code2) {
        if (code2 !== 72 && code2 - 32 !== 72 || !previous(self2.previous)) {
          return nok(code2);
        }
        effects.enter("literalAutolink");
        effects.enter("literalAutolinkHttp");
        effects.consume(code2);
        return t1;
      }
      function t1(code2) {
        if (code2 === 84 || code2 - 32 === 84) {
          effects.consume(code2);
          return t2;
        }
        return nok(code2);
      }
      function t2(code2) {
        if (code2 === 84 || code2 - 32 === 84) {
          effects.consume(code2);
          return p2;
        }
        return nok(code2);
      }
      function p2(code2) {
        if (code2 === 80 || code2 - 32 === 80) {
          effects.consume(code2);
          return s2;
        }
        return nok(code2);
      }
      function s2(code2) {
        if (code2 === 83 || code2 - 32 === 83) {
          effects.consume(code2);
          return colon2;
        }
        return colon2(code2);
      }
      function colon2(code2) {
        if (code2 === 58) {
          effects.consume(code2);
          return slash1;
        }
        return nok(code2);
      }
      function slash1(code2) {
        if (code2 === 47) {
          effects.consume(code2);
          return slash2;
        }
        return nok(code2);
      }
      function slash2(code2) {
        if (code2 === 47) {
          effects.consume(code2);
          return effects.attempt(domain, effects.attempt(path, done), nok);
        }
        return nok(code2);
      }
      function done(code2) {
        effects.exit("literalAutolinkHttp");
        effects.exit("literalAutolink");
        return ok2(code2);
      }
    }
    function tokenizeDomain(effects, ok2, nok) {
      var hasUnderscoreInLastSegment;
      var hasUnderscoreInLastLastSegment;
      var hasDot;
      return start;
      function start(code2) {
        effects.enter("literalAutolinkDomain");
        return domain2(code2);
      }
      function domain2(code2) {
        if (
          // `-`
          code2 === 45 || // `_`
          code2 === 95 || asciiAlphanumeric(code2)
        ) {
          if (code2 === 95) {
            hasUnderscoreInLastSegment = true;
          }
          effects.consume(code2);
          return domain2;
        }
        if (code2 === 46) {
          return effects.check(punctuation, done, dotContinuation)(code2);
        }
        return done(code2);
      }
      function dotContinuation(code2) {
        effects.consume(code2);
        hasDot = true;
        hasUnderscoreInLastLastSegment = hasUnderscoreInLastSegment;
        hasUnderscoreInLastSegment = void 0;
        return domain2;
      }
      function done(code2) {
        if (hasDot && !hasUnderscoreInLastLastSegment && !hasUnderscoreInLastSegment) {
          effects.exit("literalAutolinkDomain");
          return ok2(code2);
        }
        return nok(code2);
      }
    }
    function tokenizePath(effects, ok2) {
      var balance = 0;
      return start;
      function start(code2) {
        if (pathEnd(code2)) {
          return ok2(code2);
        }
        if (trailingPunctuation(code2)) {
          return effects.check(punctuation, ok2, atPathStart)(code2);
        }
        return atPathStart(code2);
      }
      function atPathStart(code2) {
        effects.enter("literalAutolinkWwwPath");
        return inPath(code2);
      }
      function inPath(code2) {
        if (code2 === 38) {
          return effects.check(
            namedCharacterReference,
            atPathEnd,
            continuedPunctuation
          )(code2);
        }
        if (code2 === 40) {
          balance++;
        }
        if (code2 === 41) {
          return effects.check(paren, parenAtPathEnd, continuedPunctuation)(code2);
        }
        if (pathEnd(code2)) {
          return atPathEnd(code2);
        }
        if (trailingPunctuation(code2)) {
          return effects.check(punctuation, atPathEnd, continuedPunctuation)(code2);
        }
        effects.consume(code2);
        return inPath;
      }
      function continuedPunctuation(code2) {
        effects.consume(code2);
        return inPath;
      }
      function parenAtPathEnd(code2) {
        balance--;
        return balance < 0 ? atPathEnd(code2) : continuedPunctuation(code2);
      }
      function atPathEnd(code2) {
        effects.exit("literalAutolinkWwwPath");
        return ok2(code2);
      }
    }
    function tokenizeNamedCharacterReference(effects, ok2, nok) {
      return start;
      function start(code2) {
        effects.enter("literalAutolinkCharacterReferenceNamed");
        effects.consume(code2);
        return inside;
      }
      function inside(code2) {
        if (asciiAlpha(code2)) {
          effects.consume(code2);
          return inside;
        }
        if (code2 === 59) {
          effects.consume(code2);
          return after;
        }
        return nok(code2);
      }
      function after(code2) {
        effects.exit("literalAutolinkCharacterReferenceNamed");
        return pathEnd(code2) ? ok2(code2) : nok(code2);
      }
    }
    function tokenizeParen(effects, ok2, nok) {
      return start;
      function start(code2) {
        effects.enter("literalAutolinkParen");
        effects.consume(code2);
        return after;
      }
      function after(code2) {
        effects.exit("literalAutolinkParen");
        return pathEnd(code2) || // `)`
        code2 === 41 ? ok2(code2) : nok(code2);
      }
    }
    function tokenizePunctuation(effects, ok2, nok) {
      return start;
      function start(code2) {
        effects.enter("literalAutolinkPunctuation");
        effects.consume(code2);
        return after;
      }
      function after(code2) {
        effects.exit("literalAutolinkPunctuation");
        return pathEnd(code2) ? ok2(code2) : nok(code2);
      }
    }
    function trailingPunctuation(code2) {
      return (
        // Exclamation mark.
        code2 === 33 || // Asterisk.
        code2 === 42 || // Comma.
        code2 === 44 || // Dot.
        code2 === 46 || // Colon.
        code2 === 58 || // Question mark.
        code2 === 63 || // Underscore.
        code2 === 95 || // Tilde.
        code2 === 126
      );
    }
    function pathEnd(code2) {
      return (
        // EOF.
        code2 === null || // CR, LF, CRLF, HT, VS.
        code2 < 0 || // Space.
        code2 === 32 || // Less than.
        code2 === 60
      );
    }
    function gfmAtext(code2) {
      return (
        // `+`
        code2 === 43 || // `-`
        code2 === 45 || // `.`
        code2 === 46 || // `_`
        code2 === 95 || asciiAlphanumeric(code2)
      );
    }
    function previous(code2) {
      return (
        // EOF.
        code2 === null || // CR, LF, CRLF, HT, VS.
        code2 < 0 || // Space.
        code2 === 32 || // Left paren.
        code2 === 40 || // Asterisk.
        code2 === 42 || // Underscore.
        code2 === 95 || // Tilde.
        code2 === 126
      );
    }
    var micromarkExtensionGfmAutolinkLiteral = syntax$4;
    var markdownLineEndingOrSpace_1 = markdownLineEndingOrSpace$2;
    function markdownLineEndingOrSpace$2(code2) {
      return code2 < 0 || code2 === 32;
    }
    var unicodePunctuationRegex = /[!-\/:-@\[-`\{-~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
    var unicodePunctuation$1 = unicodePunctuationRegex;
    var check$1 = regexCheck_1;
    var unicodePunctuation_1 = check$1(unicodePunctuation$1);
    var check = regexCheck_1;
    var unicodeWhitespace$1 = check(/\s/);
    var classifyCharacter_1 = classifyCharacter$1;
    var markdownLineEndingOrSpace$1 = markdownLineEndingOrSpace_1;
    var unicodePunctuation = unicodePunctuation_1;
    var unicodeWhitespace = unicodeWhitespace$1;
    function classifyCharacter$1(code2) {
      if (code2 === null || markdownLineEndingOrSpace$1(code2) || unicodeWhitespace(code2)) {
        return 1;
      }
      if (unicodePunctuation(code2)) {
        return 2;
      }
    }
    var resolveAll_1 = resolveAll$1;
    function resolveAll$1(constructs2, events, context) {
      var called = [];
      var index2 = -1;
      var resolve;
      while (++index2 < constructs2.length) {
        resolve = constructs2[index2].resolveAll;
        if (resolve && called.indexOf(resolve) < 0) {
          events = resolve(events, context);
          called.push(resolve);
        }
      }
      return events;
    }
    var assign$1 = Object.assign;
    var shallow_1 = shallow$1;
    var assign = assign$1;
    function shallow$1(object) {
      return assign({}, object);
    }
    var micromarkExtensionGfmStrikethrough = create$1;
    var classifyCharacter = classifyCharacter_1;
    var chunkedSplice = chunkedSplice_1;
    var resolveAll = resolveAll_1;
    var shallow = shallow_1;
    function create$1(options) {
      var settings = options || {};
      var single = settings.singleTilde;
      var tokenizer2 = {
        tokenize: tokenizeStrikethrough,
        resolveAll: resolveAllStrikethrough
      };
      if (single === null || single === void 0) {
        single = true;
      }
      return { text: { 126: tokenizer2 }, insideSpan: { null: tokenizer2 } };
      function resolveAllStrikethrough(events, context) {
        var index2 = -1;
        var strikethrough2;
        var text2;
        var open;
        var nextEvents;
        while (++index2 < events.length) {
          if (events[index2][0] === "enter" && events[index2][1].type === "strikethroughSequenceTemporary" && events[index2][1]._close) {
            open = index2;
            while (open--) {
              if (events[open][0] === "exit" && events[open][1].type === "strikethroughSequenceTemporary" && events[open][1]._open && // If the sizes are the same:
              events[index2][1].end.offset - events[index2][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {
                events[index2][1].type = "strikethroughSequence";
                events[open][1].type = "strikethroughSequence";
                strikethrough2 = {
                  type: "strikethrough",
                  start: shallow(events[open][1].start),
                  end: shallow(events[index2][1].end)
                };
                text2 = {
                  type: "strikethroughText",
                  start: shallow(events[open][1].end),
                  end: shallow(events[index2][1].start)
                };
                nextEvents = [
                  ["enter", strikethrough2, context],
                  ["enter", events[open][1], context],
                  ["exit", events[open][1], context],
                  ["enter", text2, context]
                ];
                chunkedSplice(
                  nextEvents,
                  nextEvents.length,
                  0,
                  resolveAll(
                    context.parser.constructs.insideSpan.null,
                    events.slice(open + 1, index2),
                    context
                  )
                );
                chunkedSplice(nextEvents, nextEvents.length, 0, [
                  ["exit", text2, context],
                  ["enter", events[index2][1], context],
                  ["exit", events[index2][1], context],
                  ["exit", strikethrough2, context]
                ]);
                chunkedSplice(events, open - 1, index2 - open + 3, nextEvents);
                index2 = open + nextEvents.length - 2;
                break;
              }
            }
          }
        }
        return removeRemainingSequences(events);
      }
      function removeRemainingSequences(events) {
        var index2 = -1;
        var length2 = events.length;
        while (++index2 < length2) {
          if (events[index2][1].type === "strikethroughSequenceTemporary") {
            events[index2][1].type = "data";
          }
        }
        return events;
      }
      function tokenizeStrikethrough(effects, ok2, nok) {
        var previous2 = this.previous;
        var events = this.events;
        var size = 0;
        return start;
        function start(code2) {
          if (code2 !== 126 || previous2 === 126 && events[events.length - 1][1].type !== "characterEscape") {
            return nok(code2);
          }
          effects.enter("strikethroughSequenceTemporary");
          return more(code2);
        }
        function more(code2) {
          var before = classifyCharacter(previous2);
          var token2;
          var after;
          if (code2 === 126) {
            if (size > 1)
              return nok(code2);
            effects.consume(code2);
            size++;
            return more;
          }
          if (size < 2 && !single)
            return nok(code2);
          token2 = effects.exit("strikethroughSequenceTemporary");
          after = classifyCharacter(code2);
          token2._open = !after || after === 2 && before;
          token2._close = !before || before === 2 && after;
          return ok2(code2);
        }
      }
    }
    var syntax$3 = {};
    var markdownSpace_1 = markdownSpace$1;
    function markdownSpace$1(code2) {
      return code2 === -2 || code2 === -1 || code2 === 32;
    }
    var factorySpace = createSpace$1;
    var markdownSpace = markdownSpace_1;
    function createSpace$1(effects, ok2, type, max2) {
      var limit = max2 ? max2 - 1 : Infinity;
      var size;
      return start;
      function start(code2) {
        if (markdownSpace(code2)) {
          effects.enter(type);
          size = 0;
          return prefix2(code2);
        }
        return ok2(code2);
      }
      function prefix2(code2) {
        if (markdownSpace(code2) && size++ < limit) {
          effects.consume(code2);
          return prefix2;
        }
        effects.exit(type);
        return ok2(code2);
      }
    }
    syntax$3.flow = {
      null: { tokenize: tokenizeTable, resolve: resolveTable, interruptible: true }
    };
    var createSpace = factorySpace;
    var setextUnderlineMini = { tokenize: tokenizeSetextUnderlineMini, partial: true };
    var nextPrefixedOrBlank = { tokenize: tokenizeNextPrefixedOrBlank, partial: true };
    function resolveTable(events, context) {
      var length2 = events.length;
      var index2 = -1;
      var token2;
      var inHead;
      var inDelimiterRow;
      var inRow;
      var cell;
      var content2;
      var text2;
      var contentStart;
      var contentEnd;
      var cellStart;
      while (++index2 < length2) {
        token2 = events[index2][1];
        if (inRow) {
          if (token2.type === "temporaryTableCellContent") {
            contentStart = contentStart || index2;
            contentEnd = index2;
          }
          if (
            // Combine separate content parts into one.
            (token2.type === "tableCellDivider" || token2.type === "tableRow") && contentEnd
          ) {
            content2 = {
              type: "tableContent",
              start: events[contentStart][1].start,
              end: events[contentEnd][1].end
            };
            text2 = {
              type: "chunkText",
              start: content2.start,
              end: content2.end,
              contentType: "text"
            };
            events.splice(
              contentStart,
              contentEnd - contentStart + 1,
              ["enter", content2, context],
              ["enter", text2, context],
              ["exit", text2, context],
              ["exit", content2, context]
            );
            index2 -= contentEnd - contentStart - 3;
            length2 = events.length;
            contentStart = void 0;
            contentEnd = void 0;
          }
        }
        if (events[index2][0] === "exit" && (token2.type === "tableCellDivider" || token2.type === "tableRow") && cellStart && cellStart + 1 < index2) {
          cell = {
            type: inDelimiterRow ? "tableDelimiter" : inHead ? "tableHeader" : "tableData",
            start: events[cellStart][1].start,
            end: events[index2][1].end
          };
          events.splice(index2 + (token2.type === "tableCellDivider" ? 1 : 0), 0, [
            "exit",
            cell,
            context
          ]);
          events.splice(cellStart, 0, ["enter", cell, context]);
          index2 += 2;
          length2 = events.length;
          cellStart = index2 + 1;
        }
        if (token2.type === "tableRow") {
          inRow = events[index2][0] === "enter";
          if (inRow) {
            cellStart = index2 + 1;
          }
        }
        if (token2.type === "tableDelimiterRow") {
          inDelimiterRow = events[index2][0] === "enter";
          if (inDelimiterRow) {
            cellStart = index2 + 1;
          }
        }
        if (token2.type === "tableHead") {
          inHead = events[index2][0] === "enter";
        }
      }
      return events;
    }
    function tokenizeTable(effects, ok2, nok) {
      var align = [];
      var tableHeaderCount = 0;
      var seenDelimiter;
      var hasDash;
      return start;
      function start(code2) {
        if (code2 === null || code2 === -5 || code2 === -4 || code2 === -3) {
          return nok(code2);
        }
        effects.enter("table")._align = align;
        effects.enter("tableHead");
        effects.enter("tableRow");
        if (code2 === 124) {
          return cellDividerHead(code2);
        }
        tableHeaderCount++;
        effects.enter("temporaryTableCellContent");
        return inCellContentHead(code2);
      }
      function cellDividerHead(code2) {
        effects.enter("tableCellDivider");
        effects.consume(code2);
        effects.exit("tableCellDivider");
        seenDelimiter = true;
        return cellBreakHead;
      }
      function cellBreakHead(code2) {
        if (code2 === null || code2 === -5 || code2 === -4 || code2 === -3) {
          return atRowEndHead(code2);
        }
        if (code2 === -2 || code2 === -1 || code2 === 32) {
          effects.enter("whitespace");
          effects.consume(code2);
          return inWhitespaceHead;
        }
        if (seenDelimiter) {
          seenDelimiter = void 0;
          tableHeaderCount++;
        }
        if (code2 === 124) {
          return cellDividerHead(code2);
        }
        effects.enter("temporaryTableCellContent");
        return inCellContentHead(code2);
      }
      function inWhitespaceHead(code2) {
        if (code2 === -2 || code2 === -1 || code2 === 32) {
          effects.consume(code2);
          return inWhitespaceHead;
        }
        effects.exit("whitespace");
        return cellBreakHead(code2);
      }
      function inCellContentHead(code2) {
        if (code2 === null || code2 < 0 || code2 === 32 || code2 === 124) {
          effects.exit("temporaryTableCellContent");
          return cellBreakHead(code2);
        }
        effects.consume(code2);
        return code2 === 92 ? inCellContentEscapeHead : inCellContentHead;
      }
      function inCellContentEscapeHead(code2) {
        if (code2 === 92 || code2 === 124) {
          effects.consume(code2);
          return inCellContentHead;
        }
        return inCellContentHead(code2);
      }
      function atRowEndHead(code2) {
        if (code2 === null) {
          return nok(code2);
        }
        effects.exit("tableRow");
        effects.exit("tableHead");
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return effects.check(
          setextUnderlineMini,
          nok,
          // Support an indent before the delimiter row.
          createSpace(effects, rowStartDelimiter, "linePrefix", 4)
        );
      }
      function rowStartDelimiter(code2) {
        if (code2 === null || code2 < 0 || code2 === 32) {
          return nok(code2);
        }
        effects.enter("tableDelimiterRow");
        return atDelimiterRowBreak(code2);
      }
      function atDelimiterRowBreak(code2) {
        if (code2 === null || code2 === -5 || code2 === -4 || code2 === -3) {
          return rowEndDelimiter(code2);
        }
        if (code2 === -2 || code2 === -1 || code2 === 32) {
          effects.enter("whitespace");
          effects.consume(code2);
          return inWhitespaceDelimiter;
        }
        if (code2 === 45) {
          effects.enter("tableDelimiterFiller");
          effects.consume(code2);
          hasDash = true;
          align.push(null);
          return inFillerDelimiter;
        }
        if (code2 === 58) {
          effects.enter("tableDelimiterAlignment");
          effects.consume(code2);
          effects.exit("tableDelimiterAlignment");
          align.push("left");
          return afterLeftAlignment;
        }
        if (code2 === 124) {
          effects.enter("tableCellDivider");
          effects.consume(code2);
          effects.exit("tableCellDivider");
          return atDelimiterRowBreak;
        }
        return nok(code2);
      }
      function inWhitespaceDelimiter(code2) {
        if (code2 === -2 || code2 === -1 || code2 === 32) {
          effects.consume(code2);
          return inWhitespaceDelimiter;
        }
        effects.exit("whitespace");
        return atDelimiterRowBreak(code2);
      }
      function inFillerDelimiter(code2) {
        if (code2 === 45) {
          effects.consume(code2);
          return inFillerDelimiter;
        }
        effects.exit("tableDelimiterFiller");
        if (code2 === 58) {
          effects.enter("tableDelimiterAlignment");
          effects.consume(code2);
          effects.exit("tableDelimiterAlignment");
          align[align.length - 1] = align[align.length - 1] === "left" ? "center" : "right";
          return afterRightAlignment;
        }
        return atDelimiterRowBreak(code2);
      }
      function afterLeftAlignment(code2) {
        if (code2 === 45) {
          effects.enter("tableDelimiterFiller");
          effects.consume(code2);
          hasDash = true;
          return inFillerDelimiter;
        }
        return nok(code2);
      }
      function afterRightAlignment(code2) {
        if (code2 === null || code2 === -5 || code2 === -4 || code2 === -3) {
          return rowEndDelimiter(code2);
        }
        if (code2 === -2 || code2 === -1 || code2 === 32) {
          effects.enter("whitespace");
          effects.consume(code2);
          return inWhitespaceDelimiter;
        }
        if (code2 === 124) {
          effects.enter("tableCellDivider");
          effects.consume(code2);
          effects.exit("tableCellDivider");
          return atDelimiterRowBreak;
        }
        return nok(code2);
      }
      function rowEndDelimiter(code2) {
        effects.exit("tableDelimiterRow");
        if (!hasDash || tableHeaderCount !== align.length) {
          return nok(code2);
        }
        if (code2 === null) {
          return tableClose(code2);
        }
        return effects.check(nextPrefixedOrBlank, tableClose, tableContinue)(code2);
      }
      function tableClose(code2) {
        effects.exit("table");
        return ok2(code2);
      }
      function tableContinue(code2) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return createSpace(effects, bodyStart, "linePrefix", 4);
      }
      function bodyStart(code2) {
        effects.enter("tableBody");
        return rowStartBody(code2);
      }
      function rowStartBody(code2) {
        effects.enter("tableRow");
        if (code2 === 124) {
          return cellDividerBody(code2);
        }
        effects.enter("temporaryTableCellContent");
        return inCellContentBody(code2);
      }
      function cellDividerBody(code2) {
        effects.enter("tableCellDivider");
        effects.consume(code2);
        effects.exit("tableCellDivider");
        return cellBreakBody;
      }
      function cellBreakBody(code2) {
        if (code2 === null || code2 === -5 || code2 === -4 || code2 === -3) {
          return atRowEndBody(code2);
        }
        if (code2 === -2 || code2 === -1 || code2 === 32) {
          effects.enter("whitespace");
          effects.consume(code2);
          return inWhitespaceBody;
        }
        if (code2 === 124) {
          return cellDividerBody(code2);
        }
        effects.enter("temporaryTableCellContent");
        return inCellContentBody(code2);
      }
      function inWhitespaceBody(code2) {
        if (code2 === -2 || code2 === -1 || code2 === 32) {
          effects.consume(code2);
          return inWhitespaceBody;
        }
        effects.exit("whitespace");
        return cellBreakBody(code2);
      }
      function inCellContentBody(code2) {
        if (code2 === null || code2 < 0 || code2 === 32 || code2 === 124) {
          effects.exit("temporaryTableCellContent");
          return cellBreakBody(code2);
        }
        effects.consume(code2);
        return code2 === 92 ? inCellContentEscapeBody : inCellContentBody;
      }
      function inCellContentEscapeBody(code2) {
        if (code2 === 92 || code2 === 124) {
          effects.consume(code2);
          return inCellContentBody;
        }
        return inCellContentBody(code2);
      }
      function atRowEndBody(code2) {
        effects.exit("tableRow");
        if (code2 === null) {
          return tableBodyClose(code2);
        }
        return effects.check(
          nextPrefixedOrBlank,
          tableBodyClose,
          tableBodyContinue
        )(code2);
      }
      function tableBodyClose(code2) {
        effects.exit("tableBody");
        return tableClose(code2);
      }
      function tableBodyContinue(code2) {
        effects.enter("lineEnding");
        effects.consume(code2);
        effects.exit("lineEnding");
        return createSpace(effects, rowStartBody, "linePrefix", 4);
      }
    }
    function tokenizeSetextUnderlineMini(effects, ok2, nok) {
      return start;
      function start(code2) {
        if (code2 !== 45) {
          return nok(code2);
        }
        effects.enter("setextUnderline");
        return sequence(code2);
      }
      function sequence(code2) {
        if (code2 === 45) {
          effects.consume(code2);
          return sequence;
        }
        return whitespace2(code2);
      }
      function whitespace2(code2) {
        if (code2 === -2 || code2 === -1 || code2 === 32) {
          effects.consume(code2);
          return whitespace2;
        }
        if (code2 === null || code2 === -5 || code2 === -4 || code2 === -3) {
          return ok2(code2);
        }
        return nok(code2);
      }
    }
    function tokenizeNextPrefixedOrBlank(effects, ok2, nok) {
      var size = 0;
      return start;
      function start(code2) {
        effects.enter("check");
        effects.consume(code2);
        return whitespace2;
      }
      function whitespace2(code2) {
        if (code2 === -1 || code2 === 32) {
          effects.consume(code2);
          size++;
          return size === 4 ? ok2 : whitespace2;
        }
        if (code2 === null || code2 < 0) {
          return ok2(code2);
        }
        return nok(code2);
      }
    }
    var micromarkExtensionGfmTable = syntax$3;
    var syntax$2 = {};
    var sizeChunks_1 = sizeChunks$1;
    function sizeChunks$1(chunks) {
      var index2 = -1;
      var size = 0;
      while (++index2 < chunks.length) {
        size += typeof chunks[index2] === "string" ? chunks[index2].length : 1;
      }
      return size;
    }
    var prefixSize_1 = prefixSize$1;
    var sizeChunks = sizeChunks_1;
    function prefixSize$1(events, type) {
      var tail = events[events.length - 1];
      if (!tail || tail[1].type !== type)
        return 0;
      return sizeChunks(tail[2].sliceStream(tail[1]));
    }
    var markdownLineEndingOrSpace = markdownLineEndingOrSpace_1;
    var spaceFactory = factorySpace;
    var prefixSize = prefixSize_1;
    var tasklistCheck = { tokenize: tokenizeTasklistCheck };
    syntax$2.text = { 91: tasklistCheck };
    function tokenizeTasklistCheck(effects, ok2, nok) {
      var self2 = this;
      return open;
      function open(code2) {
        if (
          // Exit if not `[`.
          code2 !== 91 || // Exit if there’s stuff before.
          self2.previous !== null || // Exit if not in the first content that is the first child of a list
          // item.
          !self2._gfmTasklistFirstContentOfListItem
        ) {
          return nok(code2);
        }
        effects.enter("taskListCheck");
        effects.enter("taskListCheckMarker");
        effects.consume(code2);
        effects.exit("taskListCheckMarker");
        return inside;
      }
      function inside(code2) {
        if (code2 === -2 || code2 === 32) {
          effects.enter("taskListCheckValueUnchecked");
          effects.consume(code2);
          effects.exit("taskListCheckValueUnchecked");
          return close;
        }
        if (code2 === 88 || code2 === 120) {
          effects.enter("taskListCheckValueChecked");
          effects.consume(code2);
          effects.exit("taskListCheckValueChecked");
          return close;
        }
        return nok(code2);
      }
      function close(code2) {
        if (code2 === 93) {
          effects.enter("taskListCheckMarker");
          effects.consume(code2);
          effects.exit("taskListCheckMarker");
          effects.exit("taskListCheck");
          return effects.check({ tokenize: spaceThenNonSpace }, ok2, nok);
        }
        return nok(code2);
      }
    }
    function spaceThenNonSpace(effects, ok2, nok) {
      var self2 = this;
      return spaceFactory(effects, after, "whitespace");
      function after(code2) {
        return prefixSize(self2.events, "whitespace") && code2 !== null && !markdownLineEndingOrSpace(code2) ? ok2(code2) : nok(code2);
      }
    }
    var micromarkExtensionGfmTaskListItem = syntax$2;
    var combine = combineExtensions_1;
    var autolink = micromarkExtensionGfmAutolinkLiteral;
    var strikethrough$2 = micromarkExtensionGfmStrikethrough;
    var table$2 = micromarkExtensionGfmTable;
    var tasklist = micromarkExtensionGfmTaskListItem;
    var syntax$1 = create;
    function create(options) {
      return combine([autolink, strikethrough$2(options), table$2, tasklist]);
    }
    var micromarkExtensionGfm = syntax$1;
    var fromMarkdown$5 = {};
    fromMarkdown$5.enter = {
      literalAutolink: enterLiteralAutolink,
      literalAutolinkEmail: enterLiteralAutolinkValue,
      literalAutolinkHttp: enterLiteralAutolinkValue,
      literalAutolinkWww: enterLiteralAutolinkValue
    };
    fromMarkdown$5.exit = {
      literalAutolink: exitLiteralAutolink,
      literalAutolinkEmail: exitLiteralAutolinkEmail,
      literalAutolinkHttp: exitLiteralAutolinkHttp,
      literalAutolinkWww: exitLiteralAutolinkWww
    };
    function enterLiteralAutolink(token2) {
      this.enter({ type: "link", title: null, url: "", children: [] }, token2);
    }
    function enterLiteralAutolinkValue(token2) {
      this.config.enter.autolinkProtocol.call(this, token2);
    }
    function exitLiteralAutolinkHttp(token2) {
      this.config.exit.autolinkProtocol.call(this, token2);
    }
    function exitLiteralAutolinkWww(token2) {
      this.config.exit.data.call(this, token2);
      this.stack[this.stack.length - 1].url = "http://" + this.sliceSerialize(token2);
    }
    function exitLiteralAutolinkEmail(token2) {
      this.config.exit.autolinkEmail.call(this, token2);
    }
    function exitLiteralAutolink(token2) {
      this.exit(token2);
    }
    var fromMarkdown$4 = {};
    fromMarkdown$4.canContainEols = ["delete"];
    fromMarkdown$4.enter = { strikethrough: enterStrikethrough };
    fromMarkdown$4.exit = { strikethrough: exitStrikethrough };
    function enterStrikethrough(token2) {
      this.enter({ type: "delete", children: [] }, token2);
    }
    function exitStrikethrough(token2) {
      this.exit(token2);
    }
    var fromMarkdown$3 = {};
    fromMarkdown$3.enter = {
      table: enterTable,
      tableData: enterCell,
      tableHeader: enterCell,
      tableRow: enterRow
    };
    fromMarkdown$3.exit = {
      codeText: exitCodeText,
      table: exitTable,
      tableData: exit,
      tableHeader: exit,
      tableRow: exit
    };
    function enterTable(token2) {
      this.enter({ type: "table", align: token2._align, children: [] }, token2);
      this.setData("inTable", true);
    }
    function exitTable(token2) {
      this.exit(token2);
      this.setData("inTable");
    }
    function enterRow(token2) {
      this.enter({ type: "tableRow", children: [] }, token2);
    }
    function exit(token2) {
      this.exit(token2);
    }
    function enterCell(token2) {
      this.enter({ type: "tableCell", children: [] }, token2);
    }
    function exitCodeText(token2) {
      var value = this.resume();
      if (this.getData("inTable")) {
        value = value.replace(/\\([\\|])/g, replace);
      }
      this.stack[this.stack.length - 1].value = value;
      this.exit(token2);
    }
    function replace($0, $1) {
      return $1 === "|" ? $1 : $0;
    }
    var fromMarkdown$2 = {};
    fromMarkdown$2.exit = {
      taskListCheckValueChecked: exitCheck,
      taskListCheckValueUnchecked: exitCheck,
      paragraph: exitParagraphWithTaskListItem
    };
    function exitCheck(token2) {
      this.stack[this.stack.length - 2].checked = token2.type === "taskListCheckValueChecked";
    }
    function exitParagraphWithTaskListItem(token2) {
      var parent = this.stack[this.stack.length - 2];
      var node2 = this.stack[this.stack.length - 1];
      var siblings = parent.children;
      var head = node2.children[0];
      var index2 = -1;
      var firstParaghraph;
      if (parent && parent.type === "listItem" && typeof parent.checked === "boolean" && head && head.type === "text") {
        while (++index2 < siblings.length) {
          if (siblings[index2].type === "paragraph") {
            firstParaghraph = siblings[index2];
            break;
          }
        }
        if (firstParaghraph === node2) {
          head.value = head.value.slice(1);
          if (head.value.length === 0) {
            node2.children.shift();
          } else {
            head.position.start.column++;
            head.position.start.offset++;
            node2.position.start = Object.assign({}, head.position.start);
          }
        }
      }
      this.exit(token2);
    }
    var autolinkLiteral$1 = fromMarkdown$5;
    var strikethrough$1 = fromMarkdown$4;
    var table$1 = fromMarkdown$3;
    var taskListItem$1 = fromMarkdown$2;
    var own = {}.hasOwnProperty;
    var fromMarkdown$1 = configure([
      autolinkLiteral$1,
      strikethrough$1,
      table$1,
      taskListItem$1
    ]);
    function configure(extensions) {
      var config2 = { canContainEols: [] };
      var length2 = extensions.length;
      var index2 = -1;
      while (++index2 < length2) {
        extension(config2, extensions[index2]);
      }
      return config2;
    }
    function extension(config2, extension2) {
      var key;
      var left;
      var right;
      for (key in extension2) {
        left = own.call(config2, key) ? config2[key] : config2[key] = {};
        right = extension2[key];
        if (key === "canContainEols") {
          config2[key] = [].concat(left, right);
        } else {
          Object.assign(left, right);
        }
      }
    }
    var toMarkdown$5 = {};
    var inConstruct = "phrasing";
    var notInConstruct = ["autolink", "link", "image"];
    toMarkdown$5.unsafe = [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct,
        notInConstruct
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct,
        notInConstruct
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct,
        notInConstruct
      }
    ];
    var toMarkdown$4 = {};
    var containerPhrasing$1 = phrasing$3;
    function phrasing$3(parent, context, safeOptions) {
      var children = parent.children || [];
      var results = [];
      var index2 = -1;
      var before = safeOptions.before;
      var after;
      var handle;
      var child;
      while (++index2 < children.length) {
        child = children[index2];
        if (index2 + 1 < children.length) {
          handle = context.handle.handlers[children[index2 + 1].type];
          if (handle && handle.peek)
            handle = handle.peek;
          after = handle ? handle(children[index2 + 1], parent, context, {
            before: "",
            after: ""
          }).charAt(0) : "";
        } else {
          after = safeOptions.after;
        }
        results.push(
          context.handle(child, parent, context, {
            before,
            after
          })
        );
        before = results[results.length - 1].slice(-1);
      }
      return results.join("");
    }
    var phrasing$2 = containerPhrasing$1;
    toMarkdown$4.unsafe = [{ character: "~", inConstruct: "phrasing" }];
    toMarkdown$4.handlers = { delete: handleDelete };
    handleDelete.peek = peekDelete;
    function handleDelete(node2, _2, context) {
      var exit2 = context.enter("emphasis");
      var value = phrasing$2(node2, context, { before: "~", after: "~" });
      exit2();
      return "~~" + value + "~~";
    }
    function peekDelete() {
      return "~";
    }
    var containerPhrasing = phrasing$1;
    function phrasing$1(parent, context, safeOptions) {
      var children = parent.children || [];
      var results = [];
      var index2 = -1;
      var before = safeOptions.before;
      var after;
      var handle;
      var child;
      while (++index2 < children.length) {
        child = children[index2];
        if (index2 + 1 < children.length) {
          handle = context.handle.handlers[children[index2 + 1].type];
          if (handle && handle.peek)
            handle = handle.peek;
          after = handle ? handle(children[index2 + 1], parent, context, {
            before: "",
            after: ""
          }).charAt(0) : "";
        } else {
          after = safeOptions.after;
        }
        results.push(
          context.handle(child, parent, context, {
            before,
            after
          })
        );
        before = results[results.length - 1].slice(-1);
      }
      return results.join("");
    }
    var inlineCode_1 = inlineCode;
    inlineCode.peek = inlineCodePeek;
    function inlineCode(node2) {
      var value = node2.value || "";
      var sequence = "`";
      var pad = "";
      while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
        sequence += "`";
      }
      if (/[^ \r\n]/.test(value) && (/[ \r\n`]/.test(value.charAt(0)) || /[ \r\n`]/.test(value.charAt(value.length - 1)))) {
        pad = " ";
      }
      return sequence + pad + value + pad + sequence;
    }
    function inlineCodePeek() {
      return "`";
    }
    /*!
     * repeat-string <https://github.com/jonschlinkert/repeat-string>
     *
     * Copyright (c) 2014-2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    var res = "";
    var cache;
    var repeatString = repeat$3;
    function repeat$3(str, num) {
      if (typeof str !== "string") {
        throw new TypeError("expected a string");
      }
      if (num === 1)
        return str;
      if (num === 2)
        return str + str;
      var max2 = str.length * num;
      if (cache !== str || typeof cache === "undefined") {
        cache = str;
        res = "";
      } else if (res.length >= max2) {
        return res.substr(0, max2);
      }
      while (max2 > res.length && num > 1) {
        if (num & 1) {
          res += str;
        }
        num >>= 1;
        str += str;
      }
      res += str;
      res = res.substr(0, max2);
      return res;
    }
    var repeat$2 = repeatString;
    var markdownTable_1 = markdownTable$1;
    var trailingWhitespace = / +$/;
    var space = " ";
    var lineFeed = "\n";
    var dash = "-";
    var colon = ":";
    var verticalBar = "|";
    var x = 0;
    var C = 67;
    var L = 76;
    var R = 82;
    var c = 99;
    var l = 108;
    var r = 114;
    function markdownTable$1(table2, options) {
      var settings = options || {};
      var padding2 = settings.padding !== false;
      var start = settings.delimiterStart !== false;
      var end = settings.delimiterEnd !== false;
      var align = (settings.align || []).concat();
      var alignDelimiters = settings.alignDelimiters !== false;
      var alignments = [];
      var stringLength = settings.stringLength || defaultStringLength;
      var rowIndex = -1;
      var rowLength = table2.length;
      var cellMatrix = [];
      var sizeMatrix = [];
      var row = [];
      var sizes = [];
      var longestCellByColumn = [];
      var mostCellsPerRow = 0;
      var cells;
      var columnIndex;
      var columnLength;
      var largest;
      var size;
      var cell;
      var lines;
      var line2;
      var before;
      var after;
      var code2;
      while (++rowIndex < rowLength) {
        cells = table2[rowIndex];
        columnIndex = -1;
        columnLength = cells.length;
        row = [];
        sizes = [];
        if (columnLength > mostCellsPerRow) {
          mostCellsPerRow = columnLength;
        }
        while (++columnIndex < columnLength) {
          cell = serialize(cells[columnIndex]);
          if (alignDelimiters === true) {
            size = stringLength(cell);
            sizes[columnIndex] = size;
            largest = longestCellByColumn[columnIndex];
            if (largest === void 0 || size > largest) {
              longestCellByColumn[columnIndex] = size;
            }
          }
          row.push(cell);
        }
        cellMatrix[rowIndex] = row;
        sizeMatrix[rowIndex] = sizes;
      }
      columnIndex = -1;
      columnLength = mostCellsPerRow;
      if (typeof align === "object" && "length" in align) {
        while (++columnIndex < columnLength) {
          alignments[columnIndex] = toAlignment(align[columnIndex]);
        }
      } else {
        code2 = toAlignment(align);
        while (++columnIndex < columnLength) {
          alignments[columnIndex] = code2;
        }
      }
      columnIndex = -1;
      columnLength = mostCellsPerRow;
      row = [];
      sizes = [];
      while (++columnIndex < columnLength) {
        code2 = alignments[columnIndex];
        before = "";
        after = "";
        if (code2 === l) {
          before = colon;
        } else if (code2 === r) {
          after = colon;
        } else if (code2 === c) {
          before = colon;
          after = colon;
        }
        size = alignDelimiters ? Math.max(
          1,
          longestCellByColumn[columnIndex] - before.length - after.length
        ) : 1;
        cell = before + repeat$2(dash, size) + after;
        if (alignDelimiters === true) {
          size = before.length + size + after.length;
          if (size > longestCellByColumn[columnIndex]) {
            longestCellByColumn[columnIndex] = size;
          }
          sizes[columnIndex] = size;
        }
        row[columnIndex] = cell;
      }
      cellMatrix.splice(1, 0, row);
      sizeMatrix.splice(1, 0, sizes);
      rowIndex = -1;
      rowLength = cellMatrix.length;
      lines = [];
      while (++rowIndex < rowLength) {
        row = cellMatrix[rowIndex];
        sizes = sizeMatrix[rowIndex];
        columnIndex = -1;
        columnLength = mostCellsPerRow;
        line2 = [];
        while (++columnIndex < columnLength) {
          cell = row[columnIndex] || "";
          before = "";
          after = "";
          if (alignDelimiters === true) {
            size = longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0);
            code2 = alignments[columnIndex];
            if (code2 === r) {
              before = repeat$2(space, size);
            } else if (code2 === c) {
              if (size % 2 === 0) {
                before = repeat$2(space, size / 2);
                after = before;
              } else {
                before = repeat$2(space, size / 2 + 0.5);
                after = repeat$2(space, size / 2 - 0.5);
              }
            } else {
              after = repeat$2(space, size);
            }
          }
          if (start === true && columnIndex === 0) {
            line2.push(verticalBar);
          }
          if (padding2 === true && // Don’t add the opening space if we’re not aligning and the cell is
          // empty: there will be a closing space.
          !(alignDelimiters === false && cell === "") && (start === true || columnIndex !== 0)) {
            line2.push(space);
          }
          if (alignDelimiters === true) {
            line2.push(before);
          }
          line2.push(cell);
          if (alignDelimiters === true) {
            line2.push(after);
          }
          if (padding2 === true) {
            line2.push(space);
          }
          if (end === true || columnIndex !== columnLength - 1) {
            line2.push(verticalBar);
          }
        }
        line2 = line2.join("");
        if (end === false) {
          line2 = line2.replace(trailingWhitespace, "");
        }
        lines.push(line2);
      }
      return lines.join(lineFeed);
    }
    function serialize(value) {
      return value === null || value === void 0 ? "" : String(value);
    }
    function defaultStringLength(value) {
      return value.length;
    }
    function toAlignment(value) {
      var code2 = typeof value === "string" ? value.charCodeAt(0) : x;
      return code2 === L || code2 === l ? l : code2 === R || code2 === r ? r : code2 === C || code2 === c ? c : x;
    }
    var phrasing = containerPhrasing;
    var defaultInlineCode = inlineCode_1;
    var markdownTable = markdownTable_1;
    var toMarkdown_1$1 = toMarkdown$3;
    function toMarkdown$3(options) {
      var settings = options || {};
      var padding2 = settings.tableCellPadding;
      var alignDelimiters = settings.tablePipeAlign;
      var stringLength = settings.stringLength;
      var around = padding2 ? " " : "|";
      return {
        unsafe: [
          { character: "\r", inConstruct: "tableCell" },
          { character: "\n", inConstruct: "tableCell" },
          // A pipe, when followed by a tab or space (padding), or a dash or colon
          // (unpadded delimiter row), could result in a table.
          { atBreak: true, character: "|", after: "[	 :-]" },
          // A pipe in a cell must be encoded.
          { character: "|", inConstruct: "tableCell" },
          // A colon must be followed by a dash, in which case it could start a
          // delimiter row.
          { atBreak: true, character: ":", after: "-" },
          // A delimiter row can also start with a dash, when followed by more
          // dashes, a colon, or a pipe.
          // This is a stricter version than the built in check for lists, thematic
          // breaks, and setex heading underlines though:
          // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
          { atBreak: true, character: "-", after: "[:|-]" }
        ],
        handlers: {
          table: handleTable,
          tableRow: handleTableRow,
          tableCell: handleTableCell,
          inlineCode: inlineCodeWithTable
        }
      };
      function handleTable(node2, _2, context) {
        return serializeData(handleTableAsData(node2, context), node2.align);
      }
      function handleTableRow(node2, _2, context) {
        var row = handleTableRowAsData(node2, context);
        var value = serializeData([row]);
        return value.slice(0, value.indexOf("\n"));
      }
      function handleTableCell(node2, _2, context) {
        var exit2 = context.enter("tableCell");
        var value = phrasing(node2, context, { before: around, after: around });
        exit2();
        return value;
      }
      function serializeData(matrix, align) {
        return markdownTable(matrix, {
          align,
          alignDelimiters,
          padding: padding2,
          stringLength
        });
      }
      function handleTableAsData(node2, context) {
        var children = node2.children;
        var index2 = -1;
        var length2 = children.length;
        var result = [];
        var subexit = context.enter("table");
        while (++index2 < length2) {
          result[index2] = handleTableRowAsData(children[index2], context);
        }
        subexit();
        return result;
      }
      function handleTableRowAsData(node2, context) {
        var children = node2.children;
        var index2 = -1;
        var length2 = children.length;
        var result = [];
        var subexit = context.enter("tableRow");
        while (++index2 < length2) {
          result[index2] = handleTableCell(children[index2], node2, context);
        }
        subexit();
        return result;
      }
      function inlineCodeWithTable(node2, parent, context) {
        var value = defaultInlineCode(node2);
        if (context.stack.indexOf("tableCell") !== -1) {
          value = value.replace(/\|/, "\\$&");
        }
        return value;
      }
    }
    var toMarkdown$2 = {};
    var checkBullet_1 = checkBullet$1;
    function checkBullet$1(context) {
      var marker = context.options.bullet || "*";
      if (marker !== "*" && marker !== "+" && marker !== "-") {
        throw new Error(
          "Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`"
        );
      }
      return marker;
    }
    var checkListItemIndent_1 = checkListItemIndent$1;
    function checkListItemIndent$1(context) {
      var style2 = context.options.listItemIndent || "tab";
      if (style2 === 1 || style2 === "1") {
        return "one";
      }
      if (style2 !== "tab" && style2 !== "one" && style2 !== "mixed") {
        throw new Error(
          "Cannot serialize items with `" + style2 + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
        );
      }
      return style2;
    }
    var containerFlow = flow$1;
    var repeat$1 = repeatString;
    function flow$1(parent, context) {
      var children = parent.children || [];
      var results = [];
      var index2 = -1;
      var child;
      while (++index2 < children.length) {
        child = children[index2];
        results.push(
          context.handle(child, parent, context, { before: "\n", after: "\n" })
        );
        if (index2 + 1 < children.length) {
          results.push(between(child, children[index2 + 1]));
        }
      }
      return results.join("");
      function between(left, right) {
        var index3 = -1;
        var result;
        while (++index3 < context.join.length) {
          result = context.join[index3](left, right, parent, context);
          if (result === true || result === 1) {
            break;
          }
          if (typeof result === "number") {
            return repeat$1("\n", 1 + Number(result));
          }
          if (result === false) {
            return "\n\n<!---->\n\n";
          }
        }
        return "\n\n";
      }
    }
    var indentLines_1 = indentLines$1;
    var eol = /\r?\n|\r/g;
    function indentLines$1(value, map2) {
      var result = [];
      var start = 0;
      var line2 = 0;
      var match5;
      while (match5 = eol.exec(value)) {
        one2(value.slice(start, match5.index));
        result.push(match5[0]);
        start = match5.index + match5[0].length;
        line2++;
      }
      one2(value.slice(start));
      return result.join("");
      function one2(value2) {
        result.push(map2(value2, line2, !value2));
      }
    }
    var listItem_1 = listItem;
    var repeat = repeatString;
    var checkBullet = checkBullet_1;
    var checkListItemIndent = checkListItemIndent_1;
    var flow = containerFlow;
    var indentLines = indentLines_1;
    function listItem(node2, parent, context) {
      var bullet = checkBullet(context);
      var listItemIndent = checkListItemIndent(context);
      var size;
      var value;
      var exit2;
      if (parent && parent.ordered) {
        bullet = (parent.start > -1 ? parent.start : 1) + (context.options.incrementListMarker === false ? 0 : parent.children.indexOf(node2)) + ".";
      }
      size = bullet.length + 1;
      if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.spread || node2.spread)) {
        size = Math.ceil(size / 4) * 4;
      }
      exit2 = context.enter("listItem");
      value = indentLines(flow(node2, context), map2);
      exit2();
      return value;
      function map2(line2, index2, blank) {
        if (index2) {
          return (blank ? "" : repeat(" ", size)) + line2;
        }
        return (blank ? bullet : bullet + repeat(" ", size - bullet.length)) + line2;
      }
    }
    var defaultListItem = listItem_1;
    toMarkdown$2.unsafe = [{ atBreak: true, character: "-", after: "[:|-]" }];
    toMarkdown$2.handlers = {
      listItem: listItemWithTaskListItem
    };
    function listItemWithTaskListItem(node2, parent, context) {
      var value = defaultListItem(node2, parent, context);
      var head = node2.children[0];
      if (typeof node2.checked === "boolean" && head && head.type === "paragraph") {
        value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check2);
      }
      return value;
      function check2($0) {
        return $0 + "[" + (node2.checked ? "x" : " ") + "] ";
      }
    }
    var autolinkLiteral = toMarkdown$5;
    var strikethrough = toMarkdown$4;
    var table = toMarkdown_1$1;
    var taskListItem = toMarkdown$2;
    var toMarkdown_1 = toMarkdown$1;
    function toMarkdown$1(options) {
      var extensions = [
        autolinkLiteral,
        strikethrough,
        table(options),
        taskListItem
      ];
      var length2 = extensions.length;
      var index2 = -1;
      var extension2;
      var unsafe = [];
      var handlers2 = {};
      while (++index2 < length2) {
        extension2 = extensions[index2];
        unsafe = unsafe.concat(extension2.unsafe || []);
        handlers2 = Object.assign(handlers2, extension2.handlers || {});
      }
      return { unsafe, handlers: handlers2 };
    }
    var syntax = micromarkExtensionGfm;
    var fromMarkdown = fromMarkdown$1;
    var toMarkdown = toMarkdown_1;
    var warningIssued;
    var remarkGfm = gfm;
    function gfm(options) {
      var data = this.data();
      if (!warningIssued && (this.Parser && this.Parser.prototype && this.Parser.prototype.blockTokenizers || this.Compiler && this.Compiler.prototype && this.Compiler.prototype.visitors)) {
        warningIssued = true;
        console.warn(
          "[remark-gfm] Warning: please upgrade to remark 13 to use this plugin"
        );
      }
      add2("micromarkExtensions", syntax(options));
      add2("fromMarkdownExtensions", fromMarkdown);
      add2("toMarkdownExtensions", toMarkdown(options));
      function add2(field, value) {
        if (data[field])
          data[field].push(value);
        else
          data[field] = [value];
      }
    }
    const remarkGfm$1 = /* @__PURE__ */ getDefaultExportFromCjs(remarkGfm);
    const isJson = (str) => {
      try {
        JSON.parse(str);
      } catch (e2) {
        return false;
      }
      return true;
    };
    const containerStyles = mergeStyles({
      padding: "4px 20px",
      fontSize: "16px"
    });
    const Markdown = ({
      className,
      content: content2,
      isDark
    }) => {
      if (typeof content2 !== "string") {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: content2 });
      }
      const _content = isJson(content2) ? `\`\`\`json
${content2}
\`\`\`` : content2;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(FluentProvider, { className, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PortalCompatProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        ReactMarkdown,
        {
          components: {
            code: (props) => {
              const { node: node2, inline, children, className: className2, ...otherProps } = props;
              const match5 = /language-(\w+)/.exec(className2 || "");
              return !inline && match5 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                SyntaxHighlighter,
                {
                  ...otherProps,
                  language: match5[1],
                  showLineNumbers: true,
                  style: isDark ? okaidia : void 0,
                  PreTag: "div",
                  children: String(children).replace(/\n$/, "")
                }
              ) : /* @__PURE__ */ jsxRuntimeExports.jsx("code", { className: className2, ...otherProps, children: props.children });
            }
          },
          className: containerStyles,
          children: _content ?? "",
          remarkPlugins: [remarkGfm$1],
          rehypePlugins: [rehypeRaw]
        }
      ) }) });
    };
    const ReactJSON = ({
      id: id2,
      src,
      isDark,
      style: style2,
      isEnableEdit,
      onEdit: _onEdit
    }) => {
      const [value, setValue] = React.useState(src);
      const theme = isDark ? "monokai" : "rjv-default";
      const onEdit = isEnableEdit ? (edit) => {
        const newPayload = edit.updated_src;
        console.log("newPayload ", newPayload);
        setValue(newPayload);
        _onEdit == null ? void 0 : _onEdit(id2, newPayload);
      } : void 0;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(FluentProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PortalCompatProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        ReactJson,
        {
          style: style2,
          src: value,
          theme,
          quotesOnKeys: false,
          displayDataTypes: false,
          onEdit,
          displayObjectSize: false
        }
      ) }) });
    };
    const CustomMessageContent = ({ message }) => {
      const { isDark, viewMode, editMessageHandlerRef } = useAppContext();
      const isLast = useIsLastMessage(message.id, ChatMessageFrom.User);
      const onEdit = (id2, newPayload) => {
        var _a2;
        (_a2 = editMessageHandlerRef.current) == null ? void 0 : _a2.call(editMessageHandlerRef, id2, newPayload);
      };
      const isUserDebug = message.from === ChatMessageFrom.User && viewMode === ViewMode.Debug;
      const jsonContent = reactExports.useMemo(() => parseJSON(message.content), [message.content]);
      const keys2 = Object.keys(jsonContent);
      const robotContent = keys2.length === 1 ? jsonContent[keys2[0]] : message.content;
      const markdownContent = message.from === ChatMessageFrom.Chatbot ? robotContent : message.content;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(MessageHeader, { message, isUserDebug }),
        isUserDebug ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          ReactJSON,
          {
            style: { padding: 10 },
            src: jsonContent,
            isEnableEdit: isLast,
            onEdit,
            isDark,
            id: `${message.id}`
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx(Markdown, { isDark, content: markdownContent }, message.id),
        /* @__PURE__ */ jsxRuntimeExports.jsx(MessageFooter, { message })
      ] });
    };
    const MessageHeaderInfo = ({ message }) => {
      const selectedNavItem = useSelectedNavItem();
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { paddingBottom: "10px" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { fontWeight: "bold", fontSize: "18px", display: "inline-flex", alignItems: "center" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: message.from === ChatMessageFrom.User ? (selectedNavItem == null ? void 0 : selectedNavItem.chatUserName) ?? "User" : (selectedNavItem == null ? void 0 : selectedNavItem.chatBotName) ?? "Chatbot" }),
          message.from === ChatMessageFrom.User ? (selectedNavItem == null ? void 0 : selectedNavItem.chatUserAvatar) && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { paddingLeft: 8 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Image, { src: selectedNavItem == null ? void 0 : selectedNavItem.chatUserAvatar, shape: "circular", width: 32, height: 32 }) }) : (selectedNavItem == null ? void 0 : selectedNavItem.chatBotAvatar) && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { paddingLeft: 8 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Image, { src: selectedNavItem == null ? void 0 : selectedNavItem.chatBotAvatar, shape: "circular", width: 32, height: 32 }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 14, paddingLeft: 12 }, children: hooks(message.timestamp).fromNow() })
      ] });
    };
    const MessageHeader = ({ message, isUserDebug }) => {
      const onCopy = () => {
        copy$1(message.content);
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            width: "100%",
            display: "flex",
            flexDirection: "row",
            alignItems: "center",
            justifyContent: "space-between"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(MessageHeaderInfo, { message }),
            !isUserDebug ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Menu, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(MenuTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { content: "More action", relationship: "label", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { shape: "circular", size: "small", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(MoreVertical24Filled, {}) }) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(MenuPopover, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuList, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Copy24Regular, {}), onClick: onCopy, children: "Copy" }) }) })
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {})
          ]
        }
      );
    };
    const MessageFooter = ({ message }) => {
      return message.duration ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { paddingTop: 5 }, children: [
        "Duration: ",
        message.duration.toFixed(4),
        "s"
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
    };
    const getIsValidInput = (content2) => {
      switch (typeof content2) {
        case "undefined":
          return false;
        case "string":
          return content2.length > 0;
        default:
          return true;
      }
    };
    const btnWrapperCls = mergeStyles({
      display: "flex",
      alignItems: "center",
      justifyContent: "flex-end",
      paddingLeft: 8,
      paddingRight: 8,
      i: {
        fontSize: "1.5em"
      }
    });
    const textFieldCls = mergeStyles({
      display: "flex !important",
      alignItems: "center",
      marginBottom: 10,
      ">label": {
        minWidth: 100,
        textAlign: "right"
      },
      ">.fui-Input": {
        flex: 1
      }
    });
    const ScoreInputBox = ({ scoreInputs, isChatbotTyping, onScore, onClear }) => {
      const messages2 = useMessages(ChatMessageFrom.User);
      const keyboardMessageIndexRef = reactExports.useRef(messages2.length - 1);
      const [inputs, setInputs] = reactExports.useState(scoreInputs);
      reactExports.useEffect(() => {
        keyboardMessageIndexRef.current = messages2.length - 1;
      }, [messages2]);
      const updateKeyboardMessageIndex = (key) => {
        const nextIndex = keyboardMessageIndexRef.current + (key === "ArrowUp" ? -1 : 1);
        if (nextIndex < 0) {
          keyboardMessageIndexRef.current = nextIndex + messages2.length;
          return;
        }
        if (nextIndex >= messages2.length) {
          keyboardMessageIndexRef.current = nextIndex - messages2.length;
          return;
        }
        keyboardMessageIndexRef.current = nextIndex;
      };
      const [areValidInputs, setAreValidInputs] = reactExports.useState(false);
      const inputsContainerRef = reactExports.useRef(null);
      const classes = useStyles$2();
      reactExports.useEffect(() => {
        if (Object.keys(scoreInputs).length) {
          setInputs(lodashExports.cloneDeep(scoreInputs));
        }
      }, [scoreInputs]);
      reactExports.useEffect(() => {
        const allValid = Object.keys(inputs).every((key) => getIsValidInput(inputs[key].value));
        setAreValidInputs(allValid);
      }, [inputs]);
      const onClick = reactExports.useCallback(() => {
        onScore(inputs);
        if (Object.keys(scoreInputs).length) {
          setInputs(
            lodashExports.cloneDeep(
              Object.fromEntries(Object.keys(scoreInputs).map((key) => [key, { ...scoreInputs[key], value: void 0 }]))
            )
          );
        }
      }, [inputs, onScore, scoreInputs]);
      const onKeyDown = reactExports.useCallback(
        (e2) => {
          if (e2.key === "Enter" && areValidInputs) {
            onClick();
          }
        },
        [areValidInputs, onClick]
      );
      reactExports.useEffect(() => {
        var _a2;
        if (!isChatbotTyping && inputsContainerRef.current) {
          (_a2 = inputsContainerRef.current.querySelector("input")) == null ? void 0 : _a2.focus();
        }
      }, [isChatbotTyping]);
      const inputNodes = Object.keys(inputs).map((key) => {
        const { type, sample, value } = inputs[key];
        const onChange = (_ev, data) => {
          const newValue = data.value;
          setInputs((prevInputs) => ({
            ...prevInputs,
            [key]: { ...prevInputs[key], value: newValue }
          }));
          keyboardMessageIndexRef.current = messages2.length - 1;
        };
        const onKeyup = (e2) => {
          if (e2.key === "ArrowUp" || e2.key === "ArrowDown") {
            setInputs((prevInputs) => {
              const payload = JSON.parse(messages2[keyboardMessageIndexRef.current].content);
              return {
                ...prevInputs,
                [key]: { ...prevInputs[key], value: payload[key] }
              };
            });
            console.log("ArrowUp");
            updateKeyboardMessageIndex(e2.key);
          }
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { label: key, required: true, orientation: "horizontal", className: textFieldCls, size: "large", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input,
          {
            type,
            size: "large",
            onKeyDown,
            disabled: isChatbotTyping,
            onChange,
            onKeyUp: onKeyup,
            placeholder: sample,
            value: value ?? ""
          }
        ) }, key);
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: classes.inputBox, "data-disabled": isChatbotTyping, style: { display: "flex" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { flex: 1, marginBottom: -10 }, ref: inputsContainerRef, children: inputNodes }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: btnWrapperCls, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { relationship: "description", content: "Send message", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              as: "button",
              appearance: "primary",
              shape: "circular",
              style: { marginLeft: "10px", width: "40px", height: "36px", maxWidth: 40, maxHeight: 40 },
              size: "medium",
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Send24Regular, {}),
              disabled: isChatbotTyping || !areValidInputs,
              onClick
            }
          ) }),
          onClear ? /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { relationship: "description", content: LocStrings.ClearHistoryTooltip, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              style: { marginLeft: "10px", width: "40px", height: "36px", maxWidth: 40, maxHeight: 40 },
              as: "button",
              shape: "circular",
              size: "medium",
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Broom16Filled, {}),
              disabled: isChatbotTyping,
              onClick: onClear
            }
          ) }) : void 0
        ] })
      ] });
    };
    const downloadBlob = (blob, fileName) => {
      const url = URL.createObjectURL(blob);
      const a2 = document.createElement("a");
      a2.href = url;
      a2.download = fileName;
      document.body.appendChild(a2);
      a2.click();
      document.body.removeChild(a2);
      URL.revokeObjectURL(url);
    };
    const formItemStyles = mergeStyles({
      display: "flex",
      flexDirection: "column",
      marginBottom: 15,
      "> label": {
        marginBottom: 10,
        fontSize: 16
      }
    });
    const ToolbarActions = () => {
      const {
        isDark,
        setIsDark,
        messages: messages2,
        viewMode,
        setViewMode,
        chatDBRef,
        isDisableChatHistory,
        appConfig,
        setAppConfig,
        setIsDisableChatHistory
      } = reactExports.useContext(AppContext);
      const [newAppDisplayName, setNewAppDisplayName] = reactExports.useState();
      const [isSettingsOpen, setIsSettingsOpen] = reactExports.useState(false);
      const dismissPanel = reactExports.useCallback(() => {
        setIsSettingsOpen(false);
      }, []);
      const [openClearCurrentApp, setOpenClearCurrentApp] = reactExports.useState(false);
      const [openClearAllApp, setOpenClearAllApp] = reactExports.useState(false);
      const onToggleDark = () => {
        setIsDark(!isDark);
      };
      const onNewAppDisplayNameChange = reactExports.useCallback(
        (_e, data) => {
          setNewAppDisplayName(data.value);
        },
        []
      );
      const onClearCurrentApp = reactExports.useCallback(() => {
        var _a2;
        (_a2 = chatDBRef.current) == null ? void 0 : _a2.clear();
        setOpenClearCurrentApp(false);
        setTimeout(() => {
          window.location.reload();
        }, 200);
      }, []);
      const openClearAllAppData = () => {
        ChatIndexedDB.clearAllDataBase(chatDBRef.current);
        setOpenClearAllApp(false);
        setTimeout(() => {
          window.location.reload();
        }, 200);
      };
      const onConfirmAppDisplayNameChange = reactExports.useCallback(() => {
        var _a2, _b;
        const nextAppConfig = { id: appConfig.id || uuid_1.v4(), type: appConfigTypeValue, appDisplayName: newAppDisplayName };
        setAppConfig((pre) => {
          if (!(pre == null ? void 0 : pre.id)) {
            return nextAppConfig;
          }
          return { ...pre, appDisplayName: newAppDisplayName };
        });
        (_b = (_a2 = chatDBRef.current) == null ? void 0 : _a2.getStore(chatConfigIndexDBName)) == null ? void 0 : _b.put(nextAppConfig);
      }, [newAppDisplayName, appConfig]);
      const appDisplayNameId = useId("appDisplayName");
      const onDownloadHistory = reactExports.useCallback(() => {
        const json2 = {};
        for (const [key, value] of messages2) {
          json2[key] = value;
        }
        const blob = new Blob([JSON.stringify(json2, void 0, 2)], { type: "application/json" });
        downloadBlob(blob, "chat-history.json");
      }, [messages2]);
      const onToggleViewMode = reactExports.useCallback(() => {
        setViewMode((pre) => pre === ViewMode.Normal ? ViewMode.Debug : ViewMode.Normal);
      }, []);
      const onToggleDisableChatHistory = () => {
        setIsDisableChatHistory((pre) => !pre);
      };
      const openSettingsPanel = reactExports.useCallback(() => {
        setIsSettingsOpen(true);
      }, []);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { content: "Settings", relationship: "label", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Settings24Regular, {}), onClick: openSettingsPanel }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { modalType: "modal", open: isSettingsOpen, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogSurface, { style: { width: 500, height: "100vh", marginRight: 0 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogBody, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", justifyContent: "space-between" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Settings" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { appearance: "subtle", icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Dismiss24Filled, {}), onClick: dismissPanel })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Switch,
              {
                labelPosition: "after",
                label: LocStrings.Settings.useDarkTheme,
                onChange: onToggleDark,
                checked: isDark
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Switch, { label: "Debug", checked: viewMode === ViewMode.Debug, onChange: onToggleViewMode }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Switch,
              {
                label: "Enable chat history",
                checked: !isDisableChatHistory,
                onChange: onToggleDisableChatHistory
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, { style: { margin: "10px 0" } }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: formItemStyles, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { htmlFor: appDisplayNameId, children: "Edit app name" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", width: "100%" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    id: appDisplayNameId,
                    value: newAppDisplayName ?? (appConfig == null ? void 0 : appConfig.appDisplayName),
                    style: { width: "100%" },
                    size: "large",
                    onChange: onNewAppDisplayNameChange
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { style: { marginLeft: 10 }, onClick: onConfirmAppDisplayNameChange, children: "Save" })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onDownloadHistory, size: "large", appearance: "secondary", children: "Download history" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, { style: { margin: "10px 0" } }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { children: "Clear Chat history" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: 10 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Popover, { open: openClearCurrentApp, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverTrigger, { disableButtonEnhancement: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    size: "large",
                    appearance: "subtle",
                    onClick: () => {
                      setOpenClearCurrentApp(true);
                    },
                    children: "Clear current chat app"
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverSurface, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { padding: 10 }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { children: "Are you sure you want to clear the current chat app data?" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", justifyContent: "center", marginTop: 10 }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Button,
                      {
                        style: { marginRight: 10 },
                        onClick: onClearCurrentApp,
                        size: "large",
                        appearance: "primary",
                        children: "Yes"
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Button,
                      {
                        onClick: () => {
                          setOpenClearCurrentApp(false);
                        },
                        size: "large",
                        appearance: "subtle",
                        children: "No"
                      }
                    )
                  ] })
                ] }) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Popover, { open: openClearAllApp, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverTrigger, { disableButtonEnhancement: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    style: { marginLeft: 10 },
                    size: "large",
                    appearance: "subtle",
                    onClick: () => {
                      setOpenClearAllApp(true);
                    },
                    children: "Clear all chat app"
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverSurface, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { padding: 10 }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { children: "Are you sure you want to clear all chat app data?" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", justifyContent: "center", marginTop: 10 }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Button,
                      {
                        style: { marginRight: 10 },
                        onClick: openClearAllAppData,
                        size: "large",
                        appearance: "primary",
                        children: "Yes"
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Button,
                      {
                        onClick: () => {
                          setOpenClearAllApp(false);
                        },
                        size: "large",
                        appearance: "subtle",
                        children: "No"
                      }
                    )
                  ] })
                ] }) })
              ] })
            ] })
          ] })
        ] }) }) })
      ] });
    };
    const typingClassName = mergeStyles({
      backgroundColor: "var(--colorNeutralBackground4)",
      padding: "10px 20px",
      borderRadius: 16
    });
    const ChatBox = ({ scoreInputs, isChatHistoryExist }) => {
      const [isChatbotTyping, setIsChatbotTyping] = reactExports.useState(false);
      const {
        isDisableChatHistory,
        setIsChatHistoryExist,
        appConfig = {},
        editMessageHandlerRef,
        currentMessageNavIdRef
      } = reactExports.useContext(AppContext);
      const displayMessages = useDisplayMessages();
      const currentChatHistory = useCurrentChatHistory();
      const { id: navId } = useSelectedNavItem() ?? {};
      const { setAddChatHistory } = useChatHistoryActions();
      const isFullScreen = useFullScreen();
      const onToggleFullScreen = useToggleFullScreen();
      const { setAddMessage, setResetAtIdAndRemoveAfterId } = useMessageActions();
      const setNewNavItemName = useSetNewNavItemName();
      const [navList] = useNavList();
      reactExports.useEffect(() => {
        setIsChatHistoryExist(isChatHistoryExist);
      }, [isChatHistoryExist]);
      const onScoreSettle = (d2, payload, duration) => {
        setAddMessage(cookRobotMessage(d2, duration));
        setAddChatHistory(payload, d2, duration);
        currentMessageNavIdRef.current = "";
      };
      const sendScoreMutation = useMutation(
        {
          url: "/score",
          method: "POST"
        },
        {
          onSettled: (resp, error, payload) => {
            var _a2;
            setIsChatbotTyping(false);
            if (error) {
              setAddMessage(cookRobotMessage(error.message));
              currentMessageNavIdRef.current = "";
              return;
            }
            onScoreSettle((resp == null ? void 0 : resp.data) ?? {}, payload || {}, (_a2 = resp == null ? void 0 : resp.config.metaData) == null ? void 0 : _a2.duration);
          }
        }
      );
      editMessageHandlerRef.current = async (id2, newPayload) => {
        setResetAtIdAndRemoveAfterId(id2, cookUserMessage(newPayload));
        setIsChatbotTyping(true);
        sendScoreMutation.mutate(newPayload);
      };
      const onScore = async (inputs) => {
        const payload = convertInputsToPayload(inputs, currentChatHistory, isChatHistoryExist, isDisableChatHistory);
        currentMessageNavIdRef.current = navId ?? "";
        const message = cookUserMessage(payload);
        setAddMessage(message);
        if (navList.length && navList[0].name === "") {
          const input = Object.values(inputs)[0].value ?? "";
          setNewNavItemName(input);
        }
        setIsChatbotTyping(true);
        sendScoreMutation.mutate(payload);
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        PureChatBox,
        {
          containerStyles: { backgroundColor: "var(--colorNeutralBackground3)" },
          toolbarContainerStyles: { backgroundColor: "var(--colorNeutralBackground1)" },
          chatTitle: appConfig.appDisplayName,
          isBottomTipVisible: void 0,
          isFullScreen,
          isChatbotTyping: isChatbotTyping && currentMessageNavIdRef.current === navId,
          typingClassName,
          messages: displayMessages,
          onBottomTipVisibleChange: void 0,
          onClear: void 0,
          LocStrings,
          onToggleFullScreen,
          onClose: void 0,
          customToolbarActions: /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarActions, {}),
          CustomMessageContentRenderer: CustomMessageContent,
          customInputBox: /* @__PURE__ */ jsxRuntimeExports.jsx(ScoreInputBox, { scoreInputs, isChatbotTyping, onScore }),
          onSendMessage: void 0
        }
      );
    };
    const fileToBase64 = async (file) => {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = function() {
          resolve(reader.result);
        };
        reader.onerror = function(error) {
          reject(error);
        };
      });
    };
    const FileInput = ({ name: name2 = "file-input", onFileChange: _onFileChange, value }) => {
      const [base64Src, setBase64Src] = reactExports.useState(value ?? "");
      const fileInputRef = reactExports.useRef(null);
      const onFileClick = reactExports.useCallback(() => {
        var _a2;
        (_a2 = fileInputRef.current) == null ? void 0 : _a2.click();
      }, []);
      const onFileChange = reactExports.useCallback(
        async (e2) => {
          var _a2;
          const file = (_a2 = e2.target.files) == null ? void 0 : _a2[0];
          if (file) {
            const base64String = await fileToBase64(file);
            setBase64Src(base64String);
            _onFileChange == null ? void 0 : _onFileChange(base64String);
          }
        },
        [_onFileChange]
      );
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("input", { type: "file", name: name2, ref: fileInputRef, onChange: onFileChange, style: { display: "none" } }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Avatar, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Add24Regular, {}), shape: "square", onClick: onFileClick }),
        base64Src ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { paddingTop: 15 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Image, { bordered: true, shape: "circular", src: base64Src, alt: "image", style: { width: 160, height: 160 } }) }) : void 0
      ] });
    };
    const useOnCopyNav = () => {
      const { name: name2 } = useSelectedNavItem() ?? {};
      return reactExports.useCallback(() => {
        copy$1(name2 ?? "");
      }, [name2]);
    };
    const navStyles = mergeStyles({
      ".ms-Nav-groupContent": {
        "> .ms-Nav-navItems": {
          "> .ms-Nav-navItem": {
            button: {
              color: "var(--colorNeutralForeground1)"
            }
          }
        }
      }
    });
    const navEditFormItemStyles = mergeStyles({
      display: "flex",
      flexDirection: "column",
      marginBottom: 15,
      "> label": {
        marginBottom: 5,
        fontSize: 16
      }
    });
    const addNav = {
      id: "newChat",
      name: "New chat",
      url: ""
    };
    const buttonContentStyles = {
      display: "flex",
      width: "100%",
      whiteSpace: "nowrap",
      overflow: "hidden",
      textOverflow: "ellipsis",
      fontSize: 18,
      fontWeight: "bold"
    };
    const CreateNavButton = ({ link: link2 }) => {
      const setCreateNavItem = useCreateNavItem();
      const isEnableCreateNavItem = useEnableCreateNavItem();
      const onClick = () => {
        setCreateNavItem();
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          onClick,
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Add24Filled, {}),
          shape: "rounded",
          disabled: !isEnableCreateNavItem,
          style: {
            width: "90%",
            marginLeft: "5%",
            marginTop: 10,
            height: 50
          },
          children: (link2 == null ? void 0 : link2.name) ?? ""
        }
      );
    };
    const LinkButton = (props) => {
      var _a2, _b, _c, _d, _e, _f;
      const { onDelete } = props;
      const selectNavItem = useSelectNavItem();
      const onItemClick = (link2) => {
        if (link2) {
          selectNavItem(link2.id);
        }
      };
      const onMoreAction = reactExports.useCallback((e2) => {
        e2.stopPropagation();
      }, []);
      const onCopy = useOnCopyNav();
      const onEdit = reactExports.useCallback(() => {
        var _a3, _b2;
        console.log("on edit", props.link);
        (_b2 = props.onEditing) == null ? void 0 : _b2.call(props, ((_a3 = props.link) == null ? void 0 : _a3.id) ?? "");
      }, [props.onEditing, (_a2 = props.link) == null ? void 0 : _a2.id]);
      const icon = reactExports.useMemo(() => {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(Menu, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(MenuTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { shape: "circular", style: {}, size: "small", onClick: onMoreAction, icon: /* @__PURE__ */ jsxRuntimeExports.jsx(MoreVertical24Filled, {}) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MenuPopover, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(MenuList, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Copy24Regular, {}), onClick: onCopy, children: "Copy" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Edit24Filled, {}), onClick: onEdit, children: "Update" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Delete24Regular, {}), onClick: onDelete, children: "Delete" })
          ] }) })
        ] });
      }, [onMoreAction, onCopy]);
      return ((_b = props.link) == null ? void 0 : _b.id) === "newChat" ? /* @__PURE__ */ jsxRuntimeExports.jsx(CreateNavButton, { link: props.link }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Tooltip, { content: ((_c = props.link) == null ? void 0 : _c.name) ?? "", relationship: "label", positioning: "after", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          onClick: () => onItemClick(props.link),
          shape: "square",
          as: "a",
          style: {
            width: "94%",
            marginLeft: "3%",
            border: 0,
            height: 50,
            marginTop: 10,
            backgroundColor: ((_d = props.link) == null ? void 0 : _d.isSelected) ? "var(--colorNeutralBackground3)" : ""
          },
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { visibility: ((_e = props.link) == null ? void 0 : _e.isSelected) ? "visible" : "hidden" }, children: icon }),
          iconPosition: "after",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: buttonContentStyles, children: (_f = props.link) == null ? void 0 : _f.name })
        }
      ) });
    };
    const NavContainer = () => {
      const [navList] = useNavList();
      const [isOpen, setIsOpen] = reactExports.useState(false);
      const [isDeleteOpen, setIsDeleteOpen] = reactExports.useState(false);
      const [newName, setNewName] = reactExports.useState("");
      const [chatUserName, setChatUserName] = reactExports.useState("");
      const [chatUserAvatar, setChatUserAvatar] = reactExports.useState("");
      const [chatBotName, setChatBotName] = reactExports.useState("");
      const [chatBotAvatar, setChatBotAvatar] = reactExports.useState("");
      const setCreateNavItem = useCreateNavItem();
      const selectNavItem = useSelectNavItem();
      const onOpenDialog = reactExports.useCallback(
        (id2) => {
          setIsOpen(true);
          const nav = navList.find((nav2) => nav2.id === id2);
          setNewName((nav == null ? void 0 : nav.name) ?? "");
          setChatUserName((nav == null ? void 0 : nav.chatUserName) ?? "");
          setChatUserAvatar((nav == null ? void 0 : nav.chatUserAvatar) ?? "");
          setChatBotName((nav == null ? void 0 : nav.chatBotName) ?? "");
          setChatBotAvatar((nav == null ? void 0 : nav.chatBotAvatar) ?? "");
        },
        [navList]
      );
      const onEdit = useEditSelectedNavItem();
      const onNewNameChange = reactExports.useCallback((e2, data) => {
        e2.stopPropagation();
        setNewName(data.value ?? "");
      }, []);
      const onNewChatUserNameChange = reactExports.useCallback(
        (e2, data) => {
          e2.stopPropagation();
          setChatUserName(data.value ?? "");
        },
        []
      );
      const onNewChatUserAvatarChange = reactExports.useCallback((base64String) => {
        setChatUserAvatar(base64String);
      }, []);
      const onNewChatBotNameChange = reactExports.useCallback(
        (e2, data) => {
          e2.stopPropagation();
          setChatBotName(data.value ?? "");
        },
        []
      );
      const onNewChatBotAvatarChange = reactExports.useCallback((base64String) => {
        setChatBotAvatar(base64String);
      }, []);
      const onEditNavName = () => {
        onEdit({
          name: newName,
          chatUserName,
          chatUserAvatar,
          chatBotName,
          chatBotAvatar
        });
        setIsOpen(false);
      };
      const navNameId = useId("navName");
      const chatUserNameId = useId("chatUserName");
      const chatBotNameId = useId("chatBotName");
      const chatUserAvatarId = useId("chatUserAvatar");
      const chatBotAvatarId = useId("chatBotAvatar");
      reactExports.useEffect(() => {
        console.log("realod the nav container");
      }, []);
      const navItems = reactExports.useMemo(() => {
        return [addNav].concat(
          navList.map((nav) => {
            return {
              id: nav.id,
              name: nav.name,
              url: "",
              isSelected: nav.isSelected
            };
          })
        );
      }, [navList]);
      const displayNavList = reactExports.useMemo(() => {
        return navItems.filter((nav) => !!nav.name);
      }, [navItems]);
      const onDelete = reactExports.useCallback(() => {
        setIsDeleteOpen(true);
      }, []);
      const onConfirmDelete = useDeleteSelectedNavItem();
      const _onConfirmDelete = reactExports.useCallback(() => {
        onConfirmDelete();
        setIsDeleteOpen(false);
        if (navList.length === 1) {
          requestAnimationFrame(() => {
            setCreateNavItem();
          });
        } else {
          selectNavItem(0);
        }
      }, [navList, onConfirmDelete, setCreateNavItem]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Nav,
          {
            className: navStyles,
            styles: {
              root: {
                width: 320
              },
              compositeLink: {
                backgroundColor: "var(--colorNeutralBackground1)"
              }
            },
            linkAs: (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(LinkButton, { ...props, onEditing: onOpenDialog, onDelete }),
            groups: [
              {
                links: displayNavList
              }
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open: isOpen, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogSurface, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogBody, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { children: "Edit this chat" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { style: { margin: "5px 0 10px 0" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: navEditFormItemStyles, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { htmlFor: navNameId, children: "Name" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input,
                {
                  id: navNameId,
                  value: newName,
                  style: { width: "100%" },
                  size: "large",
                  onChange: onNewNameChange
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: navEditFormItemStyles, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { htmlFor: chatUserNameId, children: "Chat user name" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input,
                {
                  id: chatUserNameId,
                  value: chatUserName,
                  style: { width: "100%" },
                  size: "large",
                  onChange: onNewChatUserNameChange
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: navEditFormItemStyles, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { htmlFor: chatUserAvatarId, children: "Chat user avatar" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(FileInput, { name: "chatUserAvatar", onFileChange: onNewChatUserAvatarChange, value: chatUserAvatar })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: navEditFormItemStyles, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { htmlFor: chatBotNameId, children: "Chat bot name" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input,
                {
                  id: chatBotNameId,
                  value: chatBotName,
                  style: { width: "100%" },
                  size: "large",
                  onChange: onNewChatBotNameChange
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: navEditFormItemStyles, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { htmlFor: chatBotAvatarId, children: "Chat bot avatar" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(FileInput, { name: "chatBotAvatar", onFileChange: onNewChatBotAvatarChange, value: chatBotAvatar })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogActions, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTrigger, { disableButtonEnhancement: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { size: "large", appearance: "secondary", onClick: () => setIsOpen(false), children: "Close" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { size: "large", appearance: "primary", onClick: onEditNavName, children: "Update" })
          ] })
        ] }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Dialog,
          {
            modalType: "alert",
            open: isDeleteOpen,
            onOpenChange: (_event, data) => {
              setIsDeleteOpen(data.open);
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogSurface, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogBody, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { children: "Delete the chat" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContent, { children: "This chat will no longer appear here. Also all the messages in this chat will be deleted." }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogActions, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTrigger, { disableButtonEnhancement: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { appearance: "secondary", children: "Close" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { appearance: "primary", onClick: _onConfirmDelete, children: "Delete" })
              ] })
            ] }) })
          }
        )
      ] });
    };
    const ChatContainer = () => {
      const { setAppInfo } = reactExports.useContext(AppContext);
      const { inputs: scoreInputs, appInfo, isChatHistoryExist } = useScoreInputs();
      useCreateChatStore(appInfo);
      reactExports.useEffect(() => {
        setAppInfo(appInfo);
      }, [appInfo]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Stack, { horizontal: true, style: { height: "100vh" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(NavContainer, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { flex: 1, width: "100%", overflow: "hidden" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChatBox, { scoreInputs, appInfo, isChatHistoryExist }) })
      ] });
    };
    const useStyles = makeStyles({
      container: {
        width: "100%",
        height: "100%",
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
      }
    });
    const Loading = () => {
      const styles2 = useStyles();
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles2.container, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { label: "Loading..." }) });
    };
    class Storage {
      static get(k2) {
        const v2 = localStorage.getItem(k2);
        if (v2 === null) {
          return null;
        }
        return JSON.parse(v2);
      }
      static set(k2, v2) {
        localStorage.setItem(k2, JSON.stringify(v2));
      }
    }
    const useAppContextValue = () => {
      const [messages2, setMessages] = reactExports.useState(/* @__PURE__ */ new Map());
      const [isChatHistoryExist, setIsChatHistoryExist] = reactExports.useState(false);
      const [appInfo, setAppInfo] = reactExports.useState({});
      const [appConfig, setAppConfig] = reactExports.useState({});
      const currentMessageNavIdRef = reactExports.useRef("");
      const [chatHistory, setChatHistory] = reactExports.useState(/* @__PURE__ */ new Map());
      const [isDisableChatHistory, setIsDisableChatHistory] = useIsDisableChatHistory();
      const [viewMode, setViewMode] = useViewMode();
      const [isDark, setIsDark] = useIsDark();
      const [navList, setNavList] = reactExports.useState([]);
      const editMessageHandlerRef = reactExports.useRef();
      const chatDBRef = reactExports.useRef();
      const chatStoreRef = reactExports.useRef();
      const chatStoreName = reactExports.useMemo(() => {
        return getChatStoreName(appInfo.name, appInfo.version);
      }, [appInfo.name, appInfo.version]);
      return reactExports.useMemo(() => {
        return {
          appInfo,
          setAppInfo,
          chatStoreName,
          currentMessageNavIdRef,
          isDark,
          setIsDark,
          isDisableChatHistory,
          setIsDisableChatHistory,
          messages: messages2,
          setMessages,
          isChatHistoryExist,
          setIsChatHistoryExist,
          chatHistory,
          setChatHistory,
          viewMode,
          setViewMode,
          editMessageHandlerRef,
          chatDBRef,
          chatStoreRef,
          navList,
          setNavList,
          appConfig,
          setAppConfig
        };
      }, [
        isDark,
        setIsDark,
        chatStoreName,
        isDisableChatHistory,
        setIsDisableChatHistory,
        viewMode,
        setViewMode,
        messages2,
        chatHistory,
        appInfo,
        navList,
        appConfig
      ]);
    };
    const useViewMode = () => {
      const [viewMode, setViewMode] = reactExports.useState(() => {
        return Storage.get("viewMode") ?? ViewMode.Normal;
      });
      const _setViewMode = reactExports.useCallback((nextViewMode) => {
        if (typeof nextViewMode === "function") {
          setViewMode((preViewMode) => {
            const _nextViewMode = nextViewMode(preViewMode);
            Storage.set("viewMode", _nextViewMode);
            return _nextViewMode;
          });
        } else {
          setViewMode(nextViewMode);
          Storage.set("viewMode", nextViewMode);
        }
      }, []);
      return [viewMode, _setViewMode];
    };
    const useIsDisableChatHistory = () => {
      const [isDisableChatHistory, setIsDisableChatHistory] = reactExports.useState(() => {
        return Storage.get("isDisableChatHistory") ?? false;
      });
      const _setIsDisableChatHistory = reactExports.useCallback(
        (nextIsDisableChatHistory) => {
          if (typeof nextIsDisableChatHistory === "function") {
            setIsDisableChatHistory((preIsDisableChatHistory) => {
              const _nextIsDisableChatHistory = nextIsDisableChatHistory(preIsDisableChatHistory);
              Storage.set("isDisableChatHistory", _nextIsDisableChatHistory);
              return _nextIsDisableChatHistory;
            });
          } else {
            Storage.set("isDisableChatHistory", nextIsDisableChatHistory);
            setIsDisableChatHistory(nextIsDisableChatHistory);
          }
        },
        []
      );
      return [isDisableChatHistory, _setIsDisableChatHistory];
    };
    const useIsDark = () => {
      const [isDark, setIsDark] = reactExports.useState(() => {
        return Storage.get("isDark") ?? false;
      });
      const _setIsDark = reactExports.useCallback((nextIsDark) => {
        if (typeof nextIsDark === "function") {
          setIsDark((preIsDark) => {
            const _nextIsDark = nextIsDark(preIsDark);
            Storage.set("isDark", _nextIsDark);
            return _nextIsDark;
          });
        } else {
          setIsDark(nextIsDark);
          Storage.set("isDark", nextIsDark);
        }
      }, []);
      return [isDark, _setIsDark];
    };
    const App = () => {
      const appContextValue = useAppContextValue();
      const theme = reactExports.useMemo(() => {
        return appContextValue.isDark ? teamsDarkTheme : teamsLightTheme;
      }, [appContextValue.isDark]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(QueryClientProvider, { client: queryClient, children: /* @__PURE__ */ jsxRuntimeExports.jsx(AppContext.Provider, { value: appContextValue, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FluentProvider, { theme, style: { width: "100%" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(Loading, {}), children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChatContainer, {}) }) }) }) });
    };
    initializeIcons();
    ReactDOM.render(/* @__PURE__ */ jsxRuntimeExports.jsx(App, {}), document.getElementById("root"));
  }
});
export default require_index_001();
