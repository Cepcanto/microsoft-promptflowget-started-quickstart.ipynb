import yaml
import logging
import tempfile
from pathlib import Path


logger = logging.getLogger(__name__)
package_name = "{{ package_name }}"
package_uuid = "{{ package_uuid }}"
meta_cache_file = Path(tempfile.gettempdir()) / "promptflow" / "tool_metas" / f"{package_uuid}.yaml"


def list_package_tools(raise_error=False):
    """
    List the meta of all tools in the package.
    The key of meta dict is the module name of tools and value is the meta data of the tool.
    """
    # This function is auto generated by pf CLI, please do not modify manually.
    tools = {}
    if meta_cache_file.exists():
        logger.debug(f"List tool metas from cache file {meta_cache_file.as_posix()}.")
        # Get tool meta from cache file.
        with open(meta_cache_file, "r") as f:
            tools = yaml.safe_load(f)
    else:
        from promptflow import PFClient

        def is_editable():
            # Check the package is editable.
            from pkg_resources import get_distribution, DistributionNotFound

            try:
                dist = get_distribution(package_name)
                return dist.has_metadata('RECORD') and 'egg-link' in dist.get_metadata_lines('RECORD')[0]
            except DistributionNotFound:
                return False

        pf_client = PFClient()
        tools = pf_client.tools._list_tools_in_package(package_name, raise_error=raise_error)

        if is_editable():
            # If the package is not editable, record tool meta in catch file.
            logger.debug(f"Generate tool metas to cache file {meta_cache_file.as_posix()}.")
            meta_cache_file.parent.mkdir(parents=True, exist_ok=True)
            with open(meta_cache_file, "w", encoding="utf-8") as f:
                yaml.safe_dump(tools, f)
    return tools
