# ---------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# ---------------------------------------------------------

import json
import string
import sys
from datetime import datetime
from enum import Enum
from functools import cached_property
from traceback import TracebackException

from promptflow._constants import ERROR_RESPONSE_COMPONENT_NAME


class ErrorTarget(str, Enum):
    EXECUTOR = "Executor"
    FLOW_EXECUTOR = "FlowExecutor"
    NODE_EXECUTOR = "NodeExecutor"
    TOOL = "Tool"
    AZURE_RUN_STORAGE = "AzureRunStorage"
    RUNTIME = "Runtime"
    UNKNOWN = "Unknown"
    RUN_TRACKER = "RunTracker"
    RUN_STORAGE = "RunStorage"
    CONTROL_PLANE_SDK = "ControlPlaneSDK"
    SERVING_APP = "ServingApp"


class ResponseCode(str, Enum):
    SUCCESS = "200"
    ACCEPTED = "202"
    REDIRECTION = "300"
    CLIENT_ERROR = "400"
    SERVICE_ERROR = "500"
    UNKNOWN = "0"


class RootErrorCode:
    USER_ERROR = "UserError"
    SYSTEM_ERROR = "SystemError"


RESPONSE_CODE = "response_code"
ADDITIONAL_INFO_USER_EXECUTION_ERROR = "ToolExecutionErrorDetails"


class ErrorResponse:
    """A class that represents the response body when an error occurs.

    It follows the following specification:
    https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md#7102-error-condition-responses

    It also compatible with the AzureML error response.
    The AzureML services' ErrorResponse is defined and created here:
    https://msdata.visualstudio.com/Vienna/_git/vienna?path=%2Fsrc%2Fazureml-api%2Fsrc%2FCommon%2FCore%2FContracts%2FErrorResponse.cs
    https://msdata.visualstudio.com/Vienna/_git/vienna?path=%2Fsrc%2Fazureml-api%2Fsrc%2FCommon%2FWebApi%2FErrorHandling%2FResponse%2FErrorResponseBuilder.cs
    """

    def __init__(self, error_dict):
        self._error_dict = error_dict

    # Input should be one error_dict.
    # Which usually is generated by ExceptionPresenter.to_dict() or PromptflowException.to_dict()
    @staticmethod
    def from_error_dict(error_dict):
        return ErrorResponse(error_dict)

    @staticmethod
    def from_exception(ex: Exception, *, include_debug_info=False):
        presenter = ExceptionPresenter(ex)
        error_dict = presenter.to_dict(include_debug_info=include_debug_info)
        return ErrorResponse(error_dict)

    @property
    def message(self):
        return self._error_dict.get("message", "")

    @property
    def response_code(self):
        """Given the error code, return the corresponding http response code."""
        root_error_code = self._error_dict.get("code")
        return (
            ResponseCode.CLIENT_ERROR
            if root_error_code == RootErrorCode.USER_ERROR
            else ResponseCode.SERVICE_ERROR
        )

    @property
    def additional_info(self):
        """Return the additional info of the error.

        The additional info is defined in the error response.
        It is stored as a list of dict, each of which contains a "type" and "info" field.

        We change the list of dict to a dict of dict for easier access.
        """
        result = {}
        list_of_dict = self._error_dict.get("additionalInfo")
        if not list_of_dict or not isinstance(list_of_dict, list):
            return result

        for item in list_of_dict:
            # We just ignore the item if it is not a dict or does not contain the required fields.
            if not isinstance(item, dict):
                continue

            name = item.get("type")
            info = item.get("info")
            if not name or not info:
                continue

            result[name] = info

        return result

    def get_additional_info(self, name):
        """Get the additional info by name."""
        return self.additional_info.get(name)

    def get_user_execution_error_info(self):
        """Get user tool execution error info from additional info."""
        user_execution_error_info = self.get_additional_info(
            ADDITIONAL_INFO_USER_EXECUTION_ERROR
        )
        if not user_execution_error_info or not isinstance(
            user_execution_error_info, dict
        ):
            return {}
        return user_execution_error_info

    def to_dict(self):
        from promptflow._utils.utils import get_runtime_version

        return {
            "error": self._error_dict,
            "correlation": None,  # TODO: to be implemented
            "environment": None,  # TODO: to be implemented
            "location": None,  # TODO: to be implemented
            "componentName": f"{ERROR_RESPONSE_COMPONENT_NAME}/{get_runtime_version()}",
            "time": datetime.utcnow().isoformat(),
        }

    def to_simplified_dict(self):
        return {
            "error": {
                "code": self._error_dict.get("code"),
                "message": self._error_dict.get("message"),
            }
        }

    @property
    def error_codes(self):
        error = self._error_dict
        error_codes = []
        while error is not None:
            code = error.get("code")
            if code is not None:
                error_codes.append(code)
                error = error.get("innerError")
            else:
                break

        return error_codes

    @property
    def error_code_hierarchy(self):
        """Get the code hierarchy from error dict."""

        return "/".join(self.error_codes)

    @property
    def innermost_error_code(self):
        error_codes = self.error_codes

        if error_codes:
            return error_codes[-1]

        return None


class ExceptionPresenter:
    """A class that can extract information from the exception instance.

    It is designed to work for both PropmtflowException and other exceptions.
    """

    def __init__(self, ex: Exception):
        self._ex = ex

    @property
    def formatted_traceback(self):
        te = TracebackException.from_exception(self._ex)
        return "".join(te.format())

    @property
    def debug_info(self):
        return {
            "type": self._ex.__class__.__qualname__,
            "stackTrace": self.formatted_traceback,
        }

    def to_dict(self, *, include_debug_info=False):
        """Return a dict representation of the exception.

        This dict specification corresponds to the specification of the Microsoft API Guidelines:
        https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md#7102-error-condition-responses

        Note that this dict representation the "error" field in the response body of the API.
        The whole error response is then populated in another place outside of this class.
        """
        # If the exception is PromptflowException, return the dict representation of it.
        if isinstance(self._ex, PromptflowException):
            return self._ex.to_dict(include_debug_info=include_debug_info)

        if isinstance(self._ex, JsonSerializedPromptflowException):
            return self._ex.to_dict(include_debug_info=include_debug_info)

        # Otherwise, return general dict representation of the exception.
        result = {
            "code": infer_error_code_from_class(SystemErrorException),
            "message": str(self._ex),
            "messageFormat": "",
            "messageParameters": {},
            "innerError": {
                "code": self._ex.__class__.__name__,
                "innerError": None,
            },
        }
        if include_debug_info:
            result["debugInfo"] = self.debug_info

        return result


class JsonSerializedPromptflowException(Exception):
    """Json serialized PromptflowException.
    This exception only has one argument message to voide the
    argument missing error when load/dump with pickle in multiprocessing.
    Ref: https://bugs.python.org/issue32696

    :param message: A Json serialized message describing the error.
    :type message: str
    """

    def __init__(self, message):
        self.message = message
        super().__init__(self.message)

    def __str__(self):
        return self.message

    def to_dict(self, *, include_debug_info=False):
        # Return a dict representation of the inner exception.
        error_dict = json.loads(self.message)

        # The original serialized error might contain debugInfo.
        # We pop it out if include_debug_info is set to False.
        if not include_debug_info and "debugInfo" in error_dict:
            error_dict.pop("debugInfo")

        return error_dict


def infer_error_code_from_class(cls):
    # Python has a built-in SystemError
    if cls == SystemErrorException:
        return RootErrorCode.SYSTEM_ERROR

    # TODO: Rename the class to UserError
    if cls == UserErrorException:
        return RootErrorCode.USER_ERROR
    if cls == ValidationException:
        return "ValidationError"

    return cls.__name__


def get_arguments_from_message_format(message_format):
    def iter_field_name():
        if not message_format:
            return

        for _, field_name, _, _ in string.Formatter().parse(message_format):
            yield field_name

    # Use set to remove duplicates
    return set(iter_field_name())


class PromptflowException(Exception):
    """Base exception for all errors.

    :param message: A message describing the error. This is the error message the user will see.
    :type message: str
    :param target: The name of the element that caused the exception to be thrown.
    :type target: ErrorTarget
    :param error: The original exception if any.
    :type error: Exception
    :param response_code: The response code that will be sent to user if the submission fails.
    "type response_code: ResponseCode
    """

    def __init__(
        self,
        # We must keep the message as the first argument,
        # since some places are using it as positional argument for now.
        message="",
        message_format="",
        target: ErrorTarget = ErrorTarget.UNKNOWN,
        module=None,
        **kwargs,
    ):
        self._inner_exception = kwargs.get("error")
        self.exc_type, self.exc_value, self.exc_traceback = sys.exc_info()
        self.exc_type = (
            self.exc_type.__name__ if self.exc_type else type(self._inner_exception)
        )
        self.exc_msg = "{}, {}: {}".format(message, self.exc_type, self.exc_value)
        self._message = str(message)
        self._target = target
        self._module = module
        self._response_code = kwargs.get(RESPONSE_CODE, ResponseCode.SERVICE_ERROR)
        self._message_format = message_format
        self._kwargs = kwargs
        super().__init__(self._message)

    @property
    def message(self):
        if self._message:
            return self._message

        if self.message_format:
            return self.message_format.format(**self.message_parameters)

        return self.__class__.__name__

    @property
    def message_format(self):
        return self._message_format

    @cached_property
    def message_parameters(self):
        if not self._kwargs:
            return {}

        arguments = get_arguments_from_message_format(self.message_format)
        return {k: v for k, v in self._kwargs.items() if k in arguments}

    @cached_property
    def serializable_message_parameters(self):
        return {k: str(v) for k, v in self.message_parameters.items()}

    @property
    def target(self):
        """Return the error target.

        :return: The error target.
        :rtype: ErrorTarget
        """
        return self._target

    @target.setter
    def target(self, value):
        self._target = value

    @property
    def module(self):
        """The module of the error that occurs.

        It is similar to `target` but is more specific.
        It is meant to store the Python module name of the code that raises the exception.
        """
        return self._module

    @module.setter
    def module(self, value):
        self._module = value

    @property
    def reference_code(self):
        if self.module:
            return f"{self.target}/{self.module}"
        else:
            return self.target

    @property
    def response_code(self):
        return self._response_code

    @property
    def inner_exception(self):
        """Get the inner exception.

        The inner exception can be set via either style:

        1) Set via the error parameter in the constructor.
            raise PromptflowException("message", error=inner_exception)

        2) Set via raise from statement.
            raise PromptflowException("message") from inner_exception
        """
        return self._inner_exception or self.__cause__

    @property
    def additional_info(self):
        """Return a dict of the additional info of the exception.

        By default, this information could usually be empty.

        However, we can still define additional info for some specific exception.
        i.e. For ToolExcutionError, we may add the tool's line number, stacktrace to the additional info.
        """
        return None

    @property
    def reversed_error_codes(self):
        for clz in self.__class__.__mro__:
            if clz is PromptflowException:
                break
            yield infer_error_code_from_class(clz)

    @property
    def error_codes(self):
        """Returns a list of the error codes for this exception.

        The error codes is defined the same as the class inheritance.
        i.e. For ToolExcutionError which inherits from UserErrorException,
        The result would be ["UserErrorException", "ToolExecutionError"].
        """
        result = list(self.reversed_error_codes)
        result.reverse()
        return result

    @property
    def error_code_recursed(self):
        """Returns a dict of the error codes for this exception.

        It is populated in a recursive manner, using the source from `error_codes` property.
        i.e. For ToolExcutionError which inherits from UserErrorException,
        The result would be:

          {
            "code": "UserErrorException",
            "innerError": {
              "code": "ToolExecutionError",
              "innerError": None,
            },
          }

        """
        current_error = None
        for code in self.reversed_error_codes:
            current_error = {
                "code": code,
                "innerError": current_error,
            }

        return current_error

    @property
    def formatted_traceback(self):
        te = TracebackException.from_exception(self)
        return "".join(te.format())

    @property
    def debug_info(self):
        """The debug info of this exception that can be sent back to api users."""
        return {
            "type": self.__class__.__qualname__,
            "stackTrace": self.formatted_traceback,
        }

    def to_dict(self, *, include_debug_info=False):
        """Return a dict representation of the exception.

        This dict specification corresponds to the specification of the Microsoft API Guidelines:
        https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md#7102-error-condition-responses

        Note that this dict representation the "error" field in the response body of the API.
        The whole error response is then populated in another place outside of this class.
        """
        result = {
            "message": self.message,
            "messageFormat": self.message_format,
            "messageParameters": self.serializable_message_parameters,
            "referenceCode": self.reference_code,
        }

        if self.error_code_recursed:
            result.update(self.error_code_recursed)
        else:
            # For PromptflowException (not a subclass), the error_code_recursed is None.
            # Handle this case specifically.
            result["code"] = infer_error_code_from_class(SystemErrorException)
            if self.inner_exception:
                # Set the type of inner_exception as the inner error
                result["innerError"] = {
                    "code": infer_error_code_from_class(self.inner_exception.__class__),
                    "innerError": None,
                }
            else:
                result["innerError"] = None
        if self.additional_info:
            result["additionalInfo"] = [
                {"type": k, "info": v} for k, v in self.additional_info.items()
            ]
        if include_debug_info:
            result["debugInfo"] = self.debug_info

        return result

    def __str__(self):
        """Return the error message.

        Some child classes may override this method to return a more detailed error message.
        """
        return self.message


class UserErrorException(PromptflowException):
    """Exception raised when invalid or unsupported inputs are provided."""

    pass


class SystemErrorException(PromptflowException):
    """Exception raised when service error is triggered."""

    pass


class ValidationException(UserErrorException):
    pass


class ToolExecutionError(UserErrorException):
    """Exception raised when tool execution failed."""

    def __init__(self, *, node_name: str, module: str = None):
        self._node_name = node_name
        super().__init__(target=ErrorTarget.TOOL, module=module)

    @property
    def message_format(self):
        if self.inner_exception:
            return "Execution failure in '{node_name}': {error_type_and_message}"
        else:
            return "Execution failure in '{node_name}'."

    @property
    def message_parameters(self):
        error_type_and_message = None
        if self.inner_exception:
            error_type_and_message = (
                f"({self.inner_exception.__class__.__name__}) {self.inner_exception}"
            )

        return {
            "node_name": self._node_name,
            "error_type_and_message": error_type_and_message,
        }

    @property
    def tool_last_frame_info(self):
        """Return the line number inside the tool where the error occurred."""
        if self.inner_exception:
            tb = TracebackException.from_exception(self.inner_exception)
            last_frame = tb.stack[-1] if tb.stack else None
            if last_frame:
                return {
                    "filename": last_frame.filename,
                    "lineno": last_frame.lineno,
                    "name": last_frame.name,
                }

        return {}

    @property
    def tool_traceback(self):
        """Return the traceback inside the tool's source code scope.

        The traceback inside the promptflow's internal code will be taken off.
        """
        exc = self.inner_exception
        if exc and exc.__traceback__ is not None:
            # The first frame is always the code in flow.py who invokes the tool.
            # We do not want to dump it to user code's traceback.
            # So, just skip it by looking up for `tb_next` here.
            tb = exc.__traceback__.tb_next
            if tb is not None:
                # We don't use traceback.format_exception since its interface differs between 3.8 and 3.10.
                # Use this internal class to adapt to different python versions.
                te = TracebackException(type(exc), exc, tb)
                formatted_tb = "".join(te.format())

                # For inline scripts that are not saved into a file,
                # The traceback will show "<string>" as the file name.
                # For these cases, replace with the node name for better understanding.
                #
                # Here is a default traceback for example:
                #   File "<string>", line 1, in <module>
                #
                # It will be updated to something like this:
                #   In "my_node", line 1, in <module>
                if self._node_name:
                    # policy: http://policheck.azurewebsites.net/Pages/TermInfo.aspx?LCID=9&TermID=79670
                    formatted_tb = formatted_tb.replace(
                        'File "<string>"', 'In "{}"'.format(self._node_name)
                    )

                return formatted_tb

        return None

    @property
    def additional_info(self):
        """Set the tool exception details as additional info."""
        if not self.inner_exception:
            # Only populate additional info when inner exception is present.
            return None

        info = {
            "type": self.inner_exception.__class__.__name__,
            "message": str(self.inner_exception),
            "traceback": self.tool_traceback,
        }
        info.update(self.tool_last_frame_info)

        return {
            ADDITIONAL_INFO_USER_EXECUTION_ERROR: info,
        }


class RunStorageError(SystemErrorException):
    """Exception raised for error in storage"""

    def __init__(self, message, target: ErrorTarget, storage_type: type):
        msg = f"Error of {storage_type.__qualname__!r}: {message}."
        super().__init__(message=msg, target=target)


class RunInfoNotFoundInStorageError(RunStorageError):
    """Exception raised when run info can not be found in storage"""

    def __init__(self, message: str, target: ErrorTarget, storage_type: type):
        super().__init__(message=message, target=target, storage_type=storage_type)


class AzureStorageOperationError(SystemErrorException):
    """Exception raised when Azure storage operation failed."""

    pass


class FlowExecutionError(SystemErrorException):
    """Base System Exceptions for flow execution"""

    pass


class AccessDeniedError(UserErrorException):
    """Exception raised when run info can not be found in storage"""

    def __init__(self, operation: str, target: ErrorTarget):
        super().__init__(
            message=f"Access is denied to perform operation {operation!r}",
            target=target,
        )


class FlowRunTimeoutError(UserErrorException):
    """Exception raised when sync submission flow run timeout"""

    def __init__(self, timeout):
        super().__init__(
            message=f"Flow run timeout for exceeding {timeout} seconds",
            target=ErrorTarget.RUNTIME,
        )


class ConnectionNotSet(ValidationException):
    pass


class ConnectionNotFound(ValidationException):
    pass


class ValueTypeUnresolved(ValidationException):
    pass


class ResolveConnectionForFlowError(ValidationException):
    pass


class LoadToolError(ValidationException):
    pass


class MissingRequiredInputs(LoadToolError):
    pass


class UserAuthenticationError(UserErrorException):
    """Exception raised when user authentication failed"""

    pass


class StorageAuthenticationError(UserAuthenticationError):
    """Exception raised when storage authentication failed"""

    pass


class PackageToolNotFoundError(ValidationException):
    """Exception raised when package tool is not found in the current runtime environment."""

    pass


class FailedToImportModule(UserErrorException):
    pass


class BulkRunException(PromptflowException):
    """Exception raised when bulk run failed."""

    def __init__(
        self, *, failed_lines: int, total_lines: int, module: str = None, **kwargs
    ):
        self.failed_lines = failed_lines
        self.total_lines = total_lines
        super().__init__(target=ErrorTarget.RUNTIME, module=module, **kwargs)

    def to_dict(self, *, include_debug_info=False):
        result = super().to_dict(include_debug_info=include_debug_info)
        result["failed_lines"] = f"{self.failed_lines}/{self.total_lines}"
        return result


class GenerateMetaUserError(UserErrorException):
    """Base exception raised when failed to validate tool."""

    def __init__(self, **kwargs):
        super().__init__(target=ErrorTarget.EXECUTOR, **kwargs)


class MetaFileNotFound(GenerateMetaUserError):
    pass


class MetaFileReadError(GenerateMetaUserError):
    pass
