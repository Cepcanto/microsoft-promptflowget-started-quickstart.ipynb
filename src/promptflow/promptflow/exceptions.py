# ---------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# ---------------------------------------------------------

import json
import string
import sys
from datetime import datetime
from enum import Enum
from functools import cached_property
from traceback import TracebackException, format_tb

from promptflow._constants import ERROR_RESPONSE_COMPONENT_NAME


class ErrorTarget(str, Enum):
    EXECUTOR = "Executor"
    FLOW_EXECUTOR = "FlowExecutor"
    NODE_EXECUTOR = "NodeExecutor"
    TOOL = "Tool"
    AZURE_RUN_STORAGE = "AzureRunStorage"
    RUNTIME = "Runtime"
    UNKNOWN = "Unknown"
    RUN_TRACKER = "RunTracker"
    RUN_STORAGE = "RunStorage"
    CONTROL_PLANE_SDK = "ControlPlaneSDK"
    SERVING_APP = "ServingApp"


class ResponseCode(str, Enum):
    SUCCESS = "200"
    ACCEPTED = "202"
    REDIRECTION = "300"
    CLIENT_ERROR = "400"
    SERVICE_ERROR = "500"
    UNKNOWN = "0"


class RootErrorCode:
    USER_ERROR = "UserError"
    SYSTEM_ERROR = "SystemError"


RESPONSE_CODE = "response_code"
ADDITIONAL_INFO_USER_EXECUTION_ERROR = "ToolExecutionErrorDetails"


class ErrorResponse:
    """A class that represents the response body when an error occurs.

    It follows the following specification:
    https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md#7102-error-condition-responses

    It also compatible with the AzureML error response.
    The AzureML services' ErrorResponse is defined and created here:
    https://msdata.visualstudio.com/Vienna/_git/vienna?path=%2Fsrc%2Fazureml-api%2Fsrc%2FCommon%2FCore%2FContracts%2FErrorResponse.cs
    https://msdata.visualstudio.com/Vienna/_git/vienna?path=%2Fsrc%2Fazureml-api%2Fsrc%2FCommon%2FWebApi%2FErrorHandling%2FResponse%2FErrorResponseBuilder.cs
    """

    def __init__(self, error_dict):
        self._error_dict = error_dict

    # Input should be one error_dict.
    # Which usually is generated by ExceptionPresenter.to_dict() or PromptflowException.to_dict()
    @staticmethod
    def from_error_dict(error_dict):
        return ErrorResponse(error_dict)

    @staticmethod
    def from_exception(ex: Exception, *, include_debug_info=False):
        presenter = ExceptionPresenter(ex)
        error_dict = presenter.to_dict(include_debug_info=include_debug_info)
        return ErrorResponse(error_dict)

    @property
    def message(self):
        return self._error_dict.get("message", "")

    @property
    def response_code(self):
        """Given the error code, return the corresponding http response code."""
        root_error_code = self._error_dict.get("code")
        return ResponseCode.CLIENT_ERROR if root_error_code == RootErrorCode.USER_ERROR else ResponseCode.SERVICE_ERROR

    @property
    def additional_info(self):
        """Return the additional info of the error.

        The additional info is defined in the error response.
        It is stored as a list of dict, each of which contains a "type" and "info" field.

        We change the list of dict to a dict of dict for easier access.
        """
        result = {}
        list_of_dict = self._error_dict.get("additionalInfo")
        if not list_of_dict or not isinstance(list_of_dict, list):
            return result

        for item in list_of_dict:
            # We just ignore the item if it is not a dict or does not contain the required fields.
            if not isinstance(item, dict):
                continue

            name = item.get("type")
            info = item.get("info")
            if not name or not info:
                continue

            result[name] = info

        return result

    def get_additional_info(self, name):
        """Get the additional info by name."""
        return self.additional_info.get(name)

    def get_user_execution_error_info(self):
        """Get user tool execution error info from additional info."""
        user_execution_error_info = self.get_additional_info(ADDITIONAL_INFO_USER_EXECUTION_ERROR)
        if not user_execution_error_info or not isinstance(user_execution_error_info, dict):
            return {}
        return user_execution_error_info

    def to_dict(self):
        from promptflow._utils.utils import get_runtime_version

        return {
            "error": self._error_dict,
            "correlation": None,  # TODO: to be implemented
            "environment": None,  # TODO: to be implemented
            "location": None,  # TODO: to be implemented
            "componentName": f"{ERROR_RESPONSE_COMPONENT_NAME}/{get_runtime_version()}",
            "time": datetime.utcnow().isoformat(),
        }

    def to_simplified_dict(self):
        return {
            "error": {
                "code": self._error_dict.get("code"),
                "message": self._error_dict.get("message"),
            }
        }

    @property
    def error_codes(self):
        error = self._error_dict
        error_codes = []
        while error is not None:
            code = error.get("code")
            if code is not None:
                error_codes.append(code)
                error = error.get("innerError")
            else:
                break

        return error_codes

    @property
    def error_code_hierarchy(self):
        """Get the code hierarchy from error dict."""

        return "/".join(self.error_codes)

    @property
    def innermost_error_code(self):
        error_codes = self.error_codes

        if error_codes:
            return error_codes[-1]

        return None


class ExceptionPresenter:
    """A class that can extract information from the exception instance.

    It is designed to work for both PropmtflowException and other exceptions.
    """

    def __init__(self, ex: Exception):
        self._ex = ex

    @property
    def formatted_traceback(self):
        te = TracebackException.from_exception(self._ex)
        return "".join(te.format())

    @property
    def debug_info(self):
        return build_debug_info(self._ex)

    def to_dict(self, *, include_debug_info=False):
        """Return a dict representation of the exception.

        This dict specification corresponds to the specification of the Microsoft API Guidelines:
        https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md#7102-error-condition-responses

        Note that this dict representation the "error" field in the response body of the API.
        The whole error response is then populated in another place outside of this class.
        """
        # If the exception is PromptflowException, return the dict representation of it.
        if isinstance(self._ex, PromptflowException):
            return self._ex.to_dict(include_debug_info=include_debug_info)

        if isinstance(self._ex, JsonSerializedPromptflowException):
            return self._ex.to_dict(include_debug_info=include_debug_info)

        # Otherwise, return general dict representation of the exception.
        result = {
            "code": infer_error_code_from_class(SystemErrorException),
            "message": str(self._ex),
            "messageFormat": "",
            "messageParameters": {},
            "innerError": {
                "code": self._ex.__class__.__name__,
                "innerError": None,
            },
        }
        if include_debug_info:
            result["debugInfo"] = self.debug_info

        return result


class JsonSerializedPromptflowException(Exception):
    """Json serialized PromptflowException.
    This exception only has one argument message to voide the
    argument missing error when load/dump with pickle in multiprocessing.
    Ref: https://bugs.python.org/issue32696

    :param message: A Json serialized message describing the error.
    :type message: str
    """

    def __init__(self, message):
        self.message = message
        super().__init__(self.message)

    def __str__(self):
        return self.message

    def to_dict(self, *, include_debug_info=False):
        # Return a dict representation of the inner exception.
        error_dict = json.loads(self.message)

        # The original serialized error might contain debugInfo.
        # We pop it out if include_debug_info is set to False.
        if not include_debug_info and "debugInfo" in error_dict:
            error_dict.pop("debugInfo")

        return error_dict


def infer_error_code_from_class(cls):
    # Python has a built-in SystemError
    if cls == SystemErrorException:
        return RootErrorCode.SYSTEM_ERROR

    # TODO: Rename the class to UserError
    if cls == UserErrorException:
        return RootErrorCode.USER_ERROR
    if cls == ValidationException:
        return "ValidationError"

    return cls.__name__


def get_arguments_from_message_format(message_format):
    def iter_field_name():
        if not message_format:
            return

        for _, field_name, _, _ in string.Formatter().parse(message_format):
            yield field_name

    # Use set to remove duplicates
    return set(iter_field_name())


_cause_message = "\nThe above exception was the direct cause of the following exception:\n\n"

_context_message = "\nDuring handling of the above exception, another exception occurred:\n\n"

_traceback_message = "Traceback (most recent call last):\n"


def build_debug_info(ex: Exception):
    innerException: dict = None
    stackTrace = _traceback_message + "".join(format_tb(ex.__traceback__))

    if ex.__cause__ is not None:
        innerException = build_debug_info(ex.__cause__)
        stackTrace = _cause_message + stackTrace

    elif ex.__context__ is not None and not ex.__suppress_context__:
        innerException = build_debug_info(ex.__context__)
        stackTrace = _context_message + stackTrace

    return {
        "type": ex.__class__.__qualname__,
        "message": str(ex),
        "stackTrace": stackTrace,
        "innerException": innerException,
    }


class PromptflowException(Exception):
    """Base exception for all errors.

    :param message: A message describing the error. This is the error message the user will see.
    :type message: str
    :param target: The name of the element that caused the exception to be thrown.
    :type target: ErrorTarget
    :param error: The original exception if any.
    :type error: Exception
    :param response_code: The response code that will be sent to user if the submission fails.
    "type response_code: ResponseCode
    """

    def __init__(
        self,
        # We must keep the message as the first argument,
        # since some places are using it as positional argument for now.
        message="",
        message_format="",
        target: ErrorTarget = ErrorTarget.UNKNOWN,
        module=None,
        **kwargs,
    ):
        self._inner_exception = kwargs.get("error")
        self.exc_type, self.exc_value, self.exc_traceback = sys.exc_info()
        self.exc_type = self.exc_type.__name__ if self.exc_type else type(self._inner_exception)
        self.exc_msg = "{}, {}: {}".format(message, self.exc_type, self.exc_value)
        self._message = str(message)
        self._target = target
        self._module = module
        self._response_code = kwargs.get(RESPONSE_CODE, ResponseCode.SERVICE_ERROR)
        self._message_format = message_format
        self._kwargs = kwargs
        super().__init__(self._message)

    @property
    def message(self):
        if self._message:
            return self._message

        if self.message_format:
            return self.message_format.format(**self.message_parameters)

        return self.__class__.__name__

    @property
    def message_format(self):
        return self._message_format

    @cached_property
    def message_parameters(self):
        if not self._kwargs:
            return {}

        arguments = get_arguments_from_message_format(self.message_format)
        return {k: v for k, v in self._kwargs.items() if k in arguments}

    @cached_property
    def serializable_message_parameters(self):
        return {k: str(v) for k, v in self.message_parameters.items()}

    @property
    def target(self):
        """Return the error target.

        :return: The error target.
        :rtype: ErrorTarget
        """
        return self._target

    @target.setter
    def target(self, value):
        self._target = value

    @property
    def module(self):
        """The module of the error that occurs.

        It is similar to `target` but is more specific.
        It is meant to store the Python module name of the code that raises the exception.
        """
        return self._module

    @module.setter
    def module(self, value):
        self._module = value

    @property
    def reference_code(self):
        if self.module:
            return f"{self.target}/{self.module}"
        else:
            return self.target

    @property
    def response_code(self):
        return self._response_code

    @property
    def inner_exception(self):
        """Get the inner exception.

        The inner exception can be set via either style:

        1) Set via the error parameter in the constructor.
            raise PromptflowException("message", error=inner_exception)

        2) Set via raise from statement.
            raise PromptflowException("message") from inner_exception
        """
        return self._inner_exception or self.__cause__

    @property
    def additional_info(self):
        """Return a dict of the additional info of the exception.

        By default, this information could usually be empty.

        However, we can still define additional info for some specific exception.
        i.e. For ToolExcutionError, we may add the tool's line number, stacktrace to the additional info.
        """
        return None

    @property
    def reversed_error_codes(self):
        for clz in self.__class__.__mro__:
            if clz is PromptflowException:
                break
            yield infer_error_code_from_class(clz)

    @property
    def error_codes(self):
        """Returns a list of the error codes for this exception.

        The error codes is defined the same as the class inheritance.
        i.e. For ToolExcutionError which inherits from UserErrorException,
        The result would be ["UserErrorException", "ToolExecutionError"].
        """
        result = list(self.reversed_error_codes)
        result.reverse()
        return result

    @property
    def error_code_recursed(self):
        """Returns a dict of the error codes for this exception.

        It is populated in a recursive manner, using the source from `error_codes` property.
        i.e. For ToolExcutionError which inherits from UserErrorException,
        The result would be:

          {
            "code": "UserErrorException",
            "innerError": {
              "code": "ToolExecutionError",
              "innerError": None,
            },
          }

        """
        current_error = None
        for code in self.reversed_error_codes:
            current_error = {
                "code": code,
                "innerError": current_error,
            }

        return current_error

    @property
    def formatted_traceback(self):
        te = TracebackException.from_exception(self)
        return "".join(te.format())

    @property
    def debug_info(self):
        """The debug info of this exception that can be sent back to api users."""
        return build_debug_info(self)

    def to_dict(self, *, include_debug_info=False):
        """Return a dict representation of the exception.

        This dict specification corresponds to the specification of the Microsoft API Guidelines:
        https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md#7102-error-condition-responses

        Note that this dict representation the "error" field in the response body of the API.
        The whole error response is then populated in another place outside of this class.
        """
        result = {
            "message": self.message,
            "messageFormat": self.message_format,
            "messageParameters": self.serializable_message_parameters,
            "referenceCode": self.reference_code,
        }

        if self.error_code_recursed:
            result.update(self.error_code_recursed)
        else:
            # For PromptflowException (not a subclass), the error_code_recursed is None.
            # Handle this case specifically.
            result["code"] = infer_error_code_from_class(SystemErrorException)
            if self.inner_exception:
                # Set the type of inner_exception as the inner error
                result["innerError"] = {
                    "code": infer_error_code_from_class(self.inner_exception.__class__),
                    "innerError": None,
                }
            else:
                result["innerError"] = None
        if self.additional_info:
            result["additionalInfo"] = [{"type": k, "info": v} for k, v in self.additional_info.items()]
        if include_debug_info:
            result["debugInfo"] = self.debug_info

        return result

    def __str__(self):
        """Return the error message.

        Some child classes may override this method to return a more detailed error message."""
        return self.message


class UserErrorException(PromptflowException):
    """Exception raised when invalid or unsupported inputs are provided."""

    pass


class SystemErrorException(PromptflowException):
    """Exception raised when service error is triggered."""

    pass


class ValidationException(UserErrorException):
    pass
